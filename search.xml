<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Swagger笔记</title>
      <link href="/2020/05/16/Swagger%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/16/Swagger%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>学习目标：</strong></p><ul><li>了解Swagger的概念及作用</li><li>掌握在项目中集成Swagger自动生成API文档</li></ul><h2 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h2><p><strong>前后端分离</strong></p><ul><li>前端 -&gt; 前端控制层、视图层</li><li>后端 -&gt; 后端控制层、服务层、数据访问层</li><li>前后端通过API进行交互</li><li>前后端相对独立且松耦合</li></ul><p><strong>产生的问题</strong></p><ul><li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li></ul><p><strong>解决方案</strong></p><ul><li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li></ul><p><strong>Swagger</strong></p><ul><li>号称世界上最流行的API框架</li><li>Restful Api 文档在线自动生成器 =&gt; <strong>API 文档 与API 定义同步更新</strong></li><li>直接运行，在线测试API</li><li>支持多种语言 （如：Java，PHP等）</li><li>官网：<a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></li></ul><h2 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h2><p><strong>SpringBoot集成Swagger</strong> =&gt; <strong>springfox</strong>，两个jar包</p><ul><li><strong>Springfox-swagger2</strong></li><li>swagger-springmvc</li></ul><p><strong>使用Swagger</strong></p><p>要求：jdk 1.8 + 否则swagger2无法运行</p><p>步骤：</p><p>1、新建一个SpringBoot-web项目</p><p>2、添加Maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、编写HelloController，测试确保运行成功！</p><p>4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2<span class="comment">// 开启Swagger2的自动配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、访问测试 ：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p><h2 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h2><p>1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//配置docket以配置Swagger具体参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、可以通过apiInfo()属性配置文档信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置文档信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Contact contact = <span class="keyword">new</span> Contact(<span class="string">"联系人名字"</span>, <span class="string">"http://xxx.xxx.com/联系人访问链接"</span>, <span class="string">"联系人邮箱"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">           <span class="string">"Swagger学习"</span>, <span class="comment">// 标题</span></span><br><span class="line">           <span class="string">"学习演示如何配置Swagger"</span>, <span class="comment">// 描述</span></span><br><span class="line">           <span class="string">"v1.0"</span>, <span class="comment">// 版本</span></span><br><span class="line">           <span class="string">"http://terms.service.url/组织链接"</span>, <span class="comment">// 组织链接</span></span><br><span class="line">           contact, <span class="comment">// 联系人信息</span></span><br><span class="line">           <span class="string">"Apach 2.0 许可"</span>, <span class="comment">// 许可</span></span><br><span class="line">           <span class="string">"许可链接"</span>, <span class="comment">// 许可连接</span></span><br><span class="line">           <span class="keyword">new</span> ArrayList&lt;&gt;()<span class="comment">// 扩展</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Docket 实例关联上 apiInfo()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、重启项目，访问测试 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a>  看下效果；</p><h2 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h2><p>1、构建Docket时通过select()方法配置怎么扫描接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.kuang.swagger.controller"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p><p>3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">any() <span class="comment">// 扫描所有，项目中的所有接口都会被扫描到</span></span><br><span class="line">none() <span class="comment">// 不扫描接口</span></span><br><span class="line"><span class="comment">// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span></span><br><span class="line">withMethodAnnotation(<span class="keyword">final</span> Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line"><span class="comment">// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span></span><br><span class="line">withClassAnnotation(<span class="keyword">final</span> Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line">basePackage(<span class="keyword">final</span> String basePackage) <span class="comment">// 根据包路径扫描接口</span></span><br></pre></td></tr></table></figure><p>4、除此之外，我们还可以配置接口扫描过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.kuang.swagger.controller"</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">"/kuang/**"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、这里的可选值还有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">any() <span class="comment">// 任何请求都扫描</span></span><br><span class="line">none() <span class="comment">// 任何请求都不扫描</span></span><br><span class="line">regex(<span class="keyword">final</span> String pathRegex) <span class="comment">// 通过正则表达式控制</span></span><br><span class="line">ant(<span class="keyword">final</span> String antPattern) <span class="comment">// 通过ant()控制</span></span><br></pre></td></tr></table></figure><h2 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h2><p>1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(<span class="keyword">false</span>) <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.kuang.swagger.controller"</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">"/kuang/**"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 设置要显示swagger的环境</span></span><br><span class="line">   Profiles of = Profiles.of(<span class="string">"dev"</span>, <span class="string">"test"</span>);</span><br><span class="line">   <span class="comment">// 判断当前是否处于该环境</span></span><br><span class="line">   <span class="comment">// 通过 enable() 接收此参数判断是否要显示</span></span><br><span class="line">   <span class="keyword">boolean</span> b = environment.acceptsProfiles(of);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(b) <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.kuang.swagger.controller"</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">"/kuang/**"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、可以在项目中增加一个dev的配置文件查看效果！</p><h2 id="配置API分组"><a href="#配置API分组" class="headerlink" title="配置API分组"></a>配置API分组</h2><p>1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">      .groupName(<span class="string">"hello"</span>) <span class="comment">// 配置分组</span></span><br><span class="line">       <span class="comment">// 省略配置....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、重启项目查看分组</p><p>3、如何配置多个分组？配置多个分组只需要配置多个docket即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">"group1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">"group2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket3</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">"group3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、重启项目查看即可</p><h2 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h2><p>1、新建一个实体类.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span>(<span class="string">"用户实体"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="meta">@ApiModelProperty</span>(<span class="string">"用户名"</span>)</span><br><span class="line">   <span class="keyword">public</span> String username;</span><br><span class="line">   <span class="meta">@ApiModelProperty</span>(<span class="string">"密码"</span>)</span><br><span class="line">   <span class="keyword">public</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、重启查看测试</p><p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p><p>@ApiModel为类添加注释</p><p>@ApiModelProperty为类属性添加注释</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>Swagger的所有注解定义在io.swagger.annotations包下</p><p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p><table><thead><tr><th>Swagger注解</th><th>简单说明</th></tr></thead><tbody><tr><td>@Api(tags = “xxx模块说明”)</td><td>作用在模块类上</td></tr><tr><td>@ApiOperation(“xxx接口说明”)</td><td>作用在接口方法上</td></tr><tr><td>@ApiModel(“xxxPOJO说明”)</td><td>作用在模型类上：如VO、BO</td></tr><tr><td>@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td><td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td></tr><tr><td>@ApiParam(“xxx参数说明”)</td><td>作用在参数、方法和字段上，类似@ApiModelProperty</td></tr></tbody></table><p>我们也可以给请求的接口配置一些注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(<span class="string">"狂神的接口"</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/kuang"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">kuang</span><span class="params">(@ApiParam(<span class="string">"这个名字会被返回"</span>)</span>String username)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p><p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p><p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api</span>：用在请求的类上，表示对类的说明</span><br><span class="line">    tags=<span class="string">"说明该类的作用，可以在UI界面上看到的注解"</span></span><br><span class="line">    value=<span class="string">"该参数没什么意义，在UI界面上也看到，所以不需要配置"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@ApiOperation</span>：用在请求的方法上，说明方法的用途、作用</span><br><span class="line">    value=<span class="string">"说明方法的用途、作用"</span></span><br><span class="line">    notes=<span class="string">"方法的备注说明"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@ApiImplicitParams</span>：用在请求的方法上，表示一组参数说明</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>：用在<span class="meta">@ApiImplicitParams</span>注解中，指定一个请求参数的各个方面</span><br><span class="line">        name：参数名</span><br><span class="line">        value：参数的汉字说明、解释</span><br><span class="line">        required：参数是否必须传</span><br><span class="line">        paramType：参数放在哪个地方</span><br><span class="line">            · header --&gt; 请求参数的获取：<span class="meta">@RequestHeader</span></span><br><span class="line">            · query --&gt; 请求参数的获取：<span class="meta">@RequestParam</span></span><br><span class="line">            · path（用于restful接口）--&gt; 请求参数的获取：<span class="meta">@PathVariable</span></span><br><span class="line">            · body（不常用）</span><br><span class="line">            · form（不常用）    </span><br><span class="line">        dataType：参数类型，默认String，其它值dataType=<span class="string">"Integer"</span>       </span><br><span class="line">        defaultValue：参数的默认值</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@ApiResponses</span>：用在请求的方法上，表示一组响应</span><br><span class="line">    <span class="meta">@ApiResponse</span>：用在<span class="meta">@ApiResponses</span>中，一般用于表达一个错误的响应信息</span><br><span class="line">        code：数字，例如<span class="number">400</span></span><br><span class="line">        message：信息，例如<span class="string">"请求参数没填好"</span></span><br><span class="line">        response：抛出异常的类</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@ApiModel</span>：用于响应类上，表示一个返回响应数据的信息</span><br><span class="line">            （这种一般用在post创建的时候，使用<span class="meta">@RequestBody</span>这样的场景，</span><br><span class="line">            请求参数无法使用<span class="meta">@ApiImplicitParam</span>注解进行描述的时候）</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>：用在属性上，描述响应类的属性</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记</title>
      <link href="/2020/05/15/Redis%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/15/Redis%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装和使用"><a href="#1-安装和使用" class="headerlink" title="1.安装和使用"></a>1.安装和使用</h1><h2 id="1-1-安装Redis"><a href="#1-1-安装Redis" class="headerlink" title="1.1 安装Redis"></a>1.1 安装Redis</h2><p><strong>下载地址：</strong><a href="https://github.com/MSOpenTech/redis/releases。" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases。</a></p><p>从redis.io下载最新版redis-X.Y.Z.tar.gz后解压，然后进入redis-X.Y.Z文件夹后直接make即可，安装非常简单。</p><p>make成功后会在src文件夹下产生一些二进制可执行文件，包括redis-server、redis-cli等等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -executable</span></span><br><span class="line">./redis-benchmark //用于进行redis性能测试的工具</span><br><span class="line">./redis-check-dump //用于修复出问题的dump.rdb文件</span><br><span class="line">./redis-cli //redis的客户端</span><br><span class="line">./redis-server //redis的服务端</span><br><span class="line">./redis-check-aof //用于修复出问题的AOF文件</span><br><span class="line">./redis-sentinel //用于集群管理</span><br></pre></td></tr></table></figure><h2 id="1-2-启动Redis"><a href="#1-2-启动Redis" class="headerlink" title="1.2 启动Redis"></a>1.2 启动Redis</h2><p>启动redis非常简单，直接./redis-server就可以启动服务端了，还可以用下面的方法指定要加载的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../redis.conf</span><br></pre></td></tr></table></figure><p>默认情况下，redis-server会以非daemon的方式来运行，且<strong>默认服务端口为6379</strong>。</p><h2 id="1-3-使用Redis客户端"><a href="#1-3-使用Redis客户端" class="headerlink" title="1.3 使用Redis客户端"></a>1.3 使用Redis客户端</h2><p>例子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这样来启动redis客户端了</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-cli</span></span><br><span class="line">//用set指令来设置key、value</span><br><span class="line">127.0.0.1:6379&gt; set name "roc" </span><br><span class="line">OK</span><br><span class="line">//来获取name的值</span><br><span class="line">127.0.0.1:6379&gt; get name </span><br><span class="line">"roc"</span><br><span class="line">//通过客户端来关闭redis服务端</span><br><span class="line">127.0.0.1:6379&gt; shutdown </span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h1 id="2-Redis数据结构"><a href="#2-Redis数据结构" class="headerlink" title="2.Redis数据结构"></a>2.Redis数据结构</h1><p>redis是一种高级的key:value存储系统，其中value支持五种数据类型：</p><p>1.字符串（strings）<br>2.字符串列表（lists）<br>3.字符串集合（sets）<br>4.有序字符串集合（sorted sets）<br>5.哈希（hashes）</p><p><strong>而关于key，有几个点要提醒大家：</strong></p><p>1.key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；<br>2.key也不要太短，太短的话，key的可读性会降低；<br>3.在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd。</p><h2 id="2-1-Redis数据结构-–-strings"><a href="#2-1-Redis数据结构-–-strings" class="headerlink" title="2.1 Redis数据结构 – strings"></a>2.1 Redis数据结构 – strings</h2><p>有人说，如果只使用redis中的字符串类型，且不使用redis的持久化功能，那么，redis就和memcache非常非常的像了。这说明strings类型是一个很基础的数据类型，也是任何存储系统都必备的数据类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set mystr "hello world!" //设置字符串类型</span><br><span class="line">get mystr //读取字符串类型</span><br></pre></td></tr></table></figure><p>字符串类型的用法就是这么简单，因为是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储。</p><p>另外，我们还可以通过字符串类型进行数值操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set mynum "2"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get mynum</span><br><span class="line">"2"</span><br><span class="line">127.0.0.1:6379&gt; incr mynum</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get mynum</span><br><span class="line">"3"</span><br></pre></td></tr></table></figure><p>在遇到数值操作时，redis会将字符串类型转换成数值。</p><p>由于INCR等指令本身就具有原子操作的特性，所以我们完全可以利用redis的<strong>INCR</strong>、<strong>INCRBY</strong>、<strong>DECR</strong>、<strong>DECRBY</strong>等指令来实现原子计数的效果，假如，在某种场景下有3个客户端同时读取了mynum的值（值为2），然后对其同时进行了加1的操作，那么，最后mynum的值一定是5。不少网站都利用redis的这个特性来实现业务上的统计计数需求。</p><h2 id="2-2-Redis数据结构-–-lists"><a href="#2-2-Redis数据结构-–-lists" class="headerlink" title="2.2  Redis数据结构 – lists"></a>2.2  Redis数据结构 – lists</h2><p>redis的另一个重要的数据结构叫做lists，翻译成中文叫做“列表”。</p><p>首先要明确一点，redis中的lists在底层实现上并不是数组，而是<strong>链表</strong>，也就是说对于一个具有上百万个元素的lists来说，在头部和尾部插入一个新元素，其时间复杂度是常数级别的，比如用LPUSH在10个元素的lists头部插入新元素，和在上千万元素的lists头部插入新元素的速度应该是相同的。</p><p>虽然lists有这样的优势，但同样有其弊端，那就是，<strong>链表型lists的元素定位会比较慢，而数组型lists的元素定位就会快得多</strong>。</p><p>lists的常用操作包括LPUSH、RPUSH、LRANGE等。我们可以用LPUSH在lists的左侧插入一个新元素，用RPUSH在lists的右侧插入一个新元素，用LRANGE命令从lists中指定一个范围来提取元素。我们来看几个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//新建一个list叫做mylist，并在列表头部插入元素"1"</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist "1" </span><br><span class="line">//返回当前mylist中的元素个数</span><br><span class="line">(integer) 1 </span><br><span class="line">//在mylist右侧插入元素"2"</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist "2" </span><br><span class="line">(integer) 2</span><br><span class="line">//在mylist左侧插入元素"0"</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist "0" </span><br><span class="line">(integer) 3</span><br><span class="line">//列出mylist中从编号0到编号1的元素</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 1 </span><br><span class="line">1) "0"</span><br><span class="line">2) "1"</span><br><span class="line">//列出mylist中从编号0到倒数第一个元素</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1 </span><br><span class="line">1) "0"</span><br><span class="line">2) "1"</span><br><span class="line">3) "2"</span><br></pre></td></tr></table></figure><p>lists的应用相当广泛，随便举几个例子：</p><p>1.我们可以利用lists来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样还需要通过ORDER BY来进行排序。<br>2.利用LRANGE还可以很方便的实现分页的功能。<br>3.在博客系统中，每片博文的评论也可以存入一个单独的list中。</p><h2 id="2-3-Redis数据结构-–-集合"><a href="#2-3-Redis数据结构-–-集合" class="headerlink" title="2.3 Redis数据结构 – 集合"></a>2.3 Redis数据结构 – 集合</h2><p>redis的集合，是一种<strong>无序的集合</strong>，集合中的元素没有先后顺序。</p><p>集合相关的操作也很丰富，如添加新元素、删除已有元素、取交集、取并集、取差集等。我们来看例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//向集合myset中加入一个新元素"one"</span><br><span class="line">127.0.0.1:6379&gt; sadd myset "one" </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset "two"</span><br><span class="line">(integer) 1</span><br><span class="line">//列出集合myset中的所有元素</span><br><span class="line">127.0.0.1:6379&gt; smembers myset </span><br><span class="line">1) "one"</span><br><span class="line">2) "two"</span><br><span class="line">//判断元素1是否在集合myset中，返回1表示存在</span><br><span class="line">127.0.0.1:6379&gt; sismember myset "one" </span><br><span class="line">(integer) 1</span><br><span class="line">//判断元素3是否在集合myset中，返回0表示不存在</span><br><span class="line">127.0.0.1:6379&gt; sismember myset "three" </span><br><span class="line">(integer) 0</span><br><span class="line">//新建一个新的集合yourset</span><br><span class="line">127.0.0.1:6379&gt; sadd yourset "1" </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd yourset "2"</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers yourset</span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">//对两个集合求并集</span><br><span class="line">127.0.0.1:6379&gt; sunion myset yourset </span><br><span class="line">1) "1"</span><br><span class="line">2) "one"</span><br><span class="line">3) "2"</span><br><span class="line">4) "two"</span><br></pre></td></tr></table></figure><p>对于集合的使用，也有一些常见的方式，比如，QQ有一个社交功能叫做“好友标签”，大家可以给你的好友贴标签，比如“大美女”、“土豪”、“欧巴”等等，这时就可以使用redis的集合来实现，把每一个用户的标签都存储在一个集合之中。</p><h2 id="2-4-Redis数据结构-–-有序集合"><a href="#2-4-Redis数据结构-–-有序集合" class="headerlink" title="2.4 Redis数据结构 – 有序集合"></a>2.4 Redis数据结构 – 有序集合</h2><p>redis不但提供了无需集合（sets），还很体贴的提供了有序集合（sorted sets）。有序集合中的每个元素都关联一个序号（score），这便是排序的依据。</p><p>很多时候，我们都将redis中的有序集合叫做zsets，这是因为在redis中，有序集合相关的操作指令都是以z开头的，比如zrange、zadd、zrevrange、zrangebyscore等等</p><p>老规矩，我们来看几个生动的例子：<br>//新增一个有序集合myzset，并加入一个元素baidu.com，给它赋予的序号是1：</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的过期策略和内存淘汰机制有什么区别?</title>
      <link href="/2020/05/14/Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/05/14/Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>Redis 和 MySQL 是面试绕不过的两座大山，他们一个是关系型数据库的代表（MySQL），一个是键值数据库以及缓存中间件的一哥。尤其 Redis 几乎是所有互联网公司都在用的技术，比如国内的 BATJ、新浪、360、小米等公司；国外的微软、Twitter、Stack Overflow、GitHub、暴雪等公司。我从业了十几年，就职过 4、5 家公司，有的公司用 MySQL、有的用 SQL Server、甚至还有的用 Oracle 和 DB2，但缓存无一例外使用的都是 Redis，从某种程度上来讲 Redis 是普及率最高的技术，没有之一。</p><p>我们本课时的面试题是，Redis 是如何处理过期数据的？当内存不够用时 Redis 又是如何处理的？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>我们在新增 Redis 缓存时可以设置缓存的过期时间，该时间保证了数据在规定的时间内失效，可以借助这个特性来实现很多功能。比如，存储一定天数的用户（登录）会话信息，这样在一定范围内用户不用重复登录了，但为了安全性，需要在一定时间之后重新验证用户的信息。因此，我们可以使用 Redis 设置过期时间来存储用户的会话信息。</p><p>对于已经过期的数据，Redis 将使用两种策略来删除这些过期键，它们分别是<strong>惰性删除</strong>和<strong>定期删除</strong>。</p><p><strong>惰性删除</strong>是指 Redis 服务器不主动删除过期的键值，而是当访问键值时，再检查当前的键值是否过期，如果过期则执行删除并返回 null 给客户端；如果没过期则正常返回值信息给客户端。</p><p>它的优点是不会浪费太多的系统资源，只是在每次访问时才检查键值是否过期。缺点是删除过期键不及时，造成了一定的空间浪费。</p><p>惰性删除的源码位于 src/db.c 文件的 expireIfNeeded 方法中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断键是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != NULL) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 删除过期键 */</span></span><br><span class="line">    <span class="comment">// 增加过期键个数</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">// 传播键过期的消息</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">    <span class="comment">// server.lazyfree_lazy_expire 为 1 表示异步删除，否则则为同步删除</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断键是否过期</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    mstime_t when = getExpire(db,key);</span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    mstime_t now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键的过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == NULL) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    serverAssertWithInfo(NULL,key,dictFind(db-&gt;dict,key-&gt;ptr) != NULL);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>惰性删除的执行流程如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p>除了惰性删除之外，Redis 还提供了定期删除功能以弥补惰性删除的不足。</p><p>定期删除是指 Redis 服务器每隔一段时间会检查一下数据库，看看是否有过期键可以被清除。</p><p>默认情况下 Redis 定期检查的频率是每秒扫描 10 次，用于定期清除过期键。当然此值还可以通过配置文件进行设置，在 redis.conf 中修改配置“hz”即可，默认的值为“hz 10”。</p><blockquote><p>小贴士：定期删除的扫描并不是遍历所有的键值对，这样的话比较费时且太消耗系统资源。Redis 服务器采用的是随机抽取形式，每次从过期字典中，取出 20 个键进行过期检测，过期字典中存储的是所有设置了过期时间的键值对。如果这批随机检查的数据中有 25% 的比例过期，那么会再抽取 20 个随机键值进行检测和删除，并且会循环执行这个流程，直到抽取的这批数据中过期键值小于 25%，此次检测才算完成。</p></blockquote><p>定期删除的源码在 expire.c 文件的 activeExpireCycle 方法中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeExpireCycle</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> unsigned <span class="keyword">int</span> current_db = <span class="number">0</span>; <span class="comment">/* 上次定期删除遍历到的数据库ID */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timelimit_exit = <span class="number">0</span>;      </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> last_fast_cycle = <span class="number">0</span>; <span class="comment">/* 上次执行定期删除的时间点 */</span></span><br><span class="line">    <span class="keyword">int</span> j, iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dbs_per_call = CRON_DBS_PER_CALL; <span class="comment">// 需要遍历数据库的数量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime(), timelimit, elapsed;</span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// ACTIVE_EXPIRE_CYCLE_FAST_DURATION 快速定期删除的执行时长</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line">    <span class="comment">// 慢速定期删除的执行时长</span></span><br><span class="line">    timelimit = <span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;</span><br><span class="line">    timelimit_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; <span class="comment">/* 删除操作花费的时间 */</span></span><br><span class="line">    <span class="keyword">long</span> total_sampled = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> total_expired = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call &amp;&amp; timelimit_exit == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> expired;</span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line">        current_db++;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// .......</span></span><br><span class="line">            expired = <span class="number">0</span>;</span><br><span class="line">            ttl_sum = <span class="number">0</span>;</span><br><span class="line">            ttl_samples = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 每个数据库中检查的键的数量</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line">            <span class="comment">// 从数据库中随机选取 num 个键进行检查</span></span><br><span class="line">            <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == NULL) <span class="keyword">break</span>;</span><br><span class="line">                ttl = dictGetSignedInteger</span><br><span class="line">                <span class="comment">// 过期检查，并对过期键进行删除</span></span><br><span class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ttl_sum += ttl;</span><br><span class="line">                    ttl_samples++;</span><br><span class="line">                &#125;</span><br><span class="line">                total_sampled++;</span><br><span class="line">            &#125;</span><br><span class="line">            total_expired += expired;</span><br><span class="line">            <span class="keyword">if</span> (ttl_samples) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line">                <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl/<span class="number">50</span>)*<span class="number">49</span> + (avg_ttl/<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* check once every 16 iterations. */</span></span><br><span class="line">                elapsed = ustime()-start;</span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt; timelimit) &#123;</span><br><span class="line">                    timelimit_exit = <span class="number">1</span>;</span><br><span class="line">                    server.stat_expired_time_cap_reached_count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 判断过期键删除数量是否超过 25% */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定期删除的执行流程，如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><blockquote><p>小贴士：Redis 服务器为了保证过期删除策略不会导致线程卡死，会给过期扫描增加了最大执行时间为 25ms。</p></blockquote><p>以上是 Redis 服务器对待过期键的处理方案，当 Redis 的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，这和过期策略是完全不同的两个概念，经常有人把二者搞混，这两者一个是在正常情况下清除过期键，一个是在非正常情况下为了保证 Redis 顺利运行的保护策略。</p><p>当 Redis 内存不够用时，Redis 服务器会根据服务器设置的淘汰策略，删除一些不常用的数据，以保证 Redis 服务器的顺利运行。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>本课时的面试题并非 Redis 的入门级面试题，需要面试者对 Redis 有一定的了解才能对答如流，并且 Redis 的过期淘汰策略和内存淘汰策略的概念比较类似，都是用于淘汰数据的。因此很多人会把二者当成一回事，但其实并不是，这个面试者特别注意一下，和此知识点相关的面试题还有以下这些：</p><ul><li>Redis 内存淘汰策略有哪些？</li><li>Redis 有哪些内存淘汰算法？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="Redis-内存淘汰策略"><a href="#Redis-内存淘汰策略" class="headerlink" title="Redis 内存淘汰策略"></a>Redis 内存淘汰策略</h3><p>我们可以使用 config get maxmemory-policy 命令，来查看当前 Redis 的内存淘汰策略，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config get maxmemory-policy</span><br><span class="line"><span class="number">1</span>) <span class="string">"maxmemory-policy"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"noeviction"</span></span><br></pre></td></tr></table></figure><p>从上面的结果可以看出，当前 Redis 服务器设置的是“noeviction”类型的内存淘汰策略，那么这表示什么含义呢？Redis 又有几种内存淘汰策略呢？</p><p>在 4.0 版本之前 Redis 的内存淘汰策略有以下 6 种。</p><ul><li>noeviction：不淘汰任何数据，当内存不足时，执行缓存新增操作会报错，它是 Redis 默认内存淘汰策略。</li><li>allkeys-lru：淘汰整个键值中最久未使用的键值。</li><li>allkeys-random：随机淘汰任意键值。</li><li>volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值。</li><li>volatile-random：随机淘汰设置了过期时间的任意键值。</li><li>volatile-ttl：优先淘汰更早过期的键值。</li></ul><p>可以看出我们上面示例使用的是 Redis 默认的内存淘汰策略“noeviction”。</p><p>而在 Redis 4.0 版本中又新增了 2 种淘汰策略：</p><ul><li><p>volatile-lfu，淘汰所有设置了过期时间的键值中最少使用的键值；</p></li><li><p>allkeys-lfu，淘汰整个键值中最少使用的键值。</p></li></ul><blockquote><p>小贴士：从以上内存淘汰策略中可以看出，allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰数据。</p></blockquote><p>这个内存淘汰策略我们可以通过配置文件来修改，redis.conf 对应的配置项是“maxmemory-policy noeviction”，只需要把它修改成我们需要设置的类型即可。</p><p>需要注意的是，如果使用修改 redis.conf 的方式，当设置完成之后需要重启 Redis 服务器才能生效。</p><p>还有另一种简单的修改内存淘汰策略的方式，我们可以使用命令行工具输入“config set maxmemory-policy noeviction”来修改内存淘汰的策略，这种修改方式的好处是执行成功之后就会生效，无需重启 Redis 服务器。但它的坏处是不能持久化内存淘汰策略，每次重启 Redis 服务器之后设置的内存淘汰策略就会丢失。</p><h3 id="Redis-内存淘汰算法"><a href="#Redis-内存淘汰算法" class="headerlink" title="Redis 内存淘汰算法"></a>Redis 内存淘汰算法</h3><p>内存淘汰算法主要包含两种：LRU 淘汰算法和 LFU 淘汰算法。</p><p><strong>LRU</strong>（ Least Recently Used，最近最少使用）<strong>淘汰算法</strong>：是一种常用的页面置换算法，也就是说最久没有使用的缓存将会被淘汰。</p><p>LRU 是基于链表结构实现的，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要进行内存淘汰时，只需要删除链表尾部的元素即可。</p><p>Redis 使用的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是给现有的数据结构添加一个额外的字段，用于记录此键值的最后一次访问时间。Redis 内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值 (此值可配置) ，然后淘汰最久没有使用的数据。</p><p><strong>LFU</strong>（Least Frequently Used，最不常用的）<strong>淘汰算法</strong>：最不常用的算法是根据总访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p><p>LFU 相对来说比 LRU 更“智能”，因为它解决了使用频率很低的缓存，只是最近被访问了一次就不会被删除的问题。如果是使用 LRU 类似这种情况数据是不会被删除的，而使用 LFU 的话，这个数据就会被删除。</p><p>Redis 内存淘汰策略使用了 LFU 和近 LRU 的淘汰算法，具体使用哪种淘汰算法，要看服务器是如何设置内存淘汰策略的，也就是要看“maxmemory-policy”的值是如何设置的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们讲了 Redis 的过期删除策略：惰性删除 + 定期删除；还讲了 Redis 的内存淘汰策略，它和过期策略是完全不同的两个概念，内存淘汰策略是当内存不够用时才会触发的一种机制，它在 Redis 4.0 之后提供了 8 种内存淘汰策略，这些淘汰策略主要使用了近 LRU 淘汰算法和 LFU 淘汰算法。</p><p>00:00 Java 源码剖析 34 讲</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系型数据和文档型数据库有什么区别？</title>
      <link href="/2020/05/14/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%92%8C%E6%96%87%E6%A1%A3%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2020/05/14/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%92%8C%E6%96%87%E6%A1%A3%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>关系数据库（Relational Database）是建立在关系模型基础上的数据库，借助于几何代数等数学概念和方法来处理数据库中的数据。所谓关系模型是一对一、一对多或者多对多等关系，常见的关系型数据库有 Oracle、SQL Server、DB2、MySQL 等。</p><p>而文档型数据库是一种非关系型数据库，非关系型数据库（Not Only SQL，NoSQL）正好与关系型数据库相反，它不是建立在“关系模型”上的数据库。文档型数据库的典型代表是 MongoDB。</p><p>我们本课时的面试题是，关系型数据库和文档型数据库有什么区别？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>关系型数据库属于早期的传统型数据库，它有着标准化的数据模型，以及事务和持久化的支持、例如，关系型数据库都会支持的 <strong>ACID</strong> 特性，也就是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），具体含义如下。</p><ul><li>原子性（Atomicity）：是指一个事务中的所有操作，要么全部完成、要么全部不完成，不会存在中间的状态。也就是说事务在正常的情况下会执行完成；异常的情况下，比如在执行的过程中如果出现问题，会回滚成最初的状态，而非中间状态。</li><li>一致性（Consistency）：是指事务从开始执行到结束执行之间的中间状态不会被其他事务看到。</li><li>隔离性（Isolation）：是指数据库允许多个事务同时对数据进行读写或修改的能力，并且整个过程对各个事务来说是相互隔离的。</li><li>持久性（Durability）：是指每次事务提交之后都不会丢失。</li></ul><p>关系型数据库一般遵循三范式设计思想，具体内容如下。</p><p><strong>第一范式（The First Normal Form，1NF）</strong>：要求对属性的原子性，也就是说要求数据库中的字段需要具备原子性，不能再被拆分。</p><p>比如，用户表中有字段：用户 ID、用户名、电话；而其中电话又可以分为：家庭电话和移动电话等。因此，此表不符合第一范式，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p><strong>第二范式（The Second Normal Form，2NF）</strong>：例如订单详情表有这些字段：订单 ID、产品 ID、产品名称、产品单价、折扣。其中，订单 ID 和产品 ID 为联合主键，但这个表中的产品名称和产品单价两个字段只依赖产品 ID，和订单 ID 就没有任何关系了，因此这个表也不符合第二范式。</p><p>我们可以把原来的订单表拆分为订单表和产品表，其中订单表包含：订单 ID、产品 ID、折扣等字段；而产品表包含：产品 ID、产品名称、产品单价等字段。这样就消除了产品名称和产品单价多次重复出现的情况了，从而避免了冗余数据的产生。</p><p><img data-src="2.png" alt="2.png"></p><p><strong>第三范式（The Third Normal Form，3NF）</strong>：想要满足第三范式必须先满足第二范式，第三范式要求所有的非主键字段必须直接依赖主键，且不存在传递依赖的情况。</p><p>例如，有一个学生表中包含了：学生 ID、姓名、所在学院 ID、学院电话、学院地址等字段。这个表的所有字段（除去主键字段）都完全依赖唯一的主键字段（学生 ID），所以符合第二范式。但它存在一个问题，学院电话、学院地址依赖非主键字段学院 ID，而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合第三范式。</p><p>我们可以把学生表分为两张表，一张是学生表包含了：学生 ID、姓名、所在学院 ID 等字段；另一张为学院表包含了：学院 ID、学院电话、学院地址等字段，这样就满足第三范式的要求了。</p><p><img data-src="3.png" alt="3.png"></p><p>可以看出，使用三范式可以避免数据的冗余，而且在更新表操作时，只需要更新单张表就可以了。</p><p>但随着互联网应用的快速发展，我们需要应对日益复杂且快速迭代的数据库，以应对互联网快速发展的趋势，于是诞生了以 MongoDB 为代表的文档型数据库。它提供了更高效的读/写性能以及可自动容灾的数据库集群，还有灵活的数据库结构，从而给系统的数据库存储带来了更多可能 性。</p><p>当然 MongoDB 的诞生并不是为了替代关系型数据库，而是为系统的快速开发提供一种可能性，它和关系型数据库是一种互补的关系，可供开发者在不同的业务场景下选择相对应的数据库类型。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>本课时的面试题考察的是面试者对数据库整体概念的理解与区分，这个问题看似简单，但包含着众多小的知识点，面试者需要真正的理解关系型数据库和非关系型数据库以及文档型数据库之间的区别才能灵活应对。与之相关的面试题还有：</p><ul><li>非关系型数据库和文档型数据库有什么区别？</li><li>MongoDB 支持事务吗？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="非关系型数据库-VS-文档型数据库"><a href="#非关系型数据库-VS-文档型数据库" class="headerlink" title="非关系型数据库 VS 文档型数据库"></a>非关系型数据库 VS 文档型数据库</h3><p>非关系型数据和文档型数据库属于包含关系，非关系型数据包含了文档型数据库，文档型数据库属于非关系型数据。</p><p>非关系型数据通常包含 3 种数据库类型：文档型数据库、键值型数据库和全文搜索型数据库，下面分别来看每种类型的具体用途。</p><h4 id="1-文档型数据库"><a href="#1-文档型数据库" class="headerlink" title="1.文档型数据库"></a>1.文档型数据库</h4><p>文档型数据库以 MongoDB 和 Apache CouchDB 为代表，文档型数据库通常以 JSON 或者 XML 为格式进行数据存储。</p><p>以 MongoDB 为例，它是由 C++ 编写的一种面向文档的数据库管理系统，在 2007 年 10 月 由 10gen 团队所开发，并在 2009 年 2 月首度推出。MongoDB 是以二进制 JSON 格式存储数据的，MongoDB 对 JSON 做了一些优化，它支持了更多的数据类型，这种二进制存储的 JSON 我们也可以称之为 <strong>BSON（Binary JSON）。</strong></p><p>BSON 具备三个特点：轻量、可遍历以及高效，它的缺点是空间利用率不是很理想。MongoDB 使用 BSON 进行存储的另一个重要原因是 BSON 具备可遍历性。</p><p>MongoDB 存储结构示例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"_id":ObjectId(“57ce2d4cce8685a6fd9df3a3"),"name":"老王","email":['java@qq.com','java@163.com']&#125;</span><br></pre></td></tr></table></figure><p>其中，“_id”为 MongoDB 默认的主键字段，它会为我们生成一起全局唯一的 id 值，并且这个值在做数据分片时非常有用。</p><p>文档型数据库的使用场景如下。</p><ul><li><strong>敏捷开发</strong>，因为 MongoDB 拥有比关系型数据库更快的开发速度，因此很多敏捷开发组织，包括纽约时报等都采用了 MongoDB 数据库。使用它可以有效地避免在增加和修改数据库带来的沟通成本，以及维护和创建数据库模型成本，使用 MongoDB 只需要在程序层面严格把关就行，程序提交的数据结构可以直接更新到数据库中，并不需要繁杂的设计数据库模型再生成修改语句等过程。</li><li><strong>日志系统</strong>，使用 MongoDB 数据库非常适合存储日志，日志对应到数据库中就是很多个文件，而 MongoDB 更擅长存储和查询文档，它提供了更简单的存储和更方便的查询功能。</li><li><strong>社交系统</strong>，使用 MongoDB 可以很方便的存储用户的位置信息，可以方便的实现查询附近的人以及附近的地点等功能。</li></ul><h4 id="2-键值型数据库"><a href="#2-键值型数据库" class="headerlink" title="2.键值型数据库"></a>2.键值型数据库</h4><p>键值数据库也就是 <strong>Key-Value 数据库</strong>，它的典型代表数据库是 <strong>Redis 和 Memcached</strong>，而它们通常被当做非持久化的内存型数据库缓存来使用。当然 Redis 数据库是具备可持久化得能力的，但是开启持久化会降低系统的运行效率，因此在使用时需要根据实际的情况，选择开启或者关闭持久化的功能。</p><p>键值型数据库以极高的性能著称，且除了 Key-Value 字符串类型之外，还包含一些其他的数据类型。以 Redis 为例，它提供了字符串类型（String）、列表类型（List）、哈希表类型（Hash）、集合类型（Set）、有序集合类型（ZSet）等五种最常用的基础数据类型，还有管道类型（Pipeline）、地理位置类型（GEO）、基数统计类型（HyperLogLog）和流类型（Stream），并且还提供了消息队列的功能。</p><p>此数据库的优点是性能比较高，缺点是对事务的支持不是很好。</p><h4 id="3-全文搜索型数据库"><a href="#3-全文搜索型数据库" class="headerlink" title="3.全文搜索型数据库"></a>3.全文搜索型数据库</h4><p>传统的关系型数据库主要是依赖索引来实现快速查询功能的，而在全文搜索的业务下，索引很难满足查询的需求。因为全文搜索需要支持模糊匹配的，当数据量比较大的情况下，传递的关系型数据库的查询效率是非常低的；另一个原因是全文搜索需要支持多条件随意组合排序，如果要通过索引来实现的话，则需要创建大量的索引，而传统型数据库也很难实现，因此需要专门全文搜索引擎和相关的数据库才能实现此功能。</p><p>全文搜索型数据库以 ElasticSearch 和 Solr 为代表，它们的出现解决了关系型数据库全文搜索功能较弱的问题。</p><h5 id="MongoDB-事务"><a href="#MongoDB-事务" class="headerlink" title="MongoDB 事务"></a>MongoDB 事务</h5><p>MongoDB 在 4.0 之前是不支持事务的，不支持的原因也很简单，因为文档型数据库和传统的关系型数据库不一样，不需要满足三范式。文档型数据库之所以性能比较高的另一个主要原因，就是使用文档型数据库不用进行多表关联性查询，因为文档型数据库会把相关的信息存放到一张表中。因此，无需关联多表查询的 MongoDB，在这种情况下的查询性能是比较高的。</p><p>把所有相关的数据都放入一个表中，这也是 MongoDB 之前很长一段时间内不支持事务的原因，它可以保证单表操作的原子性，一条记录要么成功插入，要么插入失败，不会存在插入了一半的数据。因此，在这种设计思路下，MongoDB 官方认为“事务功能”的实现没有那么紧迫。</p><p>但在 MongoDB 4.0 之中正式添加了事务的功能，并且在 MongoDB 4.2 中实现了分布式事务的功能，至此 MongoDB 开启了支持事务之旅。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们首先讲了关系型数据库的 ACID 特性以及设计时需要遵循的三范式设计思想；然后介绍了以 MongoDB 为代表的文档型数据库与关系型数据库的不同；最后还讲了 MongoDB 的事务功能，以及文档性数据库与非关系型数据库的关系，希望本课时的内容对你有帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 的优化方案有哪些</title>
      <link href="/2020/05/07/MySQL-%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
      <url>/2020/05/07/MySQL-%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<p><strong>性能优化（Optimize）</strong>指的是在保证系统正确性的前提下，能够更快速响应请求的一种手段。而且有些性能问题，比如慢查询等，如果积累到一定的程度或者是遇到急速上升的并发请求之后，会导致严重的后果，轻则造成服务繁忙，重则导致应用不可用。它对我们来说就像一颗即将被引爆的定时炸弹一样，时刻威胁着我们。因此在上线项目之前需要严格的把关，以确保 MySQL 能够以最优的状态进行运行。同时，在实际工作中还有面试中关于 MySQL 优化的知识点，都是面试官考察的重点内容。</p><p>我们本课时的面试题是，MySQL 的优化方案有哪些？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>MySQL 数据库常见的优化手段分为三个层面：<strong>SQL 和索引优化、数据库结构优化、系统硬件优化等</strong>，然而每个大的方向中又包含多个小的优化点，下面我们具体来看看。</p><h3 id="1-SQL-和索引优化"><a href="#1-SQL-和索引优化" class="headerlink" title="1.SQL 和索引优化"></a>1.SQL 和索引优化</h3><p>此优化方案指的是通过优化 SQL 语句以及索引来提高 MySQL 数据库的运行效率，具体内容如下。</p><h4 id="①-使用正确的索引"><a href="#①-使用正确的索引" class="headerlink" title="① 使用正确的索引"></a>① 使用正确的索引</h4><p>索引是数据库中最重要的概念之一，也是提高数据库性能最有效的手段之一，它的诞生本身就是为了提高数据查询效率的，就像字典的目录一样，通过目录可以很快找到相关的内容，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p><img data-src="2.png" alt="2.png"></p><p>假如我们没有添加索引，那么在查询时就会触发全表扫描，因此查询的数据就会很多，并且查询效率会很低，为了提高查询的性能，我们就需要给最常使用的查询字段上，添加相应的索引，这样才能提高查询的性能。</p><blockquote><p>小贴士：我们应该尽可能的使用主键查询，而非其他索引查询，因为主键查询不会触发回表查询，因此节省了一部分时间，变相的提高了查询的性能。</p></blockquote><p>在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，在 MySQL 5.0 之后的版本中引入了索引合并，简单来说就是把多条件查询，比如 or 或 and 查询的结果集进行合并交集或并集的功能，因此就不会导致索引失效的问题了。</p><p>避免在 where 查询条件中使用 != 或者 &lt;&gt; 操作符，因为这些操作符会导致查询引擎放弃索引而进行全表扫描。</p><p>适当使用前缀索引，MySQL 是支持前缀索引的，也就是说我们可以定义字符串的一部分来作为索引。我们知道索引越长占用的磁盘空间就越大，那么在相同数据页中能放下的索引值也就越少，这就意味着搜索索引需要的查询时间也就越长，进而查询的效率就会降低，所以我们可以适当的选择使用前缀索引，以减少空间的占用和提高查询效率。比如，邮箱的后缀都是固定的“@xxx.com”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引。</p><h4 id="②-查询具体的字段而非全部字段"><a href="#②-查询具体的字段而非全部字段" class="headerlink" title="② 查询具体的字段而非全部字段"></a>② 查询具体的字段而非全部字段</h4><p>要尽量避免使用 select *，而是查询需要的字段，这样可以提升速度，以及减少网络传输的带宽压力。</p><h4 id="③-优化子查询"><a href="#③-优化子查询" class="headerlink" title="③ 优化子查询"></a>③ 优化子查询</h4><p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，但 Join 语句并不会创建临时表，因此性能会更高。</p><h4 id="④-注意查询结果集"><a href="#④-注意查询结果集" class="headerlink" title="④ 注意查询结果集"></a>④ 注意查询结果集</h4><p>我们要尽量使用小表驱动大表的方式进行查询，也就是如果 B 表的数据小于 A 表的数据，那执行的顺序就是先查 B 表再查 A 表，具体查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B);</span><br></pre></td></tr></table></figure><h4 id="⑤-不要在列上进行运算操作"><a href="#⑤-不要在列上进行运算操作" class="headerlink" title="⑤ 不要在列上进行运算操作"></a>⑤ 不要在列上进行运算操作</h4><p>不要在列字段上进行算术运算或其他表达式运算，否则可能会导致查询引擎无法正确使用索引，从而影响了查询的效率。</p><h4 id="⑥-适当增加冗余字段"><a href="#⑥-适当增加冗余字段" class="headerlink" title="⑥ 适当增加冗余字段"></a>⑥ 适当增加冗余字段</h4><p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是<strong>以空间换时间的优化策略</strong>。</p><h3 id="2-数据库结构优化"><a href="#2-数据库结构优化" class="headerlink" title="2.数据库结构优化"></a>2.数据库结构优化</h3><h4 id="①-最小数据长度"><a href="#①-最小数据长度" class="headerlink" title="① 最小数据长度"></a>① 最小数据长度</h4><p>一般说来数据库的表越小，那么它的查询速度就越快，因此为了提高表的效率，应该将表的字段设置的尽可能小，比如身份证号，可以设置为 char(18) 就不要设置为 varchar(18)。</p><h4 id="②-使用最简单数据类型"><a href="#②-使用最简单数据类型" class="headerlink" title="② 使用最简单数据类型"></a>② 使用最简单数据类型</h4><p>能使用 int 类型就不要使用 varchar 类型，因为 int 类型比 varchar 类型的查询效率更高。</p><h4 id="③-尽量少定义-text-类型"><a href="#③-尽量少定义-text-类型" class="headerlink" title="③ 尽量少定义 text 类型"></a>③ 尽量少定义 text 类型</h4><p>text 类型的查询效率很低，如果必须要使用 text 定义字段，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率。</p><h4 id="④-适当分表、分库策略"><a href="#④-适当分表、分库策略" class="headerlink" title="④ 适当分表、分库策略"></a>④ 适当分表、分库策略</h4><p>分表和分库方案也是我们经常说的垂直分隔（分表）和水平分隔（分库）。</p><p><strong>分表</strong>是指当一张表中的字段更多时，可以尝试将一张大表拆分为多张子表，把使用比较高频的主信息放入主表中，其他的放入子表，这样我们大部分查询只需要查询字段更少的主表就可以完成了，从而有效的提高了查询的效率。</p><p><strong>分库</strong>是指将一个数据库分为多个数据库。比如我们把一个数据库拆分为了多个数据库，一个主数据库用于写入和修改数据，其他的用于同步主数据并提供给客户端查询，这样就把一个库的读和写的压力，分摊给了多个库，从而提高了数据库整体的运行效率。</p><h3 id="3-硬件优化"><a href="#3-硬件优化" class="headerlink" title="3.硬件优化"></a>3.硬件优化</h3><p>MySQL 对硬件的要求主要体现在三个方面：磁盘、网络和内存。</p><h4 id="①-磁盘"><a href="#①-磁盘" class="headerlink" title="① 磁盘"></a>① 磁盘</h4><p>磁盘应该尽量使用有高性能读写能力的磁盘，比如固态硬盘，这样就可以减少 I/O 运行的时间，从而提高了 MySQL 整体的运行效率。</p><p>磁盘也可以尽量使用多个小磁盘而不是一个大磁盘，因为磁盘的转速是固定的，有多个小磁盘就相当于拥有多个并行运行的磁盘一样。</p><h4 id="②-网络"><a href="#②-网络" class="headerlink" title="② 网络"></a>② 网络</h4><p>保证网络带宽的通畅（低延迟）以及够大的网络带宽是 MySQL 正常运行的基本条件，如果条件允许的话也可以设置多个网卡，以提高网络高峰期 MySQL 服务器的运行效率。</p><h4 id="③-内存"><a href="#③-内存" class="headerlink" title="③ 内存"></a>③ 内存</h4><p>MySQL 服务器的内存越大，那么存储和缓存的信息也就越多，而内存的性能是非常高的，从而提高了整个 MySQL 的运行效率。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>MySQL 性能优化的方案很多，因此它可以全面考察的一个程序员的经验是否丰富。当然这个问题的回答也是可深可浅，不同的岗位对此问题的答案要求也是不同的，这个问题也可以引申出更多的面试问题，比如：</p><ul><li>联合索引需要注意什么问题？</li><li>如何排查慢查询？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="正确使用联合索引"><a href="#正确使用联合索引" class="headerlink" title="正确使用联合索引"></a>正确使用联合索引</h3><p>使用了 B+ 树的 MySQL 数据库引擎，比如 InnoDB 引擎，在每次查询复合字段时是从左往右匹配数据的，因此在创建联合索引的时候需要注意索引创建的顺序。例如，我们创建了一个联合索引是 idx(name,age,sex)，那么当我们使用，姓名+年龄+性别、姓名+年龄、年龄+性别等这种从左往右顺序查询的条件时，就会触发联合索引进行查询；然而如果使用年龄+姓名这种非从左边往右边匹配的组合查询条件，就不能使用此联合索引进行查询了。</p><p>当然，当我们已经有了（name,age）这个联合索引之后，一般情况下就不需要在 name 字段单独创建索引了，这样就可以少维护一个索引。</p><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p><strong>慢查询</strong>通常的排查手段是先使用慢查询日志功能，查询出比较慢的 SQL 语句，然后再通过 explain 来查询 SQL 语句的执行计划，最后分析并定位出问题的根源，再进行处理。</p><p>慢查询日志指的是在 MySQL 中可以通过配置来开启慢查询日志的记录功能，超过 long_query_time 值的 SQL 将会被记录在日志中。我们可以通过设置“slow_query_log=1”来开启慢查询，它的开启方式有两种：</p><ul><li>通过 MySQL 命令行的模式进行开启，只需要执行“set global slow_query_log=1”即可，然而这种配置模式再重启 MySQL 服务之后就会失效；</li><li>另一种方式可通过修改 MySQL 配置文件的方式进行开启，我们需要配置 my.cnf 中的“slow_query_log=1”即可，并且可以通过设置“slow_query_log_file=/tmp/mysql_slow.log”来配置慢查询日志的存储目录，但这种方式配置完成之后需要重启 MySQL 服务器才可生效。</li></ul><p>需要注意的是，在开启慢日志功能之后，会对 MySQL 的性能造成一定的影响，因此在生产环境中要慎用此功能。</p><p>explain 执行计划的使用示例 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">where</span> uname = <span class="string">'Java'</span>;</span><br></pre></td></tr></table></figure><p>它的执行结果如下图所示：</p><p><img data-src="3.png" alt="3.png"></p><p>摘要说明如下表所示：</p><p><img data-src="4.png" alt="4.png"></p><p>以上字段中最重要的就是 type 字段，它的所有值如下所示：</p><p><img data-src="5.png" alt="5.png"></p><p>当 type 为 all 时，则表示全表扫描，因此效率会比较低，此时需要查看一下为什么会造成此种原因，是没有创建索引还是索引创建的有问题？以此来优化整个 MySQL 运行的速度。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们从三个维度讲了 MySQL 的优化手段：SQL 和索引优化、数据库结构优化以及系统硬件优化等；同时深入到每个维度中，详细地介绍了 MySQL 具体的优化细节；最后我们讲了联合索引的最左匹配原则，以及慢查询的具体解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的运行机制是什么它有哪些引擎</title>
      <link href="/2020/05/07/MySQL%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E6%93%8E/"/>
      <url>/2020/05/07/MySQL%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>数据库是 Java 程序员面试必问的知识点之一，它和 Java 的核心面试点共同组成了一个完整的技术面试。而数据库一般泛指的就是 MySQL，因为 MySQL 几乎占据了数据库的半壁江山，即使有些公司没有使用 MySQL 数据库，如果你对 MySQL 足够精通的话，也是会被他们录取的。因为数据库的核心与原理基本是相通的，所以有了 MySQL 的基础之后，再去熟悉其他数据库也是非常快的，那么接下来的几个课时就让我们好好的学习一下 MySQL。</p><p>我们本课时的面试题是，MySQL 是如何运行的？说一下它有哪些引擎？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>MySQL 的执行流程是这样的，首先客户端先要发送用户信息去服务器端进行授权认证。如果使用的是命令行工具，通常需要输入如下信息：</p><blockquote><p>mysql -h 主机名(IP) -u 用户名 -P 端口 -p</p></blockquote><p>其中：</p><ul><li>h 表示要连接的数据库服务器的主机名或者 IP 信息；</li><li>u 表示数据库的用户名称；</li><li>P 表示数据库服务器的端口号，</li><li>小写的 -p 表示需要输入数据库的密码。</li></ul><p>具体使用示例，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p><strong>当输入正确密码之后可以连接到数据库了</strong>，如果密码输入错误，则会提示“Access denied for user ‘xxx’@’xxx’ (using password: YES)”密码错误信息，如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><p><strong>当连接服务器端成功之后就可以正常的执行 SQL 命令了</strong>，MySQL 服务器拿到 SQL 命令之后，<strong>会使用 MySQL 的分析器解析 SQL 指令，同时会根据语法分析器验证 SQL 指令</strong>，查询 SQL 指令是否满足 MySQL 的语法规则。如果不支持此语法，则会提示“SQL syntax”语法错误信息。</p><p><strong>当分析器验证并解析 SQL 命令之后，会进入优化器阶段，执行生成计划，并设置相应的索引；当上面的这些步骤都执行完之后，就进入了执行器阶段，并开始正式执行 SQL 命令。</strong>同样在执行命令之前，它会先对你的执行命令进行权限查询，看看是否有操作某个表的权限，如果有相应的权限，执行器就去调用 MySQL 数据库引擎提供的接口，<strong>执行相应的命令；如果是非查询操作会记录对应的操作日志，再命令执行完成之后返回结果给客户端，这就是整个 MySQL 操作的完整流程</strong>。</p><p>需要注意的是，如果执行的是 select 语句并且是 MySQL 8.0 之前的版本的话，则会去 MySQL 的查询缓存中查看之前是否有执行过这条 SQL；如果缓存中可以查到，则会直接返回查询结果，这样查询性能就会提升很高。</p><p>整个 SQL 的执行流程，如下图所示：</p><p><img data-src="3.png" alt="3.png"></p><p>我们可以使用 SHOW ENGINES 命令来查看 MySQL 数据库使用的存储引擎，如下图所示：</p><p><img data-src="4.png" alt="4.png"></p><p>常用的数据库引擎有 InnoDB、MyISAM、MEMORY 等，其中 InnoDB 支持事务功能，而 MyISAM 不支持事务，但 MyISAM 拥有较高的插入和查询的速度。而 MEMORY 是内存型的数据库引擎，它会将表中的数据存储到内存中，因为它是内存级的数据引擎，因此具备最快速的查询效率，但它的缺点是，重启数据库之后，所有数据都会丢失，因为这些数据是存放在内存中的。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>此面试题考察的是面试者对 MySQL 基础知识的掌握程度，以及对于 MySQL 引擎的了解程度，这些都是属于 MySQL 最核心的原理之一，也是面试中常见的面试问题，它一般作为数据库面试题的开始题目，和此面试题相关的面试点还有以下几个：</p><ul><li>查询缓存在什么问题？</li><li>如何选择数据库的引擎？</li><li>InnoDB 自增索引的持久化问题。</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-查询缓存的利弊"><a href="#1-查询缓存的利弊" class="headerlink" title="1.查询缓存的利弊"></a>1.查询缓存的利弊</h3><p>MySQL 8.0 之前可以正常的使用查询缓存的功能，可通过“SHOW GLOBAL VARIABLES LIKE ‘query_cache_type’”命令查询数据库是否开启了查询缓存的功能，它的结果值有以下三项：</p><ul><li>OFF，关闭了查询缓存功能；</li><li>ON，开启了查询缓存功能；</li><li>DEMAND，在 sql 语句中指定 sql_cache 关键字才会有查询缓存，也就是说必须使用 sql_cache 才可以把该 select 语句的查询结果缓存起来，比如“select sql_cache name from token where tid=1010”语句。</li></ul><p>开启和关闭查询缓存可以通过修改 MySQL 的配置文件 my.cnf 进行修改，它的配置项如下：</p><blockquote><p>query_cache_type = ON</p></blockquote><p>注意：配置被更改之后需要重启 MySQL 服务才能生效。</p><p>查询缓存的功能要根据实际的情况进行使用，建议设置为<strong>按需缓存（DEMAND）模式</strong>，因为查询缓存的功能并不是那么好用。比如我们设置了 query_cache_type = ON，当我们好不容易缓存了很多查询语句之后，任何一条对此表的更新操作都会把和这个表关联的所有查询缓存全部清空，那么在更新频率相对较高的业务中，查询缓存功能完全是一个鸡肋。因此，在 MySQL 8.0 的版本中已经完全移除了此功能，也就是说在 MySQL 8.0 之后就完全没有查询缓存这个概念和功能了。</p><h3 id="2-如何选择数据库引擎"><a href="#2-如何选择数据库引擎" class="headerlink" title="2.如何选择数据库引擎"></a>2.如何选择数据库引擎</h3><p>选择数据库引擎要从实际的业务情况入手，比如是否需要支持事务？是否需要支持外键？是否需要支持持久化？以及是否支持地理位置存储以及索引等方面进行综合考量。</p><p>我们最常用的数据库引擎是 InnoDB，它是 MySQL 5.5.5 之后的默认引擎，其优点是支持事务，且支持 4 种隔离级别。</p><ul><li><p>读未提交：也就是一个事务还没有提交时，它做的变更就能被其他事务看到。</p></li><li><p>读已提交：指的是一个事务只有提交了之后，其他事务才能看得到它的变更。</p></li><li><p>可重复读：此方式为默认的隔离级别，它是指一个事务在执行过程中（从开始到结束）看到的数据都是一致的，在这个过程中未提交的变更对其他事务也是不可见的。</p></li><li><p>串行化：是指对同一行记录的读、写都会添加读锁和写锁，后面访问的事务必须等前一个事务执行完成之后才能继续执行，所以这种事务的执行效率很低。</p></li></ul><p>InnoDB 还支持外键、崩溃后的快速恢复、支持全文检索（需要 5.6.4+ 版本）、集群索引，以及地理位置类型的存储和索引等功能。</p><p>MyISAM 引擎是 MySQL 原生的引擎，但它并不支持事务功能，这也是后来被 InnoDB 替代为默认引擎的主要原因。MyISAM 有独立的索引文件，因此在读取数据方面的性能很高，它也支持全文索引、地理位置存储和索引等功能，但不支持外键。</p><p>InnoDB 和 MyISAM 都支持持久化，但 MEMORY 引擎是将数据直接存储在内存中了，因此在重启服务之后数据就会丢失，但它带来的优点是执行速度很快，可以作为临时表来使用。</p><p>我们可以根据实际的情况设置相关的数据库引擎，还可以针对不同的表设置不同的数据引擎，只需要在创建表的时候指定 engine=引擎名称即可，SQL 代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">   uname <span class="built_in">varchar</span>(<span class="number">60</span>),</span><br><span class="line">   age <span class="built_in">int</span></span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">Memory</span>;</span><br></pre></td></tr></table></figure><h3 id="3-InnoDB-自增主键"><a href="#3-InnoDB-自增主键" class="headerlink" title="3.InnoDB 自增主键"></a>3.InnoDB 自增主键</h3><p>在面试的过程中我们经常看到这样一道面试题：</p><blockquote><p>在一个自增表里面一共有 5 条数据，id 从 1 到 5，删除了最后两条数据，也就是 id 为 4 和 5 的数据，之后重启的 MySQL 服务器，又新增了一条数据，请问新增的数据 id 为几？</p></blockquote><p>我们通常的答案是如果表为 MyISAM 引擎，那么 id 就是 6，如果是 InnoDB 那么 id 就是 4。</p><p>但是这个情况在高版本的 InnoDB 中，也就是 MySQL 8.0 之后就不准确了，它的 id 就不是 4 了，而是 6 了。因为在 MySQL 8.0 之后 InnoDB 会把索引持久化到日志中，重启服务之后自增索引是不会丢失的，因此答案是 6，这个需要面试者注意一下。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们讲了 MySQL 数据库运行流程的几个阶段，先从连接器授权，再到分析器进行语法分析。如果是 MySQL 8.0 之前的 select 语句可能会先查询缓存，如果有缓存则会直接返回结果给客户端，否则会从分析器进入优化器生成 SQL 的执行计划，然后交给执行器调用操作引擎执行相关的 SQL，再把结果返回给客户端。我们还讲了最常见的三种数据库引擎 InnoDB、MyISAM、MEMORY，以及它们的利弊分析。最后讲了 InnoDB 在高版本（8.0）之后可以持久化自增主键的小特性，希望可以帮助到你。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ有什么作用,你都用过哪些MQ中间件</title>
      <link href="/2020/05/07/MQ%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8-%E4%BD%A0%E9%83%BD%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BMQ%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2020/05/07/MQ%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8-%E4%BD%A0%E9%83%BD%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BMQ%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在第 10 课时中讲过“手写消息队列”，当时粗略的讲了 Java API 中使用 Queue 实现自定义消息队列，以及使用 Delayed 实现延迟队列的示例；同时还讲了 RabbitMQ 中的一些基础概念。本课时我们将会更加深入的讲解 MQ（Message Queue，消息队列）中间件，以及这些热门中间件的具体使用。</p><p>我们本课时的面试题是，MQ 常见的使用场景有哪些？你都用过哪些 MQ 中间件？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>在介绍 MQ 的使用场景之前，先来回忆一下 MQ 的作用。MQ 可以用来实现削峰填谷，也就是使用它可以解决短时间内爆发式的请求任务，在不使用 MQ 的情况下会导致服务处理不过来，出现应用程序假死的情况，而使用了 MQ 之后可以把这些请求先暂存到消息队列中，然后进行排队执行，那么就不会出现应用程序假死的情况了，所以它的<strong>第一个应用就是商品秒杀以及产品抢购等使用场景</strong>，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><h3 id="使用-MQ-实现消息通讯"><a href="#使用-MQ-实现消息通讯" class="headerlink" title="使用 MQ 实现消息通讯"></a>使用 MQ 实现消息通讯</h3><p>使用 MQ 可以作为消息通讯的实现手段，利用它可以实现点对点的通讯或者多对多的聊天室功能。</p><p>点对点的消息通讯如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><p>多对多的消息通讯如下图所示：</p><p><img data-src="3.png" alt="3.png"></p><h3 id="使用-MQ-实现日志系统"><a href="#使用-MQ-实现日志系统" class="headerlink" title="使用 MQ 实现日志系统"></a>使用 MQ 实现日志系统</h3><p>可使用 MQ 实现对日志的采集和转发，比如有多个日志写入到程序中，然后把日志添加到 MQ，紧接着由日志处理系统订阅 MQ，最后 MQ 将消息接收并转发给日志处理系统，这样就完成了日志的分析和保存功能，如下图所示：</p><p><img data-src="4.png" alt="4.png"></p><p>常用的 MQ 中间件有 RabbitMQ、Kafka 和 Redis 等，其中 Redis 属于轻量级的消息队列，而 RabbitMQ、Kafka 属于比较成熟且比较稳定和高效的 MQ 中间件。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>MQ 属于中高级或优秀的程序员必备的技能，对于 MQ 中间件掌握的数量则是你技术广度和编程经验的直接体现信息之一。值得庆幸的是，关于 MQ 中间件的实现原理和使用方式都比较类似，因此如果开发者掌握一项 MQ 中间件再去熟悉其他 MQ 中间件时，会非常的容易。</p><p>MQ 相关的面试题还有这些：</p><ul><li>MQ 的特点是什么？引入 MQ 中间件会带来哪些问题？</li><li>常见的 MQ 中间件的优缺点分析。</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="MQ-的特点及注意事项"><a href="#MQ-的特点及注意事项" class="headerlink" title="MQ 的特点及注意事项"></a>MQ 的特点及注意事项</h3><p>MQ 具有以下 5 个特点。</p><ul><li><p><strong>先进先出：</strong>消息队列的顺序一般在入列时就基本确定了，最先到达消息队列的信息，一般情况下也会先转发给订阅的消费者，我们把这种实现了先进先出的数据结构称之为队列。</p></li><li><p><strong>发布、订阅工作模式</strong>：生产者也就是消息的创建者，负责创建和推送数据到消息服务器；消费者也就是消息的接收方，用于处理数据和确认消息的消费；消息队列也是 MQ 服务器中最重要的组成元素之一，它负责消息的存储，这三者是 MQ 中的三个重要角色。而它们之间的消息传递与转发都是通过发布以及订阅的工作模式来进行的，即生产者把消息推送到消息队列，消费者订阅到相关的消息后进行消费，在消息非阻塞的情况下，此模式基本可以实现同步操作的效果。并且此种工作模式会把请求的压力转移给 MQ 服务器，以减少了应用服务器本身的并发压力。</p></li><li><p><strong>持久化</strong>：持久化是把消息从内存存储到磁盘的过程，并且在服务器重启或者发生宕机的情况下，重新启动服务器之后是保证数据不会丢失的一种手段，也是目前主流 MQ 中间件都会提供的重要功能。</p></li><li><p><strong>分布式：</strong>MQ 的一个主要特性就是要应对大流量、大数据的高并发环境，一个单体的 MQ 服务器是很难应对这种高并发的压力的，所以 MQ 服务器都会支持分布式应用的部署，以分摊和降低高并发对 MQ 系统的冲击。</p></li><li><p><strong>消息确认：</strong>消息消费确认是程序稳定性和安全性的一个重要考核指标，假如消费者在拿到消息之后突然宕机了，那么 MQ 服务器会误认为此消息已经被消费者消费了，从而造成消息丢失的问题，而目前市面上的主流 </p><p>MQ 都实现了消息确认的功能，保证了消息不会丢失，从而保证了系统的稳定性。</p></li></ul><h4 id="引入-MQ-系统会带来的问题"><a href="#引入-MQ-系统会带来的问题" class="headerlink" title="引入 MQ 系统会带来的问题"></a>引入 MQ 系统会带来的问题</h4><p>任何系统的引入都是有两面性的，MQ 也不例外，在引入 MQ 之后，可能会带来以下两个问题。</p><ul><li>增加了系统的运行风险：引入 MQ 系统，则意味着新增了一套系统，并且其他的业务系统会对 MQ 系统进行深度依赖，系统部署的越多则意味着发生故障的可能性就越大，如果 MQ 系统挂掉的话可能会导致整个业务系统瘫痪。</li><li>增加了系统的复杂度：引入 MQ 系统后，需要考虑消息丢失、消息重复消费、消息的顺序消费等问题，同时还需要引入新的客户端来处理 MQ 的业务，增加了编程的运维门槛，增加了系统的复杂性。</li></ul><p>使用 MQ 需要注意的问题，不要过度依赖 MQ，比如发送短信验证码或邮件等功能，这种低频但有可能比较耗时的功能可以使用多线程异步处理即可，不用任何的功能都依赖 MQ 中间件来完成，但像秒杀抢购可能会导致超卖（也就是把货卖多了，库存变成负数了）等短时间内高并发的请求，此时建议使用 MQ 中间件。</p><h3 id="常用的-MQ-中间件"><a href="#常用的-MQ-中间件" class="headerlink" title="常用的 MQ 中间件"></a>常用的 MQ 中间件</h3><p>常用的 MQ 中间件有 Redis、RabbitMQ、Kafka，下来我们分别来看看各自的作用。</p><h4 id="Redis-轻量级的消息中间件"><a href="#Redis-轻量级的消息中间件" class="headerlink" title="Redis 轻量级的消息中间件"></a>Redis 轻量级的消息中间件</h4><p>Redis 是一个高效的内存性数据库中间件，但使用 Redis 也可以实现消息队列的功能。</p><p>早期的 Redis（Redis 5.0 之前）是不支持消息确认的，那时候我们可以通过 List 数据类型的 lpush 和 rpop 方法来实现队列消息的存入和读取功能，或者使用 Redis 提供的发布订阅（pub/sub）功能来实现消息队列，但这种模式不支持持久化，List 虽然支持持久化但不能设置复杂的路由规则来匹配多个消息，并且他们二者都不支持消息消费确认。</p><p>于是在 Redis 5.0 之后提供了新的数据类型 Stream 解决了消息确认的问题，但它同样不能提供复杂的路由匹配规则，因此在业务不复杂的场景下可以尝试性的使用 Redis 提供的消息队列。</p><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>在第 10 课时中，我们对 RabbitMQ 有过初步的讲解，它是一个实现了标准的高级消息队列协议（AMQP，Advanced Message Queuing Protocol）的老牌开源消息中间件，最初起源于金融系统，后来被普遍应用在了其他分布式系统中，它支持集群部署，和多种客户端调用。</p><p>之前主要介绍了 RabbitMQ 的基础功能，本课时我们重点来看 RabbitMQ 集群相关的内容。</p><p>RabbitMQ 集群是由多个节点组成，但默认情况下每个节点并不是存储所有队列的完整拷贝，这是出于存储空间和性能的考虑，因为如果存储了队列的完整拷贝，那么就会有很多冗余的重复数据，并且在新增节点的情况下，不但没有新增存储空间，反而需要更大的空间来存储旧的数据；同样的道理，如果每个节点都保存了所有队列的完整信息，那么非查询操作的性能就会很慢，就会需要更多的网络带宽和磁盘负载来存储这些数据。</p><p>为了能兼顾性能和稳定性，RabbitMQ 集群的节点分为两种类型，即磁盘节点和内存节点，对于磁盘节点来说显然它的优势就是稳定，可以把相关数据保存下来，若 RabbitMQ 因为意外情况宕机，重启之后保证了数据不丢失；而内存节点的优势是快，因为是在内存中进行数据交换和操作，因此性能比磁盘节点要高出很多倍。</p><p>如果是单个 RabbitMQ 那么就必须要求是磁盘节点，否则当 RabbitMQ 服务器重启之后所有的数据都会丢失，这样显然是不能接受的。在 RabbitMQ 的集群中，至少需要一个磁盘节点，这样至少能保证集群数据的相对可靠性。</p><blockquote><p>小贴士：对于 RabbitMQ 集群来说，我们启动集群节点的顺序应该是先启动磁盘节点再启动内存节点，而关闭的顺序正好和启动的顺序相反，不然可能会导致 RabbitMQ 集群启动失败或者是数据丢失等异常问题。</p></blockquote><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>Kafka 是 LinkedIn 公司开发的基于 ZooKeeper 的多分区、多副本的分布式消息系统，它于 2010 年贡献给了 Apache 基金会，并且成为了 Apache 的顶级开源项目。其中 ZooKeeper 的作用是用来为 Kafka 提供集群元数据管理以及节点的选举和发现等功能。</p><p>与 RabbitMQ 比较类似，一个典型的 Kafka 是由多个 Broker、多个生产者和消费者，以及 ZooKeeper 集群组成的，其中 Broker 可以理解为一个代理，Kafka 集群中的一台服务器称之为一个 Broker，其组成框架图如下所示：</p><p><img data-src="5.png" alt="5.png"></p><h3 id="Kafka-VS-RabbitMQ"><a href="#Kafka-VS-RabbitMQ" class="headerlink" title="Kafka VS RabbitMQ"></a>Kafka VS RabbitMQ</h3><p>Kafka（2.0.0）和 RabbitMQ（3.6.10）的区别主要体现在以下几点：</p><ul><li>Kafka 支持消息回溯，它可以根据 Offset（消息偏移量）、TimeStamp（时间戳）等维度进行消息回溯，而 RabbitMQ 并不支持消息回溯；</li><li>Kafka 的消息消费是基于拉取数据的模式，也就是消费者主动向服务器端发送拉取消息请求，而 RabbitMQ 支持拉取数据模式和主动推送数据的模式，也就说 RabbitMQ 服务器会主动把消息推送给订阅的消费者；</li><li>在相同配置下，Kafka 的吞吐量通常会比 RabbitMQ 高一到两个级别，比如在单机模式下，RabbitMQ 的吞吐量大概是万级别的处理能力，而 Kafka 则可以到达十万甚至是百万的吞吐级别；</li><li>Kafka 从 0.11 版本就开始支持幂等性了，当然所谓的幂等性指的是对单个生产者在单分区上的单会话的幂等操作，但对于全局幂等性则还需要结合业务来处理，比如，消费者在消费完一条消息之后没有来得及确认就发生异常了，等到恢复之后又得重新消费原来消费过的消息，类似这种情况，是无法在消息中间件层面来保证的，这个时候则需要引入更多的外部资源来保证全局幂等性，比如唯一的订单号、消费之前先做去重判断等；而 RabbitMQ 是没有幂等性功能支持的；</li><li>RabbitMQ 支持多租户的功能，也就是常说的 Virtual Host（vhost），每一个 vhost 相当于一个独立的小型 RabbitMQ 服务器，它们拥有自己独立的交换器、消息队列及绑定关系等，并且拥有自己独立权限，而且多个 vhost 之间是绝对隔离的，但 Kafka 并不支持多租户的功能。</li></ul><p>Kafka 和 RabbitMQ 都支持分布式集群部署，并且都支持数据持久化和消息消费确认等 MQ 的核心功能，对于 MQ 的选型要结合自己团队本身的情况，从性能、稳定性及二次开发的难易程度等维度来进行综合的考量并选择。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们讲了 MQ 的常见使用场景，以及常见的 MQ 中间件（Redis、RabbitMQ、Kafka）及其优缺点分析；同时还了解了 MQ 的五大特点：先进先出、发布和订阅的模式、持久化、分布式和消息确认等；接着讲了 MQ 引入对系统可能带来的风险；最后讲了 MQ 在使用时需要注意的问题。希望本课时对你整体了解 MQ 系统有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简谈你对synchronized关键字的理解</title>
      <link href="/2020/05/05/%E7%AE%80%E8%B0%88%E4%BD%A0%E5%AF%B9synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/05/05/%E7%AE%80%E8%B0%88%E4%BD%A0%E5%AF%B9synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="面试官：sychronized关键字有哪些特性？"><a href="#面试官：sychronized关键字有哪些特性？" class="headerlink" title="面试官：sychronized关键字有哪些特性？"></a><strong>面试官：sychronized关键字有哪些特性？</strong></h2><p>应聘者：</p><ul><li>可以用来修饰方法;</li><li>可以用来修饰代码块;</li><li>可以用来修饰静态方法;</li><li>可以保证线程安全;</li><li>支持锁的重入;</li><li>sychronized使用不当导致死锁;</li></ul><p>了解sychronized之前,我们先来看一下几个常见的概念:内置锁、互斥锁、对象锁和类锁。</p><h2 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a><strong>内置锁</strong></h2><p>在Java中每一个对象都可以作为同步的锁，那么这些锁就被称为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><strong>互斥锁</strong></h2><p>内置锁同时也是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，直到线程B抛出异常或者正常执行完毕释放这个锁；如果B线程不释放这个锁，那么A线程将永远等待下去。</p><h2 id="对象锁和类锁"><a href="#对象锁和类锁" class="headerlink" title="对象锁和类锁"></a><strong>对象锁和类锁</strong></h2><p>对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的。</p><ul><li>对象锁是用于对象实例方法；</li><li>类锁是用于类的静态方法或者一个类的class对象上的</li></ul><p>一个对象无论有多少个同步方法区，它们共用一把锁，某一时刻某个线程已经进入到某个synchronzed方法，那么在该方法没有执行完毕前，其他线程无法访问该对象的任何synchronzied 方法的，但可以访问非synchronzied方法。</p><p>如果synchronized方法是static的，那么当线程访问该方法时，它锁的并不是synchronized方法所在的对象，而是synchronized方法所在对象的对应的Class对象，</p><p>因为java中无论一个类有多少个对象，这些对象会对应唯一一个Class对象，因此当线程分别访问同一个类的两个对象的static，synchronized方法时，他们的执行也是按顺序来的，也就是说一个线程先执行，一个线程后执行。</p><p>synchronized的用法：修饰方法和修饰代码块，下面分别分析这两种用法在对象锁和类锁上的效果。</p><h2 id="对象锁的synchronized修饰方法和代码块"><a href="#对象锁的synchronized修饰方法和代码块" class="headerlink" title="对象锁的synchronized修饰方法和代码块"></a><strong>对象锁的synchronized修饰方法和代码块</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TestSynchronized myt2 = <span class="keyword">new</span> TestSynchronized();</span><br><span class="line">    Thread test1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myt2.test1();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"test1"</span>);</span><br><span class="line">    Thread test2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myt2.test2();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"test2"</span>);</span><br><span class="line">    test1.start();</span><br><span class="line">    test2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test2 : <span class="number">4</span></span><br><span class="line">test2 : <span class="number">3</span></span><br><span class="line">test2 : <span class="number">2</span></span><br><span class="line">test2 : <span class="number">1</span></span><br><span class="line">test2 : <span class="number">0</span></span><br><span class="line">test1 : <span class="number">4</span></span><br><span class="line">test1 : <span class="number">3</span></span><br><span class="line">test1 : <span class="number">2</span></span><br><span class="line">test1 : <span class="number">1</span></span><br><span class="line">test1 : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上述的代码，第一个方法用了同步代码块的方式进行同步，传入的对象实例是this，表明是当前对象；第二个方法是修饰方法的方式进行同步</p><p>。因为第一个同步代码块传入的this，所以两个同步代码所需要获得的对象锁都是同一个对象锁，下面main方法时分别开启两个线程，分别调用test1和test2方法，那么两个线程都需要获得该对象锁，另一个线程必须等待。</p><p>上面也给出了运行的结果可以看到：直到test2线程执行完毕，释放掉锁，test1线程才开始执行。这里test2方法先抢到CPU资源，故它先执行，它获得了锁，它执行完毕后，test1才开始执行。</p><p>如果我们把test2方法的synchronized关键字去掉，执行结果会如何呢？　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test1 : <span class="number">4</span></span><br><span class="line">test2 : <span class="number">4</span></span><br><span class="line">test2 : <span class="number">3</span></span><br><span class="line">test2 : <span class="number">2</span></span><br><span class="line">test2 : <span class="number">1</span></span><br><span class="line">test2 : <span class="number">0</span></span><br><span class="line">test1 : <span class="number">3</span></span><br><span class="line">test1 : <span class="number">2</span></span><br><span class="line">test1 : <span class="number">1</span></span><br><span class="line">test1 : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们可以看到，结果输出是交替着进行输出的，这是因为，某个线程得到了对象锁，但是另一个线程还是可以访问没有进行同步的方法或者代码。进行了同步的方法（加锁方法）和没有进行同步的方法（普通方法）是互不影响的，一个线程进入了同步方法，得到了对象锁，其他线程还是可以访问那些没有同步的方法（普通方法）。</p><h2 id="类锁的修饰（静态）方法和代码块"><a href="#类锁的修饰（静态）方法和代码块" class="headerlink" title="类锁的修饰（静态）方法和代码块　　"></a><strong>类锁的修饰（静态）方法和代码块</strong>　　</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (TestSynchronized<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TestSynchronized myt2 = <span class="keyword">new</span> TestSynchronized();</span><br><span class="line">    Thread test1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myt2.test1();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"test1"</span>);</span><br><span class="line">    Thread test2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestSynchronized.test2();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"test2"</span>);</span><br><span class="line">    test1.start();</span><br><span class="line">    test2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test1 : <span class="number">4</span></span><br><span class="line">test1 : <span class="number">3</span></span><br><span class="line">test1 : <span class="number">2</span></span><br><span class="line">test1 : <span class="number">1</span></span><br><span class="line">test1 : <span class="number">0</span></span><br><span class="line">test2 : <span class="number">4</span></span><br><span class="line">test2 : <span class="number">3</span></span><br><span class="line">test2 : <span class="number">2</span></span><br><span class="line">test2 : <span class="number">1</span></span><br><span class="line">test2 : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>类锁修饰方法和代码块的效果和对象锁是一样的，因为类锁只是一个抽象出来的概念，只是为了区别静态方法的特点，因为静态方法是所有对象实例共用的，所以对应着synchronized修饰的静态方法的锁也是唯一的，所以抽象出来个类锁。其实这里重点在下面这块代码，synchronized同时修饰静态和非静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TestSynchronized myt2 = <span class="keyword">new</span> TestSynchronized();</span><br><span class="line">    Thread test1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myt2.test1();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"test1"</span>);</span><br><span class="line">    Thread test2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestSynchronized.test2();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"test2"</span>);</span><br><span class="line">    test1.start();</span><br><span class="line">    test2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test1 : <span class="number">4</span></span><br><span class="line">test2 : <span class="number">4</span></span><br><span class="line">test1 : <span class="number">3</span></span><br><span class="line">test2 : <span class="number">3</span></span><br><span class="line">test2 : <span class="number">2</span></span><br><span class="line">test1 : <span class="number">2</span></span><br><span class="line">test2 : <span class="number">1</span></span><br><span class="line">test1 : <span class="number">1</span></span><br><span class="line">test1 : <span class="number">0</span></span><br><span class="line">test2 : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上面代码synchronized同时修饰静态方法和实例方法，但是运行结果是交替进行的，这证明了类锁和对象锁是两个不一样的锁，控制着不同的区域，它们是互不干扰的。同样，线程获得对象锁的同时，也可以获得该类锁，即同时获得两个锁，这是允许的。</p><h2 id="synchronized是如何保证线程安全的"><a href="#synchronized是如何保证线程安全的" class="headerlink" title="synchronized是如何保证线程安全的"></a><strong>synchronized是如何保证线程安全的</strong></h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p>我们通过一个案例，演示线程的安全问题：</p><p>我们来模拟一下火车站卖票过程，总共有100张票，总共有三个窗口卖票。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建票对象</span></span><br><span class="line">    Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">    <span class="comment">// 创建3个窗口</span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口2"</span>);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口3"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 模拟票</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 共100票</span></span><br><span class="line">  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟卖票</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 模拟选坐的操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖票:"</span></span><br><span class="line">            + ticket--);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果发现：上面程序出现了问题</p><ul><li>票出现了重复的票</li><li>错误的票 0、-1</li></ul><p>其实，线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p><p>那么出现了上述问题，我们应该如何解决呢？</p><h2 id="线程同步（线程安全处理Synchronized）"><a href="#线程同步（线程安全处理Synchronized）" class="headerlink" title="线程同步（线程安全处理Synchronized）"></a><strong>线程同步（线程安全处理Synchronized）</strong></h2><p>java中提供了线程同步机制，它能够解决上述的线程安全问题。</p><p>线程同步的方式有两种：</p><ul><li>方式1：同步代码块</li><li>方式2：同步方法</li></ul><p><strong>同步代码块</strong></p><p>同步代码块: 在代码块声明上 加上synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (锁对象) &#123;</span><br><span class="line">  可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。</p><p>使用同步代码块，对火车站卖票案例中Ticket类进行如下代码修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建票对象</span></span><br><span class="line">    Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">    <span class="comment">// 创建3个窗口</span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口2"</span>);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口3"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 模拟票</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 共100票</span></span><br><span class="line">  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">  Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟卖票</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 同步代码块</span></span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 模拟选坐的操作</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()</span><br><span class="line">              + <span class="string">"正在卖票:"</span> + ticket--);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用了同步代码块后，上述的线程的安全问题，解决了。</p><p><strong>同步方法</strong></p><p>同步方法：在方法声明上加上synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法中的锁对象是 this</p><p>使用同步方法，对火车站卖票案例中Ticket类进行如下代码修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建票对象</span></span><br><span class="line">    Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">    <span class="comment">// 创建3个窗口</span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口2"</span>);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口3"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 模拟票</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 共100票</span></span><br><span class="line">  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">  Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟卖票</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 同步方法</span></span><br><span class="line">      method();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 同步方法,锁对象this</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 模拟选坐的操作</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖票:"</span></span><br><span class="line">          + ticket--);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized支持锁的重入吗？"><a href="#synchronized支持锁的重入吗？" class="headerlink" title="synchronized支持锁的重入吗？　　"></a><strong>synchronized支持锁的重入吗？</strong>　　</h2><p>我们先来看下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"a"</span>);</span><br><span class="line">    b();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"b"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReentrantLockDemo d = <span class="keyword">new</span> ReentrantLockDemo();</span><br><span class="line">        d.a();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码，我们分析一下，两个方法，方法a和方法b都被synchronized关键字修饰，锁对象是当前对象实例，按照上文我们对synchronized的了解，如果调用方法a,在方法a还没有执行完之前，我们是不能执行方法b的，方法a必须先释放锁，方法b才能执行，方法b处于等待状态，那样不就形成死锁了吗？那么事实真的如分析一致吗？</p><p>运行结果发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><p>代码很快就执行完了，实验结果与分析不一致，这就引入了另外一个概念：重入锁。在 java 内部，同一线程在调用自己类中其他 synchronized 方法/块或调用父类的 synchronized 方法/块都不会阻碍该线程的执行。就是说同一线程对同一个对象锁是可重入的，而且同一个线程可以获取同一把锁多次，也就是可以多次重入。在JDK1.5后对synchronized关键字做了相关优化。</p><h2 id="synchronized死锁问题"><a href="#synchronized死锁问题" class="headerlink" title="synchronized死锁问题"></a><strong>synchronized死锁问题</strong></h2><p>同步锁使用的弊端：当线程任务中出现了多个同步(多个锁)时，如果同步中嵌套了其他的同步。这时容易引发一种现象：程序出现无限等待，这种现象我们称为死锁。这种情况能避免就避免掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronzied(A锁)&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(B锁)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进行下死锁情况的代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">  Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">  Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">        System.out.println(<span class="string">"a"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">        System.out.println(<span class="string">"b"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DeadLock d = <span class="keyword">new</span> DeadLock();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        d.a();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        d.b();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码，我们分析一下，两个方法，我们假设两个线程T1,T2，T1运行到方法a了，拿到了obj1这把锁，此时T2运行到方法b了，拿到了obj2这把锁，T1要往下执行，就必须等待T2释放了obj2这把锁，线程T2要往下面执行，就必须等待T1释放了持有的obj1这把锁，他们两个互相等待，就形成了死锁。</p><p>为了演示的更明白，需要让两个方法执行过程中睡眠10ms，要不然很难看到现象，因为计算机执行速度贼快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">  Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">  Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">        System.out.println(<span class="string">"a"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">        System.out.println(<span class="string">"b"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DeadLock d = <span class="keyword">new</span> DeadLock();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        d.a();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        d.b();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感兴趣的童鞋，下去可以试一下，程序执行不完，永远处于等待状态。</p><p><strong>总结</strong></p><ul><li>sychronized是隐式锁，是JVM底层支持的关键字，由JVM来维护；</li><li>单体应用下，多线程并发操作时，使用sychronized关键字可以保证线程安全;</li><li>sychronized可以用来修饰方法和代码块，此时锁是当前对象实例，修饰静态方法时，锁是对象的class字节码文件;</li><li>一个线程进入了sychronized修饰的同步方法，得到了对象锁，其他线程还是可以访问那些没有同步的方法（普通方法）;</li><li>sychronized支持锁的重入;</li></ul><p>以上就是本文的全部内容，希望对大家的学习有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2020/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>所谓单例，就是整个程序有且仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。在Java，一般常用在工具类的实现或创建对象需要消耗资源。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>类构造器私有</li><li>持有自己类型的属性</li><li>对外提供获取实例的静态方法</li></ul><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a><strong>懒汉模式</strong></h3><p>线程不安全，延迟初始化，严格意义上不是不是单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a><strong>饿汉模式</strong></h3><p>线程安全，比较常用，但容易产生垃圾，因为一开始就初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重锁模式"><a href="#双重锁模式" class="headerlink" title="双重锁模式"></a><strong>双重锁模式</strong></h3><p>线程安全，延迟初始化。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。由于<code>singleton=new Singleton()</code>对象的创建在JVM中可能会进行重排序，在多线程访问下存在风险，使用<code>volatile</code>修饰<code>signleton</code>实例变量有效，解决该问题。</p><h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a><strong>静态内部类单例模式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Inner.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。</p><h3 id="枚举单例模式"><a href="#枚举单例模式" class="headerlink" title="枚举单例模式"></a><strong>枚举单例模式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。实际上</p><ul><li>枚举类隐藏了私有的构造器。</li><li>枚举类的域 是相应类型的一个实例对象<br>那么枚举类型日常用例是这样子的：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton  &#123;</span><br><span class="line">    INSTANCE </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//doSomething 该实例支持的行为</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//可以省略此方法，通过Singleton.INSTANCE进行操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton get <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举单例模式在《Effective Java》中推荐的单例模式之一。但枚举实例在日常开发是很少使用的，就是很简单以导致可读性较差。</p><p>在以上所有的单例模式中，推荐静态内部类单例模式。主要是非常直观，即保证线程安全又保证唯一性。<br>众所周知，单例模式是创建型模式，都会新建一个实例。那么一个重要的问题就是反序列化。当实例被写入到文件到反序列化成实例时，我们需要重写<code>readResolve</code>方法，以让实例唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap详解</title>
      <link href="/2020/04/28/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/04/28/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Map 这样的 <code>Key Value</code> 在软件开发中是非常经典的结构，常用于在内存中存放数据。</p><p>本篇主要想讨论 ConcurrentHashMap 这样一个并发容器，在正式开始之前我觉得有必要谈谈 HashMap，没有它就不会有后面的 ConcurrentHashMap。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>众所周知 HashMap 底层是基于 <code>数组 + 链表</code> 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p><h3 id="Base-1-7"><a href="#Base-1-7" class="headerlink" title="Base 1.7"></a>Base 1.7</h3><p>1.7 中的数据结构图：</p><p><img data-src="1.png" alt="1.png"></p><p>先来看看 1.7 中的实现。</p><p><img data-src="2.png" alt="2.png"></p><p>这是 HashMap 中比较核心的几个成员变量；看看分别是什么意思？</p><ol><li>初始化桶大小，因为底层是数组，所以这是数组默认的大小。</li><li>桶最大值。</li><li>默认的负载因子（0.75）</li><li><code>table</code> 真正存放数据的数组。</li><li><code>Map</code> 存放数量的大小。</li><li>桶大小，可在初始化时显式指定。</li><li>负载因子，可在初始化时显式指定。</li></ol><p>重点解释下负载因子：</p><p>由于给定的 HashMap 的容量大小是固定的，比如默认初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 <code>16 * 0.75 = 12</code> 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><p>因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗。</p><p>根据代码可以看到其实真正存放数据的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Entry&lt;K,V&gt;[] table &#x3D; (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p>这个数组，那么它又是如何定义的呢？</p><p><img data-src="3.png" alt="3.png"></p><p>Entry 是 HashMap 中的一个内部类，从他的成员变量很容易看出：</p><ul><li>key 就是写入时的键。</li><li>value 自然就是值。</li><li>开始的时候就提到 HashMap 是由数组和链表组成，所以这个 next 就是用于实现链表结构。</li><li>hash 存放的是当前 key 的 hashcode。</li></ul><p>知晓了基本结构，那来看看其中重要的写入、获取函数：</p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前数组是否需要初始化。</li><li>如果 key 为空，则 put 一个空值进去。</li><li>根据 key 计算出 hashcode。</li><li>根据计算出的 hashcode 定位出所在桶。</li><li>如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。</li><li>如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当调用 addEntry 写入 Entry 时需要判断是否需要扩容。</p><p>如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位。</p><p>而在 <code>createEntry</code> 中会将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表。</p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><p>再来看看 get 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。</li><li>判断该位置是否为链表。</li><li>不是链表就根据 <code>key、key 的 hashcode</code> 是否相等来返回值。</li><li>为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。</li><li>啥都没取到就直接返回 null 。</li></ul><h3 id="Base-1-8"><a href="#Base-1-8" class="headerlink" title="Base 1.8"></a>Base 1.8</h3><p>不知道 1.7 的实现大家看出需要优化的点没有？</p><p>其实一个很明显的地方就是：</p><blockquote><p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。</p></blockquote><p>因此 1.8 中重点优化了这个查询效率。</p><p>1.8 HashMap 结构图：</p><p><img data-src="4.png" alt="4.png"></p><p>先来看看几个核心的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span>    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 4     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> 5     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> 6     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> 7     */</span></span><br><span class="line"> <span class="number">8</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"> <span class="number">9</span></span><br><span class="line"><span class="number">10</span>    <span class="comment">/**</span></span><br><span class="line"><span class="comment">11     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">12     */</span></span><br><span class="line"><span class="number">13</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span>    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span>    <span class="comment">/**</span></span><br><span class="line"><span class="comment">20     * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">21     * for keySet() and values().</span></span><br><span class="line"><span class="comment">22     */</span></span><br><span class="line"><span class="number">23</span>    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span>    <span class="comment">/**</span></span><br><span class="line"><span class="comment">26     * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">27     */</span></span><br><span class="line"><span class="number">28</span>    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>和 1.7 大体上都差不多，还是有几个重要的区别：</p><ul><li><code>TREEIFY_THRESHOLD</code> 用于判断是否需要将链表转换为红黑树的阈值。</li><li>HashEntry 修改为 Node。</li></ul><p>Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 <code>key value hashcode next</code> 等数据。</p><p>再来看看核心方法。</p><h4 id="put-方法-1"><a href="#put-方法-1" class="headerlink" title="put 方法"></a>put 方法</h4><p>  <img data-src="5.png" alt="5.png"></p><p>看似要比 1.7 的复杂，我们一步步拆解：</p><ol><li>判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。</li><li>根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。</li><li>如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 <code>key、key 的 hashcode</code> 与写入的 key 是否相等，相等就赋值给 <code>e</code>,在第 8 步的时候会统一进行赋值及返回。</li><li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</li><li>如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。</li><li>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</li><li>如果在遍历过程中找到 key 相同时直接退出遍历。</li><li>如果 <code>e != null</code> 就相当于存在相同的 key,那就需要将值覆盖。</li><li>最后判断是否需要进行扩容。</li></ol><h4 id="get-方法-1"><a href="#get-方法-1" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>        Node&lt;K,V&gt; e;</span><br><span class="line"> <span class="number">3</span>        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line"> <span class="number">4</span>    &#125;</span><br><span class="line"> <span class="number">5</span></span><br><span class="line"> <span class="number">6</span>    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line"> <span class="number">7</span>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"> <span class="number">8</span>        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line"> <span class="number">9</span>            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">10</span>            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line"><span class="number">11</span>                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">12</span>                <span class="keyword">return</span> first;</span><br><span class="line"><span class="number">13</span>            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">14</span>                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">15</span>                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"><span class="number">16</span>                <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">17</span>                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">18</span>                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">19</span>                        <span class="keyword">return</span> e;</span><br><span class="line"><span class="number">20</span>                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="number">21</span>            &#125;</span><br><span class="line"><span class="number">22</span>        &#125;</span><br><span class="line"><span class="number">23</span>        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">24</span>    &#125;</span><br></pre></td></tr></table></figure><p>get 方法看起来就要简单许多了。</p><ul><li>首先将 key hash 之后取得所定位的桶。</li><li>如果桶为空则直接返回 null 。</li><li>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。</li><li>如果第一个不匹配，则判断它的下一个是红黑树还是链表。</li><li>红黑树就按照树的查找方式返回值。</li><li>不然就按照链表的方式遍历匹配返回值。</li></ul><p>从这两个核心方法（get/put）可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 <code>O(logn)</code>。</p><p>但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">final</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="number">2</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="number">3</span>    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="number">4</span>        <span class="meta">@Override</span></span><br><span class="line"><span class="number">5</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">6</span>            map.put(UUID.randomUUID().toString(), <span class="string">""</span>);</span><br><span class="line"><span class="number">7</span>        &#125;</span><br><span class="line"><span class="number">8</span>    &#125;).start();</span><br><span class="line"><span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure><p>但是为什么呢？简单分析下。</p><p>看过上文的还记得在 HashMap 扩容的时候会调用 <code>resize()</code> 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</p><p>如下图：</p><p><img data-src="6.png" alt="6.png"></p><p><img data-src="7.png" alt="7.png"></p><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line"> <span class="number">2</span>        <span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line"> <span class="number">3</span>            Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line"> <span class="number">4</span>            System.out.println(<span class="string">"key="</span> + next.getKey() + <span class="string">" value="</span> + next.getValue());</span><br><span class="line"> <span class="number">5</span>        &#125;</span><br><span class="line"> <span class="number">6</span></span><br><span class="line"> <span class="number">7</span> Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"> <span class="number">8</span>        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"> <span class="number">9</span>            String key = iterator.next();</span><br><span class="line"><span class="number">10</span>            System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + map.get(key));</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span>        &#125;</span><br></pre></td></tr></table></figure><p><code>强烈建议</code>使用第一种 EntrySet 进行遍历。</p><p>第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。</p><blockquote><p>简单总结下 HashMap：无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至出现死循环导致系统不可用</p></blockquote><p>因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 <code>java.util.concurrent</code> 包下，专门用于解决并发问题。</p><blockquote><p>坚持看到这里的朋友算是已经把 ConcurrentHashMap 的基础已经打牢了，下面正式开始分析。</p></blockquote><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap 同样也分为 1.7 、1.8 版，两者在实现上略有不同。</p><h3 id="Base-1-7-1"><a href="#Base-1-7-1" class="headerlink" title="Base 1.7"></a>Base 1.7</h3><p>先来看看 1.7 的实现，下面是他的结构图：</p><p><img data-src="8.png" alt="8.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4MQ?x-oss-process=image/format,png" alt="img"></p><p>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。</p><p>它的核心成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看其中 HashEntry 的组成：</p><p><img data-src="9.png" alt="9.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4Mg?x-oss-process=image/format,png" alt="img"></p><p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</p><p>原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p><p>下面也来看看核心的 <code>put get</code> 方法。</p><p>put 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。</p><p>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</p><p><img data-src="10.png" alt="10.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4Mw?x-oss-process=image/format,png" alt="img"></p><ol><li>尝试自旋获取锁。</li><li>如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li></ol><p><img data-src="11.png" alt="11.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4NA?x-oss-process=image/format,png" alt="img"></p><p>再结合图看看 put 的流程。</p><ol><li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li><li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li><li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li><li>最后会解除在 1 中所获取当前 Segment 的锁。</li></ol><p>get 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 逻辑比较简单：</p><p>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p><p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p><p>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</p><h3 id="Base-1-8-1"><a href="#Base-1-8-1" class="headerlink" title="Base 1.8"></a>Base 1.8</h3><p>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题。</p><blockquote><p>那就是查询遍历链表效率太低。</p></blockquote><p>因此 1.8 做了一些数据结构上的调整。</p><p>首先来看下底层的组成结构：</p><p><img data-src="12.png" alt="12.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4NQ?x-oss-process=image/format,png" alt="img"></p><p>看起来是不是和 1.8 HashMap 结构类似？</p><p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p><p><img data-src="13.png" alt="13.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4Ng?x-oss-process=image/format,png" alt="img"></p><p>也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。</p><p>其中的 <code>val next</code> 都用了 volatile 修饰，保证了可见性。</p><p>put 方法</p><p>重点来看看 put 函数：</p><p><img data-src="14.png" alt="14.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4Nw?x-oss-process=image/format,png" alt="img"></p><ul><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li><code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ul><p>get 方法</p><p><img data-src="15.png" alt="15.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4OA?x-oss-process=image/format,png" alt="img"></p><ul><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值。</li></ul><blockquote><p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code>），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完了整个 HashMap 和 ConcurrentHashMap 在 1.7 和 1.8 中不同的实现方式相信大家对他们的理解应该会更加到位。</p><p>其实这块也是面试的重点内容，通常的套路是：</p><ol><li>谈谈你理解的 HashMap，讲讲其中的 get put 过程。</li><li>1.8 做了什么优化？</li><li>是线程安全的嘛？</li><li>不安全会导致哪些问题？</li><li>如何解决？有没有线程安全的并发容器？</li><li>ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-多路查找树</title>
      <link href="/2020/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/2020/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot有哪些优点它和Spring有什么区别</title>
      <link href="/2020/04/26/SpringBoot%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%AE%83%E5%92%8CSpring%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/04/26/SpringBoot%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%AE%83%E5%92%8CSpring%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>Spring 和 Spring Boot 的区别很多新手容易搞混，从这道简单的面试题也可以很轻易试探出你的 Java 基础功底，如果连这个问题都答不上来的话，通常就没有什么下文了，因为这已经是用人单位对面试者的最低要求了，所以本课时我们就来看一下二者的区别，以及 Spring Boot 的特性。</p><p>我们本课时的面试题是，Spring 和 Spring Boot 有什么区别？Spring Boot 的优点有哪些？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>作为 Java 开发人员对 Spring 框架都很熟悉，Spring 为 Java 程序提供了全面的基础架构支持，包含了很多非常实用的功能，如 Spring JDBC、Spring AOP、Spring ORM、Spring Test 等，这些模块的出现，大大的缩短了应用程序的开发时间，同时提高了应用开发的效率。</p><p>Spring Boot 本质上是 Spring 框架的延伸和扩展，它的诞生是为了简化 Spring 框架初始搭建以及开发的过程，使用它可以不再依赖 Spring 应用程序中的 XML 配置，为更快、更高效的开发 Spring 提供更加有力的支持。Spring Boot 具体的特性如下。</p><h3 id="Spring-Boot-特性一：更快速的构建能力"><a href="#Spring-Boot-特性一：更快速的构建能力" class="headerlink" title="Spring Boot 特性一：更快速的构建能力"></a>Spring Boot 特性一：更快速的构建能力</h3><p>Spring Boot 提供了更多的 Starters 用于快速构建业务框架，Starters 可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找依赖包。</p><p>例如在 Spring 中如果要创建 Web 应用程序的最小依赖项为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而 Spring Boot 只需要一个依赖项就可以来启动和运行 Web 应用程序，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们添加了 Starter 模块支持之后，在项目的构建期，它就会把所有其他依赖项将自动添加到项目中。</p><p>这样的例子还有很多，比如测试库，如果是 Spring 项目我们通常要添加 Spring Test、JUnit、Hamcrest 和 Mockito 库；而如果是 Spring Boot 项目的话，只需要添加 spring-boot-starter-test 即可，它会自动帮我们把其他的依赖项添加到项目中。</p><p>常见的 Starters 有以下几个：</p><ul><li>spring-boot-starter-test</li><li>spring-boot-starter-web</li><li>spring-boot-starter-data-jpa</li><li>spring-boot-starter-thymeleaf</li></ul><h3 id="Spring-Boot-特性二：起步依赖"><a href="#Spring-Boot-特性二：起步依赖" class="headerlink" title="Spring Boot 特性二：起步依赖"></a>Spring Boot 特性二：起步依赖</h3><p>Spring Boot 提供了起步依赖，也就是在创建 Spring Boot 时可以直接勾选依赖模块，这样在项目初始化时就会把相关依赖直接添加到项目中，大大缩短了查询并添加依赖的时间，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><h3 id="Spring-Boot-特性三：内嵌容器支持"><a href="#Spring-Boot-特性三：内嵌容器支持" class="headerlink" title="Spring Boot 特性三：内嵌容器支持"></a>Spring Boot 特性三：内嵌容器支持</h3><p>Spring Boot 内嵌了 Tomcat、Jetty、Undertow 三种容器，其默认嵌入的容器是 Tomcat，这个在我们启动 Spring Boot 项目的时候，在控制台上就能看到，具体信息如下：</p><p>o.s.b.w.embedded.tomcat.TomcatWebServer :Tomcat started on port(s): 8080 (http) with context path ‘’</p><p>可以看出 Spring Boot 默认使用的是 Tomcat 容器启动的。</p><p>我们可以通过修改 pom.xml 来移除内嵌的 Tomcat 更换为其他的容器，比如更换为 Jetty 容器，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 移处 Tomcat --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 移处 jetty 容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们添加完成之后，再重新生成 pom.xml 文件，然后再启动 Spring Boot 项目容器信息就变了，如下所示：</p><p>o.e.jetty.server.AbstractConnector: Started ServerConnector@53f9009d{HTTP/1.1, (http/1.1)}{0.0.0.0:8080}<br>o.s.b.web.embedded.jetty.JettyWebServer</p><p>可以看出 Spring Boot 使用了我们指定的 Jetty 容器启动了。</p><h3 id="Spring-Boot-特性四：Actuator-监控"><a href="#Spring-Boot-特性四：Actuator-监控" class="headerlink" title="Spring Boot 特性四：Actuator 监控"></a>Spring Boot 特性四：Actuator 监控</h3><p>Spring Boot 自带了 Actuator 监控功能，主要用于提供对应用程序监控，以及控制的能力，比如监控应用程序的运行状况，或者内存、线程池、Http 请求统计等，同时还提供了关闭应用程序等功能。</p><p>Actuator 提供了 19 个接口，接口请求地址和代表含义如下表所示：</p><table><thead><tr><th>访问路径</th><th>描述</th></tr></thead><tbody><tr><td>/auditevents</td><td>显示应用暴露的审计事件（比如认证进入）</td></tr><tr><td>/beans</td><td>显示应用程序中所有 Spring Bean 的完整列表</td></tr><tr><td>/caches</td><td>公开可用的缓存</td></tr><tr><td>/conditions</td><td>显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因</td></tr><tr><td>/configprops</td><td>获取全部环境属性</td></tr><tr><td>/env</td><td>获取全部环境属性</td></tr><tr><td>/flyway</td><td>提供一份 Flyway 数据库迁移信息</td></tr><tr><td>/health</td><td>显示应用程序运行状况信息</td></tr><tr><td>/httptrace</td><td>显示 HTTP 跟踪信息（默认情况下，最近 100 个 HTTP 请求-响应交换）</td></tr><tr><td>/info</td><td>获取应用程序的定制信息，这些信息由 info 开头的属性提供</td></tr><tr><td>/integrationgraph</td><td>显示 Spring Integration 图，需要依赖于 spring-integration-core</td></tr><tr><td>/loggers</td><td>显示和修改应用程序的配置</td></tr><tr><td>/liquibase</td><td>显示已应用的所有 Liquibase 数据库迁移</td></tr><tr><td>/metrics/{name}</td><td>报告指定名称的应用程序度量值</td></tr><tr><td>/mappings</td><td>显示所有 @RequestMapping 路径的列表</td></tr><tr><td>/scheduledtasks</td><td>显示应用程序中的计划任务</td></tr><tr><td>/sessions</td><td>允许从 Spring Session 支持的会话存储中检索和删除用户会话，需要使用 Spring Session 基于 Servlet 的 Web 应用程序</td></tr><tr><td>/shutdown</td><td>使应用程序正常关闭，默认禁用</td></tr><tr><td>/threaddump</td><td>获取线程活动的快照</td></tr></tbody></table><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>很多人都知道 Spring Boot 是基于 Spring 的，使用它可以更加快速高效的构建 Spring，然而当面试官问到 Spring Boot 是如何高效构建 Spring 时，可能大部分人回答不上来了，上面讲解的 Spring Boot 四大特性基本涵盖了此问题的答案。如果面试官继续追问更深的细节的话，可能会问到关于 Spring Boot 执行的源码细节，比如 Spring Boot 的启动流程是怎么样的？</p><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="Spring-Boot-启动源码分析"><a href="#Spring-Boot-启动源码分析" class="headerlink" title="Spring Boot 启动源码分析"></a>Spring Boot 启动源码分析</h3><p>我们知道 Spring Boot 程序的入口是 SpringApplication.run(Application.class, args) 方法，那么就从 run() 方法开始分析吧，它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建并启动计时监控类</span></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="comment">// 2.声明应用上下文对象和异常报告集合</span></span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">// 3.设置系统属性 headless 的值</span></span><br><span class="line">    <span class="keyword">this</span>.configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 4.创建所有 Spring 运行监听器并发布应用启动事件</span></span><br><span class="line">    SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    Collection exceptionReporters;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 5.处理 args 参数</span></span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">// 6.准备环境</span></span><br><span class="line">        ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">// 7.创建 Banner 的打印类</span></span><br><span class="line">        Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</span><br><span class="line">        <span class="comment">// 8.创建应用上下文</span></span><br><span class="line">        context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">        <span class="comment">// 9.实例化异常报告器</span></span><br><span class="line">        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        <span class="comment">// 10.准备应用上下文</span></span><br><span class="line">        <span class="keyword">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">// 11.刷新应用上下文</span></span><br><span class="line">        <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">        <span class="comment">// 12.应用上下文刷新之后的事件的处理</span></span><br><span class="line">        <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">// 13.停止计时监控类</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="comment">// 14.输出日志记录执行主类名、时间信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 15.发布应用上下文启动完成事件</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">// 16.执行所有 Runner 运行器</span></span><br><span class="line">        <span class="keyword">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var10);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 17.发布应用上下文就绪事件</span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">        <span class="comment">// 18.返回应用上下文对象</span></span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出 Spring Boot 的启动总共分为以下 18 个步骤。</p><h3 id="Spring-Boot-的启动流程"><a href="#Spring-Boot-的启动流程" class="headerlink" title="Spring Boot 的启动流程"></a>Spring Boot 的启动流程</h3><h4 id="1-创建并启动计时监控类"><a href="#1-创建并启动计时监控类" class="headerlink" title="1.创建并启动计时监控类"></a>1.创建并启动计时监控类</h4><p>此计时器是为了监控并记录 Spring Boot 应用启动的时间的，它会记录当前任务的名称，然后开启计时器。</p><h4 id="2-声明应用上下文对象和异常报告集合"><a href="#2-声明应用上下文对象和异常报告集合" class="headerlink" title="2.声明应用上下文对象和异常报告集合"></a>2.声明应用上下文对象和异常报告集合</h4><p>此过程声明了应用上下文对象和一个异常报告的 ArrayList 集合。</p><h4 id="3-设置系统属性-headless-的值"><a href="#3-设置系统属性-headless-的值" class="headerlink" title="3.设置系统属性 headless 的值"></a>3.设置系统属性 headless 的值</h4><p>设置 Java.awt.headless = true，其中 awt（Abstract Window Toolkit）的含义是抽象窗口工具集。设置为 true 表示运行一个 headless 服务器，可以用它来作一些简单的图像处理。</p><h4 id="4-创建所有-Spring-运行监听器并发布应用启动事件"><a href="#4-创建所有-Spring-运行监听器并发布应用启动事件" class="headerlink" title="4.创建所有 Spring 运行监听器并发布应用启动事件"></a>4.创建所有 Spring 运行监听器并发布应用启动事件</h4><p>此过程用于获取配置的监听器名称并实例化所有的类。</p><h4 id="5-初始化默认应用的参数类"><a href="#5-初始化默认应用的参数类" class="headerlink" title="5.初始化默认应用的参数类"></a>5.初始化默认应用的参数类</h4><p>也就是说声明并创建一个应用参数对象。</p><h4 id="6-准备环境"><a href="#6-准备环境" class="headerlink" title="6.准备环境"></a>6.准备环境</h4><p>创建配置并且绑定环境（通过 property sources 和 profiles 等配置文件）。</p><h4 id="7-创建-Banner-的打印类"><a href="#7-创建-Banner-的打印类" class="headerlink" title="7.创建 Banner 的打印类"></a>7.创建 Banner 的打印类</h4><p>Spring Boot 启动时会打印 Banner 图片，如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><p>此 banner 信息是在 SpringBootBanner 类中定义的，我们可以通过实现 Banner 接口来自定义 banner 信息，然后通过代码 setBanner() 方法设置 Spring Boot 项目使用自己自定义 Banner 信息，或者是在 resources 下添加一个 banner.txt，把 banner 信息添加到此文件中，就可以实现自定义 banner 的功能了。</p><h4 id="8-创建应用上下文"><a href="#8-创建应用上下文" class="headerlink" title="8.创建应用上下文"></a>8.创建应用上下文</h4><p>根据不同的应用类型来创建不同的 ApplicationContext 上下文对象。</p><h4 id="9-实例化异常报告器"><a href="#9-实例化异常报告器" class="headerlink" title="9.实例化异常报告器"></a>9.实例化异常报告器</h4><p>它调用的是 getSpringFactoriesInstances() 方法来获取配置异常类的名称，并实例化所有的异常处理类。</p><h4 id="10-准备应用上下文"><a href="#10-准备应用上下文" class="headerlink" title="10.准备应用上下文"></a>10.准备应用上下文</h4><p>此方法的主要作用是把上面已经创建好的对象，传递给 prepareContext 来准备上下文，例如将环境变量 environment 对象绑定到上下文中、配置 bean 生成器以及资源加载器、记录启动日志等操作。</p><h4 id="11-刷新应用上下文"><a href="#11-刷新应用上下文" class="headerlink" title="11.刷新应用上下文"></a>11.刷新应用上下文</h4><p>此方法用于解析配置文件，加载 bean 对象，并且启动内置的 web 容器等操作。</p><h4 id="12-应用上下文刷新之后的事件处理"><a href="#12-应用上下文刷新之后的事件处理" class="headerlink" title="12.应用上下文刷新之后的事件处理"></a>12.应用上下文刷新之后的事件处理</h4><p>这个方法的源码是空的，可以做一些自定义的后置处理操作。</p><h4 id="13-停止计时监控类"><a href="#13-停止计时监控类" class="headerlink" title="13.停止计时监控类"></a>13.停止计时监控类</h4><p>停止此过程第一步中的程序计时器，并统计任务的执行信息。</p><h4 id="14-输出日志信息"><a href="#14-输出日志信息" class="headerlink" title="14.输出日志信息"></a>14.输出日志信息</h4><p>把相关的记录信息，如类名、时间等信息进行控制台输出。</p><h4 id="15-发布应用上下文启动完成事件"><a href="#15-发布应用上下文启动完成事件" class="headerlink" title="15.发布应用上下文启动完成事件"></a>15.发布应用上下文启动完成事件</h4><p>触发所有 SpringApplicationRunListener 监听器的 started 事件方法。</p><h4 id="16-执行所有-Runner-运行器"><a href="#16-执行所有-Runner-运行器" class="headerlink" title="16.执行所有 Runner 运行器"></a>16.执行所有 Runner 运行器</h4><p>执行所有的 ApplicationRunner 和 CommandLineRunner 运行器。</p><h4 id="17-发布应用上下文就绪事件"><a href="#17-发布应用上下文就绪事件" class="headerlink" title="17.发布应用上下文就绪事件"></a>17.发布应用上下文就绪事件</h4><p>触发所有的 SpringApplicationRunListener 监听器的 running 事件。</p><h4 id="18-返回应用上下文对象"><a href="#18-返回应用上下文对象" class="headerlink" title="18.返回应用上下文对象"></a>18.返回应用上下文对象</h4><p>到此为止 Spring Boot 的启动程序就结束了，我们就可以正常来使用 Spring Boot 框架了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本课时首先讲了 Spring 和 Spring Boot 的区别，Spring Boot 本质上是 Spring 的延伸，它是基于 Spring 的，它为快速构建和开发 Spring 提供了有力的支撑；接着介绍了 Spring Boot 的四大特性：更快速的构建能力、起步依赖、内嵌容器支持、Actuator 监控支持等，最后 还介绍了 Spring Boot 启动的 18 个步骤。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试真题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis使用了哪些设计模式在源码中是如何体现的</title>
      <link href="/2020/04/26/MyBatis%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%BA%90%E7%A0%81%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%E7%9A%84/"/>
      <url>/2020/04/26/MyBatis%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%BA%90%E7%A0%81%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>MyBatis 的前身是 IBatis，IBatis 是由 Internet 和 Abatis 组合而成，其目的是想当做互联网的篱笆墙，围绕着数据库提供持久化服务的一个框架，2010 年正式改名为 MyBatis。它是一款优秀的持久层框架，支持自定义 SQL、存储过程及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作，还可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><p>关于 MyBatis 的介绍与使用，官方已经提供了比较详尽的中文参考文档，可点击这里查看，而本课时则以面试的角度出发，聊一聊不一样的知识点，它也是 MyBatis 比较热门的面试题之一，MyBatis 使用了哪些设计模式？在源码中是如何体现的？</p><p><strong>注意：本课时使用的 MyBatis 源码为 3.5.5。</strong></p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h3><p>工厂模式想必都比较熟悉，它是 Java 中最常用的设计模式之一。工厂模式就是提供一个工厂类，当有客户端需要调用的时候，只调用这个工厂类就可以得到自己想要的结果，从而无需关注某类的具体实现过程。这就好比你去餐馆吃饭，可以直接点菜，而不用考虑厨师是怎么做的。</p><p>工厂模式在 MyBatis 中的典型代表是 SqlSessionFactory。</p><p>SqlSession 是 MyBatis 中的重要 Java 接口，可以通过该接口来执行 SQL 命令、获取映射器示例和管理事务，而 SqlSessionFactory 正是用来产生 SqlSession 对象的，所以它在 MyBatis 中是比较核心的接口之一。</p><p>工厂模式应用解析：SqlSessionFactory 是一个接口类，它的子类 DefaultSqlSessionFactorys 有一个 openSession(ExecutorType execType) 的方法，其中使用了工厂模式，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">        <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        closeTransaction(tx); </span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从该方法我们可以看出它会 configuration.newExecutor(tx, execType) 读取对应的环境配置，而此方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 newExecutor() 方法为标准的工厂模式，它会根据传递 ExecutorType 值生成相应的对象然后进行返回。</p><h3 id="2-建造者模式（Builder）"><a href="#2-建造者模式（Builder）" class="headerlink" title="2.建造者模式（Builder）"></a>2.建造者模式（Builder）</h3><p>建造者模式指的是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。也就是说建造者模式是通过多个模块一步步实现了对象的构建，相同的构建过程可以创建不同的产品。</p><p>例如，组装电脑，最终的产品就是一台主机，然而不同的人对它的要求是不同的，比如设计人员需要显卡配置高的；而影片爱好者则需要硬盘足够大的（能把视频都保存起来），但对于显卡却没有太大的要求，我们的装机人员根据每个人不同的要求，组装相应电脑的过程就是<strong>建造者模式</strong>。</p><p>建造者模式在 MyBatis 中的典型代表是 SqlSessionFactoryBuilder。</p><p>普通的对象都是通过 new 关键字直接创建的，但是如果创建对象需要的构造参数很多，且不能保证每个参数都是正确的或者不能一次性得到构建所需的所有参数，那么就需要将构建逻辑从对象本身抽离出来，让对象只关注功能，把构建交给构建类，这样可以简化对象的构建，也可以达到分步构建对象的目的，而 SqlSessionFactoryBuilder 的构建过程正是如此。</p><p>在 SqlSessionFactoryBuilder 中构建 SqlSessionFactory 对象的过程是这样的，首先需要通过 XMLConfigBuilder 对象读取并解析 XML 的配置文件，然后再将读取到的配置信息存入到 Configuration 类中，然后再通过 build 方法生成我们需要的 DefaultSqlSessionFactory 对象，实现源码如下（在 SqlSessionFactoryBuilder 类中）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">        <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlSessionFactoryBuilder 类相当于一个建造工厂，先读取文件或者配置信息、再解析配置、然后通过反射生成对象，最后再把结果存入缓存，这样就一步步构建造出一个 SqlSessionFactory 对象。</p><h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，此模式保证某个类在运行期间，只有一个实例对外提供服务，而这个类被称为<strong>单例类</strong>。</p><p>单例模式也比较好理解，比如一个人一生当中只能有一个真实的身份证号，每个收费站的窗口都只能一辆车子一辆车子的经过，类似的场景都是属于<strong>单例模式</strong>。</p><p>单例模式在 MyBatis 中的典型代表是 ErrorContext。</p><p>ErrorContext 是线程级别的的单例，每个线程中有一个此对象的单例，用于记录该线程的执行环境的错误信息。</p><p>ErrorContext 的实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.lineSeparator();</span><br><span class="line">  <span class="comment">// 每个线程存储的容器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ErrorContext&gt; LOCAL = ThreadLocal.withInitial(ErrorContext::<span class="keyword">new</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorContext <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LOCAL.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 忽略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 ErrorContext 使用 private 修饰的 ThreadLocal 来保证每个线程拥有一个 ErrorContext 对象，在调用 instance() 方法时再从 ThreadLocal 中获取此单例对象。</p><h3 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="4.适配器模式"></a>4.适配器模式</h3><p>适配器模式是指将一个不兼容的接口转换成另一个可以兼容的接口，这样就可以使那些不兼容的类可以一起工作。</p><p>例如，最早之前我们用的耳机都是圆形的，而现在大多数的耳机和电源都统一成了方形的 typec 接口，那之前的圆形耳机就不能使用了，只能买一个适配器把圆形接口转化成方形的，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p>而这个转换头就相当于程序中的适配器模式，适配器模式在 MyBatis 中的典型代表是 Log。</p><p>MyBatis 中的日志模块适配了以下多种日志类型：</p><ul><li>SLF4J</li><li>Apache Commons Logging</li><li>Log4j 2</li><li>Log4j</li><li>JDK logging</li></ul><p>首先 MyBatis 定义了一个 Log 的接口，用于统一和规范接口的行为，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 MyBatis 定义了多个适配接口，例如 Log4j2 实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4j2Impl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Log log;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Log4j2Impl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">    Logger logger = LogManager.getLogger(clazz);</span><br><span class="line">    <span class="keyword">if</span> (logger <span class="keyword">instanceof</span> AbstractLogger) &#123;</span><br><span class="line">      log = <span class="keyword">new</span> Log4j2AbstractLoggerImpl((AbstractLogger) logger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log = <span class="keyword">new</span> Log4j2LoggerImpl(logger);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">    log.error(s, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.error(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.debug(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.trace(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.warn(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当你项目中添加了 Log4j2 时，MyBatis 就可以直接使用它打印 MyBatis 的日志信息了。Log 的所有子类如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><h3 id="5-代理模式"><a href="#5-代理模式" class="headerlink" title="5.代理模式"></a>5.代理模式</h3><p>代理模式指的是给某一个对象提供一个代理对象，并由代理对象控制原对象的调用。</p><p>代理模式在生活中也比较常见，比如我们常见的超市、小卖店其实都是一个个“代理”，他们的最上游是一个个生产厂家，他们这些代理负责把厂家生产出来的产品卖出去。</p><p>代理模式在 MyBatis 中的典型代表是 MapperProxyFactory。</p><p>MapperProxyFactory 的 newInstance() 方法就是生成一个具体的代理来实现功能的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethodInvoker&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethodInvoker&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建代理类</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-模板方法模式"><a href="#6-模板方法模式" class="headerlink" title="6.模板方法模式"></a>6.模板方法模式</h3><p>模板方法模式是最常用的设计模式之一，它是指定义一个操作算法的骨架，而将一些步骤的实现延迟到子类中去实现，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。此模式是基于继承的思想实现代码复用的。</p><p>例如，我们喝茶的一般步骤都是这样的：</p><ul><li>把热水烧开</li><li>把茶叶放入壶中</li><li>等待一分钟左右</li><li>把茶倒入杯子中</li><li>喝茶</li></ul><p>整个过程都是固定的，唯一变的就是泡入茶叶种类的不同，比如今天喝的是绿茶，明天可能喝的是红茶，那么我们就可以把流程定义为一个模板，而把茶叶的种类延伸到子类中去实现，这就是模板方法的实现思路。</p><p>模板方法在 MyBatis 中的典型代表是 BaseExecutor。</p><p>在 MyBatis 中 BaseExecutor 实现了大部分 SQL 执行的逻辑，然后再把几个方法交给子类来实现，它的继承关系如下图所示：</p><p><img data-src="3.png" alt="3.png"></p><p>比如 doUpdate() 就是交给子类自己去实现的，它在 BaseExecutor 中的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>在 SimpleExecutor 中的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(configuration, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 忽略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 SimpleExecutor 每次使用完 Statement 对象之后，都会把它关闭掉，而 ReuseExecutor 中的实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Statement&gt; statementMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReuseExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(configuration, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    Statement stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 忽略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，ReuseExecutor 每次使用完 Statement 对象之后不会把它关闭掉。</p><h3 id="7-装饰器模式"><a href="#7-装饰器模式" class="headerlink" title="7.装饰器模式"></a>7.装饰器模式</h3><p>装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构，这种类型的设计模式属于结构型模式，它是作为现有类的一个包装。</p><p>装饰器模式在生活中很常见，比如装修房子，我们在不改变房子结构的同时，给房子添加了很多的点缀；比如安装了天然气报警器，增加了热水器等附加的功能都属于装饰器模式。</p><p>装饰器模式在 MyBatis 中的典型代表是 Cache。</p><p>Cache 除了有数据存储和缓存的基本功能外（由 PerpetualCache 永久缓存实现），还有其他附加的 Cache 类，比如先进先出的 FifoCache、最近最少使用的 LruCache、防止多线程并发访问的 SynchronizedCache 等众多附加功能的缓存类，Cache 所有实现子类如下图所示：</p><p><img data-src="4.png" alt="4.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本课时我们重点讲了 MyBatis 源码中的几个主要设计模式，即工厂模式、建造者模式、单例模式、适配器模式、代理模式、模板方法模式等，希望本课时的内容能起到抛砖引玉的作用，对你理解设计模式和 MyBatis 提供一些帮助，如果想要阅读全部的 MyBatis 源码可以访问：<a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试真题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说自己是怎么使用synchronized关键字在项目中用到了吗</title>
      <link href="/2020/04/26/%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%90%97/"/>
      <url>/2020/04/26/%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%90%97/</url>
      
        <content type="html"><![CDATA[<p><img data-src="1.png" alt="1.png"></p><h3 id="synchronized关键字最主要的三种使用方式的总结"><a href="#synchronized关键字最主要的三种使用方式的总结" class="headerlink" title="synchronized关键字最主要的三种使用方式的总结"></a>synchronized关键字最主要的三种使用方式的总结</h3><ul><li><strong>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</strong></li><li><strong>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</strong> 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</strong> 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</li></ul><p>下面我已一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题整理</title>
      <link href="/2020/04/26/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2020/04/26/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="JAVA基础部分"><a href="#JAVA基础部分" class="headerlink" title="JAVA基础部分"></a><strong>JAVA基础</strong>部分</h2><h3 id="1-Java中的String，StringBuilder，StringBuffer三者的区别"><a href="#1-Java中的String，StringBuilder，StringBuffer三者的区别" class="headerlink" title="1.Java中的String，StringBuilder，StringBuffer三者的区别"></a>1.<strong>Java中的String，StringBuilder，StringBuffer三者的区别</strong></h3><p>执行速度：StringBuilder &gt; StringBuffer &gt; String<br>String：适用于少量的字符串操作的情况<br>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p><h3 id="2-Hashtable和HashMap的区别："><a href="#2-Hashtable和HashMap的区别：" class="headerlink" title="2.Hashtable和HashMap的区别："></a><strong>2.Hashtable和HashMap的区别：</strong></h3><p>a) 继承不同。 </p><p>public class Hashtable extends Dictionary implements Map </p><p>public class HashMap extends AbstractMap implements Map<br>b) Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。<br>c) Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。<strong>因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断。</strong><br>d) 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。<br>e) 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。<br>f) Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。<strong>HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</strong><br>注： HashSet子类依靠hashCode()和equal()方法来区分重复元素。 HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。</p><h3 id="3-乐观锁和悲观锁"><a href="#3-乐观锁和悲观锁" class="headerlink" title="3.乐观锁和悲观锁"></a>3.乐观锁和悲观锁</h3><p><strong>悲观锁</strong><br>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<strong>synchronized</strong>和<strong>ReentrantLock</strong>等独占锁就是悲观锁思想的实现。<br><strong>乐观锁</strong><br>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。<br><strong>两种锁的使用场景</strong><br>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，<strong>像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量</strong>。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p><h3 id="4-java的8种基本数据类型"><a href="#4-java的8种基本数据类型" class="headerlink" title="4.java的8种基本数据类型"></a>4.java的8种基本数据类型</h3><p>四种整数类型(byte、short、int、long)、两种浮点数类型(float、double)、一种字符类型(char)、一种布尔类型(boolean)<br>类型转换： char–&gt; 自动转换：byte–&gt;short–&gt;int–&gt;long–&gt;float–&gt;double 强制转换：①会损失精度，产生误差，小数点以后的数字全部舍弃。②容易超过取值范围。</p><h3 id="5-synchronized和Lock有什么区别？"><a href="#5-synchronized和Lock有什么区别？" class="headerlink" title="5.synchronized和Lock有什么区别？"></a>5.<strong>synchronized和Lock有什么区别？</strong></h3><p>①:synchronized是JVM层面实现的，java提供的关键字，Lock是API层面的锁。</p><p>②: synchronized不需要手动释放锁，底层会自动释放，</p><p>​        Lock则需要手动释放锁，否则有可能导致死锁</p><p> ③:synchronized等待不可中断，除非抛出异常或者执行完成</p><p>​      Lock可以中断，通过interrupt()可中断</p><p> ④: synchronized是非公平锁</p><p>​       Lock是默认公平锁，当传入false时是非公平锁</p><p>  ⑤:synchronized不可绑定多个条件</p><p>​        Lock可实现分组唤醒需要唤醒的锁</p><h3 id="6-请说明一下JAVA中反射的实现过程和作用分别是什么？"><a href="#6-请说明一下JAVA中反射的实现过程和作用分别是什么？" class="headerlink" title="6.请说明一下JAVA中反射的实现过程和作用分别是什么？"></a>6.请说明一下JAVA中反射的实现过程和作用分别是什么？</h3><p>JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。反射的实现主要借助以下四个类：Class：类的对象，Constructor：类的构造方法，Field：类中的属性对象，Method：类中的方法对象。</p><p>作用：反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，只要给定类的名字，那么就可以通过反射机制来获取类的所有信息。</p><h3 id="7-请你介绍一下map的分类和常见的情况"><a href="#7-请你介绍一下map的分类和常见的情况" class="headerlink" title="7.请你介绍一下map的分类和常见的情况"></a>7.请你介绍一下map的分类和常见的情况</h3><p>java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap.</p><p><strong>Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。</strong></p><p>Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 <strong>HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;</strong>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</p><p>Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:<strong>它不允许记录的键或者值为空;它支持线程的同步</strong>，<strong>即任一时刻只有一个线程能写Hashtable</strong>,因此也导致了 <strong>Hashtable在写入时会比较慢</strong>。</p><p><strong>LinkedHashMap 是HashMap的一个子类</strong>，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</p><p><strong>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</strong></p><p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p><h3 id="8-说说-synchronized-关键字和-volatile-关键字的区别？"><a href="#8-说说-synchronized-关键字和-volatile-关键字的区别？" class="headerlink" title="8.说说 synchronized 关键字和 volatile 关键字的区别？"></a>8.说说 synchronized 关键字和 volatile 关键字的区别？</h3><p>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</p><p>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</p><p>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p><p>volatile关键字是线程同步的轻量级实现。所以volatile性能肯定比synchronized关键字要好。但是volatile关 键字只能用于变量而synchronized关键字可以修饰方法以及代码块。</p><p>synchronized关键字在JavaSE1.6之后进 行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行 效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</p><p>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞 volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</p><p>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访 问资源的同步性。 </p><h3 id="9-hashCode-与-equals-？为什么重写equals时必须重写hashCode方法？"><a href="#9-hashCode-与-equals-？为什么重写equals时必须重写hashCode方法？" class="headerlink" title="9.hashCode 与 equals ？为什么重写equals时必须重写hashCode方法？"></a>9.hashCode 与 equals ？为什么重写equals时必须重写hashCode方法？</h3><h4 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h4><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个int整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。<strong>hashCode() 在散列表中才有用，在其它情况下没用</strong>。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><h4 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h4><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h3 id="10-面向对象的特征有哪些方面"><a href="#10-面向对象的特征有哪些方面" class="headerlink" title="10.面向对象的特征有哪些方面"></a>10.面向对象的特征有哪些方面</h3><p>有四大基本特征:<strong>封装、抽象、继承、多态</strong></p><p>​      面向对象的<strong>封装</strong>性，即将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。</p><p>张三这个人，他的姓名等属性，要有自己提供的获取或改变的方法来操作。private name setName getName</p><p>​      <strong>抽象</strong>就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。 <strong>就是把现实生活中的对象，抽象为类。</strong></p><p>在定义和实现一个类的时候，<strong>可以在一个已经存在的类的基础之上来进行</strong>，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是<strong>继承</strong>。遗产继承</p><p><strong>多态</strong>是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>Object obj = new xxx();</p><p>UserDao userDao = new UserDaoJdbcImpl();</p><p>UserDao userDao = new UserDaoHibernateImpl();</p><p>靠的是<strong>父类或接口定义的引用变量可以指向子类或具体实现类的实例对象</strong>，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。  </p><p><strong>原则：回答比较抽象问题的时候，要举例说明</strong></p><h3 id="11-有了基本数据类型，为什么还需要包装类型？"><a href="#11-有了基本数据类型，为什么还需要包装类型？" class="headerlink" title="11.有了基本数据类型，为什么还需要包装类型？"></a>11.有了基本数据类型，为什么还需要包装类型？</h3><p>基本数据类型，java中提供了8中基本的数据类型。boolean int float等</p><p>包装类型：每一个基本的数据类型都会一一对应一个包装类型。</p><p>boolean —–&gt;Boolean</p><p>Int ——–&gt;Integer</p><h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><p><strong>装箱</strong>：<strong>把基本的数据类型转换成对应的包装类型.</strong></p><p>Integer .valueOf(1)</p><p>Integer i = 1;自动装箱，实际上在编译时会调用Integer .valueOf方法来装箱</p><p><strong>拆箱</strong>：<strong>就是把包装类型转换为基本数据类型.基本数据类型 名称 = 对应的包装类型。</strong></p><p>Integer i = 1;</p><p>int j = i;//自动拆箱//int j = i=intValue();手动拆箱</p><p>自动拆箱：实际上会在编译调用intValue</p><p>为什么：</p><p><strong>Java是一个面向对象的语言，而基本的数据类型，不具备面向对象的特性。</strong></p><p>null Integer—&gt;null int—-&gt;0 用Integer和int分别表示Person这个类的ID</p><p>Max 最大值</p><p>min 最小值</p><p>缓存值:对象缓存,Integer i=1; integer j= 1;i ==j  常量池</p><h3 id="12-说一下”-”和equals方法究竟有什么区别？"><a href="#12-说一下”-”和equals方法究竟有什么区别？" class="headerlink" title="12.说一下”==”和equals方法究竟有什么区别？"></a>12.说一下”==”和equals方法究竟有什么区别？</h3><p>非常经典的一个面试题？先说清楚一个，再来说另一个？</p><p>==用来判断两个变量之间的的值是否相等。变量就可以分为基本数据类型变量，引用类型。</p><p><strong>如果是基本数据类型的变量直接比较值而引用类型要比较对应的引用的内存的首地址。</strong></p><p><img data-src="1.png" alt="1.png"></p><p>equals 用来比较两个对象长得是否一样。判断两个对象的某些特征是否一样。实际上就是调用对象的equals方法进行比较。</p><h3 id="13-讲一下String和StringBuilder的区别-final-？StringBuffer和StringBuilder的区别"><a href="#13-讲一下String和StringBuilder的区别-final-？StringBuffer和StringBuilder的区别" class="headerlink" title="13.讲一下String和StringBuilder的区别(final)？StringBuffer和StringBuilder的区别?"></a>13.讲一下String和StringBuilder的区别(final)？StringBuffer和StringBuilder的区别?</h3><p>String 不可变 StringBuilder StringBuff 是可变的 StringBuffer是线程安全得多 StringBuilder不是线程安全的。</p><p>1.在java中提供三个类String StringBuillder StringBuffer来表示和操作字符串。字符串就是多个字符的集合。</p><p><strong>String是内容不可变的字符串</strong>。String底层使用了一个不可变的字符数组(final char[])</p><p>String str =new String(“bbbb”);</p><p><img data-src="2.png" alt="2.png"></p><p><strong>而StringBuillder StringBuffer,是内容可以改变的字符串</strong>。StringBuillder StringBuffer底层使用的可变的字符数<br>组（没有使用final来修饰） </p><p><img data-src="3.png" alt="3.png"></p><p>2.最经典就是拼接字符串。</p><p>1、String进行拼接.String c = “a”+”b”;</p><p>2、StringBuilder或者StringBuffer </p><p>StringBuilder sb = new StringBuilder(); sb.apend(“a”).apend(“b”) </p><p>拼接字符串不能使用String进行拼接，要使用StringBuilder或者StringBuffer。 </p><p>3.StringBuilder是线程不安全的，效率较高，而StringBuffer是线程安全的，效率较低。</p><h3 id="14-讲一下java中的集合"><a href="#14-讲一下java中的集合" class="headerlink" title="14.讲一下java中的集合?"></a>14.讲一下java中的集合?</h3><p>Java中的集合分为value，key–vale(Conllection Map)两种。</p><p>存储值有分为<strong>List</strong> 和<strong>Set</strong>.</p><p>List是有序的，可以重复的。</p><p>Set是无序的，不可以重复的。根据equals和hashcode判断，也就是如果</p><p><strong>一个对象要存储在Set中，必须重写equals和hashCode方法。</strong></p><p>存储key-value的为map.</p><h4 id="List又分为两种："><a href="#List又分为两种：" class="headerlink" title="List又分为两种："></a><strong>List又分为两种：</strong></h4><p><strong>ArrayList和LinkedList的区别?</strong></p><p>List常用的ArrayList和LinkedList。区别和使用场景?</p><p>ArrayList底层使用时<strong>数组</strong>。LinkedList底层使用的是<strong>链表</strong>。</p><p>数组查询具有所有<strong>查询</strong>特定元素比较<strong>快</strong>。而<strong>插入和删除和修改比较慢(</strong>数组在内存中是一块连续的内存，如果插入或删除是需要移动内=存)。</p><p>链表不要求内存是连续的，在当前元素中存放下一个或上一个元素的地址。<strong>查询时需要从头部开始，一个一个的找。所以查询效率低</strong>。<strong>插入时不需要移动内存，只需改变引用指向即可。所以插入或者删除的效率高</strong>。 </p><p><strong>ArrayList使用在查询比较多，但是插入和删除比较少的情况，而LinkedList使用在查询比较少而插入和删除比较多的情况。</strong></p><h3 id="15-讲一下HashMap哈HashTable的区别-HashTable和ConcurrentHashMap的区别"><a href="#15-讲一下HashMap哈HashTable的区别-HashTable和ConcurrentHashMap的区别" class="headerlink" title="15.讲一下HashMap哈HashTable的区别?HashTable和ConcurrentHashMap的区别?"></a>15.讲一下HashMap哈HashTable的区别?HashTable和ConcurrentHashMap的区别?</h3><p>相同点：HashMap和HasheTalbe都可以使用来存储key–value的数据。</p><p>区别：</p><p>1、HashMap是可以把null作为key或者value的，而HashTable是不可以的。</p><p>2、HashMap是线程不安全的，效率较高。而HashTalbe是线程安全的，效率较低。</p><p> 线程安全但是我又想效率高？</p><p>通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</p><h3 id="16-讲一下线程的几种实现方式-启动方式？区分方式？"><a href="#16-讲一下线程的几种实现方式-启动方式？区分方式？" class="headerlink" title="16.讲一下线程的几种实现方式?启动方式？区分方式？"></a>16.讲一下线程的几种实现方式?启动方式？区分方式？</h3><h4 id="①实现方式"><a href="#①实现方式" class="headerlink" title="①实现方式"></a>①实现方式</h4><p>1、<strong>通过继承Thread类实现一个线程</strong></p><p>2、<strong>通过实现Runnable接口实现一个线程</strong></p><p>   继承扩展性不强，java总只支持单继承，如果一个类继承Thread就不能继承其他的类了。</p><h4 id="②怎么启动？"><a href="#②怎么启动？" class="headerlink" title="②怎么启动？"></a>②怎么启动？</h4><p>   Thread thread = new Thread(继承了Thread的对象/实现了Runnable的对象)</p><p>   thread.setName(“设置一个线程名称”);</p><p>   thread.start();</p><p>   启动线程使用start方法，而启动了以后执行的是run方法。</p><h4 id="③怎么区分线程？在一个系统中有很多线程，每个线程都会打印日志，我想区分是哪个线程打印的怎么办？"><a href="#③怎么区分线程？在一个系统中有很多线程，每个线程都会打印日志，我想区分是哪个线程打印的怎么办？" class="headerlink" title="③怎么区分线程？在一个系统中有很多线程，每个线程都会打印日志，我想区分是哪个线程打印的怎么办？"></a>③怎么区分线程？在一个系统中有很多线程，每个线程都会打印日志，我想区分是哪个线程打印的怎么办？</h4><p>   thread.setName(“设置一个线程名称”); 这是一种规范，在创建线程完成后，都需要设置名称。</p><h3 id="17-有没有使用过线程并发库"><a href="#17-有没有使用过线程并发库" class="headerlink" title="17.有没有使用过线程并发库?"></a>17.有没有使用过线程并发库?</h3><p>简单了解过？</p><p>JDK5中增加了Doug Lea的并发库，这一引进给Java线程的管理和使用提供了强大的便利性。 java.util.current包中提供了对线程优化、管理的各项操作，使得线程的使用变得的心应手。该包提供了线程的运行，线程池的创建，线程生命周期的控制.</p><p><strong>Java通过Executors提供四个静态方法创建四种线程池</strong>，分别为：</p><p><strong>newCachedThreadPool</strong>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p><strong>newFixedThreadPool</strong> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p><strong>newScheduledThreadPool</strong> 创建一个定长线程池，支持定时及周期性任务执行。</p><p><strong>newSingleThreadExecutor</strong> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p><h3 id="18-线程池的作用？"><a href="#18-线程池的作用？" class="headerlink" title="18.线程池的作用？"></a>18.线程池的作用？</h3><p>1、限定线程的个数，不会导致由于线程过多导致系统运行缓慢或崩溃</p><p>2、线程池不需要每次都去创建或销毁，节约了资源、</p><p>3、线程池不需要每次都去创建，响应时间更快。</p><p>连接池也是一样</p><h3 id="19-讲一下什么是设计模式？常用的设计模式有哪些？"><a href="#19-讲一下什么是设计模式？常用的设计模式有哪些？" class="headerlink" title="19.讲一下什么是设计模式？常用的设计模式有哪些？"></a>19.讲一下什么是设计模式？常用的设计模式有哪些？</h3><p>设计模式就是<strong>经过前人无数次的实践总结出的</strong>，设计过程中可以反复使用的、可以解决特定问题的<strong>设计方法</strong>。</p><h4 id="单例-饿汉模式、懒汉模式"><a href="#单例-饿汉模式、懒汉模式" class="headerlink" title="单例(饿汉模式、懒汉模式)"></a>单例(饿汉模式、懒汉模式)</h4><p>1、构造方法私有化，除了自己类中能创建外其他地方都不能创建</p><p>2、在自己的类中创建一个单实例（<strong>饿汉模式是一出来就创建创建单实例，而懒汉模式需要的时候才创建</strong>）</p><p>3、提供一个方法获取该实例对象(<strong>创建时需要进行方法同步</strong>)</p><h4 id="工厂模式-Spring-IOC就是使用了工厂模式"><a href="#工厂模式-Spring-IOC就是使用了工厂模式" class="headerlink" title="工厂模式:Spring IOC就是使用了工厂模式."></a>工厂模式:Spring IOC就是使用了工厂模式.</h4><p>​       对象的创建交给一个工厂去创建。</p><h4 id="代理模式-Spring-AOP就是使用的动态代理。"><a href="#代理模式-Spring-AOP就是使用的动态代理。" class="headerlink" title="代理模式:Spring AOP就是使用的动态代理。"></a>代理模式:Spring AOP就是使用的动态代理。</h4><h2 id="JAVA-Web部分"><a href="#JAVA-Web部分" class="headerlink" title="JAVA Web部分"></a>JAVA Web部分</h2><h3 id="1-讲一下http-get和post请求的区别"><a href="#1-讲一下http-get和post请求的区别" class="headerlink" title="1.讲一下http get和post请求的区别?"></a>1.讲一下http get和post请求的区别?</h3><p>GET和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作,具体点来讲GET一般用于获取/查询资源信息，而POST一般用于更新资源信息</p><p>1、<strong>Get请求提交的数据会在地址栏显示出来，而post请求不会再地址栏显示出来.</strong></p><p>GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；</p><p>POST提交：把提交的数据放置在是HTTP包的包体中。 <strong>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</strong></p><p>2、传输数据的大小</p><p>http <strong>Get请求</strong>由于浏览器对<strong>地址长度</strong>的限制而导致传输的数据<strong>有限制</strong>。而POST请求不会因为地址长度限制而导致传输数据限制。</p><p>3、安全性,<strong>POST的安全性要比GET的安全性高</strong>。由于数据是会在地址中呈现，所以可以通过历史记录找到密码等关键信息。</p><h3 id="2-说一下你对servlet的理解？或者servlet是什么？"><a href="#2-说一下你对servlet的理解？或者servlet是什么？" class="headerlink" title="2.说一下你对servlet的理解？或者servlet是什么？"></a>2.说一下你对servlet的理解？或者servlet是什么？</h3><p><strong>Servlet</strong>（Server Applet），全称<strong>Java Servlet</strong>， <strong>是用Java编写的服务器端程序</strong>。而这些Sevlet都要实现Servlet这个接口。<strong>其主要功能在于交互式地浏览和修改数据，生成动态Web内容</strong>。Servlet运行于支持Java的应用服务器中。</p><p> HttpServlet 重写doGet和doPost方法或者你也可以重写service方法完成对get和post请求的响应</p><h3 id="3-简单说一下servlet的生命周期"><a href="#3-简单说一下servlet的生命周期" class="headerlink" title="3.简单说一下servlet的生命周期?"></a>3.简单说一下servlet的生命周期?</h3><p>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。</p><p><strong>加载Servlet的class—-&gt;实例化Servlet—–&gt;调用Servlet的init完成初始化—-&gt;响应请求（Servlet的service方法）—–&gt;Servlet容器关闭时(Servlet的destory方法)</strong></p><p>Servlet启动时，开始加载servlet生命周期开始。Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候(服务器关闭)调用其destroy方法。</p><h3 id="4-Servlet-API中forward-与redirect-的区别？"><a href="#4-Servlet-API中forward-与redirect-的区别？" class="headerlink" title="4.Servlet API中forward() 与redirect()的区别？"></a>4.Servlet API中forward() 与redirect()的区别？</h3><p>1、forward是服务器端的转向而redirect是客户端的跳转。 请求转发—–重定向</p><p>2、使用forward浏览器的地址不会发生改变。而redirect会发生改变。</p><p>3、Forward是一次请求中完成。而redirect是重新发起请求。</p><p>4、Forward是在服务器端完成，而不用客户端重新发起请求，效率较高。</p><h3 id="5-JSP和Servlet有哪些相同点和不同点"><a href="#5-JSP和Servlet有哪些相同点和不同点" class="headerlink" title="5.JSP和Servlet有哪些相同点和不同点?"></a>5.JSP和Servlet有哪些相同点和不同点?</h3><p>JSP是Servlet技术的扩展，所有的jsp文件都会被翻译为一个继承HttpServlet的类。也就是jsp最终也是一个Servlet.这个Servlet对外提供服务。</p><p><img data-src="4.png" alt="4.png"></p><p><strong>Servlet和JSP最主要的不同点在于JSP侧重于视图，Servlet主要用于控制逻辑。</strong></p><p>Servlet如果要实现html的功能，必须使用Writer输出对应的html,比较麻烦。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件,做界面展示比较方便而嵌入逻辑比较复杂。</p><h3 id="6-jsp有哪些内置对象-作用分别是什么"><a href="#6-jsp有哪些内置对象-作用分别是什么" class="headerlink" title="6. jsp有哪些内置对象?作用分别是什么?"></a>6. jsp有哪些内置对象?作用分别是什么?</h3><p><strong>9个内置的对象：</strong> </p><p>request 用户端请求，此请求会包含来自GET/POST请求的参数 </p><p>response 网页传回用户端的回应 </p><p>pageContext 网页的属性是在这里管理 </p><p>session 与请求有关的会话期 </p><p>application servlet正在执行的内容 </p><p>out 用来传送回应的输出 </p><p>config servlet的构架部件 </p><p>page JSP网页本身 </p><p>exception 针对错误网页，未捕捉的例外 </p><p><strong>四大作用域</strong>：<strong>pageContext request session application</strong> 可以通过jstl从四大作用域中取值.</p><p>Jsp传递值request session application cookie也能传值</p><h3 id="7-说一下session和cookie的区别？你在项目中都有哪些地方使用了？"><a href="#7-说一下session和cookie的区别？你在项目中都有哪些地方使用了？" class="headerlink" title="7.说一下session和cookie的区别？你在项目中都有哪些地方使用了？"></a>7.说一下session和cookie的区别？你在项目中都有哪些地方使用了？</h3><p>Session和cookie都是会话(Seesion)跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。但是Session的实现依赖于Cookie,sessionId(session的唯一标识需要存放在客户端).</p><h4 id="cookie-和session-的区别："><a href="#cookie-和session-的区别：" class="headerlink" title="cookie 和session 的区别："></a>cookie 和session 的区别：</h4><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>    考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：<br>    将<strong>登陆信息等重要信息存放为SESSION</strong><br>    其他信息如果需要保留，可以放在COOKIE中，比如<strong>购物车</strong></p><p><strong>购物车最好使用cookie，但是cookie是可以在客户端禁用的，这时候我们要使用cookie+数据库的方式实现，当从cookie中不能取出数据时，就从数据库获取。</strong></p><h3 id="8-MVC的各个部分都有那些技术来实现"><a href="#8-MVC的各个部分都有那些技术来实现" class="headerlink" title="8.MVC的各个部分都有那些技术来实现?"></a>8.MVC的各个部分都有那些技术来实现?</h3><p>M(Model) 模型 javabean</p><p>V(View) 视图  html jsp volicity freemaker</p><p>C(Control) 控制器 Servlet,Action</p><p>Jsp+Servlet+javabean 最经典mvc模式,实际上就是model2的实现方式，就是把视图和逻辑隔离开来</p><p>Model1的方式 jsp+service+dao</p><p>MOdel2的方式 jsp+servlet+service+dao</p><p>使用struts2和springmvc这样的mvc框架后，jsp+核心控制器+action+javabean</p><h2 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h2><h3 id="1-数据库的分类及常用的数据库"><a href="#1-数据库的分类及常用的数据库" class="headerlink" title="1.数据库的分类及常用的数据库"></a>1.数据库的分类及常用的数据库</h3><p>数据库分为：<strong>关系型数据库</strong>和<strong>非关系型数据库</strong></p><p>​          关系型：mysql oracle sqlserver等</p><p>​          非关系型：redis,memcache,mogodb,hadoop等</p><h3 id="2-简单介绍一下关系数据库三范式？"><a href="#2-简单介绍一下关系数据库三范式？" class="headerlink" title="2.简单介绍一下关系数据库三范式？"></a>2.简单介绍一下关系数据库三范式？</h3><p>范式就是规范,就是关系型数据库在设计表时，要遵循的三个规范。</p><p>要想满足第二范式必须先满足第一范式，要满足第三范式必须先满足第二范式。</p><p>第一范式（1NF）是指<strong>数据库表的每一列都是不可分割的基本数据项</strong>，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。列数据的不可分割</p><p>二范式（2NF）<strong>要求数据库表中的每个行必须可以被唯一地区分</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。(主键)</p><p> 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求<strong>一个数据库表中不包含已在其它表中已包含的非主关键字信息</strong>。(外键)</p><p>1NF:字段不可分;</p><p>2NF:有主键，非主键字段依赖主键;</p><p>3NF:非主键字段不能相互依赖;</p><p>反三范式,<strong>有的时候为了效率，可以设置重复或者可以推导出的字段.</strong><br>        订单（总价）和订单项（单价）</p><h3 id="3-事务四个基本特征或-ACID-特性。"><a href="#3-事务四个基本特征或-ACID-特性。" class="headerlink" title="3.事务四个基本特征或 ACID 特性。"></a>3.事务四个基本特征或 ACID 特性。</h3><p><strong>事务是并发控制的单位，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。</strong><br>一个转账必须 A账号扣钱成功，B账号加钱成功，才算正真的转账成功。</p><p>  <strong>事务必须满足四大特征</strong>:原子性,一致性,隔离性,持久性/持续性</p><p> 原子性：表示事务内操作不可分割。要么都成功、要么都是失败.</p><p> 一致性：要么都成功、要么都是失败.后面的失败了要对前面的操作进行回滚。</p><p> 隔离性：一个事务开始后，不能受其他事务干扰。</p><p> 持久性/持续性：表示事务开始了，就不能终止。</p><h3 id="4-mysql数据库的默认的最大连接数？"><a href="#4-mysql数据库的默认的最大连接数？" class="headerlink" title="4. mysql数据库的默认的最大连接数？"></a>4. mysql数据库的默认的最大连接数？</h3><p>100</p><p>为什么需要最大连接数？特定服务器上面的数据库只能支持一定数目同时连接，这时候我们一般都会设置最大连接数（最多同时服务多少连接）。在数据库安装时都会有一个默认的最大连接数为100</p><p><img data-src="5.png" alt="5.png"></p><h3 id="5-说一下msyql的分页？Oracle的分页？"><a href="#5-说一下msyql的分页？Oracle的分页？" class="headerlink" title="5.说一下msyql的分页？Oracle的分页？"></a>5.说一下msyql的分页？Oracle的分页？</h3><p>为什么需要分页？在很多数据是，不可能完全显示数据。进行分段显示.</p><p>Mysql是使用关键字limit来进行分页的 limit offset,size 表示从多少索引去多少位.</p><p>Oracle的分页，大部分情况下，我们是记不住的。说思路，要使用三层嵌套查询。</p><p>Oracle的分页有点儿记不住了，只记得一些大概。是使用了三层嵌套查询。如果在工作中使用了，可以到原来的项目中拷贝或上网查询。</p><p><strong>mysql:</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql =  <span class="string">"select * from students order by id limit "</span> + pageSize*(pageNumber-<span class="number">1</span>) + <span class="string">","</span> + pageSize;</span><br></pre></td></tr></table></figure><p>​              </p><p><strong>oracle:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String sql = </span><br><span class="line"></span><br><span class="line">         <span class="string">"select * from "</span> +  </span><br><span class="line">          (select *,<span class="function">rownum rid <span class="title">from</span> <span class="params">(select * from students order by postime desc)</span> where rid&lt;</span>=<span class="string">" + pagesize*pagenumber + "</span>) as t<span class="string">" + </span></span><br><span class="line"><span class="string">          "</span>where t&gt;<span class="string">" + pageSize*(pageNumber-1);</span></span><br></pre></td></tr></table></figure><p>​         </p><h3 id="6-简单讲一下数据库的触发器的使用场景？"><a href="#6-简单讲一下数据库的触发器的使用场景？" class="headerlink" title="6.简单讲一下数据库的触发器的使用场景？"></a>6.简单讲一下数据库的触发器的使用场景？</h3><p><strong>触发器，需要有触发条件，当条件满足以后做什么操作。</strong></p><p>触发器用处还是很多的，比如校内网、开心网、Facebook，你发一个日志，自动通知好友，其实就是在增加日志时做一个后触发，再向通知表中写入条目。因为触发器效率高。而UCH没有用触发器，效率和数据处理能力都很低。</p><p>每插入一个帖子，都希望将版面表中的最后发帖时间，帖子总数字段进行同步更新，用触发器做效率就很高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> board1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>),ar</span><br><span class="line">ticleCount <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> article1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,title <span class="built_in">varchar</span>(<span class="number">50</span>)</span><br><span class="line">,bid <span class="built_in">int</span> <span class="keyword">references</span> board1(<span class="keyword">id</span>));</span><br><span class="line"></span><br><span class="line">delimiter |<span class="comment">#把分割符;改成|</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> insertArticle_Trigger <span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> article1 <span class="keyword">for</span> <span class="keyword">each</span> ro</span><br><span class="line">w <span class="keyword">begin</span></span><br><span class="line">    -&gt; <span class="keyword">update</span> board1 <span class="keyword">set</span> articleCount=articleCount+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>= NEW.bid;</span><br><span class="line">    -&gt; end;</span><br><span class="line">    -&gt; |</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> board1 <span class="keyword">value</span> (<span class="literal">null</span>,<span class="string">'test'</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> article1 <span class="keyword">value</span>(<span class="literal">null</span>,<span class="string">'test'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="7-简单讲一下数据库的存储过程的使用场景？"><a href="#7-简单讲一下数据库的存储过程的使用场景？" class="headerlink" title="7.简单讲一下数据库的存储过程的使用场景？"></a>7.简单讲一下数据库的存储过程的使用场景？</h3><p><strong>数据库存储过程具有如下优点：</strong></p><p>1、存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次，因此使用存储过程可以大大提高数据库执行速度。</p><p>2、通常，复杂的业务逻辑需要多条 SQL 语句。这些语句要分别地从客户机发送到服务器，当客户机和服务器之间的操作很多时，将产生大量的网络传输。如果将这些操作放在一个存储过程中，那么客户机和服务器之间的网络传输就会大大减少，降低了网络负载。</p><p>3、存储过程创建一次便可以重复使用，从而可以减少数据库开发人员的工作量。</p><p>4、<strong>安全性高</strong>，存储过程可以屏蔽对底层数据库对象的直接访问，使用 EXECUTE 权限调用存储过程，无需拥有访问底层数据库对象的显式权限。</p><p>正是由于存储过程的上述优点，目前常用的数据库都支持存储过程，例如 IBM DB2，Microsoft SQL Server，Oracle，Access 等，开源数据库系统 MySQL 也在 5.0 的时候实现了对存储过程的支持。</p><p>定义存储过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_Student (_name <span class="built_in">varchar</span>(<span class="number">50</span>),_age <span class="built_in">int</span> ,<span class="keyword">out</span> _id <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">value</span>(<span class="literal">null</span>,_name,_age);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(stuId) <span class="keyword">into</span> _id <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> insert_Student(<span class="string">'wfz'</span>,<span class="number">23</span>,@<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">select</span> @<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><h3 id="8-用jdbc怎么调用存储过程？"><a href="#8-用jdbc怎么调用存储过程？" class="headerlink" title="8.用jdbc怎么调用存储过程？"></a>8.用jdbc怎么调用存储过程？</h3><p><strong>贾琏欲执事</strong></p><p>加载驱动</p><p>获取连接</p><p>设置参数</p><p>执行</p><p>释放连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.CallableStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Types;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Connection cn = <span class="keyword">null</span>;</span><br><span class="line">CallableStatement cstmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里最好不要这么干，因为驱动名写死在程序中了</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//实际项目中，这里应用DataSource数据，如果用框架，</span></span><br><span class="line"><span class="comment">//这个数据源不需要我们编码创建，我们只需Datasource ds = context.lookup()</span></span><br><span class="line"><span class="comment">//cn = ds.getConnection();</span></span><br><span class="line">cn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///test"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">cstmt = cn.prepareCall(<span class="string">"&#123;call insert_Student(?,?,?)&#125;"</span>);</span><br><span class="line">cstmt.registerOutParameter(<span class="number">3</span>,Types.INTEGER);</span><br><span class="line">cstmt.setString(<span class="number">1</span>, <span class="string">"wangwu"</span>);</span><br><span class="line">cstmt.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line">cstmt.execute();</span><br><span class="line"><span class="comment">//get第几个，不同的数据库不一样，建议不写</span></span><br><span class="line">System.out.println(cstmt.getString(<span class="number">3</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*try&#123;cstmt.close();&#125;catch(Exception e)&#123;&#125;</span></span><br><span class="line"><span class="comment">try&#123;cn.close();&#125;catch(Exception e)&#123;&#125;*/</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(cstmt != <span class="keyword">null</span>)</span><br><span class="line">cstmt.close();</span><br><span class="line"><span class="keyword">if</span>(cn != <span class="keyword">null</span>)</span><br><span class="line">cn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-简单说一下你对jdbc的理解？"><a href="#9-简单说一下你对jdbc的理解？" class="headerlink" title="9.简单说一下你对jdbc的理解？"></a>9.简单说一下你对jdbc的理解？</h3><p><strong>1.什么是 JDBC ？</strong></p><p>JDBC（Java Data Base Connectivity，java数据库连接）是一种用于执行SQL语句的Java API（Application Programming Interface），可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。</p><p><strong>简单说：</strong>  它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。</p><p><img data-src="6.png" alt="6.png"></p><p><strong>2.JDBC 有什么用 ？</strong></p><p>我们用JAVA就能连接到数据库；创建SQL或者MYSQL语句；执行SQL或MYSQL的查询数据库；查看和修改结果记录。</p><p><strong>3.JDBC API 介绍及接口</strong></p><p>JDBC API主要做三件事：<strong>与数据库建立连接，发送SQL语句，处理结果</strong>。</p><p>提供的接口包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JAVA API：提供对JDBC的管理链接；</span><br><span class="line"></span><br><span class="line">JAVA Driver API：支持JDBC管理到驱动器连接。</span><br><span class="line"></span><br><span class="line">DriverManager：这个类管理数据库驱动程序的列表，查看加载的驱动是否符合JAVA Driver API的规范。 装载驱动程序，并为创建新的数据库连接提供支持。</span><br><span class="line"></span><br><span class="line">Connection：与数据库中的所有的通信是通过唯一的连接对象。负责连接数据库并担任传送数据的任务。</span><br><span class="line"></span><br><span class="line">Statement：把创建的SQL对象，转而存储到数据库当中。由Connection产生，负责执行SQL语句。</span><br><span class="line"></span><br><span class="line">ResultSet：它是一个迭代器，用于检索查询数据。负责保存和处理Statement中心执行后所产生的查询结果。</span><br></pre></td></tr></table></figure><p><strong>4.采用JDBC访问数据库的基本步骤：</strong></p><p><strong>a) 注册驱动</strong>  </p><p><strong>b) 建立数据库连接(Connection)</strong>  </p><p><strong>c) 准备 SQL 语句</strong>  </p><p><strong>d) 获取 SQL 语句发送器(Statement)</strong> </p><p> <strong>e) 发送并执行 SQL 语句, 得到结果集(ResultSet)</strong>  </p><p><strong>f) 处理结果集</strong>  </p><p><strong>g) 关闭资源(ResultSet, Statement, Connection)</strong></p><p><strong>5.执行查询操作</strong></p><h3 id="10-JDBC中的PreparedStatement相比Statement的好处"><a href="#10-JDBC中的PreparedStatement相比Statement的好处" class="headerlink" title="10.JDBC中的PreparedStatement相比Statement的好处"></a>10.JDBC中的PreparedStatement相比Statement的好处</h3><p><strong>大多数我们都使用PreparedStatement代替Statement</strong></p><p><strong>1：PreparedStatement是预编译的，比Statement速度快</strong> </p><p><strong>2：代码的可读性和可维护性</strong></p><p>虽然用PreparedStatement来代替Statement会使代码多出几行,但这样的代码无论从可读性还是可维护性上来说.都比直接用Statement的代码高很多档次：</p><p>stmt.executeUpdate(“insert into tb_name (col1,col2,col2,col4) values (‘“+var1+”‘,’”+var2+”‘,”+var3+”,’”+var4+”‘)”); </p><p>perstmt = con.prepareStatement(“insert into tb_name (col1,col2,col2,col4) values (?,?,?,?)”);</p><p>perstmt.setString(1,var1);</p><p>perstmt.setString(2,var2);</p><p>perstmt.setString(3,var3);</p><p>perstmt.setString(4,var4);</p><p>perstmt.executeUpdate();</p><p>不用我多说,对于第一种方法，别说其他人去读你的代码，就是你自己过一段时间再去读,都会觉得伤心。</p><p><strong>3：安全性</strong></p><p><strong>PreparedStatement可以防止SQL注入攻击，而Statement却不能</strong>。比如说：</p><p>String sql = “select * from tb_name where name= ‘“+varname+”‘ and passwd=’”+varpasswd+”‘“;</p><p>如果我们把[‘ or ‘1’ = ‘1]作为varpasswd传入进来.用户名随意,看看会成为什么?</p><p>select * from tb_name = ‘随意’ and passwd = ‘’ or ‘1’ = ‘1’;</p><p>因为’1’=’1’肯定成立，所以可以任何通过验证，更有甚者：</p><p>把[‘;drop table tb_name;]作为varpasswd传入进来,则：</p><p>select * from tb_name = ‘随意’ and passwd = ‘’;drop table tb_name;有些数据库是不会让你成功的，但也有很多数据库就可以使这些语句得到执行。</p><p>而如果你使用预编译语句你传入的任何内容就不会和原来的语句发生任何匹配的关系，只要全使用预编译语句你就用不着对传入的数据做任何过虑。而如果使用普通的statement,有可能要对drop等做费尽心机的判断和过虑。</p><h3 id="11-数据库连接池作用"><a href="#11-数据库连接池作用" class="headerlink" title="11.数据库连接池作用"></a>11.数据库连接池作用</h3><p>1、限定数据库的个数，不会导致由于数据库连接过多导致系统运行缓慢或崩溃</p><p>2、数据库连接不需要每次都去创建或销毁，节约了资源</p><p>3、数据库连接不需要每次都去创建，响应时间更快。</p><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><h3 id="1-简单说一下html-css-javascript在网页开发中的定位"><a href="#1-简单说一下html-css-javascript在网页开发中的定位" class="headerlink" title="1.简单说一下html,css,javascript在网页开发中的定位?"></a>1.简单说一下html,css,javascript在网页开发中的定位?</h3><p>HTML 超文本标记语言 <strong>定义网页的结构</strong></p><p>CSS 层叠样式表，<strong>用来美化页面</strong></p><p>JavaScript主要用来验证表单，<strong>做动态交互(</strong>其中ajax)</p><h3 id="2-简单介绍一下Ajax"><a href="#2-简单介绍一下Ajax" class="headerlink" title="2.简单介绍一下Ajax?"></a>2.简单介绍一下Ajax?</h3><h4 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax?"></a>什么是Ajax?</h4><p>异步的javascript和xml（局部刷新，异步交互）</p><h4 id="作用是什么？"><a href="#作用是什么？" class="headerlink" title="作用是什么？"></a>作用是什么？</h4><p>通过AJAX与服务器进行数据交换，AJAX可以使网页实现布局更新。</p><p>这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><h4 id="怎么来实现Ajax"><a href="#怎么来实现Ajax" class="headerlink" title="怎么来实现Ajax"></a>怎么来实现Ajax</h4><p>XmlHttpRequest对象，使用这个对象可以异步向服务器发送请求，获取获取响应，完成局部更新。Open send responseText/responseXML 局部响应.</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>登陆失败时不跳转页面，注册时提示用户名是否存在,二级联动等等使用场景</p><h3 id="3-js和jQuery的关系"><a href="#3-js和jQuery的关系" class="headerlink" title="3.js和jQuery的关系?"></a>3.js和jQuery的关系?</h3><p> jQuery是一个js框架，封装了js的属性和方法。让用户使用起来更加便利,并且增强了js的功能。</p><p>使用原生js时要处理很多兼容性的问题(注册事件等)，由jQuery封装了底层，就不用处理兼容性问题。</p><p>原生的js的dom和事件绑定和Ajax等操作非常麻烦，jQuery封装以后操作非常方便。</p><h3 id="4-jQuery的常用选择器？"><a href="#4-jQuery的常用选择器？" class="headerlink" title="4.jQuery的常用选择器？"></a>4.jQuery的常用选择器？</h3><p><strong>ID选择器</strong>   通过ID获取一个元素</p><p><strong>Class选择器</strong> 通过类(css)获取元素</p><p><strong>标签选择器</strong> 通过标签获取元素</p><p><strong>通用选择器(*)</strong> 获取所以的元素</p><p>div.myCls  获取有myCls这个类的div</p><p><strong>层次选择器</strong></p><p>​     儿子选择器 &gt; 获取下面的子元素</p><p>​     后代选择器 空格 获取下面后代，包括儿子、孙子等后代</p><p><strong>属性选择器</strong></p><p>​    Tag[attrName=’test’] 获取有属性名为xxxx并且属性的值为test的所有xxx标签</p><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>/&gt;</span> 吃饭<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>/&gt;</span> 睡觉<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>   Input[name=’hobby’],表示获取属性名为name并且name属性值为hobby的的所有input标签元素 </p><h3 id="5-Jquery的Ajax和原生Js实现Ajax有什么关系？"><a href="#5-Jquery的Ajax和原生Js实现Ajax有什么关系？" class="headerlink" title="5.Jquery的Ajax和原生Js实现Ajax有什么关系？"></a>5.Jquery的Ajax和原生Js实现Ajax有什么关系？</h3><p><strong>jQuery中的Ajax也是通过原生的js封装的。封装完成后让我们使用起来更加便利，不用考虑底层实现或兼容性等处理。</strong></p><p>如果采用原生js实现Ajax是非常麻烦的，并且每次都是一样的。如果我们不使用jQuery我们也要封装Ajax对象的方法和属性。有像jQuery这些已经封装完成，并经过很多企业实际的框架，比较可靠并且开源。我们就不需要封装，直接使用成熟的框架(jQuery)即可.</p><h2 id="框架部分"><a href="#框架部分" class="headerlink" title="框架部分"></a>框架部分</h2><h3 id="1-什么是框架"><a href="#1-什么是框架" class="headerlink" title="1.什么是框架?"></a>1.什么是框架?</h3><p>框架（Framework）是一个框子——指其约束性，也是一个架子——指其支撑性。</p><p>  IT语境中的框架，特指<strong>为解决一个开放性问题而设计的具有一定约束性的支撑结构</strong>。在此结构上可以根据具体问题<strong>扩展、安插更多的组成部分，从而更迅速和方便地构建完整的解决问题的方案</strong>。</p><p>1）框架本身一般不完整到可以解决特定问题,但是可以帮助您快速解决特定问题；</p><p>   没有框架所有的工作都从零开始做,有了框架,为我们提供了一定的功能,我们就可以在框 架的基础上开发,极大的解放了生产力。</p><p>不同的框架，是为了解决不同领域的问题。一定要为了解决问题才去学习框架。</p><p>2）框架天生就是为扩展而设计的；</p><p>3）框架里面可以为后续扩展的组件提供很多辅助性、支撑性的方便易用的实用工具（utilities），也就是说框架时常配套了一些帮助解决某类问题的库（libraries）或工具（tools）。</p><p>  java中就是一系列的jar包，其本质就是对jdk功能的扩展.</p><h3 id="2-MVC模式"><a href="#2-MVC模式" class="headerlink" title="2.MVC模式"></a>2.MVC模式</h3><p>MVC全名是<strong>Model View Controller</strong>，是<strong>模型(model)－视图(view)－控制器(controller)</strong>的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p><p><strong>最简单的、最经典就是Jsp(view) +Servlet(controller) + JavaBean(model)</strong></p><p><img data-src="7.png" alt="7.png"></p><p>1、当控制器收到来自用户的请求</p><p>2、控制器调用JavaBean完成业务</p><p>3、完成业务后通过控制器跳转JSP页面的方式给用户反馈信息</p><p>4、Jsp个 用户做出响应。</p><p>​    控制器都是核心</p><h3 id="3-MVC框架"><a href="#3-MVC框架" class="headerlink" title="3.MVC框架"></a>3.MVC框架</h3><p><strong>什么是MVC框架？</strong></p><p>  是为了解决传统MVC模式(Jsp + Servlet + JavaBean)的一些问题而出现的框架。</p><p><strong>传统MVC模式问题</strong></p><p>1、所有的Servlet和Servlet映射都要配置在web.xml中，如果项目太大，web.xml就太庞大，并且不能实现模块化管理。</p><p>2、Servlet的主要功能就是<strong>接受参数、调用逻辑、跳转页面</strong>，比如像其他字符编码、文件上传等功能也要写在Servlet中，不能让Servlet主要功能而需要做处理一下特例。</p><p>3、接受参数比较麻烦(String name = request.getParameter(“name”),User user=new User user.setName(name))，不能通过model接收，只能单个接收，接收完成后转换封装model.</p><p>4、跳转页面方式比较单一(forword,redirect),并且当我的页面名称发生改变时需要修改Servlet源代码.</p><p><strong>现在比较常用的MVC框架有：</strong></p><p>   struts</p><p>   webwork</p><p>   <strong>Struts2</strong></p><p>   <strong>Spring MVC</strong></p><h3 id="4-简单讲一下SpringMVC的执行流程？"><a href="#4-简单讲一下SpringMVC的执行流程？" class="headerlink" title="4. 简单讲一下SpringMVC的执行流程？"></a>4. 简单讲一下SpringMVC的执行流程？</h3><p><img data-src="8.png" alt="8.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588473268676.png" alt="1588473268676"></p><ol><li><p>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</p></li><li><p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</p></li><li><p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（<strong>附注</strong>：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）</p></li><li><p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p><p><strong>HttpMessageConveter：</strong> 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p></li></ol><p>​      <strong>数据转换</strong>：对请求消息进行数据转换。如String转换成Integer、Double等</p><p>​      <strong>数据格式化：</strong>对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p><p>​      <strong>数据验证：</strong> 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p><p>5.Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</p><p>6.根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</p><p>​      7. ViewResolver 结合Model和View，来渲染视图</p><p>​      8. 将渲染结果返回给客户端。</p><h4 id="面试："><a href="#面试：" class="headerlink" title="面试："></a>面试：</h4><p>1、 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获(<strong>捕获</strong>)</p><p>2、 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；(<strong>查找handler)</strong></p><p>3、 DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller), Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象(<strong>执行handler</strong>)</p><p>4、DispatcherServlet 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver) (<strong>选择ViewResolver</strong>)</p><p>5、通过ViewResolver 结合Model和View，来渲染视图,DispatcherServlet 将渲染结果返回给客户端。（<strong>渲染返回</strong>）</p><h4 id="快速记忆技巧："><a href="#快速记忆技巧：" class="headerlink" title="快速记忆技巧："></a>快速记忆技巧：</h4><p>核心控制器捕获请求、查找Handler、执行Handler、选择ViewResolver,通过ViewResolver渲染视图并返回</p><h3 id="5-说一下struts2和springMVC有什么不同？"><a href="#5-说一下struts2和springMVC有什么不同？" class="headerlink" title="5.说一下struts2和springMVC有什么不同？"></a>5.说一下struts2和springMVC有什么不同？</h3><p>目前企业中使用SpringMVC的比例已经远远超过Struts2,那么两者到底有什么区别，是很多初学者比较关注的问题，下面我们就来对SpringMvc和Struts2进行各方面的比较:</p><ol><li>核心控制器（前端控制器、预处理控制器）：对于使用过mvc框架的人来说这个词应该不会陌生，核心控制器的主要用途是处理所有的请求，然后对那些特殊的请求 （控制器）统一的进行处理(字符编码、文件上传、参数接受、异常处理等等),<strong>spring mvc核心控制器是Servlet，而Struts2是Filter</strong>。</li><li>控制器实例：Spring Mvc会比Struts快一些（理论上）。Spring Mvc是基于方法设计，而Sturts是基于对象，每次发一次请求都会实例一个action，每个action都会被注入 属性，而Spring更像Servlet一样，只有一个实例，每次请求执行对应的方法即可(注意：由于是单例实例，所以应当避免全局变量的修改，这样会产生线程安全问题)。</li><li>管理方式：大部分的公司的核心架构中，就会使用到spring,而spring mvc又是spring中的一个模块，所以spring对于spring mvc的控制器管理更加简单方便，而且提供了全 注解方式进行管理，各种功能的注解都比较全面，使用简单，而struts2需要采用XML很多的配置参数来管理（虽然也可以采用注解，但是几乎没有公司那 样使用）。</li><li>参数传递：Struts2中自身提供多种参数接受，其实都是通过（ValueStack）进行传递和赋值，而SpringMvc是通过方法的参数进行接收。</li><li>学习难度：Struts更加很多新的技术点，比如拦截器、值栈及OGNL表达式，学习成本较高，springmvc 比较简单，很较少的时间都能上手。</li><li>intercepter 的实现机制：struts有以自己的interceptor机制，spring mvc用的是独立的AOP方式。这样导致struts的配置文件量还是比spring mvc大，虽然struts的配置能继承，所以我觉得论使用上来讲，spring mvc使用更加简洁，开发效率Spring MVC确实比struts2高。spring mvc是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上spring3 mvc就容易实现restful url。struts2是类级别的拦截，一个类对应一个request上下文；实现restful url要费劲，因为struts2 action的一个方法可以对应一个url；而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。spring3 mvc的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架方法之间不共享变量，而struts2搞的就比较乱，虽然方法之间 也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码，读程序时带来麻烦。</li><li>spring mvc处理ajax请求,直接通过返回数据，方法中使用注解@ResponseBody，spring mvc自动帮我们对象转换为JSON数据。而struts2是通过插件的方式进行处理</li></ol><p>在SpringMVC流行起来之前，Struts2在MVC框架中占核心地位，随着SpringMVC的出现，SpringMVC慢慢的取代struts2,但是很多企业都是原来搭建的框架，使用Struts2较多。</p><h3 id="6-说一下Spring中的两大核心？"><a href="#6-说一下Spring中的两大核心？" class="headerlink" title="6.说一下Spring中的两大核心？"></a>6.说一下Spring中的两大核心？</h3><p><strong>Spring是什么？</strong></p><p>spring是<strong>J2EE应用程序框架</strong>，是轻量级的<strong>IoC和AOP的容器框架</strong>(相对于重量级的EJB)，主要是针对javaBean的生命周期进行管理的<strong>轻量级容器</strong>，可以单独使用，也可以和Struts框架，ibatis框架等组合使用。</p><p><strong>1、IOC(Inversion of Control )或DI(Dependency Injection)</strong></p><p>​       IOC控制权反转</p><p>​          原来：我的Service需要调用DAO，Service就需要创建DAO</p><p>​          Spring:Spring发现你Service依赖于dao,就给你注入.</p><p>​       核心原理：就是配置文件+反射(工厂也可以)+容器(map)  </p><p><strong>2、AOP:面向切面编程</strong></p><p>​       核心原理：使用动态代理的设计模式在执行方法前后或出现异常后加入相关逻辑。</p><p>​      我们主要使用AOP来做：</p><p>​      1、事务处理    执行方法前，开启事务、执行完成后关闭事务、出现异常后回滚事务</p><p>​      2、权限判断    在执行方法前，判断是否具有权限</p><p>​      3、日志      在执行前进行日志处理</p><p>​      4、….</p><h3 id="7-讲一下Spring的事务传播特性"><a href="#7-讲一下Spring的事务传播特性" class="headerlink" title="7.讲一下Spring的事务传播特性"></a>7.讲一下Spring的事务传播特性</h3><p>多个事务存在是怎么处理的策略</p><ol><li>PROPAGATION_REQUIRED:<br>如果存在一个事务，则支持当前事务。如果没有事务则开启</li><li>PROPAGATION_SUPPORTS: 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</li><li>PROPAGATION_MANDATORY: 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</li><li>PROPAGATION_REQUIRES_NEW: 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</li><li>PROPAGATION_NOT_SUPPORTED: 总是非事务地执行，并挂起任何存在的事务。</li><li>PROPAGATION_NEVER: 总是非事务地执行，如果存在一个活动事务，则抛出异常</li><li>PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED<br>属性执行</li></ol><p><strong>Propagation</strong></p><p><strong>Required</strong> <strong>需要</strong> 如果存在一个事务，则支持当前事务。如果没有事务，则开启</p><p><strong>Supports 支持</strong> 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</p><p><strong>Mandatory 必要的</strong> 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p><p><strong>required_new</strong> 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p><p><strong>Not_support</strong> 总是非事务地执行，并挂起任何存在的事务。</p><p><strong>Never</strong> <strong>绝不</strong> 总是非事务地执行，如果存在一个活动事务，则抛出异常</p><p><strong>Nested 嵌套的</strong> 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</p><h3 id="8-什么是ORM"><a href="#8-什么是ORM" class="headerlink" title="8.什么是ORM?"></a>8.什么是ORM?</h3><p>对象关系映射（<strong>Object Relational Mapping</strong>，简称ORM）模式是一种<strong>为了解决面向对象与关系数据库存在的互不匹配的现象的技术</strong>。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。那么，到底如何实现持久化呢？<strong>一种简单的方案是采用硬编码方式(jdbc操作sql方式)</strong>，为每一种可能的数据库访问操作提供单独的方法。</p><p><strong>这种方案存在以下不足：</strong> </p><p>​    1.持久化层缺乏弹性。一旦出现业务需求的变更，就必须修改持久化层的接口 </p><p>​    2.持久化层同时与域模型与关系数据库模型绑定，不管域模型还是关系数据库模型发生变化，都要修改持久化层的相关程序代码，增加了软件的维护难度。 </p><p>   <strong>ORM提供了实现持久化层的另一种模式，它采用映射元数据来描述对象关系的映射，使得ORM中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁</strong>。</p><p>Java典型的ORM框架有:Hibernate,ibatis(mybatis),speedframework。</p><p>   <strong>ORM的方法论基于三个核心原则：</strong> </p><p>　　   简单：以最基本的形式建模数据。 </p><p>　　   传达性：数据库结构被任何人都能理解的语言文档化。 </p><p>　　   精确性：基于数据模型创建正确标准化了的结构。</p><h4 id="面试：-1"><a href="#面试：-1" class="headerlink" title="面试："></a>面试：</h4><p>   对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向<strong>对象</strong>与<strong>关系</strong>数据库存在的互不匹配的现象的技术。可以简单的方案是采用硬编码方式(jdbc操作sql方式)，为每一种可能的数据库访问操作提供单独的方法。这种方法存在很多缺陷</p><p>使用ORM框架(为了解决解决面向<strong>对象</strong>与<strong>关系</strong>数据库存在的互不匹配的现象的框架)来解决. </p><p>   Hibernate,ibatis(mybatis),</p><h3 id="9-mybatis与Hibernate有什么不同"><a href="#9-mybatis与Hibernate有什么不同" class="headerlink" title="9.mybatis与Hibernate有什么不同?"></a>9.mybatis与Hibernate有什么不同?</h3><p>相同点：</p><p>   <strong>都是java中orm框架、屏蔽jdbc api的底层访问细节，使用我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。</strong>jdbc api编程流程固定，还将sql语句与java代码混杂在了一起，经常需要拼凑sql语句，细节很繁琐。</p><h4 id="mybatis的好处："><a href="#mybatis的好处：" class="headerlink" title="mybatis的好处："></a>mybatis的好处：</h4><p>屏蔽jdbc api的底层访问细节；<strong>将sql语句与java代码进行分离</strong>;提供了将结果集自动封装称为实体对象和对象的集合的功能.queryForList返回对象集合，用queryForObject返回单个对象；<strong>提供了自动将实体对象的属性传递给sql语句的参数</strong>。</p><h4 id="Hibername的好处："><a href="#Hibername的好处：" class="headerlink" title="Hibername的好处："></a>Hibername的好处：</h4><p>Hibernate是一个全自动的orm映射工具，它可以自动生成sql语句，并执行并返回java结果。</p><p>不同点：</p><p>   1、hibernate要比mybatis功能强大很多。因为hibernate自动生成sql语句。</p><p>   2、mybatis需要我们自己在xml配置文件中写sql语句，hibernate我们无法直接控制该语句，我们就无法去写特定的高效率的sql。对于一些不太复杂的sql查询，hibernate可以很好帮我们完成，但是，对于特别复杂的查询，hibernate就很难适应了，这时候用mybatis就是不错的选择，因为mybatis还是由我们自己写sql语句。</p><p>  <strong>mybatis可以出来复杂语句，而hibernate不能。</strong></p><p>   3、mybatis要比hibernate简单的多。mybatis是面向sql的，<strong>不用考虑对象间一些复杂的映射关系</strong>。</p><h3 id="10-Hibernate映射对象的状态"><a href="#10-Hibernate映射对象的状态" class="headerlink" title="10.Hibernate映射对象的状态"></a>10.Hibernate映射对象的状态</h3><p><strong>临时状态/瞬时状态</strong>(transient)：刚刚用new语句创建，没有被持久化，不处于session中(没有使用session的方法去操作临时对象)。该对象成为临时对象</p><p><strong>持久化状态</strong>/托管状态(persistent)：已经被持久化，加入到session的缓存中。session是没有关闭的，该状态的对象为持久化对象。</p><p><strong>游离状态</strong>/脱管状态(detached)：已经被持久化，但不处于session中。该状态的对象为游离对象。</p><p><strong>删除状态</strong>(removed)：对象有关联的ID，并且在Session管理下，但是已经被计划(事务提交的时候,commit())删除。如果没有事务就不能删除</p><p>相互转换</p><p><img data-src="9.png" alt="9.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588490670148.png" alt="1588490670148"></p><h3 id="11-介绍一下Hibernate的缓存"><a href="#11-介绍一下Hibernate的缓存" class="headerlink" title="11.介绍一下Hibernate的缓存?"></a>11.介绍一下Hibernate的缓存?</h3><h4 id="一、why（为什么要用Hibernate缓存？）"><a href="#一、why（为什么要用Hibernate缓存？）" class="headerlink" title="一、why（为什么要用Hibernate缓存？）"></a>一、why（为什么要用Hibernate缓存？）</h4><p>Hibernate是一个持久层框架，经常访问物理数据库。 </p><p><strong>为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能。</strong></p><p>缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。 </p><p><strong>为了提供访问速度，把磁盘或数据库访问变成内存访问。</strong></p><h4 id="二、what（Hibernate缓存原理是怎样的？）"><a href="#二、what（Hibernate缓存原理是怎样的？）" class="headerlink" title="二、what（Hibernate缓存原理是怎样的？）"></a>二、what（Hibernate缓存原理是怎样的？）</h4><p>Hibernate缓存包括两大类：Hibernate<strong>一级缓存</strong>和Hibernate<strong>二级缓存</strong>。</p><p>1.Hibernate一级缓存又称为“<strong>Session的缓存</strong>”。 </p><p>Session缓存内置不能被卸载，Session的缓存是事务范围的缓存（Session对象的生命周期通常对应一个数据库事务或者一个应用事务）。 </p><p>一级缓存中，持久化类的每个实例都具有唯一的OID。</p><p>2.Hibernate二级缓存又称为“<strong>SessionFactory的缓存</strong>”。 </p><p>由于SessionFactory对象的生命周期和应用程序的整个过程对应，因此Hibernate二级缓存是进程范围或者集群范围的缓存，<strong>有可能出现并发问题</strong>，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。</p><p><strong>第二级缓存是可选的，是一个可配置的插件，默认下SessionFactory不会启用这个插件</strong>。</p><p>Hibernate提供了org.hibernate.cache.CacheProvider接口,它充当缓存插件与Hibernate之间的适配器。</p><h4 id="面试：-2"><a href="#面试：-2" class="headerlink" title="面试："></a>面试：</h4><p>   Hibernate中的缓存分一级缓存和二级缓存。</p><p>   一级缓存就是Session级别的缓存，在事务范围内有效是,内置的不能被卸载。二级缓存是SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。</p><p>​    保存数据库后，在内存中保存一份，如果更新了数据库就要同步更新。</p><p> <strong>什么样的数据适合存放到第二级缓存中？</strong> 　　</p><p>1) 很少被修改的数据 　帖子的最后回复时间　</p><p>2) 经常被查询的数据   电商的地点</p><p>3) 不是很重要的数据，允许出现偶尔并发的数据 　　</p><p>4) 不会被并发访问的数据 　　</p><p>5) 常量数据 </p><p>扩展：hibernate的二级缓存默认是不支持分布式缓存的。使用memcahe,redis等中央缓存来代替二级缓存。</p><h3 id="12-简单讲一下webservice使用的场景？"><a href="#12-简单讲一下webservice使用的场景？" class="headerlink" title="12.简单讲一下webservice使用的场景？"></a>12.简单讲一下webservice使用的场景？</h3><p>webservice是一个SOA（<strong>面向服务的编程</strong>）的架构，它是<strong>不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用</strong>，通过Internet进行<strong>基于Http协议的网络应用间的交互</strong>。</p><p>1、<strong>异构系统(不同语言)的整合</strong></p><p>2、<strong>不同客户端的整合</strong>  浏览器、手机端(android,ios.塞班)、微信单、PC端等终端来访问</p><p><img data-src="10.png" alt="10.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588519415640.png" alt="1588519415640"></p><p>3、实实在在的列子：</p><p>​       <strong>天气预报</strong>：可以通过实现webservice客户端调用远程天气服务实现的。</p><p>​       <strong>单点登录</strong>：一个服务是所有系统的登录</p><h2 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a>高级部分</h2><h3 id="1-有没有用过linux-你都用它来做什么？"><a href="#1-有没有用过linux-你都用它来做什么？" class="headerlink" title="1.有没有用过linux?你都用它来做什么？"></a>1.有没有用过linux?你都用它来做什么？</h3><p>Linux是一个<strong>长时间运行比较稳定</strong>的操作系统，所有我们<strong>一般会拿它作为服务器</strong>(web,db,app等)。</p><p>Linux本身具有C的编译环境、我们的一些软件是没有软件包(redis、nginx等)的，需要在Linux的C编译环境编译得到软件包.</p><h3 id="2-说一下linux下面的一下常用命令？"><a href="#2-说一下linux下面的一下常用命令？" class="headerlink" title="2.说一下linux下面的一下常用命令？"></a>2.说一下linux下面的一下常用命令？</h3><p>常用：</p><ul><li>Pwd 获取当前路径</li><li>Cd 跳转到目录</li><li>Su -u 切换到管理员</li><li>Ls ls 列举目录</li></ul><p>文件操作命令：</p><ul><li>文件<ul><li>tail 查看</li><li>rm -rf  删除</li><li>vi  修改</li></ul></li><li>文件夹<ul><li>mkdir  创建</li><li>rm -r 删除</li></ul></li></ul><h3 id="3-你是使用什么来连接远程的Linux服务器的？"><a href="#3-你是使用什么来连接远程的Linux服务器的？" class="headerlink" title="3.你是使用什么来连接远程的Linux服务器的？"></a>3.你是使用什么来连接远程的Linux服务器的？</h3><p>需要依赖于Linux服务器安装ssh服务端，一般这个ssh服务的端口22.</p><p>需要依赖于Linux服务器安装sftp服务端，一般这个sftp服务的端口25.</p><p><strong>使用ssh客户端连接linux服务器</strong>，就有点儿像windows下面的远程连接。但是linux通过ssh连接上以后是没有图形界面，全是命令行。</p><p>Putty</p><p><strong>Xshell</strong></p><p><strong>使用sftp客户端来连接sftp服务端</strong>，来上传和下载文件.(上传安装包，修改了配置文件上传。)</p><p>Winscp</p><p><strong>xftp</strong></p><p>企业中常用的两种组合:</p><p>​     putty+winscp </p><p>​     Xshell+xftp=xmanager</p><p><img data-src="file:///C:/Users/zhy/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><h4 id="面试：-3"><a href="#面试：-3" class="headerlink" title="面试："></a>面试：</h4><p><strong>使用xshell、putty等ssh客户端来连接服务器，使用xftp、winscp等sftp客户端来上传和下载文件。连接和上传、下载必须依赖于服务器的ssh、sftp服务，也就是linux服务器需要启动这两个服务。</strong></p><h3 id="4-有没有使用过云主机？"><a href="#4-有没有使用过云主机？" class="headerlink" title="4.有没有使用过云主机？"></a>4.有没有使用过云主机？</h3><p>使用过，在原来的公司，我们没有使用自己的服务器，而是租用阿里的云主机。</p><p>没有使用过，但是有所了解。 </p><p>云主机就是一些云服务运营商(阿里、华为、西部数码、新浪等)，提供的远程的服务器功能，我们开发者或者企业只需按需付费就可以租用对应的服务器。 </p><p>使用ssh和sftp来进行操作。</p><h3 id="5-有没有做过数据库优化方面的事情"><a href="#5-有没有做过数据库优化方面的事情" class="headerlink" title="5.有没有做过数据库优化方面的事情?"></a>5.有没有做过数据库优化方面的事情?</h3><p> 做过mysql数据库的优化、其他数据库类似</p><p>定位：查找、定位慢查询</p><h4 id="优化手段："><a href="#优化手段：" class="headerlink" title="优化手段："></a>优化手段：</h4><p>a)       <strong>创建索引</strong>:创建合适的索引，我们就可以现在索引中查询，查询到以后直接找对应的记录。</p><p>b)       <strong>分表</strong>：当一张表的数据比较多或者一张表的某些字段的值比较多并且很少使用时，采用<strong>水平分表和垂直分表</strong>来优化</p><p>c)        <strong>读写分离</strong>：当一台服务器不能满足需求时，采用读写分离的方式进行集群。</p><p>d)       <strong>缓存</strong>:使用redis来进行缓存</p><p>e)       一些常用优化技巧</p><h3 id="6-数据库优化之遵循范式？"><a href="#6-数据库优化之遵循范式？" class="headerlink" title="6.数据库优化之遵循范式？"></a>6.数据库优化之遵循范式？</h3><p> <strong>数据库表设计时需要遵循方式</strong></p><p> 表的范式，是<strong>首先符合1NF, 才能满足2NF , 进一步满足3NF</strong></p><p><strong>1NF: 即表的列的具有原子性,不可再分解</strong>，即列的信息，不能分解.只要数据库是关系型数据库(mysql/oracle/db2/sysbase/sql server)，就自动的满足1NF.关系型数据库中是不允许分割列的。</p><p><strong>2NF:表中的记录是唯一的</strong>.通常我们设计一个主键来实现</p><p><strong>3NF:即表中不要有冗余数据</strong>, 就是说，<strong>表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放</strong>.(外键)</p><p>反3NF :<strong>没有冗余的数据库未必是最好的数据库</strong>，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余<strong>。</strong> 订单和订单项、相册浏览次数和照片的浏览次数</p><h3 id="7-选择合适的存储引擎"><a href="#7-选择合适的存储引擎" class="headerlink" title="7.选择合适的存储引擎"></a>7.选择合适的存储引擎</h3><p>在开发中，我们经常使用的存储引擎 <strong>myisam / innodb/ memory</strong></p><p><strong>MyISAM存储引擎</strong></p><p>如果表<strong>对事务要求不高，同时是以查询和添加为主的</strong>，我们考虑使用myisam存储引擎. 比如 bbs 中的 <strong>发帖表，回复表</strong>.</p><p><strong>INNODB存储引擎:</strong> </p><p><strong>对事务要求高，保存的数据都是重要数据</strong>，我们建议使用INNODB,比如<strong>订单表，账号表</strong>.</p><p><strong>Memory 存储</strong></p><p>我们<strong>数据变化频繁，不需要入库，同时又频繁的查询和修改</strong>，我们考虑使用memory, 速度极快.</p><h4 id="问-MyISAM-和-INNODB的区别-主要"><a href="#问-MyISAM-和-INNODB的区别-主要" class="headerlink" title="问 MyISAM 和 INNODB的区别(主要)"></a><strong>问 MyISAM 和 INNODB的区别(主要)</strong></h4><ol><li><p>事务安全 myisam不支持事务而innodb支持</p></li><li><p>查询和添加速度 myisam不用支持事务就不用考虑同步锁，查找和添加和添加的速度快</p></li><li><p>支持全文索引 myisam支持innodb不支持</p></li><li><p>锁机制 myisam支持表锁而innodb支持行锁(事务)</p></li><li><p>外键 MyISAM 不支持外键， INNODB支持外键. (通常不设置外键，通常是在程序中保证数据的一致)</p></li></ol><p><img data-src="11.png" alt="11.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588522546110.png" alt="1588522546110"></p><h3 id="8-数据库优化之创建合适的索引"><a href="#8-数据库优化之创建合适的索引" class="headerlink" title="8.数据库优化之创建合适的索引?"></a>8.数据库优化之创建合适的索引?</h3><p><strong>索引（Index）是帮助DBMS高效获取数据的数据结构。</strong></p><p>分类：普通索引/唯一索引/主键索引/全文索引</p><ul><li>普通索引:<strong>允许重复的值出现</strong></li><li>唯一索引:除了<strong>不能有重复的记录</strong>外，其它和普通索引一样(用户名、用户身份证、email,tel)</li><li>主键索引：是随着设定主键而创建的，也就是把某个列设为主键的时候，数据库就会給改列创建索引。这就是主键索引.<strong>唯一且没有null值</strong></li><li>全文索引:<strong>用来对表中的文本域(char，varchar，text)进行索引</strong>， 全文索引针对MyIsam</li></ul><p>explain select * from articles where match(title,body) against(‘database’);【会使用全文索引】</p><h3 id="9-索引使用小技巧？"><a href="#9-索引使用小技巧？" class="headerlink" title="9.索引使用小技巧？"></a>9.索引使用小技巧？</h3><h4 id="索引弊端"><a href="#索引弊端" class="headerlink" title="索引弊端"></a><strong>索引弊端</strong></h4><p>1.占用磁盘空间。</p><p>2.对dml(插入、修改、删除)操作有影响，变慢。</p><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a><strong>使用场景：</strong></h4><p>a: 肯定在where条件经常使用,如果不做查询就没有意义</p><p>b: 该字段的内容不是唯一的几个值(sex) </p><p>c: 字段内容不是频繁变化.</p><h4 id="具体技巧："><a href="#具体技巧：" class="headerlink" title="具体技巧："></a><strong>具体技巧：</strong></h4><ol><li><strong>对于创建的多列索引（复合索引），不是使用的第一部分就不会使用索引。</strong></li></ol><p>alter table dept add index my_ind (dname,loc); // dname 左边的列,loc就是右边的列</p><p>explain select * from dept where dname=’aaa’\G 会使用到索引</p><p>explain select * from dept where loc=’aaa’\G 就不会使用到索引</p><ol start="2"><li><p><strong>对于使用like的查询，查询如果是’%aaa’不会使用到索引而‘aaa%’会使用到索引。</strong></p><p>explain select * from dept where dname like ‘%aaa’\G不能使用索引</p><p>explain select * from dept where dname like ‘aaa%’\G使用索引.</p></li></ol><p>所以在like查询时，‘关键字’的最前面不能使用 % 或者 _这样的字符.，如果一定要前面有变化的值，则考虑使用 全文索引-&gt;sphinx.</p><ol start="3"><li>如果条件中有or，<strong>有条件没有使用索引,即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段,都必须单独使用时能使用索引.</strong></li></ol><p>​    </p><ol start="4"><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。</li></ol><p>expain select * from dept where dname=’111’;</p><p>expain select * from dept where dname=111;（数值自动转字符串）</p><p>expain select * from dept where dname=qqq;报错</p><p>也就是，如果列是字符串类型，无论是不是字符串数字就一定要用 ‘’ 把它包括起来.</p><ol start="5"><li><p>如果mysql估计使用全表扫描要比使用索引快，则不使用索引。</p><p>表里面只有一条记录</p></li></ol><h3 id="10-数据库优化之分表？"><a href="#10-数据库优化之分表？" class="headerlink" title="10.数据库优化之分表？"></a>10.数据库优化之分表？</h3><p>分表分为<strong>水平(按行)分表和垂直(按列)分表</strong></p><p>根据经验，Mysql表数据一般达到<strong>百万级别，查询效率会很低，容易造成表锁，甚至堆积很多连接，直接挂掉；水平分表能够很大程度较少这些压力。</strong></p><p>按行数据进行分表。</p><p><strong>如果一张表中某个字段值非常多(长文本、二进制等)，而且只有在很少的情况下会查询。这时候就可以把字段多个单独放到一个表，通过外键关联起来。</strong></p><p>​     考试详情，一般我们只关注分数，不关注详情。</p><h4 id="水平分表策略："><a href="#水平分表策略：" class="headerlink" title="水平分表策略："></a>水平分表策略：</h4><h5 id="1-按时间分表"><a href="#1-按时间分表" class="headerlink" title="1.按时间分表"></a>1.按时间分表</h5><p>这种分表方式有一定的局限性，当数据有较强的实效性，如<strong>微博发送记录、微信消息记录</strong>等，<strong>这种数据很少有用户会查询几个月前的数据</strong>，如就<strong>可以按月分表</strong>。</p><h5 id="2-按区间范围分表"><a href="#2-按区间范围分表" class="headerlink" title="2.按区间范围分表"></a>2.按区间范围分表</h5><p><strong>一般在有严格的自增id需求上，如按照user_id水平分表：</strong></p><p>table_1  user_id从1~100w </p><p>table_2  user_id从101~200w </p><p>table_3  user_id从201~300w </p><h5 id="3-hash分表"><a href="#3-hash分表" class="headerlink" title="3.hash分表"></a>3.hash分表</h5><p>通过一个原始目标的ID或者名称通过一定的hash算法计算出数据存储表的表名，然后访问相应的表。</p><h3 id="11-数据库优化之读写分离"><a href="#11-数据库优化之读写分离" class="headerlink" title="11.数据库优化之读写分离"></a>11.数据库优化之读写分离</h3><p>一台数据库支持的最大并发连接数是有限的，如果用户并发访问太多。一台服务器满足不了要求时就可以集群处理。Mysql的集群处理技术最常用的就是读写分离。 </p><p><img data-src="12.png" alt="12.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588523931634.png" alt="1588523931634"></p><p><strong>主从同步</strong></p><p>数据库最终会把数据持久化到磁盘，如果集群必须确保每个数据库服务器的数据是一直的。<strong>能改变数据库数据的操作都往主数据库去写</strong>，<strong>而其他的数据库从主数据库上同步数据。</strong></p><p><strong>读写分离</strong></p><p>   使用负载均衡来实现写的操作都往主数据库去，而读的操作往从服务器去。</p><h3 id="12-数据库优化之缓存"><a href="#12-数据库优化之缓存" class="headerlink" title="12.数据库优化之缓存"></a>12.数据库优化之缓存</h3><p>在<strong>持久层(dao)和数据库(db)</strong>之间添加一个<strong>缓存层</strong>，如果用户访问的数据已经缓存起来时，在用户访问时直接从缓存中获取，不用访问数据库。而<strong>缓存是在操作内存级</strong>，访问速度快。</p><p>作用：减少数据库服务器压力，减少访问时间。</p><p>Java中常用的缓存有，</p><p>   1、hibernate的二级缓存。该缓存不能完成分布式缓存。</p><p><img data-src="13.png" alt="13.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588553532967.png" alt="1588553532967"></p><p>2、可以使用redis(memcahe等)来作为中央缓存。</p><p>​        对缓存的数据进行集中处理</p><h3 id="13-语句优化小技巧"><a href="#13-语句优化小技巧" class="headerlink" title="13.语句优化小技巧"></a>13.语句优化小技巧</h3><h4 id="DDL优化"><a href="#DDL优化" class="headerlink" title="DDL优化:"></a>DDL优化:</h4><p>1 、通过禁用索引来提供导入数据性能 。 这个操作主要针对有数据库的表，追加数据</p><p>//去除键</p><p>alter table test3 DISABLE keys;</p><p>//批量插入数据</p><p>insert into test3 select * from test;</p><p>//恢复键</p><p>alter table test3 ENABLE keys;</p><p>2、 关闭唯一校验</p><p>set unique_checks=0  关闭</p><p>set unique_checks=1  开启</p><p>3、修改事务提交方式(导入)（变多次提交为一次）</p><p>set autocommit=0   关闭</p><p>//批量插入</p><p>set autocommit=1   开启</p><h4 id="DML优化（变多次提交为一次）"><a href="#DML优化（变多次提交为一次）" class="headerlink" title="DML优化（变多次提交为一次）"></a>DML优化（变多次提交为一次）</h4><p>insert into test values(1,2);</p><p>insert into test values(1,3);</p><p>insert into test values(1,4);</p><p>//合并多条为一条</p><p>insert into test values(1,2),(1,3),(1,4)</p><h4 id="DQL优化"><a href="#DQL优化" class="headerlink" title="DQL优化"></a>DQL优化</h4><h5 id="Order-by优化"><a href="#Order-by优化" class="headerlink" title="Order by优化"></a>Order by优化</h5><p>​                1、多用索引排序</p><p>2、普通结果排序（非索引排序）Filesort</p><h5 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h5><p>​      是使用order by null,取消默认排序</p><h5 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h5><p>在客户列表找到不在支付列表的客户</p><p>#在客户列表找到不在“支付列表”的客户 , 查询没买过东西的客户</p><p>explain</p><p>select * from customer where customer_id not in (select DISTINCT customer_id from payment); #子查询      – 这种是基于func外链</p><p>explain </p><p>select * from customer c left join payment p on(c.customer_id=p.customer_id) where p.customer_id is null   – 这种是基于“索引”外链</p><h5 id="Or优化"><a href="#Or优化" class="headerlink" title="Or优化"></a>Or优化</h5><p>在两个独立索引上使用or的性能优于 </p><p>1、 or两边都是用索引字段做判断，性能好！！</p><p>2、 or两边，有一边不用，性能差</p><p>3、 如果employee表的name和email这两列是一个复合索引，但是如果是 :name=’A’ OR email=’B’ 这种方式，不会用到索引！</p><h5 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h5><p>select film_id,description from film order by title limit 50,5;</p><p>select a.film_id,a.description from film a inner join (select film_id from film order by title limit 50,5)b on a.film_id=b.film_id</p><h3 id="14-jdbc批量插入几百万数据怎么实现？-重要"><a href="#14-jdbc批量插入几百万数据怎么实现？-重要" class="headerlink" title="14.jdbc批量插入几百万数据怎么实现？(重要)"></a>14.jdbc批量插入几百万数据怎么实现？(重要)</h3><p>1、变多次提交为一次</p><p>2、使用批量操作</p><p><img data-src="14.png" alt="14.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588554137522.png" alt="1588554137522"></p><p>省出的时间可观。</p><p>像这样的批量插入操作能不使用代码操作就不使用，可以使用存储过程来实现</p><h3 id="15-有没有使用过redis-Redis是什么"><a href="#15-有没有使用过redis-Redis是什么" class="headerlink" title="15.有没有使用过redis? Redis是什么"></a>15.有没有使用过redis? Redis是什么</h3><p>Redis是一个<strong>key-value</strong>的<strong>nosql数据库</strong>.先存到内存中，会根据一定的策略持久化到磁盘,<strong>即使断电也不会丢失数据</strong>。支持的数据类型比较多。</p><p>主要用来<strong>做缓存数据库的数据和web集群时当做中央缓存存放seesion</strong></p><h3 id="16-简单说一下redis的使用场景？"><a href="#16-简单说一下redis的使用场景？" class="headerlink" title="16.简单说一下redis的使用场景？"></a>16.简单说一下redis的使用场景？</h3><h4 id="缓存："><a href="#缓存：" class="headerlink" title="缓存："></a><strong>缓存：</strong></h4><p>把<strong>经常需要查询的、很少修改的数据</strong>，放到读速度很快的空间(内存)，以便下次访问减少时间。减轻压力，减少访问时间.</p><h4 id="计数器："><a href="#计数器：" class="headerlink" title="计数器："></a><strong>计数器：</strong></h4><p>​     redis中的<strong>计数器是原子性的内存操作</strong>。                            </p><p>​       可以<strong>解决库存溢出问题</strong>.进销存系统库存溢出。                  </p><h4 id="session缓存服务器："><a href="#session缓存服务器：" class="headerlink" title="session缓存服务器："></a><strong>session缓存服务器：</strong></h4><p>web集群时作为session缓存服务器</p><p><img data-src="15.png" alt="15.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588554427301.png" alt="1588554427301"></p><h3 id="17-redis对象保存方式？"><a href="#17-redis对象保存方式？" class="headerlink" title="17. redis对象保存方式？"></a>17. redis对象保存方式？</h3><p><strong>Json字符串:</strong></p><p>需要把对象转换为json字符串，当做字符串处理。直接使用set和get来设置或者获取。</p><p>优点：设置和获取比较简单</p><p>缺点：没有提供专门的方法，需要把把对象转换为json。(jsonlib)</p><p><strong>字节:</strong></p><p>   需要做序列号，就是把对象序列化为字节保存。</p><p>如果是担心JSON转对象会消耗资源的情况，这个问题需要考量几个地方，</p><p>第一点：就是使用的JSON转换lib是否就会存在性能问题。</p><p>第二点：就是数据的数据量级别，<strong>如果是存储百万级的大数据对象，建议采用存储序列化对象方式。如果是少量的数据级对象，或者是数据对象字段不多，还是建议采用JSON转换成String方式</strong>。</p><p>毕竟redis对存储字符类型这部分优化的非常好。具体采用的方式与方法，还要看你所使用的场景。 </p><h3 id="18-Java访问Redis"><a href="#18-Java访问Redis" class="headerlink" title="18.Java访问Redis"></a>18.Java访问Redis</h3><p>1、使用jedis java客户端来访问redis服务器，有点类似通过jdbc访问mysql一样。</p><p>2、当然如果是spring进行集成时，可以使用spring data来访问redis,spring data只是对jedis的二次封装。jdbcTemplate jdbc关系一样。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL存储引擎介绍</title>
      <link href="/2020/04/26/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/04/26/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>MySQL5.5以后默认使用<strong>InnoDB</strong>存储引擎，其中<strong>InnoDB和BDB提供事务安全表</strong>，其它存储引擎都是非事务安全表。<br>若要<strong>修改默认引擎</strong>，可以修改配置文件中的default-storage-engine。</p><p>可以通过：show variables like ‘default_storage_engine’;查看当前数据库到默认引擎。</p><p>命令：<em>show engines</em>和<em>show variables like ‘have%’</em>可 以列出当前数据库所支持到引擎。</p><p>其中Value显示为disabled的记录表示数据库支持此引擎，而在数据库启动时被禁用。</p><p>在MySQL5.1以 后，INFORMATION_SCHEMA数据库中存在一个ENGINES的表，它提供的信息与show engines;语句完全一样，可以使用下面语句来查询哪些存储引擎支持事物处理：</p><p>select engine from information_chema.engines where transactions = ‘yes’;<br>可以通过engine关键字在创建或修改数据库时指定所使用到引擎。</p><h2 id="主要存储引擎：MyISAM、InnoDB、MEMORY和MERGE介绍："><a href="#主要存储引擎：MyISAM、InnoDB、MEMORY和MERGE介绍：" class="headerlink" title="主要存储引擎：MyISAM、InnoDB、MEMORY和MERGE介绍："></a>主要存储引擎：MyISAM、InnoDB、MEMORY和MERGE介绍：</h2><p>在创建表到时候通过<em>engine=…</em>或<em>type=…</em>来指定所要使用到引擎。<em>show table status from DBname</em>来查看指定表到引擎。</p><p><strong>(一)MyISAM</strong>　　它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。<br>每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但是扩展名分别为：</p><ul><li>.frm(存储表定义)</li><li>MYD(MYData，存储数据)</li><li>MYI(MYIndex，存储索引)</li></ul><p>　　数据文件和索引文件可以放置在不同的目录，平均分配IO，获取更快的速度。要指定数据文件和索引文件的路径，需要在创建表的时候通过DATA DIRECTORY和INDEX DIRECTORY语句指定，文件路径需要使用绝对路径。<br>　 　每个MyISAM表都有一个标志，服务器或myisamchk程序在检查MyISAM数据表时会对这个标志进行设置。MyISAM表还有一个标志用来表 明该数据表在上次使用后是不是被正常的关闭了。如果服务器以为当机或崩溃，这个标志可以用来判断数据表是否需要检查和修复。如果想让这种检查自动进行，可 以在启动服务器时使用–myisam-recover现象。这会让服务器在每次打开一个MyISAM数据表是自动检查数据表的标志并进行必要的修复处 理。MyISAM类型的表可能会损坏，可以使用CHECK TABLE语句来检查MyISAM表的健康，并用REPAIR TABLE语句修复一个损坏到MyISAM表。<br>　　MyISAM的表还支持3种不同的存储格式：</p><ul><li>静态(固定长度)表</li><li>动态表</li><li>压缩表</li></ul><p>　　其中静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现 故障容易恢复；缺点是占用的空间通常比动态表多。静态表在数据存储时会根据列定义的宽度定义补足空格，但是在访问的时候并不会得到这些空格，这些空格在返 回给应用之前已经去掉。同时需要注意：在某些情况下可能需要返回字段后的空格，而使用这种格式时后面到空格会被自动处理掉。<br>　　动态表包含变长字段，记录不是固定长度的，这样存储的优点是占用空间较少，但是频繁到更新删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk -r命令来改善性能，并且出现故障的时候恢复相对比较困难。<br>　　压缩表由myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。<br><strong>(二)InnoDB</strong>　　</p><p>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。<br><em>1)自动增长列：</em>　　</p><p>​        InnoDB 表的自动增长列可以手工插入，但是插入的如果是空或0，则实际插入到则是自动增长后到值。可以通过”ALTER TABLE…AUTO_INCREMENT=n;”语句强制设置自动增长值的起始值，默认为1，但是该强制到默认值是保存在内存中，数据库重启后该值 将会丢失。可以使用LAST_INSERT_ID()查询当前线程最后插入记录使用的值。如果一次插入多条记录，那么返回的是第一条记录使用的自动增长 值。<br>对于InnoDB表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于MyISAM表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引到前面几列排序后递增的。<br><em>2)外键约束：</em>　　</p><p>​        MySQL支持外键的存储引擎只有InnoDB，在创建外键的时候，父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。<br>​      在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括restrict、cascade、set null和no action。其中restrict和no action相同，是指限制在子表有关联的情况下，父表不能更新；casecade表示父表在更新或删除时，更新或者删除子表对应的记录；set null 则表示父表在更新或者删除的时候，子表对应的字段被set null。<br>　　当某个表被其它表创建了外键参照，那么该表对应的索引或主键被禁止删除。<br>　　可以使用set foreign_key_checks=0;临时关闭外键约束，set foreign_key_checks=1;打开约束。<br><strong>(三)MEMORY</strong>　　memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm。MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。<br>​      默认情况下，memory数据表使用散列索引，利用这种索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了。因此，散列索引值适合使用 在”=”和”&lt;=&gt;”的操作符中，不适合使用在”&lt;”或”&gt;”操作符中，也同样不适合用在order by字句里。如果确实要使用”&lt;”或”&gt;”或betwen操作符，可以使用btree索引来加快速度。<br>　　存储在MEMORY数据表里的数据行使用的是长度不变的格式，因此加快处理速度，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型。VARCHAR是一种长度可变的类型，但因为它在MySQL内部当作长度固定不变的CHAR类型，所以可以使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_memory <span class="keyword">engine</span>=<span class="keyword">memory</span> <span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age,addr <span class="keyword">from</span> man <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><p>使用USING HASH/BTREE来指定特定到索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> mem_hash <span class="keyword">using</span> <span class="keyword">hash</span> <span class="keyword">on</span> tab_memory(city_id);</span><br></pre></td></tr></table></figure><p>在启动MySQL服务的时候使用–init-file选项，把insert into…select或load data infile 这样的语句放入到这个文件中，就可以在服务启动时从持久稳固的数据源中装载表。<br>　　服务器需要足够的内存来维持所在的在同一时间使用的MEMORY表，当不再使用MEMORY表时，要释放MEMORY表所占用的内存，应该执行DELETE FROM或truncate table或者删除整个表。<br>　　每个MEMORY表中放置到数据量的大小，受到max_heap_table_size系统变量的约束，这个系统变量的初始值是16M，同时在创建MEMORY表时可以使用MAX_ROWS子句来指定表中的最大行数。</p><p><strong>(四)MERGE</strong>　　merge 存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，MERGE表中并没有数据，对MERGE类型的表可以进行查询、更新、删除的 操作，这些操作实际上是对内部的MyISAM表进行操作。对于对MERGE表进行的插入操作，是根据INSERT_METHOD子句定义的插入的表，可以 有3个不同的值，first和last值使得插入操作被相应的作用在第一个或最后一个表上，不定义这个子句或者为NO，表示不能对这个MERGE表进行插 入操作。可以对MERGE表进行drop操作，这个操作只是删除MERGE表的定义，对内部的表没有任何影响。MERGE在磁盘上保留2个以MERGE表 名开头文件：.frm文件存储表的定义；.MRG文件包含组合表的信息，包括MERGE表由哪些表组成，插入数据时的依据。可以通过修改.MRG文件来修 改MERGE表，但是修改后要通过flush table刷新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> man_all(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>))<span class="keyword">engine</span>=<span class="keyword">merge</span> <span class="keyword">union</span>=(man1,man2) insert_methos=<span class="keyword">last</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-平衡二叉树</title>
      <link href="/2020/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="平衡二叉树-AVL-树"><a href="#平衡二叉树-AVL-树" class="headerlink" title="平衡二叉树(AVL 树)"></a>平衡二叉树(AVL 树)</h2><h3 id="二叉排序树可能的问题"><a href="#二叉排序树可能的问题" class="headerlink" title="二叉排序树可能的问题"></a>二叉排序树可能的问题</h3><p>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.</p><p>左边 BST 存在的问题分析:</p><p>1) 左子树全部为空，从形式上看，更像一个单链表.<br>2) 插入速度没有影响<br>3) 查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比<br>单链表还慢</p><p>4) 解决方案-平衡二叉树(AVL)</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1) 平衡二叉树也叫平衡 <strong>二叉搜索树</strong>（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。<br>2) 具有以下特点：它是 <strong>一棵空树</strong>或 <strong>它的左右两个子树的高度差的绝对值不超过 1</strong>，并且 <strong>左右两个子树都是一棵</strong><br><strong>平衡二叉树</strong>。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。<br>3) 举例说明, 看看下面哪些 AVL 树, 为什么?</p><p><img data-src="1.png" alt="1.png"></p><h3 id="应用案例-单旋转-左旋转"><a href="#应用案例-单旋转-左旋转" class="headerlink" title="应用案例-单旋转(左旋转)"></a>应用案例-单旋转(左旋转)</h3><p>1) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8}</p><p>2) 思路分析(示意图)</p><p><img data-src="2.png" alt="2.png"></p><p><strong>左旋转的目的就是降低右子树的高度</strong></p><p>3) 代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建新的结点，以当前根结点的值</span></span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line"><span class="comment">// 把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line"><span class="comment">// 把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">newNode.right = <span class="keyword">this</span>.right.left;</span><br><span class="line"><span class="comment">// 把当前结点的值替换成右子结点的值</span></span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.right.value;</span><br><span class="line"><span class="comment">// 把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line"><span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line"><span class="comment">// 把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line"><span class="keyword">this</span>.left = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用案例-单旋转-右旋转"><a href="#应用案例-单旋转-右旋转" class="headerlink" title="应用案例-单旋转(右旋转)"></a>应用案例-单旋转(右旋转)</h3><p>1) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}<br>2) 思路分析(示意图)</p><p><img data-src="3.png" alt="3.png"></p><p>3) 代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line"><span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line"><span class="keyword">this</span>.right = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改add方法"><a href="#修改add方法" class="headerlink" title="修改add方法"></a>修改add方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line"><span class="keyword">if</span> (rightHeight()-leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">leftRotate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line"><span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">rightRotate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用案例-双旋转"><a href="#应用案例-双旋转" class="headerlink" title="应用案例-双旋转"></a>应用案例-双旋转</h3><p>前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转<br>不能完成平衡二叉树的转换。比如数列<br>int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树.<br>int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成 AVL 树</p><p>1) 问题分析</p><p><img data-src="4.png" alt="4.png"></p><p>2) 解决思路分析</p><ol><li><p>当符合右旋转的条件时</p></li><li><p>如果它的<strong>左子树的右子树高度大于它的左子树的左子树</strong>的高度（2 &gt; 1）</p></li><li><p>先对当前这个结点的左节点进行左旋转</p></li><li><p>在对当前结点进行右旋转的操作即可</p></li></ol><p><img data-src="5.png" alt="5.png"></p><p>左旋后</p><p><img data-src="6.png" alt="6.png"></p><p>所以原树变为</p><p><img data-src="7.png" alt="7.png"></p><p>在进行右旋，变为</p><p><img data-src="8.png" alt="8.png"></p><p>3) 代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line"><span class="keyword">if</span> (rightHeight()-leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.leftHeight() &gt; <span class="keyword">this</span>.right.rightHeight()) &#123;</span><br><span class="line"><span class="comment">//先对右子结点进行右旋转</span></span><br><span class="line"><span class="keyword">this</span>.right.rightRotate();</span><br><span class="line"><span class="comment">//然后在对当前结点进行左旋转</span></span><br><span class="line"><span class="keyword">this</span>.leftRotate();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//直接进行左旋转即可</span></span><br><span class="line">leftRotate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//处理完一个不能继续往下走</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line"><span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.rightHeight()&gt;<span class="keyword">this</span>.left.leftHeight())&#123;</span><br><span class="line"><span class="comment">//先对当前结点的左结点(左子树)-&gt;左旋转</span></span><br><span class="line"><span class="keyword">this</span>.left.leftRotate();</span><br><span class="line"><span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">rightRotate();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//直接进行右旋转即可</span></span><br><span class="line">rightRotate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AVL树全部代码"><a href="#AVL树全部代码" class="headerlink" title="AVL树全部代码"></a>AVL树全部代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int[] arr = &#123;4,3,6,5,7,8&#125;;</span></span><br><span class="line"><span class="comment">//int[] arr = &#123; 10, 12, 8, 9, 7, 6 &#125;;</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;  </span><br><span class="line"><span class="comment">//创建一个 AVLTree对象</span></span><br><span class="line">AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line"><span class="comment">// 添加结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">avlTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"中序遍历"</span>);</span><br><span class="line">avlTree.infixOrder();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"在没有平衡处理前~~"</span>);</span><br><span class="line">System.out.println(<span class="string">"树的高度="</span> + avlTree.getRoot().height()); <span class="comment">//3</span></span><br><span class="line">System.out.println(<span class="string">"树的左子树高度="</span> + avlTree.getRoot().leftHeight()); <span class="comment">// 2</span></span><br><span class="line">System.out.println(<span class="string">"树的右子树高度="</span> + avlTree.getRoot().rightHeight()); <span class="comment">// 2</span></span><br><span class="line">System.out.println(<span class="string">"当前的根结点="</span> + avlTree.getRoot());<span class="comment">//8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建AVLTree</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写方法: </span></span><br><span class="line"><span class="comment">//1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">//2. 删除node 为根结点的二叉排序树的最小结点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">Node target = node;</span><br><span class="line"><span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line"><span class="keyword">while</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">target = target.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时 target就指向了最小结点</span></span><br><span class="line"><span class="comment">// 删除最小结点</span></span><br><span class="line">delNode(target.value);</span><br><span class="line"><span class="keyword">return</span> target.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">Node targetNode = search(value);</span><br><span class="line"><span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点 targetNode == root</span></span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">Node parent = searchParent(value);</span><br><span class="line"><span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是右子结点</span></span><br><span class="line">parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line"><span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">targetNode.value = minVal;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//删除只有一颗子树的结点</span></span><br><span class="line"><span class="comment">//如果要删除的结点有左子结点 </span></span><br><span class="line"><span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.left;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.left;</span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要删除的结点有右子结点 </span></span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回 以该结点为根结点的树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.max(left == <span class="keyword">null</span> ? <span class="number">0</span> : left.height(), right == <span class="keyword">null</span> ? <span class="number">0</span> : right.height())+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回左子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回右子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> right.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 希望删除的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到则返回该节点，否则，返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;<span class="comment">//说明就是该节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="comment">//如果左子节点为空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果查找的值不小于（大于或等于）当前节点，向右子树递归查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找要删除节点的父节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要找的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的是要删除的节点的父节点 如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果当前节点就是要删除的结点的父节点，就返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value || </span><br><span class="line"><span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要查找的值小于当前结点的值，并且当前结点的左子结点不为空，</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有找到父节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line"><span class="keyword">if</span> (rightHeight()-leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.leftHeight() &gt; <span class="keyword">this</span>.right.rightHeight()) &#123;</span><br><span class="line"><span class="comment">//先对右子结点进行右旋转</span></span><br><span class="line"><span class="keyword">this</span>.right.rightRotate();</span><br><span class="line"><span class="comment">//然后在对当前结点进行左旋转</span></span><br><span class="line"><span class="keyword">this</span>.leftRotate();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//直接进行左旋转即可</span></span><br><span class="line">leftRotate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//处理完一个不能继续往下走</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line"><span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.rightHeight()&gt;<span class="keyword">this</span>.left.leftHeight())&#123;</span><br><span class="line"><span class="comment">//先对当前结点的左结点(左子树)-&gt;左旋转</span></span><br><span class="line"><span class="keyword">this</span>.left.leftRotate();</span><br><span class="line"><span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">rightRotate();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//直接进行右旋转即可</span></span><br><span class="line">rightRotate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左旋转方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建新的结点，以当前根结点的值</span></span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line"><span class="comment">// 把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line"><span class="comment">// 把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">newNode.right = <span class="keyword">this</span>.right.left;</span><br><span class="line"><span class="comment">// 把当前结点的值替换成右子结点的值</span></span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.right.value;</span><br><span class="line"><span class="comment">// 把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line"><span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line"><span class="comment">// 把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line"><span class="keyword">this</span>.left = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line"><span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line"><span class="keyword">this</span>.right = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-二叉排序树</title>
      <link href="/2020/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
      <url>/2020/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉排序树介绍"><a href="#二叉排序树介绍" class="headerlink" title="二叉排序树介绍"></a>二叉排序树介绍</h2><p><strong>二叉排序树：BST</strong>: (Binary Sort(Search) Tree), 对于二叉排序树的 <strong>任何一个非叶子节点</strong>，要求 <strong>左子节点的值比当</strong><br><strong>前节点的值小， 右子节点的值比当前节点的值大。</strong><br><strong>特别说明</strong>：如果有相同的值，可以将该节点放在左子节点或右子节点<br>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p><p><img data-src="1.png" alt="1.png"></p><h2 id="二叉排序树创建和遍历"><a href="#二叉排序树创建和遍历" class="headerlink" title="二叉排序树创建和遍历"></a>二叉排序树创建和遍历</h2><h3 id="1-先创建Node节点和中序遍历"><a href="#1-先创建Node节点和中序遍历" class="headerlink" title="1.先创建Node节点和中序遍历"></a>1.先创建Node节点和中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Node节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建二叉排序树和添加方法"><a href="#2-创建二叉排序树和添加方法" class="headerlink" title="2.创建二叉排序树和添加方法"></a>2.创建二叉排序树和添加方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h2><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑</p><p>1) 点 删除叶子节点 (比如：2, 5, 9, 12)<br>2) 删除点 只有一颗子树的节点 (比如：1)<br>3) 删除 有两颗子树的节点. (比如：7, 3，10 )<br>4) 操作的思路分析</p><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况:"></a>第一种情况:</h3><p>删除叶子节点 (比如：2, 5, 9, 12)</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>(1) 需求先去找到要删除的结点  targetNode</p><p>(2)  找到targetNode 的 父结点 parent </p><p>(3)  确定 targetNode 是 parent的左子结点 还是右子结点</p><p>(4)  根据前面的情况来对应删除</p><p>左子结点 parent.left = null</p><p>右子结点 parent.right = null;</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line"><span class="comment">//循环的添加结点到二叉排序树</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">System.out.println(<span class="string">"中序遍历二叉排序树~"</span>);</span><br><span class="line">binarySortTree.infixOrder();<span class="comment">// 1, 3, 5, 7, 9, 10, 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一下删除叶子结点   </span></span><br><span class="line">    binarySortTree.delNode(<span class="number">12</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"删除结点后"</span>);</span><br><span class="line">binarySortTree.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">Node targetNode = search(value);</span><br><span class="line"><span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点 targetNode == root</span></span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">Node parent = searchParent(value);</span><br><span class="line"><span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是右子结点</span></span><br><span class="line">parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 希望删除的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到则返回该节点，否则，返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;<span class="comment">//说明就是该节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="comment">//如果左子节点为空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果查找的值不小于（大于或等于）当前节点，向右子树递归查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找要删除节点的父节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要找的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的是要删除的节点的父节点 如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果当前节点就是要删除的结点的父节点，就返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value || </span><br><span class="line"><span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要查找的值小于当前结点的值，并且当前结点的左子结点不为空，</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有找到父节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种情况-删除只有一颗子树的节点-比如：1"><a href="#第二种情况-删除只有一颗子树的节点-比如：1" class="headerlink" title="第二种情况: 删除只有一颗子树的节点 (比如：1 )"></a>第二种情况: <strong>删除只有一颗子树的节点</strong> (比如：1 )</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>(1) 需求先去找到要删除的结点  targetNode</p><p>(2)  找到targetNode 的 父结点 parent </p><p>(3) 确定targetNode 的子结点是左子结点还是右子结点</p><p>(4) targetNode 是 parent 的左子结点还是右子结点</p><p>(5) 如果targetNode 有左子结点</p><p>5.1 如果 targetNode 是 parent 的左子结点</p><p>parent.left = targetNode.left;</p><p>5.2  如果 targetNode 是 parent 的右子结点</p><p>parent.right = targetNode.left;</p><p>(6) 如果targetNode 有右子结点</p><p>6.1 如果 targetNode 是 parent 的左子结点</p><p>parent.left = targetNode.right;</p><p>6.2 如果 targetNode 是 parent 的右子结点</p><p>parent.right = targetNode.right</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line"><span class="comment">//循环的添加结点到二叉排序树</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">System.out.println(<span class="string">"中序遍历二叉排序树~"</span>);</span><br><span class="line">binarySortTree.infixOrder();<span class="comment">// 1, 3, 5, 7, 9, 10, 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一下删除叶子结点   </span></span><br><span class="line">    binarySortTree.delNode(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"删除结点后"</span>);</span><br><span class="line">binarySortTree.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">Node targetNode = search(value);</span><br><span class="line"><span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点 targetNode == root</span></span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">Node parent = searchParent(value);</span><br><span class="line"><span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是右子结点</span></span><br><span class="line">parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//删除只有一颗子树的结点</span></span><br><span class="line"><span class="comment">//如果要删除的结点有左子结点 </span></span><br><span class="line"><span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.left;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.left;</span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要删除的结点有右子结点 </span></span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 希望删除的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到则返回该节点，否则，返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;<span class="comment">//说明就是该节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="comment">//如果左子节点为空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果查找的值不小于（大于或等于）当前节点，向右子树递归查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找要删除节点的父节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要找的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的是要删除的节点的父节点 如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果当前节点就是要删除的结点的父节点，就返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value || </span><br><span class="line"><span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要查找的值小于当前结点的值，并且当前结点的左子结点不为空，</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有找到父节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况三-：-删除有两颗子树的节点-比如：7-3，10"><a href="#情况三-：-删除有两颗子树的节点-比如：7-3，10" class="headerlink" title="情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 )"></a>情况三 ： 删除有两颗子树的节点. (比如：7, 3，<strong>10</strong> )</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>(1) 需求先去找到要删除的结点  targetNode</p><p>(2)  找到targetNode 的 父结点 parent </p><p>(3)  从targetNode 的<strong>右子树</strong>找到<strong>最小的结点</strong>(左子树则要最大值)</p><p>(4) 用一个临时变量，将 最小结点的值保存 temp </p><p>(5)  删除该最小结点</p><p>(6)  targetNode.value = temp</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line"><span class="comment">//循环的添加结点到二叉排序树</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">System.out.println(<span class="string">"中序遍历二叉排序树~"</span>);</span><br><span class="line">binarySortTree.infixOrder();<span class="comment">// 1, 3, 5, 7, 9, 10, 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一下删除叶子结点   </span></span><br><span class="line">    binarySortTree.delNode(<span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"删除结点后"</span>);</span><br><span class="line">binarySortTree.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写方法: </span></span><br><span class="line"><span class="comment">//1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">//2. 删除node 为根结点的二叉排序树的最小结点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">Node target = node;</span><br><span class="line"><span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line"><span class="keyword">while</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">target = target.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时 target就指向了最小结点</span></span><br><span class="line"><span class="comment">// 删除最小结点</span></span><br><span class="line">delNode(target.value);</span><br><span class="line"><span class="keyword">return</span> target.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">Node targetNode = search(value);</span><br><span class="line"><span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点 targetNode == root</span></span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">Node parent = searchParent(value);</span><br><span class="line"><span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是右子结点</span></span><br><span class="line">parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line"><span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">targetNode.value = minVal;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//删除只有一颗子树的结点</span></span><br><span class="line"><span class="comment">//如果要删除的结点有左子结点 </span></span><br><span class="line"><span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.left;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.left;</span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要删除的结点有右子结点 </span></span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 希望删除的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到则返回该节点，否则，返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;<span class="comment">//说明就是该节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="comment">//如果左子节点为空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果查找的值不小于（大于或等于）当前节点，向右子树递归查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找要删除节点的父节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要找的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的是要删除的节点的父节点 如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果当前节点就是要删除的结点的父节点，就返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value || </span><br><span class="line"><span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要查找的值小于当前结点的值，并且当前结点的左子结点不为空，</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有找到父节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商项目整理</title>
      <link href="/2020/04/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86/"/>
      <url>/2020/04/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-解决浮点型商业运算中丢失精度的问题"><a href="#1-解决浮点型商业运算中丢失精度的问题" class="headerlink" title="1.解决浮点型商业运算中丢失精度的问题"></a>1.解决浮点型商业运算中丢失精度的问题</h2><h3 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h3><p>我们知道整数类型没有精度丢失的问题，但是浮点数有精度丢失的问题，下面我们来探究一下其精度丢失的原因所在。</p><p><strong>浮点数，分单精度（float）和双精度（double）：</strong></p><p>float ，介于 -3.402823e38 和 +3.402823e38 之间的32位数字；</p><p>double ，介于 -1.79769313486232e308 和 +1.79769313486232e308 之间的64位数字；</p><p>我们知道，计算机只识别 0 和 1，所以数值都是以二进制的方式储存在内存中的。<br>所以要知道数值在内存中是如何储存的，需先将数值转为二进制<br>根据 IEEE 754 标准，任意一个二进制浮点数 V 均可表示为：V = (-1 ^ s) * M * (2 ^ e)。<br>其中 s ∈ {0, 1}；M ∈ [1, 2)；e 表示偏移指数。</p><p>具体浮点数的 IEEE 754表示方法在我之前的博客有所讲解，不清楚的可以查看，这里就不解释了。</p><h4 id="精度丢失原因"><a href="#精度丢失原因" class="headerlink" title="精度丢失原因"></a>精度丢失原因</h4><p>首先计算机进行的是二进制运算，我们输入的十进制数字会先转换成二进制，进行运算后再转换为十进制输出。Float和Double提供了快速的运算，然而问题在于转换为二进制的时候，有些数字不能完全转换，<strong>只能无限接近于原本的值</strong>，这就导致了在后来的运算会出现不正确结果的情况。</p><p>我们先探究一下int 和 float同样都是用32位表示，但是为什么float范围就比int大很多呢？</p><p>int取值范围：-2147483648~2147483647，远远不足float： -3.402823e38 ~+3.402823e38</p><p>我们知道int数值是连续且等分的，而float数值是跳跃的，并且间隔不一定相等。都是用32位表示，也就是说int和float可存储数值的最大数量是相等的，为2的32次方。</p><p>文字理解有点抽象，下面我们上图来看</p><p><img data-src="3.png" alt="3.png"></p><p>大概意思我们可以看到，在负数值范围内，float可以表示更加精确的数（图中较为密集的部分），但是在正数范围中，float表示的就不如int精确了，并且float数值不是等分表示的，这就造成了float的精度丢失。</p><p>这样应该就能理解浮点数精度丢失的原因了，其实最根本原因还是计算机只能采取二进制存储数据</p><h3 id="普通测试"><a href="#普通测试" class="headerlink" title="普通测试"></a>普通测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="number">0.05</span> + <span class="number">0.01</span>);</span><br><span class="line">       System.out.println(<span class="number">1.0</span> - <span class="number">0.42</span>);</span><br><span class="line">       System.out.println(<span class="number">4.015</span> * <span class="number">100</span>);</span><br><span class="line">       System.out.println(<span class="number">123.3</span> / <span class="number">100</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img data-src="1.png" alt="1.png"></p><p>如图所示，在进行加减乘除运算时，得到的结果并不是我们预期的结果，假设我们在电商项目内进行价格计算时就会出现问题，很有可能造成余额为 9.99999999999999，但是无法购买10元的商品。</p><h3 id="使用Integer类型的BigDecimal构造器进行运算"><a href="#使用Integer类型的BigDecimal构造器进行运算" class="headerlink" title="使用Integer类型的BigDecimal构造器进行运算"></a>使用Integer类型的BigDecimal构造器进行运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(<span class="number">0.05</span>);</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(<span class="number">0.01</span>);</span><br><span class="line">    System.out.println(b1.add(b2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="2.png" alt="2.png"></p><p>结果如图所示，结果也不正确，支付时也会出现问题。</p><h3 id="使用String类型的BigDecimal构造器进行运算"><a href="#使用String类型的BigDecimal构造器进行运算" class="headerlink" title="使用String类型的BigDecimal构造器进行运算"></a>使用String类型的BigDecimal构造器进行运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.05"</span>);</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.01"</span>);</span><br><span class="line">    System.out.println(b1.add(b2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为0.06，正确</p>]]></content>
      
      
      <categories>
          
          <category> 电商项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试宝典-GC</title>
      <link href="/2020/04/20/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-GC/"/>
      <url>/2020/04/20/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-GC/</url>
      
        <content type="html"><![CDATA[<h2 id="●-请简单描述一下垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？"><a href="#●-请简单描述一下垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？" class="headerlink" title="● 请简单描述一下垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？"></a>● 请简单描述一下垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？</h2><p>考察点：垃圾回收</p><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p><h2 id="●-请问，在java中会存在内存泄漏吗？请简单描述一下。"><a href="#●-请问，在java中会存在内存泄漏吗？请简单描述一下。" class="headerlink" title="● 请问，在java中会存在内存泄漏吗？请简单描述一下。"></a>● 请问，在java中会存在内存泄漏吗？请简单描述一下。</h2><p>考察点：内存</p><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Java中的确存在Java的内存泄漏, 并且事态可以变得相当严重</p><p>Java garbage collector自动释放哪些内存里面程序不在需要的对象, 以此避免大多数的其他程序上下文的内存泄漏. 但是Java应用程序依旧会有相当的内存泄漏. 查找原因会十分困难.<br>有两类主要的Java内存泄漏:<br>* 不再需要的对象引用<br>* 未释放的系统资源<br>2.2 非必要的对象引用<br>Java代码常常保留对于不再需要的对象引用, 并且这组织了内存的垃圾收集器的工作. Java对象通常被其他对象包含引用, 为此一个单一对象可以保持整个对象树在内存中, 于是导致了如下问题:<br>* 在向数组添加对象以后遗漏了对于他们的处理<br>* 直到你再次使用对象的时候都不释放引用. 比如一个菜单指令可以插件一个对象实例引用并且不释放便于以后再次调用的时候使用, 但是也许永远不会发生.<br>* 在其他引用依然需要旧有状态的时候贸然修改对象状态. 比如当你为了在一个文本文件里面保存一些属性而使用一个数组, 诸如”字符个数”等字段在不再需要的时候依然保留在内存当中.<br>* 允许一个长久执行的线程所引用的对象. 设置引用为NULL也无济于事, 在线程退出和空闲之前, 对象不会被收集释放<br>2.3 未释放的系统资源<br>Java方法可以定位Java实例意外的堆内存, 诸如针对视窗和位图的内存资源. Java常常通过JNI(Java Native Interface)调用C/C++子程序定位这些资源.</p><h2 id="●-请说明一下垃圾回收的优点以及原理。"><a href="#●-请说明一下垃圾回收的优点以及原理。" class="headerlink" title="● 请说明一下垃圾回收的优点以及原理。"></a>● 请说明一下垃圾回收的优点以及原理。</h2><p>考察点：垃圾回收</p><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Java 语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</p><h2 id="●-请问GC是什么-还有为什么要有GC"><a href="#●-请问GC是什么-还有为什么要有GC" class="headerlink" title="● 请问GC是什么? 还有为什么要有GC?"></a>● 请问GC是什么? 还有为什么要有GC?</h2><p>考察点：回收</p><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p><h2 id="●-请简述一下GC算法"><a href="#●-请简述一下GC算法" class="headerlink" title="● 请简述一下GC算法"></a>● 请简述一下GC算法</h2><p>考察点：JVM</p><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>①GC（GarbageCollection 垃圾收集），GC的对象是堆空间和永久区</p><p>②GC算法包含：引用计数法，标记清除，标记压缩，复制算法。</p><p>③引用计数器的实现很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。</p><p>④标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。与标记-清除算法相比，复制算法是一种相对高效的回收方法不适用于存活对象较多的场合如老年代将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p><h2 id="●-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？请简要说明一下"><a href="#●-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？请简要说明一下" class="headerlink" title="● 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？请简要说明一下"></a>● 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？请简要说明一下</h2><p>考察点：GC</p><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><h3 id="minor-gc运行的很频繁可能是什么原因引起的？"><a href="#minor-gc运行的很频繁可能是什么原因引起的？" class="headerlink" title="minor gc运行的很频繁可能是什么原因引起的？"></a>minor gc运行的很频繁可能是什么原因引起的？</h3><p>1、 产生了太多朝生夕灭的对象导致需要频繁minor gc</p><p>2、 新生代空间设置的比较小</p><h3 id="minor-gc运行的很慢有可能是什么原因引起的？"><a href="#minor-gc运行的很慢有可能是什么原因引起的？" class="headerlink" title="minor gc运行的很慢有可能是什么原因引起的？"></a>minor gc运行的很慢有可能是什么原因引起的？</h3><p>1、 新生代空间设置过大。</p><p>2、 对象引用链较长，进行可达性分析时间较长。</p><p>3、 新生代survivor区设置的比较小，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销。</p><p>4、 内存分配担保失败，由minor gc转化为full gc</p><p>5、 采用的垃圾收集器效率较低，比如新生代使用serial收集器</p><h2 id="●-请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？"><a href="#●-请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？" class="headerlink" title="● 请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？"></a>● 请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？</h2><p>考察点：内存泄漏</p><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试宝典 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试宝典-锁</title>
      <link href="/2020/04/20/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-%E9%94%81/"/>
      <url>/2020/04/20/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="●-请你简述一下synchronized与java-util-concurrent-locks-Lock的相同之处和不同之处？"><a href="#●-请你简述一下synchronized与java-util-concurrent-locks-Lock的相同之处和不同之处？" class="headerlink" title="● 请你简述一下synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处？"></a>● 请你简述一下synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处？</h2><p>考察点：锁机制</p><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>主要相同点：Lock能完成synchronized所实现的所有功能</p><p>主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。</p><h2 id="●-JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？"><a href="#●-JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？" class="headerlink" title="● JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？"></a>● JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？</h2><p>考察点：死锁</p><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p><p>预防死锁，预先破坏产生死锁的四个条件。互斥不可能破坏，所以有如下三种方法：</p><p>1.破坏请求和保持条件，进程必须等所有要请求的资源都空闲时才能申请资源，这种方法会使资源浪费严重(有些资源可能仅在运行初期或结束时才使用，甚至根本不使用). 允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源，比如有一个进程的任务是把数据复制到磁盘中再打印，前期只需获得磁盘资源而不需要获得打印机资源，待复制完毕后再释放掉磁盘资源。这种方法比第一种方法好，会使资源利用率上升。</p><p>2.破坏不可抢占条件，这种方法代价大，实现复杂。</p><p>3.破坏循坏等待条件，对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对资源的利用率比前两种都高，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制。</p><h2 id="●-请问什么是死锁-deadlock"><a href="#●-请问什么是死锁-deadlock" class="headerlink" title="● 请问什么是死锁(deadlock)?"></a>● 请问什么是死锁(deadlock)?</h2><p>考察点：线程死锁</p><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。</p><p>例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。</p><h2 id="●-请说明一下锁和同步的区别。"><a href="#●-请说明一下锁和同步的区别。" class="headerlink" title="● 请说明一下锁和同步的区别。"></a>● 请说明一下锁和同步的区别。</h2><p>考察点：锁</p><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>用法上的不同：<br>synchronized既可以加在方法上，也可以加载特定代码块上，而lock需要显示地指定起始位置和终止位置。<br>synchronized是托管给JVM执行的，lock的锁定是通过代码实现的，它有比synchronized更精确的线程语义。<br>性能上的不同：<br>lock接口的实现类ReentrantLock，不仅具有和synchronized相同的并发性和内存语义，还多了超时的获取锁、定时锁、等候和中断锁等。<br>在竞争不是很激烈的情况下，synchronized的性能优于ReentrantLock，竞争激烈的情况下synchronized的性能会下降的非常快，而ReentrantLock则基本不变。<br>锁机制不同：<br>synchronized获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且是自动解锁。而Lock则需要开发人员手动释放，并且必须在finally中释放，否则会引起死锁。</p><h2 id="●-请说明一下synchronized的可重入怎么实现。"><a href="#●-请说明一下synchronized的可重入怎么实现。" class="headerlink" title="● 请说明一下synchronized的可重入怎么实现。"></a>● 请说明一下synchronized的可重入怎么实现。</h2><p>考察点：锁</p><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。</p><h2 id="●-请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。"><a href="#●-请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。" class="headerlink" title="● 请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。"></a>● 请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。</h2><p>考察点：锁</p><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，FIFO。对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试宝典 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试宝典-集合</title>
      <link href="/2020/04/20/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-%E9%9B%86%E5%90%88/"/>
      <url>/2020/04/20/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="●-请说明List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#●-请说明List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="● 请说明List、Map、Set三个接口存取元素时，各有什么特点？"></a>● 请说明List、Map、Set三个接口存取元素时，各有什么特点？</h2><p>考察点：List</p><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p><h2 id="●-阐述ArrayList、Vector、LinkedList的存储性能和特性"><a href="#●-阐述ArrayList、Vector、LinkedList的存储性能和特性" class="headerlink" title="● 阐述ArrayList、Vector、LinkedList的存储性能和特性"></a>● 阐述ArrayList、Vector、LinkedList的存储性能和特性</h2><p>考察点：ArrayList</p><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p><h2 id="●-请判断List、Set、Map是否继承自Collection接口？"><a href="#●-请判断List、Set、Map是否继承自Collection接口？" class="headerlink" title="● 请判断List、Set、Map是否继承自Collection接口？"></a>● 请判断List、Set、Map是否继承自Collection接口？</h2><p>考察点：collection接口</p><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p><h2 id="●-请讲讲你所知道的常用集合类以及主要方法？"><a href="#●-请讲讲你所知道的常用集合类以及主要方法？" class="headerlink" title="● 请讲讲你所知道的常用集合类以及主要方法？"></a>● 请讲讲你所知道的常用集合类以及主要方法？</h2><p>考察点：集合</p><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>最常用的集合类是List 和 Map。</p><p>List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。</p><p>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。</p><h2 id="●-请说明Collection-和-Collections的区别。"><a href="#●-请说明Collection-和-Collections的区别。" class="headerlink" title="● 请说明Collection 和 Collections的区别。"></a>● 请说明Collection 和 Collections的区别。</h2><p>考察点：集合</p><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Collection是集合类的上级接口，继承与他的接口主要有Set 和List.</p><p>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p><h2 id="●-请说明ArrayList和LinkedList的区别？"><a href="#●-请说明ArrayList和LinkedList的区别？" class="headerlink" title="● 请说明ArrayList和LinkedList的区别？"></a>● 请说明ArrayList和LinkedList的区别？</h2><p>考察点：ArrayList</p><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：<br>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。<br>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p><h2 id="●-请你说明HashMap和Hashtable的区别？"><a href="#●-请你说明HashMap和Hashtable的区别？" class="headerlink" title="● 请你说明HashMap和Hashtable的区别？"></a>● 请你说明HashMap和Hashtable的区别？</h2><p>考察点：集合</p><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：<br>HashMap允许键和值是null，而Hashtable不允许键或者值是null。<br>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。<br>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。<br>一般认为Hashtable是一个遗留的类。</p><h2 id="●-请说说快速失败-fail-fast-和安全失败-fail-safe-的区别？"><a href="#●-请说说快速失败-fail-fast-和安全失败-fail-safe-的区别？" class="headerlink" title="● 请说说快速失败(fail-fast)和安全失败(fail-safe)的区别？"></a>● 请说说快速失败(fail-fast)和安全失败(fail-safe)的区别？</h2><p>考察点：集合</p><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p><h2 id="●-请你说说Iterator和ListIterator的区别？"><a href="#●-请你说说Iterator和ListIterator的区别？" class="headerlink" title="● 请你说说Iterator和ListIterator的区别？"></a>● 请你说说Iterator和ListIterator的区别？</h2><p>考察点：迭代器</p><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Iterator和ListIterator的区别是：<br>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p><h2 id="●-请简单说明一下什么是迭代器？"><a href="#●-请简单说明一下什么是迭代器？" class="headerlink" title="● 请简单说明一下什么是迭代器？"></a>● 请简单说明一下什么是迭代器？</h2><p>考察点：JAVA迭代器</p><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口,<br>每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作.<br>有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除.</p><h2 id="●-请解释为什么集合类没有实现Cloneable和Serializable接口？"><a href="#●-请解释为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="● 请解释为什么集合类没有实现Cloneable和Serializable接口？"></a>● 请解释为什么集合类没有实现Cloneable和Serializable接口？</h2><p>考察点：JAVA集合</p><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p><p>考察点：JAVA集合集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：Collection：代表一组对象，每一个对象都是它的子元素。Set：不包含重复元素的Collection。List：有顺序的collection，并且可以包含重复元素。Map：可以把键(key)映射到值(value)的对象，键不能重复。</p><h2 id="●-请你说明一下ConcurrentHashMap的原理？"><a href="#●-请你说明一下ConcurrentHashMap的原理？" class="headerlink" title="● 请你说明一下ConcurrentHashMap的原理？"></a>● 请你说明一下ConcurrentHashMap的原理？</h2><p>考察点：JAVA内存模型</p><h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;                       <span class="comment">// 声明 key 为 final 型</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;                   <span class="comment">// 声明 hash 值为 final 型</span></span><br><span class="line">       <span class="keyword">volatile</span> V value;                 <span class="comment">// 声明 value 为 volatile 型</span></span><br><span class="line">       <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;      <span class="comment">// 声明 next 为 final 型</span></span><br><span class="line">  </span><br><span class="line">       HashEntry(K key, <span class="keyword">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图：</p><p>图1. 插入三个节点后桶的结构示意图：</p><p><img data-src="1.png" alt="1.png"></p><p>注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。</p><p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。</p><h2 id="●-请解释一下TreeMap"><a href="#●-请解释一下TreeMap" class="headerlink" title="● 请解释一下TreeMap?"></a>● 请解释一下TreeMap?</h2><p>考察点：key-value集合</p><h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>TreeMap是一个有序的key-value集合，基于红黑树（Red-Black tree）的 NavigableMap实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator进行排序，具体取决于使用的构造方法。</p><p>考点：集合</p><h3 id="参考回答：-13"><a href="#参考回答：-13" class="headerlink" title="参考回答："></a>参考回答：</h3><p>ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；ArrayList并发add()可能出现数组下标越界异常。</p><h2 id="●-请你说明concurrenthashmap有什么优势以及1-7和1-8区别？"><a href="#●-请你说明concurrenthashmap有什么优势以及1-7和1-8区别？" class="headerlink" title="● 请你说明concurrenthashmap有什么优势以及1.7和1.8区别？"></a>● 请你说明concurrenthashmap有什么优势以及1.7和1.8区别？</h2><p>考点：集合</p><h3 id="参考回答：-14"><a href="#参考回答：-14" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Concurrenthashmap线程安全的，1.7是在jdk1.7中采用Segment + HashEntry的方式进行实现的，lock加在Segment上面。1.7size计算是先采用不加锁的方式，连续计算元素的个数，最多计算3次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数；</p><p>1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数；</p><h2 id="●-请你说明一下TreeMap的底层实现？"><a href="#●-请你说明一下TreeMap的底层实现？" class="headerlink" title="● 请你说明一下TreeMap的底层实现？"></a>● 请你说明一下TreeMap的底层实现？</h2><p>考点：集合</p><h3 id="参考回答：-15"><a href="#参考回答：-15" class="headerlink" title="参考回答："></a>参考回答：</h3><p>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。</p><p>红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑树性质：</p><p>性质1：每个节点要么是红色，要么是黑色。</p><p>性质2：根节点永远是黑色的。</p><p>性质3：所有的叶节点都是空节点（即 null），并且是黑色的。</p><p>性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</p><p>性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p><h2 id="●-请你说明ConcurrentHashMap锁加在了哪些地方？"><a href="#●-请你说明ConcurrentHashMap锁加在了哪些地方？" class="headerlink" title="● 请你说明ConcurrentHashMap锁加在了哪些地方？"></a>● 请你说明ConcurrentHashMap锁加在了哪些地方？</h2><p>考点：集合</p><h3 id="参考回答：-16"><a href="#参考回答：-16" class="headerlink" title="参考回答："></a>参考回答：</h3><p>加在每个Segment 上面。</p><h2 id="●-请你解释HashMap的容量为什么是2的n次幂？"><a href="#●-请你解释HashMap的容量为什么是2的n次幂？" class="headerlink" title="● 请你解释HashMap的容量为什么是2的n次幂？"></a>● 请你解释HashMap的容量为什么是2的n次幂？</h2><p>考点：集合</p><h3 id="参考回答：-17"><a href="#参考回答：-17" class="headerlink" title="参考回答："></a>参考回答：</h3><p>负载因子默认是0.75， 2^n是为了让散列更加均匀，例如出现极端情况都散列在数组中的一个下标，那么hashmap会由O（1）复杂退化为O（n）的。</p><h2 id="●-请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？"><a href="#●-请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？" class="headerlink" title="● 请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？"></a>● 请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？</h2><p>考点：集合</p><h3 id="参考回答：-18"><a href="#参考回答：-18" class="headerlink" title="参考回答："></a>参考回答：</h3><p>ArrayList采用数组数组实现的，查找效率比LinkedList高。LinkedList采用双向链表实现的，插入和删除的效率比ArrayList要高。一直在list的尾部添加元素，LinkedList效率要高。</p><h2 id="●-如果hashMap的key是一个自定义的类，怎么办？"><a href="#●-如果hashMap的key是一个自定义的类，怎么办？" class="headerlink" title="● 如果hashMap的key是一个自定义的类，怎么办？"></a>● 如果hashMap的key是一个自定义的类，怎么办？</h2><p>考点：集合</p><h3 id="参考回答：-19"><a href="#参考回答：-19" class="headerlink" title="参考回答："></a>参考回答：</h3><p>使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。</p><h2 id="●-请你解释一下hashMap具体如何实现的？"><a href="#●-请你解释一下hashMap具体如何实现的？" class="headerlink" title="● 请你解释一下hashMap具体如何实现的？"></a>● 请你解释一下hashMap具体如何实现的？</h2><p>考点：集合</p><h3 id="参考回答：-20"><a href="#参考回答：-20" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Hashmap基于数组实现的，通过对key的hashcode &amp; 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。put时在多线程情况下，会形成环从而导致死循环。数组长度一般是2n，从0开始编号，所以hashcode &amp; （2n-1），（2n-1）每一位都是1，这样会让散列均匀。需要注意的是，HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><h2 id="●-请你说明一下Map和ConcurrentHashMap的区别？"><a href="#●-请你说明一下Map和ConcurrentHashMap的区别？" class="headerlink" title="● 请你说明一下Map和ConcurrentHashMap的区别？"></a>● 请你说明一下Map和ConcurrentHashMap的区别？</h2><p>考点：集合</p><h3 id="参考回答：-21"><a href="#参考回答：-21" class="headerlink" title="参考回答："></a>参考回答：</h3><p>hashmap是线程不安全的，put时在多线程情况下，会形成环从而导致死循环。CoucurrentHashMap是线程安全的，采用分段锁机制，减少锁的粒度。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试宝典 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>底层源码分析 Spring 的核心功能和执行流程？（下）</title>
      <link href="/2020/04/19/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Spring-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B(%E4%B8%8B)/"/>
      <url>/2020/04/19/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Spring-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B(%E4%B8%8B)/</url>
      
        <content type="html"><![CDATA[<p>上一课时我们讲了Bean 相关的内容，它其实也是属于loC的具体实现之一，本课时我们就来讲讲Spring 中其他几个高频的面试点，希望能起到抛砖引玉的作用，能为你理解 Spring 打开一扇门。因为Spring 涉及的内容和知识点太多了，用它来写一本书也绰绰有余，因此这里我们只讲核心的内容，希望下来你能查漏补缺，完善自己的Spring 技术栈。</p><p><strong>我们本课时的面试题是，谈一谈你对loC和DI的理解。</strong></p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p><strong>loC</strong>（Inversion of Control，翻译为“控制反转”）不是一个具体的技术，而是一种设计思想。与传统控制流相比，loC会颠倒控制流，在传统的编程中需要开发者自行创建并销毁对象，而在loC中会把这些操作交给框架来处理，这样开发者就不用关注具体的实现细节了，拿来直接用就可以了，这就是<strong>控制反转</strong>。</p><p>loC很好的体现出了面向对象的设计法则之一——好莱坞法则：“别找我们，我们找你”。即由loC<br>容器帮对象找到相应的依赖对象并注入，而不是由对象主动去找。</p><p>举个例子，比如说传统找对象，先要设定好你的要求，如身高、体重、长相等，然后再一个一个的主动去找符合要求的对象，而loC相当于，你把这些要求直接告诉婚介中心，由他们直接给你匹配到符合要求的对象，理想情况下是直接会帮你找到合适的对象，这就是传统编程模式和loC的区别。</p><p><strong>DI</strong>（Dependency Injection，翻译为“<strong>依赖注入</strong>”）表示组件间的依赖关系交由容器在运行期自动生成，也就是说，由容器动态的将某个依赖关系注入到组件之中，这样就能提升组件的重用频率。通过依赖注入机制，我们只需要通过简单的配置，就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心资源来自哪里、由谁实现等问题。<br>loC和DI其实是同一个概念从不同角度的描述的，由于控制反转这个概念比较含糊（可能只理解成了容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年被开发者尊称为“教父”的Martin Fowler（世界顶级专家，敏捷开发方法的创始人之一）又给出了一个新的名字“依赖注入”，相对loC而言，“依赖注入”<strong>明确描述了“被注入对象依赖loC容器配置依赖对象</strong>”。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>loC和DI为Spring框架设计的精髓所在，也是面试中必问的考点之一，这个优秀的设计思想对于初学者来说可能理解起来比较困难，但对于Spring的使用者来说可以很快的看懂。因此如果对于此概念还有疑问的话，建议先上手使用Spring 实现几个小功能再回头来看这些概念，相信你会豁然开朗。</p><p>Spring 相关的高频面试题，还有以下这些：</p><ul><li>Spring loC有哪些优势？</li><li>loC的注入方式有哪些？</li><li>谈一谈你对AOP的理解。</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-Spring-loC的优点"><a href="#1-Spring-loC的优点" class="headerlink" title="1.Spring loC的优点"></a>1.Spring loC的优点</h3><p>loC的优点有以下几个：</p><ul><li>使用更方便，拿来即用，无需显式的创建和销毁的过程；·可以很容易提供众多服务，比如事务管理、消息服务等；</li><li>提供了单例模式的支持；</li><li>提供了AOP抽象，利用它很容易实现权限拦截、运行期监控等功能；</li><li>更符合面向对象的设计法则；</li><li>低侵入式设计，代码的污染极低，降低了业务对象替换的复杂性。</li></ul><h3 id="2-Spring-loC注入方式汇总"><a href="#2-Spring-loC注入方式汇总" class="headerlink" title="2.Spring loC注入方式汇总"></a>2.Spring loC注入方式汇总</h3><p>loC的注入方式有三种：构造方法注入、Setter注入和接口注入。</p><h4 id="①构造方法注入"><a href="#①构造方法注入" class="headerlink" title="①构造方法注入"></a>①构造方法注入</h4><p>构造方法注入主要是依赖于构造方法去实现，构造方法可以是有参的也可以是无参的，我们平时new对象时就是通过类的构造方法来创建类对象的，每个类对象默认会有一个无参的构造方法，Spring通过构造方法注入的代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 忽略 Setter、Getter 的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applicationContext.xml 配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.Person"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="②Setter-注入"><a href="#②Setter-注入" class="headerlink" title="②Setter 注入"></a>②Setter 注入</h4><p>Setter 方法注入的方式是目前Spring 主流的注入方式，它可以利用Java Bean规范所定义的Setter/Getter方法来完成注入，可读性和灵活性都很高，它不需要使用声明式构造方法，而是使用Setter 注入直接设置相关的值，实现示例如下：    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Java"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="③接口注入"><a href="#③接口注入" class="headerlink" title="③接口注入"></a>③接口注入</h4><p>接口注入方式是比较古老的注入方式，因为它需要被依赖的对象实现不必要的接口，带有侵入性，因此现在已经被完全舍弃了，所以本文也不打算做过多的描述，大家只要知道有这回事就行了。</p><h3 id="3-Spring-AOP"><a href="#3-Spring-AOP" class="headerlink" title="3.Spring AOP"></a>3.Spring AOP</h3><p>AOP（Aspect-OrientedProgramming，面向切面编程）可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善，OOP引入封装、继承和多态性等概念来建立一种公共对象处理的能力，当我们需要处理公共行为的时候，OOP就会显得无能为力，而AOP的出现正好解决了这个问题。比如统一的日志处理模块、授权验证模块等都可以使用AOP很轻松的处理。<br>Spring AOP目前提供了三种配置方式：</p><ul><li>基于JavaAPl的方式；</li><li>基于@AspectJ（Java）注解的方式；</li><li>基于XML&lt;aop/&gt;标签的方式。</li></ul><h4 id="①基于JavaAPI的方式"><a href="#①基于JavaAPI的方式" class="headerlink" title="①基于JavaAPI的方式"></a>①基于JavaAPI的方式</h4><p>此配置方式需要实现相关的接口，例如MethodBeforeAdvice和AfterReturningAdvice，并且在<br>XML配置中定义相应的规则即可实现。<br>我们先来定义一个实体类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person <span class="title">findPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"JDK"</span>);</span><br><span class="line">      System.out.println(<span class="string">"findPerson 被执行"</span>);</span><br><span class="line">      <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> Integer id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="comment">// 忽略 Getter、Setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个 advice 类，用于对拦截方法的调用之前和调用之后进行相关的业务处理，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span>, <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"准备执行方法: "</span> + method.getName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(method.getName() + <span class="string">" 方法执行结束"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后需要在 application.xml 文件中配置相应的拦截规则，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义 advisor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAdvice"</span> <span class="attr">class</span>=<span class="string">"org.springframework.advice.MyAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置规则，拦截方法名称为 find* --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"myAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"org.springframework.beans.*.find.*"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义 DefaultAdvisorAutoProxyCreator 使所有的 advisor 配置自动生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从以上配置中可以看出，我们需要配置一个拦截方法的规则，然后定义一个<br>DefaultAdvisorAutoProxyCreator 让所有的 advisor 配置自动生效。<br>最后，我们使用测试代码来完成调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ApplicationContext context =</span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath*:application.xml"</span>);</span><br><span class="line">      Person person = context.getBean(<span class="string">"person"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      person.findPerson();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">准备执行方法: findPerson</span><br><span class="line">findPerson 被执行</span><br><span class="line">findPerson 方法执行结束</span><br></pre></td></tr></table></figure><p>可以看出AOP的拦截已经成功了。</p><h4 id="②基于-AspectJ注解的方式"><a href="#②基于-AspectJ注解的方式" class="headerlink" title="②基于@AspectJ注解的方式"></a>②基于@AspectJ注解的方式</h4><p>首先需要在项目中添加aspectjweaver的jar包，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此jar包来自于AspectJ，因为Spring 使用了Aspect提供的一些注解，因此需要添加此jar包。之后，我们需要开启@Aspect的注解，开启方式有两种。</p><p>可以在application.xml 配置如下代码中开启@AspectJ的注解：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用 @EnableAspectJAutoProxy 注解开启，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们需要声明拦截器的类和拦截方法，以及配置相应的拦截规则，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectJ</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 配置拦截类 Person</span></span><br><span class="line">   <span class="meta">@Pointcut</span>(<span class="string">"execution(* org.springframework.beans.Person.*(..))"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"执行 doBefore 方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@After</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"执行 doAfter 方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们只需要在 application.xml 配置中添加注解类，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.advice.MyAspectJ"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>紧接着，我们添加一个需要拦截的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要拦截的 Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person <span class="title">findPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"JDK"</span>);</span><br><span class="line">      System.out.println(<span class="string">"执行 findPerson 方法"</span>);</span><br><span class="line">      <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 获取其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们开启测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ApplicationContext context =</span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath*:application.xml"</span>);</span><br><span class="line">      Person person = context.getBean(<span class="string">"person"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      person.findPerson();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 doBefore 方法</span><br><span class="line">执行 findPerson 方法</span><br><span class="line">执行 doAfter 方法</span><br></pre></td></tr></table></figure><p>可以看出AOP拦截成功了。</p><h4 id="③基于XML-lt-aop-gt-标签的方式"><a href="#③基于XML-lt-aop-gt-标签的方式" class="headerlink" title="③基于XML&lt;aop/&gt;标签的方式"></a>③基于XML&lt;aop/&gt;标签的方式</h4><p>基于XML的方式与基于注解的方式类似，只是无需使用注解，把相关信息配置到application.xml中即可，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 拦截处理类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myPointcut"</span> <span class="attr">class</span>=<span class="string">"org.springframework.advice.MyPointcut"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截规则配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcutConfig"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">expression</span>=<span class="string">"execution(* org.springframework.beans.Person.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截方法配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"myPointcut"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"doBefore"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcutConfig"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"doAfter"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcutConfig"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后，添加一个普通的类来进行拦截业务的处理，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPointcut</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"执行 doBefore 方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"执行 doAfter 方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截的方法和测试代码与第二种注解的方式相同，这里就不在熬述。<br>最后执行程序，执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 doBefore 方法</span><br><span class="line">执行 findPerson 方法</span><br><span class="line">执行 doAfter 方法</span><br></pre></td></tr></table></figure><p>可以看出AOP拦截成功了。<br>Spring AOP的原理其实很简单，它其实就是一个动态代理，我们在调用getBean(）方法的时候返回的其实是代理类的实例，而这个代理类在Spring中使用的是JDK Proxy或CgLib实现的，它的核心代码在DefaultAopProxyFactory#createAopProxy（..）中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&amp;lt;?&amp;gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line"><span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 判断目标类是否为接口</span></span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">                <span class="comment">// 是接口使用 jdk 的代理</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 其他情况使用 CgLib 代理</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 忽略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong><br>本课时讲了loC和DI概念，以及loC的优势和loC注入的三种方式：构造方法注入、Setter注入和接口注入，最后讲了Spring AOP的概念与它的三种配置方式：基于JavaAPI的方式、基于Java注解的方式和基于XML标签的方式。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>底层源码分析 Spring 的核心功能和执行流程？（上）</title>
      <link href="/2020/04/19/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Spring-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B(%E4%B8%8A)/"/>
      <url>/2020/04/19/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Spring-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<p>Spring Framework 已是公认的Java标配开发框架了，甚至还有人说Java编程就是面向Spring编程的，可见Spring在整个Java体系中的重要位置。</p><p>Spring 中包含了众多的功能和相关模块，比如 spring-core、spring-beans、spring-aop、spring-<br>context、spring-expression、spring-test等，本课时先从面试中必问的问题出发，来帮你更好的<br>Spring框架。</p><p><strong>我们本课时的面试题是，Spring Bean的作用域有哪些？它的注册方式有几种？</strong></p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>在Spring 容器中管理一个或多个Bean，这些Bean的定义表示为BeanDefinition对象，这些对象包含以下重要信息：</p><ul><li>Bean的实际实现类</li><li>Bean的作用范围</li><li>Bean的引用或者依赖项</li></ul><p>Bean的注册方式有三种：</p><ul><li>XML配置文件的注册方式</li><li>Java 注解的注册方式</li><li>Java APl的注册方式</li></ul><h2 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h2><h3 id="1-XML-配置文件注册方式"><a href="#1-XML-配置文件注册方式" class="headerlink" title="1.XML 配置文件注册方式"></a>1.XML 配置文件注册方式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Java"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-Java-注解注册方式"><a href="#2-Java-注解注册方式" class="headerlink" title="2.Java 注解注册方式"></a>2.Java 注解注册方式</h3><p>可以使用 @Component 注解方式来注册 Bean，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Integer id;</span><br><span class="line">   <span class="keyword">private</span> String name</span><br><span class="line">   <span class="comment">// 忽略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用 @Bean 注解方式来注册 Bean，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person  <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="comment">// 忽略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中@Configuration可理解为XML配置里的&lt;beans&gt;标签，而@Bean可理解为用XML配置里面的&lt;bean&gt;标签。</p><h3 id="3-Java-API-注册方式"><a href="#3-Java-API-注册方式" class="headerlink" title="3.Java API 注册方式"></a>3.Java API 注册方式</h3><p>使用 BeanDefinitionRegistry.registerBeanDefinition() 方法的方式注册 Bean，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanDefinitionRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        RootBeanDefinition personBean = <span class="keyword">new</span> RootBeanDefinition(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 新增 Bean</span></span><br><span class="line">registry.registerBeanDefinition(<span class="string">"person"</span>, personBean);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean-的作用域一共有-5-个。"><a href="#Bean-的作用域一共有-5-个。" class="headerlink" title="Bean 的作用域一共有 5 个。"></a>Bean 的作用域一共有 5 个。</h2><p>（1）<strong>singleton作用域</strong>：表示在Spring容器中只有一个Bean实例，以单例的形式存在，是默认的<br>Bean 作用域。<br>配置方式，缺省即可，XML的配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）<strong>prototype 作用域</strong>：原型作用域，每次调用 Bean 时都会创建一个新实例，也就是说每次调用getBean() 方法时，相当于执行了 new Bean()。</p><p>XML 的配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）<strong>request 作用域</strong>：每次 Http 请求时都会创建一个新的 Bean，该作用域仅适应于WebApplicationContext 环境。</p><p>XML 的配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"request"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java 注解的配置方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(WebApplicationContext.SCOPE_REQUEST)</span><br></pre></td></tr></table></figure><p>或是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestScope</span>(WebApplicationContext.SCOPE_REQUEST)</span><br></pre></td></tr></table></figure><p>（4）<strong>session作用域</strong>：同一个Http Session共享一个Bean对象，不同的Session拥有不同的<br>Bean 对象，仅适用于WebApplicationContext环境。</p><p>XML的配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"session"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java 注解的配置方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(WebApplicationContext.SCOPE_SESSION)</span><br></pre></td></tr></table></figure><p>或是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestScope</span>(WebApplicationContext.SCOPE_SESSION)</span><br></pre></td></tr></table></figure><p>（5）<strong>application 作用域</strong>：全局的 Web 作用域，类似于 Servlet 中的 Application。</p><p>XML 的配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"application"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java 注解的配置方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(WebApplicationContext.SCOPE_APPLICATION)</span><br></pre></td></tr></table></figure><p>或是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestScope</span>(WebApplicationContext.SCOPE_APPLICATION)</span><br></pre></td></tr></table></figure><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>在Spring中最核心的概念是AOP（面向切面编程）、loC（控制反转）、DI（依赖注入）等（此内容将会在下一课时中讲到），而最实用的功能则是Bean，他们是概念和具体实现的关系。和Bean相关的面试题，还有以下几个：</p><ul><li>什么是同名Bean？它是如何产生的？应该如何避免？</li><li>聊一聊Bean的生命周期。</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-同名Bean-问题"><a href="#1-同名Bean-问题" class="headerlink" title="1.同名Bean 问题"></a>1.同名Bean 问题</h3><p>每个Bean拥有一个或多个标识符，在基于XML的配置中，我们可以使用id或者name来作为<br>Bean 的标识符。通常Bean的标识符由字母组成，允许使用特殊字符。</p><p>同一个Spring配置文件中Bean的id和name是不能够重复的，否则Spring 容器启动时会报错。<br>但如果Spring加载了多个配置文件的话，可能会出现同名Bean的问题。同名Bean指的是多个<br>Bean 有相同的name或者id。</p><p><strong>Spring 对待同名Bean的处理规则是使用最后面的Bean覆盖前面的Bean</strong>，所以我们在定义Bean<br>时，尽量使用长命名非重复的方式来定义，避免产生同名Bean的问题。</p><p>Bean的id 或name 属性并非必须指定，如果留空的话，容器会为Bean自动生成一个唯一的名称，这样也不会出现同名Bean的问题。</p><h3 id="2-Bean-生命周期"><a href="#2-Bean-生命周期" class="headerlink" title="2.Bean 生命周期"></a>2.Bean 生命周期</h3><p>对于Spring Bean来说，并不是启动阶段就会触发Bean的实例化，只有当客户端通过显式或者隐式的方式调用BeanFactory的getBean()方法时，它才会触发该类的实例化方法。当然对于BeanFactory 来说，也不是所有的getBean(）方法都会实例化Bean对象，例如作用域为singleton时，只会在第一次，实例化该Bean对象，之后会直接返回该对象。但如果使用的是ApplicationContext 容器，则会在该容器启动的时候，立即调用注册到该容器所有Bean的实例化方法。</p><p>getBean()既然是Bean对象的入口，我们就先从这个方法说起，getBean(）方法是属于<br>BeanFactory 接口的，它的真正实现是AbstractAutowireCapableBeanFactory的createBean()方法，而createBean(）是通过doCreateBean()来实现的，具体源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">    <span class="comment">// 确定并加载 Bean 的 class</span></span><br><span class="line">    Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证以及准备需要覆盖的方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 给BeanPostProcessors 一个机会来返回代理对象来代替真正的 Bean 实例，在这里实现创建代理对象功能</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Bean</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doCreateBean 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化 bean，BeanWrapper 对象提供了设置和获取属性值的功能</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果 RootBeanDefinition 是单例，则移除未完成的 FactoryBean 实例的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建 bean 实例</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 BeanWrapper 中封装的 Object 对象，其实就是 bean 对象的实例</span></span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    <span class="comment">// 获取 BeanWrapper 中封装 bean 的 Class</span></span><br><span class="line">    Class&amp;lt;?&amp;gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 应用 MergedBeanDefinitionPostProcessor 后处理器，合并 bean 的定义信息</span></span><br><span class="line">    <span class="comment">// Autowire 等注解信息就是在这一步完成预解析，并且将注解需要的信息放入缓存</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; <span class="keyword">this</span>.allowCircularReferences &amp;amp;&amp;amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了避免循环依赖，在 bean 初始化完成前，就将创建 bean 实例的 ObjectFactory 放入工厂缓存（singletonFactories）</span></span><br><span class="line">        addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 bean 属性进行填充</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 调用初始化方法，如 init-method 注入 Aware 对象</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;amp;&amp;amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 如果存在循环依赖，也就是说该 bean 已经被其他 bean 递归加载过，放入了提早公布的 bean 缓存中</span></span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 exposedObject 没有在 initializeBean 初始化方法中被增强</span></span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">// 依赖检测</span></span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&amp;lt;String&amp;gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&amp;lt;&amp;gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 actualDependentBeans 不为空，则表示依赖的 bean 并没有被创建完，即存在循环依赖</span></span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                                    StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                    <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                                    <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                                    <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                                    <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注册 DisposableBean 以便在销毁时调用</span></span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码中可以看出，在doCreateBean()方法中，首先对Bean进行了实例化工作，它是通过调用createBeanlnstance()方法来实现的，该方法返回一个BeanWrapper对象。BeanWrapper对象是Spring中一个基础的Bean 结构接口，说它是基础接口是因为它连基本的属性都没有。</p><p>BeanWrapper 接口有一个默认实现类BeanWrapperlmpl，其主要作用是对Bean进行填充，比如填充和注入Bean的属性等。</p><p>当Spring完成Bean 对象实例化并且设置完相关属性和依赖后，则会调用Bean的初始化方法initializeBean()，初始化第一个阶段是检查当前Bean 对象是否实现了BeanNameAware、BeanClassLoaderAware、BeanFactoryAware等接口，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，BeanNameAware是把Bean对象定义的beanName设置到当前对象实例中；<br>BeanClassLoaderAware 是将当前Bean对象相应的ClassLoader注入到当前对象实例中；<br>BeanFactoryAware是BeanFactory 容器会将自身注入到当前对象实例中，这样当前对象就会拥有一个BeanFactory 容器的引用。</p><p>初始化第二个阶段则是BeanPostProcessor 增强处理，它主要是对Spring 容器提供的Bean实例对象进行有效的扩展，允许Spring在初始化Bean阶段对其进行定制化修改，比如处理标记接口或者为其提供代理实现。</p><p>在初始化的前置处理完成之后就会检查和执行InitializingBean和init-method方法。</p><p>InitializingBean 是一个接口，它有一个afterPropertiesSet()方法，在Bean初始化时会判断当前<br>Bean 是否实现了InitializingBean，如果实现了则调用 afterPropertiesSet()方法，进行初始化工作；然后再检查是否也指定了init-method，如果指定了则通过反射机制调用指定的init-method方法，它的实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前 Bean 是否实现了 InitializingBean，如果是的话需要调用 afterPropertiesSet()</span></span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;amp;&amp;amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123; <span class="comment">// 安全模式</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&amp;lt;Object&amp;gt;) () -&amp;gt; &#123;</span><br><span class="line">                    ((InitializingBean) bean).afterPropertiesSet(); <span class="comment">// 属性初始化</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="keyword">throw</span> pae.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet(); <span class="comment">// 属性初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否指定了 init-method()</span></span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;amp;&amp;amp; bean.getClass() != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        String initMethodName = mbd.getInitMethodName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;amp;&amp;amp;</span><br><span class="line">                !(isInitializingBean &amp;amp;&amp;amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;amp;&amp;amp;</span><br><span class="line">                !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">            <span class="comment">// 利用反射机制执行指定方法</span></span><br><span class="line">            invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完成之后就可以正常的使用Bean对象了，在Spring 容器关闭时会执行销毁方法，但是<br>Spring 容器不会自动去调用销毁方法，而是需要我们主动的调用。</p><p>如果是BeanFactory 容器，那么我们需要主动调用destroySingletons()方法，通知BeanFactory<br>容器去执行相应的销毁方法；如果是ApplicationContext容器，那么我们需要主动调用<br>registerShutdownHook()方法，告知ApplicationContext 容器执行相应的销毁方法。</p><p><strong>注：本课时源码基于 Spring 5.2.2.RELEASE。</strong></p><p><strong>小结</strong><br>本课时我们讲了Bean的三种注册方式：XML、Java注解和JavaAPl，以及Bean的五个作用域：<br>singleton、prototype、request、session和application；还讲了读取多个配置文件可能会出现同名Bean的问题，以及通过源码讲了Bean执行的生命周期，它的生命周期如下图所示：.</p><p><img data-src="1.png" alt="1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何手写一个消息队列和延迟消息队列</title>
      <link href="/2020/04/19/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2020/04/19/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>第一次听到“消息队列”这个词时，不知你是不是和我反应一样，感觉很高阶很厉害的样子，其实当我们了解了消息队列之后，发现它与普通的技术类似，当我们熟悉之后，也能很快地上手并使用。</p><p>我们本课时的面试题是，消息队列的使用场景有哪些？如何手动实现一个消息队列和延迟消息队列？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>消息队列的使用场景有很多，最常见的使用场景有以下几个。</p><h3 id="1-商品秒杀"><a href="#1-商品秒杀" class="headerlink" title="1.商品秒杀"></a>1.商品秒杀</h3><p>比如，我们在做秒杀活动时，会发生短时间内出现爆发式的用户请求，如果不采取相关的措施，会导致服务器忙不过来，响应超时的问题，轻则会导致服务假死，重则会让服务器直接宕机，给用户带来的体验也非常不好。如果这个时候加上了消息队列，服务器接收到用户的所有请求后，先把这些请求全部写入到消息队列中再排队处理，这样就不会导致同时处理多个请求的情况；如果消息队列长度超过可以承载的最大数量，那么我们可以抛弃当前用户的请求，通知前台用户“页面出错啦，请重新刷新”等提示，这样就会有更好的交互体验。</p><h3 id="2-系统解耦"><a href="#2-系统解耦" class="headerlink" title="2.系统解耦"></a>2.系统解耦</h3><p>使用了消息队列之后，我们可以<strong>把系统的业务功能模块化</strong>，实现系统的解耦。例如，在没有使用消息队列之前，当前台用户完善了个人信息之后，首先我们需要更新用户的资料，再添加一条用户信息修改日志。但突然有一天产品经理提了一个需求，在前台用户信息更新之后，需要给此用户的增加一定的积分奖励，然后没过几天产品经理又提了一个需求，在前台用户信息更新之后，不但要增加积分奖励，还要增加用户的经验值，但没过几天产品经理的需求又变了，他要求完善资料无需增加用户的积分了，这样反反复复、来来回回的折腾，我想研发的同学一定受不了，但这是互联网公司的常态，那我们有没有一劳永逸的办法呢？</p><p>没错，这个时候我们想到了使用消息队列来实现系统的解耦，每个功能的实现独立开，只需要一个订阅或者取消订阅的开关就可以了，当需要增加功能时，只需要打开订阅“用户信息完善”的队列就行，如果过两天不用了，再把订阅的开关关掉就行了，这样我们就不用来来回回的改业务代码了，也就轻松的实现了系统模块间的解耦。</p><h3 id="3-日志记录"><a href="#3-日志记录" class="headerlink" title="3.日志记录"></a>3.日志记录</h3><p>我们大部分的日志记录行为其实是和前台用户操作的主业务没有直接关系的，只是我们的运营人和经营人员需要拿到这部分用户操作的日志信息，来进行用户行为分析或行为监控。在我们没有使用消息队列之前，笼统的做法是当有用户请求时，先处理用户的请求再记录日志，这两个操作是放在一起的，而前台用户也需要等待日志添加完成之后才能拿到后台的响应信息，这样其实浪费了前台用户的部分时间。此时我们可以使用消息队列，当响应完用户请求之后，只需要把这个操作信息放入消息队列之后，就可以直接返回结果给前台用户了，无序等待日志处理和日志添加完成，从而缩短了前台用户的等待时间。</p><p>我们可以通过JDK提供的Queue来实现自定义消息队列，使用DelayQueue实现延迟消息队列。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>对于消息队列的考察更侧重于消息队列的核心思想，因为只有理解了什么是消息队列？以及什么情况下要用消息队列？才能解决我们日常工作中遇到的问题，而消息队列的具体实现，只需要掌握一个消息中间件的使用即可，因为消息队列中间件的核心实现思路是一致的，不但如此，消息队列中间件的使用也大致类似，只要掌握了一个就能触类旁通的用好其他消息中间件。</p><p>和本课时相关的面试题，还有以下这两个：</p><ul><li>介绍一个你熟悉的消息中间件？</li><li>如何手动实现消息队列？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-常用消息中间件-RabbitMQ"><a href="#1-常用消息中间件-RabbitMQ" class="headerlink" title="1.常用消息中间件 RabbitMQ"></a>1.常用消息中间件 RabbitMQ</h3><p>目前市面上比较常用的MQ（Message Queue，消息队列）中间件有RabbitMQ、Kafka、<br>RocketMQ，如果是轻量级的消息队列可以使用Redis提供的消息队列，本课时我们先来介绍一下<br>RabbitMQ，其他消息中间件将会在第15课时中单独介绍。</p><p>RabbitMQ 是一个老牌开源的消息中间件，它实现了标准的AMQP（Advanced Message Queuing Protocol，高级消息队列协议）消息中间件，使用Erlang 语言开发，支持集群部署，和多种客户端语言混合调用，它支持的主流开发语言有以下这些：</p><ul><li>Java and Spring</li><li>.NET</li><li>Ruby</li><li>Python</li><li>PHP</li><li>JavaScript and Node</li><li>Objective-C and Swift</li><li>Rust</li><li>Scala</li><li>Go</li></ul><p>更多支持语言，<a href="https://www.rabbitmq.com/devtools.html" target="_blank" rel="noopener">点击这里访问官网查看</a>。</p><p>RabbitMQ中有3个重要的概念：生产者、消费者和代理。</p><ul><li>生产者：消息的创建者，负责创建和推送数据到消息服务器。</li><li>消费者：消息的接收方，用于处理数据和确认消息。</li><li>代理：也就是RabbitMQ服务本身，它用于扮演“快递”的角色，因为它本身并不生产消息，只是扮演了“快递”的角色，把消息进行暂存和传递。</li></ul><p>它们的运行流程，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><h4 id="RabbitMQ具备以下几个优点："><a href="#RabbitMQ具备以下几个优点：" class="headerlink" title="RabbitMQ具备以下几个优点："></a>RabbitMQ具备以下几个优点：</h4><ul><li><strong>支持持久化</strong>，RabbitMQ支持磁盘持久化功能，保证了消息不会丢失；</li><li><strong>高并发</strong>，RabbitMQ使用了Erlang 开发语言，Erlang是为电话交换机开发的语言，天生自带高并发光环和高可用特性；</li><li><strong>支持分布式集群</strong>，正是因为Erlang 语言实现的，因此RabbitMQ集群部署也非常简单，只需要启动每个节点并使用–link 把节点加入到集群中即可，并且RabbitMQ支持自动选主和自动容灾；</li><li><strong>支持多种语言</strong>，比如Java、NET、PHP、Python、JavaScript、Ruby、Go等；</li><li><strong>支持消息确认</strong>，支持消息消费确认（ack）保证了每条消息可以被正常消费；</li><li><strong>它支持很多插件</strong>，比如网页控制台消息管理插件、消息延迟插件等，RabbitMQ的插件很多并且使用都很方便。</li></ul><h4 id="RabbitMQ的消息型，分为以下四种："><a href="#RabbitMQ的消息型，分为以下四种：" class="headerlink" title="RabbitMQ的消息型，分为以下四种："></a>RabbitMQ的消息型，分为以下四种：</h4><ul><li><strong>direct</strong>（默认类型）模式，此模式为一对一的发送方式，也就是一条消息只会发送给一个消费者；</li><li><strong>headers</strong> 模式，允许你匹配消息的header 而非路由键（RoutingKey），除此之外headers和<br>direct的使用完全一致，但因为headers匹配的性能很差，几乎不会被用到；</li><li><strong>fanout</strong>模式，为多播的方式，会把一个消息分发给所有的订阅者；</li><li><strong>topic</strong>模式，为主题订阅模式，允许使用通配符（#、*）匹配一个或者多个消息，我可以使用<br>“cn.mq.#”匹配到多个前缀是“cn.mq.xxx”的消息，比如可以匹配到”cn.mq.rabbit”、<br>“cn.mq.kafka”等消息。</li></ul><h3 id="2-自定义消息队列"><a href="#2-自定义消息队列" class="headerlink" title="2.自定义消息队列"></a>2.自定义消息队列</h3><p>我们可使用Queue来实现消息队列，Queue大体可分为以下三类：</p><ul><li>双端队列（Deque）是Queue的子类也是Queue的补充类，头部和尾部都支持元素插入和获取；</li><li>阻塞队列指的是在元素操作时（添加或删除），如果没有成功，会阻塞等待执行，比如当添加元素时，如果队列元素已满，队列则会阻塞等待直到有空位时再插入；</li><li>非阻塞队列，和阻塞队列相反，它会直接返回操作的结果，而非阻塞等待操作，双端队列也属于非阻塞队列。</li></ul><p>自定义消息队列的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        producer(); <span class="comment">// 调用生产者</span></span><br><span class="line">        consumer(); <span class="comment">// 调用消费者</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加消息</span></span><br><span class="line">        queue.add(<span class="string">"first message."</span>);</span><br><span class="line">        queue.add(<span class="string">"second message."</span>);</span><br><span class="line">        queue.add(<span class="string">"third message."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 消费消息</span></span><br><span class="line">            System.out.println(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first message.</span><br><span class="line">second message.</span><br><span class="line">third message.</span><br></pre></td></tr></table></figure><p>可以看出消息是以<strong>先进先出</strong>顺序进行消费的。</p><p>实现自定义延迟队列需要实现 Delayed 接口，重写 getDelay() 方法，延迟队列完整实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义延迟队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDelayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 延迟消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DelayQueue delayQueue = <span class="keyword">new</span> DelayQueue();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        producer(); <span class="comment">// 调用生产者</span></span><br><span class="line">        consumer(); <span class="comment">// 调用消费者</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加消息</span></span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> MyDelay(<span class="number">1000</span>, <span class="string">"消息1"</span>));</span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> MyDelay(<span class="number">3000</span>, <span class="string">"消息2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 消费者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始执行时间："</span> +</span><br><span class="line">                           DateFormat.getDateTimeInstance().format(<span class="keyword">new</span> Date()));</span><br><span class="line">        <span class="keyword">while</span> (!delayQueue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(delayQueue.take());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"结束执行时间："</span> +</span><br><span class="line">                DateFormat.getDateTimeInstance().format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义延迟队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDelay</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 延迟截止时间（单位：毫秒）</span></span><br><span class="line">        <span class="keyword">long</span> delayTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 借助 lombok 实现</span></span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        <span class="meta">@Setter</span></span><br><span class="line">        <span class="keyword">private</span> String msg;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> delayTime 设置延迟执行时间</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> msg       执行的消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyDelay</span><span class="params">(<span class="keyword">long</span> delayTime, String msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.delayTime = (<span class="keyword">this</span>.delayTime + delayTime);</span><br><span class="line">            <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取剩余时间</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> unit.convert(delayTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 队列里元素的排序依据</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始执行时间：<span class="number">2020</span>-<span class="number">4</span>-<span class="number">2</span> <span class="number">16</span>:<span class="number">17</span>:<span class="number">28</span></span><br><span class="line">消息<span class="number">1</span></span><br><span class="line">消息<span class="number">2</span></span><br><span class="line">结束执行时间：<span class="number">2020</span>-<span class="number">4</span>-<span class="number">2</span> <span class="number">16</span>:<span class="number">17</span>:<span class="number">31</span></span><br></pre></td></tr></table></figure><p>可以看出，消息 1 和消息 2 都实现了延迟执行的功能。</p><p><strong>小结</strong><br>本课时讲了消息队列的使用场景：商品秒杀、系统解耦和日志记录，我们还介绍了RabbitMQ以及它的消息类型和它的特点等内容，同时还使用Queue的子类LinkedList 实现了自定义消息队列，使用<br>DelayQueue 实现了自定义延迟消息队列。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-赫夫曼编码</title>
      <link href="/2020/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
      <url>/2020/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol><li>赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</li><li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li><li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间</li><li>赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码</li></ol><h2 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h2><h3 id="通信领域中信息的处理方式-1-定长编码"><a href="#通信领域中信息的处理方式-1-定长编码" class="headerlink" title="通信领域中信息的处理方式 1-定长编码"></a>通信领域中信息的处理方式 1-定长编码</h3><p><img data-src="1.png" alt="1.png"></p><h3 id="通信领域中信息的处理方式-2-变长编码"><a href="#通信领域中信息的处理方式-2-变长编码" class="headerlink" title="通信领域中信息的处理方式 2-变长编码"></a>通信领域中信息的处理方式 2-变长编码</h3><p><img data-src="2.png" alt="2.png"></p><h3 id="通信领域中信息的处理方式-3-赫夫曼编码"><a href="#通信领域中信息的处理方式-3-赫夫曼编码" class="headerlink" title="通信领域中信息的处理方式 3-赫夫曼编码"></a>通信领域中信息的处理方式 3-赫夫曼编码</h3><p><strong>步骤如下:</strong></p><ol><li>传输的字符串: i like like like java do you like a java</li><li>各个字符对应的个数：d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9</li><li>按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值<br>构成赫夫曼树的步骤：<br>1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树<br>2) 取出根节点权值最小的两颗二叉树<br>3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和<br>4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li></ol><p><img data-src="3.png" alt="3.png"></p><p>​    4.根据赫夫曼树,给各个字符,规定编码 (前缀编码)， <strong>向左的路径为 0 向右的路径为 1</strong> ， 编码如下:</p><p>​        o: 1000 u: 10010 d: 100110 y: 100111 i: 101<br>​        a : 110 k: 1110 e: 1111 j: 0000 v: 0001<br>​        l: 001  : 01</p><p>​    5.按照上面的赫夫曼编码，我们的”i like like like java do you like a java” 字符串对应的编码为 (注<br>​        意这里我们使用的无损压缩)</p><p>​        <strong>101</strong>01<strong>001</strong>101111011110100110111101111010011011110111101000011000011100110011110000110<br>​        01111000100100100110111101111011100100001100001110</p><p>​    6. 通过赫夫曼编码处理长度为 ： 133</p><p>说明:<br>原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%</p><p>此编码满足<strong>前缀编码</strong>, 即字符的编码都不能是其他字符编码的前缀。<strong>不会造成匹配的多义性</strong><br>赫夫曼编码是无损处理方案</p><h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><h3 id="1-将字节数组转成集合并统计每个字符出现的次数"><a href="#1-将字节数组转成集合并统计每个字符出现的次数" class="headerlink" title="1.将字节数组转成集合并统计每个字符出现的次数"></a>1.将字节数组转成集合并统计每个字符出现的次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的就是 List 形式   [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]......],</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line"><span class="comment">//1创建一个ArrayList</span></span><br><span class="line">ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储每个byte出现的次数 -&gt;map</span></span><br><span class="line"><span class="comment">//遍历 bytes , 统计 每一个byte出现的次数-&gt;map[key,value]</span></span><br><span class="line">Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">byte</span> b:bytes)&#123;</span><br><span class="line">Integer count = counts.get(b);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123; <span class="comment">// Map还没有这个字符数据,第一次</span></span><br><span class="line">counts.put(b, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把每一个键值对转成一个Node 对象，并加入到nodes集合</span></span><br><span class="line"><span class="comment">//遍历map</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Byte, Integer&gt; entry :counts.entrySet())&#123;</span><br><span class="line">nodes.add(<span class="keyword">new</span> Node(entry.getKey(),entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-通过list创建赫夫曼树"><a href="#2-通过list创建赫夫曼树" class="headerlink" title="2.通过list创建赫夫曼树"></a>2.通过list创建赫夫曼树</h3><p>定义Node类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Node ,带数据和权值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;  </span>&#123;</span><br><span class="line">Byte data; <span class="comment">// 存放数据(字符)本身，比如'a' =&gt; 97 ' ' =&gt; 32</span></span><br><span class="line"><span class="keyword">int</span> weight; <span class="comment">//权值, 表示字符出现的次数</span></span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line"><span class="keyword">this</span>.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 从小到大排序</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [data = "</span> + data + <span class="string">" weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过List 创建对应的赫夫曼树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过List 创建对应的赫夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//排序 从小到大</span></span><br><span class="line">Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出根节点权值最小的两颗二叉树 </span></span><br><span class="line"><span class="comment">//(1) 取出权值最小的结点（二叉树）</span></span><br><span class="line">Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//(2) 取出权值第二小的结点（二叉树）</span></span><br><span class="line">Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//(3)构建一颗新的二叉树</span></span><br><span class="line">Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>,leftNode.weight + rightNode.weight);</span><br><span class="line">parent.left = leftNode;</span><br><span class="line">parent.right = rightNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">nodes.remove(leftNode);</span><br><span class="line">nodes.remove(rightNode);</span><br><span class="line"><span class="comment">//(5)将parent加入到nodes</span></span><br><span class="line">nodes.add(parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回哈夫曼树的root结点</span></span><br><span class="line"><span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-生成赫夫曼树对应的赫夫曼编码"><a href="#3-生成赫夫曼树对应的赫夫曼编码" class="headerlink" title="3.生成赫夫曼树对应的赫夫曼编码"></a>3.生成赫夫曼树对应的赫夫曼编码</h3><p>思路:<br>    1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式<br>    2.生成的赫夫曼编码表{32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;Byte,String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径</span></span><br><span class="line"><span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了调用方便，我们重载 getCodes</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理root的左子树</span></span><br><span class="line">getCodes(root.left, <span class="string">"0"</span>, stringBuilder);</span><br><span class="line"><span class="comment">// 处理root的右子树</span></span><br><span class="line">getCodes(root.right, <span class="string">"1"</span>, stringBuilder);</span><br><span class="line"><span class="keyword">return</span> huffmanCodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 传入结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code 路径： 左子结点是 0, 右子结点 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line"><span class="comment">//将code加入到stringBuilder2</span></span><br><span class="line">stringBuilder2.append(code);</span><br><span class="line"><span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123; <span class="comment">//如果node == null 就不处理</span></span><br><span class="line"><span class="comment">//判断当前node 是叶子结点还是非叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (node.data == <span class="keyword">null</span>) &#123;<span class="comment">//data为空 就说明是非叶子结点 </span></span><br><span class="line"><span class="comment">//递归处理</span></span><br><span class="line"><span class="comment">//向左</span></span><br><span class="line">getCodes(node.left, <span class="string">"0"</span>, stringBuilder2);</span><br><span class="line"><span class="comment">//向右递归</span></span><br><span class="line">getCodes(node.right, <span class="string">"1"</span>, stringBuilder2);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//说明是一个叶子结点</span></span><br><span class="line"><span class="comment">//就表示找到了某个叶子结点的最后</span></span><br><span class="line">huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组"><a href="#4-根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组" class="headerlink" title="4.根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组"></a>4.根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</h3><p>举例： String content = “i like like like java do you like a java”; =》 byte[] contentBytes = content.getBytes();<br>      返回的是 字符串 “1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100”<br>      =&gt; 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes<br>      huffmanCodeBytes[0] =  10101000(补码) =&gt; byte  [推导  10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ]<br>      huffmanCodeBytes[1] = -88</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 原始的字符串对应的 byte[]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanCodes 生成的赫夫曼编码map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回赫夫曼编码处理后的 byte[] </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes,Map&lt;Byte, String&gt; huffmanCodes)&#123;</span><br><span class="line"><span class="comment">//1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">byte</span> b: bytes)&#123;</span><br><span class="line">stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将 "1010100010111111110..." 转成 byte[]</span></span><br><span class="line"><span class="comment">//统计返回 的byte[] huffmanCodeBytes 长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">len = stringBuilder.length()/<span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length();i+=<span class="number">8</span>)&#123;<span class="comment">//每8位 对应一个byte 所以步长为8</span></span><br><span class="line">String strByte;</span><br><span class="line"><span class="keyword">if</span>(i+<span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">strByte = stringBuilder.substring(i);<span class="comment">//取到最后</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Integer.parseInt(String s,int radix)返回的结果是一个十进制数</span></span><br><span class="line">huffmanCodeBytes[index] = (<span class="keyword">byte</span>) Integer.parseInt(strByte,<span class="number">2</span>);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-编码封装"><a href="#5-编码封装" class="headerlink" title="5.编码封装"></a>5.编码封装</h3><p>将前面几步封装成一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用一个方法，将前面的方法封装起来，便于我们的调用.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是经过 赫夫曼编码处理后的字节数组(压缩后的数组)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line"><span class="comment">//根据 nodes 创建的赫夫曼树</span></span><br><span class="line">Node huffmanTreeRoot = createHuffmanTree(nodes);</span><br><span class="line"><span class="comment">//对应的赫夫曼编码(根据 赫夫曼树)</span></span><br><span class="line">Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line"><span class="comment">//根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line"><span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据解压"><a href="#数据解压" class="headerlink" title="数据解压"></a>数据解压</h2><p>使用赫夫曼编码来解码数据，具体要求是</p><p>1) 前面我们得到了赫夫曼编码和对应的编码 byte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]<br>2) 现在要求使用赫夫曼编码， 进行解码，又重新得到原来的字符串”i like like like java do you like a java”<br>3) 思路：解码过程，就是编码的一个逆向操作。<br>4) 代码实现</p><h3 id="1-将一个byte-转成一个二进制的字符串"><a href="#1-将一个byte-转成一个二进制的字符串" class="headerlink" title="1.将一个byte 转成一个二进制的字符串"></a>1.将一个byte 转成一个二进制的字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 传入的 byte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是该b 对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToBitString</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用变量保存 b</span></span><br><span class="line"><span class="keyword">int</span> temp = b; <span class="comment">//将 b 转成 int</span></span><br><span class="line"><span class="comment">//如果是正数我们还存在补高位</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">temp |= <span class="number">256</span>; <span class="comment">//按位或256  1 0000 0000  | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">&#125;</span><br><span class="line">String str = Integer.toBinaryString(temp);<span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line"><span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-编写一个方法，完成对压缩数据的解码"><a href="#2-编写一个方法，完成对压缩数据的解码" class="headerlink" title="2.编写一个方法，完成对压缩数据的解码"></a>2.编写一个方法，完成对压缩数据的解码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个方法，完成对压缩数据的解码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表 map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte,String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line"><span class="comment">//1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//将byte数组转成二进制的字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line"><span class="keyword">byte</span> b = huffmanBytes[i];</span><br><span class="line"><span class="comment">//判断是不是最后一个字节</span></span><br><span class="line"><span class="keyword">boolean</span> flag = (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把字符串按照指定的赫夫曼编码进行解码</span></span><br><span class="line"><span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a</span></span><br><span class="line">Map&lt;String, Byte&gt;  map = <span class="keyword">new</span> HashMap&lt;String,Byte&gt;();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Byte, String&gt; entry: huffmanCodes.entrySet()) &#123;</span><br><span class="line">map.put(entry.getValue(), entry.getKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建要给集合，存放byte</span></span><br><span class="line">List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//i 可以理解成就是索引,扫描 stringBuilder </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; stringBuilder.length();)&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">//小的计数器</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">Byte b= <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (flag) &#123;</span><br><span class="line"><span class="comment">//取出一个 '1' '0'</span></span><br><span class="line">String key = stringBuilder.substring(i,i+count);<span class="comment">//i不动 count移动 直到匹配到一个字符</span></span><br><span class="line">b = map.get(key);</span><br><span class="line"><span class="keyword">if</span>(b == <span class="keyword">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">count++;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//匹配到</span></span><br><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">list.add(b);</span><br><span class="line">i +=count; <span class="comment">//i 直接移动到 count</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当for循环结束后，我们list中就存放了所有的字符  "i like like like java do you like a java"</span></span><br><span class="line"><span class="comment">//把list 中的数据放入到byte[] 并返回</span></span><br><span class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; b.length; i++) &#123;</span><br><span class="line">b[i] = list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h2><p>我们学习了通过赫夫曼编码对一个字符串进行编码和解码, 下面我们来完成对文件的压缩和解压， 具体要求：<br>给你一个图片文件，要求对其进行无损压缩, 看看压缩效果如何。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写方法，将一个文件进行压缩</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String srcFile, String dstFile)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建输出流</span></span><br><span class="line">OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 创建文件的输入流</span></span><br><span class="line">FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建文件的输入流</span></span><br><span class="line">is = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line"><span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">is.read(b);</span><br><span class="line"><span class="comment">//直接对源文件压缩</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line"><span class="comment">//创建文件的输出流, 存放压缩文件</span></span><br><span class="line">os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line"><span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line"><span class="comment">//把 赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">oos.writeObject(huffmanBytes); </span><br><span class="line"><span class="comment">//这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line"><span class="comment">//注意一定要把赫夫曼编码 写入压缩文件</span></span><br><span class="line">oos.writeObject(huffmanCodes);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">is.close();</span><br><span class="line">oos.close();</span><br><span class="line">os.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件解压-文件恢复"><a href="#文件解压-文件恢复" class="headerlink" title="文件解压(文件恢复)"></a>文件解压(文件恢复)</h2><p>具体要求：将前面压缩的文件，重新恢复成原来的文件。</p><p>1) 思路：读取压缩文件(数据和赫夫曼编码表)-&gt; 完成解压(文件恢复)<br>2) 代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个方法，完成对压缩文件的解压</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义文件输入流</span></span><br><span class="line">FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 定义一个对象输入流</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 定义文件的输出流</span></span><br><span class="line">OutputStream os = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建文件输入流</span></span><br><span class="line">is = <span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line"><span class="comment">//创建一个和  is关联的对象输入流</span></span><br><span class="line">ois = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line"><span class="comment">//读取byte数组  huffmanBytes</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanBytes = (<span class="keyword">byte</span>[])ois.readObject();</span><br><span class="line"><span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line"><span class="comment">//将bytes 数组写入到目标文件</span></span><br><span class="line">os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line"><span class="comment">//写数据到 dstFile 文件</span></span><br><span class="line">os.write(bytes);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">os.close();</span><br><span class="line">ois.close();</span><br><span class="line">is.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e2.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-赫夫曼树</title>
      <link href="/2020/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2020/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol><li>给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，<strong>若该树的带权路径长度(wpl) 达到最小</strong>，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</li><li>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近</li></ol><h2 id="赫夫曼树几个重要概念和举例说明"><a href="#赫夫曼树几个重要概念和举例说明" class="headerlink" title="赫夫曼树几个重要概念和举例说明"></a>赫夫曼树几个重要概念和举例说明</h2><ol><li><strong>路径和路径长度</strong>：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。<strong>通路中分支的数目称为路径长度</strong>。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1</li><li><strong>结点的权及带权路径长度</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。 <strong>结</strong><br><strong>点的带权路径长度为</strong>：从根结点到该结点之间的路径长度与该结点的权的乘积</li><li>树的带权路径长度：树的带权路径长度规定为 <strong>所有叶子结点的带权路径长度之和</strong>，<strong>记为 WPL</strong>(weighted path<br>length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</li><li><strong>WPL 最小的就是赫夫曼树</strong></li></ol><p><img data-src="1.png" alt="1.png"></p><h2 id="赫夫曼树创建思路图解"><a href="#赫夫曼树创建思路图解" class="headerlink" title="赫夫曼树创建思路图解"></a>赫夫曼树创建思路图解</h2><p>给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树.</p><p><strong>构成赫夫曼树的步骤：</strong></p><ol><li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li><li>取出根节点权值最小的两颗二叉树</li><li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</li><li>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数<br>据都被处理，就得到一颗赫夫曼树</li><li>图解:</li></ol><p>如何构建一颗 赫夫曼树的步骤</p><p>数组： 13, 7, 8, 3, 29, 6, 1</p><p>排序后：1,3, 6, 7, 8, 13, 29 </p><h3 id="1-挑出-1-和-3-组成新的二叉树"><a href="#1-挑出-1-和-3-组成新的二叉树" class="headerlink" title="1.挑出 1 和 3 组成新的二叉树"></a>1.挑出 1 和 3 组成新的二叉树</h3><p><img data-src="2.png" alt="2.png"></p><p>数组还剩 4,6,7,8,13,29</p><h3 id="2-挑出-4-和-6-组成新的二叉树"><a href="#2-挑出-4-和-6-组成新的二叉树" class="headerlink" title="2.挑出 4 和 6 组成新的二叉树"></a>2.挑出 4 和 6 组成新的二叉树</h3><p><img data-src="3.png" alt="3.png"></p><p>数组还剩 7,8,10,13,29</p><h3 id="3-挑出-7-和-8-组成新的二叉树"><a href="#3-挑出-7-和-8-组成新的二叉树" class="headerlink" title="3.挑出 7 和 8 组成新的二叉树"></a>3.挑出 7 和 8 组成新的二叉树</h3><p><img data-src="4.png" alt="4.png"></p><p>数组还剩 10,13,15,29</p><h3 id="4-挑出-10-和-13-组成新的二叉树"><a href="#4-挑出-10-和-13-组成新的二叉树" class="headerlink" title="4.挑出 10 和 13 组成新的二叉树"></a>4.挑出 10 和 13 组成新的二叉树</h3><p><img data-src="5.png" alt="5.png"></p><p>数组还剩 15,23,29</p><h3 id="5-挑出-15-和-23-组成新的二叉树"><a href="#5-挑出-15-和-23-组成新的二叉树" class="headerlink" title="5.挑出 15 和 23 组成新的二叉树"></a>5.挑出 15 和 23 组成新的二叉树</h3><p><img data-src="6.png" alt="6.png"></p><p>数组还剩  29,38</p><h3 id="6-挑出-29-和-38-组成新的二叉树"><a href="#6-挑出-29-和-38-组成新的二叉树" class="headerlink" title="6.挑出 29 和 38 组成新的二叉树"></a>6.挑出 29 和 38 组成新的二叉树</h3><p><img data-src="7.png" alt="7.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span> &#125;;</span><br><span class="line">Node root = createHuffmanTree(arr);</span><br><span class="line">preOrder(root); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个前序遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.preOrder();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"是空树，不能遍历~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建赫夫曼树的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 需要创建成哈夫曼树的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 创建好后的赫夫曼树的root结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 第一步为了操作方便</span></span><br><span class="line"><span class="comment">// 1. 遍历 arr 数组</span></span><br><span class="line"><span class="comment">// 2. 将arr的每个元素构成成一个Node</span></span><br><span class="line"><span class="comment">// 3. 将Node 放入到ArrayList中</span></span><br><span class="line">List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> value : arr)&#123;</span><br><span class="line">nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后只有根节点</span></span><br><span class="line"><span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//排序 从小到大</span></span><br><span class="line">Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出根节点权值最小的两颗二叉树 </span></span><br><span class="line"><span class="comment">//(1) 取出权值最小的结点（二叉树）</span></span><br><span class="line">Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//(2) 取出权值第二小的结点（二叉树）</span></span><br><span class="line">Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//(3)构建一颗新的二叉树</span></span><br><span class="line">Node parent = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line">parent.left = leftNode;</span><br><span class="line">parent.right = rightNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">nodes.remove(leftNode);</span><br><span class="line">nodes.remove(rightNode);</span><br><span class="line"><span class="comment">//(5)将parent加入到nodes</span></span><br><span class="line">nodes.add(parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回哈夫曼树的root结点</span></span><br><span class="line"><span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建结点类</span></span><br><span class="line"><span class="comment">//为了让Node 对象持续排序Collections集合排序</span></span><br><span class="line"><span class="comment">//让Node 实现Comparable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value; <span class="comment">// 结点权值</span></span><br><span class="line"><span class="keyword">char</span> c; <span class="comment">//字符</span></span><br><span class="line">Node left; <span class="comment">// 指向左子结点</span></span><br><span class="line">Node right; <span class="comment">// 指向右子结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写一个前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//表示从小到大排序</span></span><br><span class="line"><span class="comment">//如果指定的数与参数相等返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果指定的数小于参数返回 -1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果指定的数大于参数返回 1。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.value - o.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-堆排序</title>
      <link href="/2020/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序基本介绍"><a href="#堆排序基本介绍" class="headerlink" title="堆排序基本介绍"></a>堆排序基本介绍</h2><p>1) 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复<br>杂度均为 <strong>O(nlogn)</strong>，它也是不稳定排序。</p><p>2) 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有<br>要求结点的左孩子的值和右孩子的值的大小关系。</p><p>3) 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p><p>4) 大顶堆举例说明</p><p><img data-src="1.png" alt="1.png"></p><p>5) 小顶堆举例说明</p><p><img data-src="2.png" alt="2.png"></p><p>6) 一般升序采用大顶堆，降序采用小顶堆</p><h2 id="堆排序基本思想"><a href="#堆排序基本思想" class="headerlink" title="堆排序基本思想"></a>堆排序基本思想</h2><p><strong>堆排序的基本思想是：</strong></p><ol><li>将待排序序列构造成一个大顶堆</li><li>此时，整个序列的最大值就是堆顶的根节点。</li><li>将其与末尾元素进行交换，此时末尾就为最大值。</li><li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。</li></ol><p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p><h2 id="堆排序步骤图解说明"><a href="#堆排序步骤图解说明" class="headerlink" title="堆排序步骤图解说明"></a>堆排序步骤图解说明</h2><p>要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。</p><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p>构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。原始的数组 [4, 6, 8, 5, 9]</p><p>1) .假设给定无序序列结构如下</p><p><img data-src="3.png" alt="3.png"></p><p>2) .此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点,arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。</p><p><img data-src="4.png" alt="4.png"></p><p>3) .找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。</p><p><img data-src="5.png" alt="5.png"></p><p>4) 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。</p><p><img data-src="6.png" alt="6.png"></p><p>此时，我们就将一个无序序列构造成了一个大顶堆。</p><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p>将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</p><p>1) .将堆顶元素 9 和末尾元素 4 进行交换</p><p><img data-src="7.png" alt="7.png"></p><p>2) .重新调整结构，使其继续满足堆定义</p><p><img data-src="8.png" alt="8.png"></p><p>3) .再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.</p><p><img data-src="9.png" alt="9.png"></p><p>4) 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p><p><img data-src="10.png" alt="10.png"></p><h2 id="再简单总结下堆排序的基本思路："><a href="#再简单总结下堆排序的基本思路：" class="headerlink" title="再简单总结下堆排序的基本思路："></a>再简单总结下堆排序的基本思路：</h2><p>1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p><p>2).将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</p><p>3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，<br>直到整个序列有序。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//要求将数组进行升序排序</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">heapSort(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个堆排序的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">System.out.println(<span class="string">"堆排序!!"</span>);</span><br><span class="line"><span class="comment">//1.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> -<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;<span class="comment">//第一个非叶子结点 =arr.length/2-1</span></span><br><span class="line">adjustHeap(arr, i, arr.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</span></span><br><span class="line"><span class="comment">//3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length-<span class="number">1</span>; j&gt;<span class="number">0</span> ; j--)&#123;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = temp;</span><br><span class="line">adjustHeap(arr, <span class="number">0</span>, j); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"数组="</span> + Arrays.toString(arr)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将一个数组(二叉树), 调整成一个大顶堆</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆</span></span><br><span class="line"><span class="comment"> * 举例  int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 &#123;4, 9, 8, 5, 6&#125;</span></span><br><span class="line"><span class="comment"> * 如果我们再次调用  adjustHeap 传入的是 i = 0 =&gt;  &#123;4, 9, 8, 5, 6&#125; =&gt; adjustHeap =&gt; &#123;9,6,8,5, 4&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待调整的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 表示非叶子结点在数组中索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 表示对多少个元素继续调整， length 是在逐渐的减少</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先取出当前元素的值，保存在临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="comment">//开始调整</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. k = i * 2 + 1 k 是 i结点的左子结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k = k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (k+<span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k+<span class="number">1</span>]) &#123;<span class="comment">//说明左子节点的值小于右子节点的值</span></span><br><span class="line">k++;<span class="comment">//k指向右子节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[k] &gt; temp) &#123; <span class="comment">//如果子节点大于父节点  将最大的放到顶部</span></span><br><span class="line">arr[i] = arr[k];<span class="comment">//把较大的值赋给当前结点</span></span><br><span class="line">i = k;<span class="comment">//!!! i 指向 k,继续循环比较</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部调成大顶堆)</span></span><br><span class="line">arr[i] = temp;<span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8000000条数据 2 秒</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-线索化二叉树</title>
      <link href="/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="线索二叉树基本介绍"><a href="#线索二叉树基本介绍" class="headerlink" title="线索二叉树基本介绍"></a>线索二叉树基本介绍</h2><ol><li>n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向<br>该结点在<strong>某种遍历次序下</strong>的前驱和后继结点的指针（这种附加的指针称为”线索”）</li><li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</li><li>一个结点的前一个结点，称为<strong>前驱</strong>结点</li><li>一个结点的后一个结点，称为<strong>后继</strong>结点</li></ol><h2 id="线索二叉树应用案例"><a href="#线索二叉树应用案例" class="headerlink" title="线索二叉树应用案例"></a>线索二叉树应用案例</h2><p>应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}</p><p><img data-src="1.png" alt="1.png"></p><p><strong>思路分析:</strong> 中序遍历的结果：{8, 3, 10, 1, 14, 6}</p><p><img data-src="2.png" alt="2.png"></p><p>说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:</p><p>1) left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的<br>就是前驱节点.</p><p>2) right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向<br>的是后继节点.</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试一把中序线索二叉树的功能</span></span><br><span class="line">HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"tom"</span>);</span><br><span class="line">HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"jack"</span>);</span><br><span class="line">HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">"smith"</span>);</span><br><span class="line">HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">"mary"</span>);</span><br><span class="line">HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">"king"</span>);</span><br><span class="line">HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">"dim"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树，后面我们要递归创建, 现在简单处理使用手动创建</span></span><br><span class="line">root.setLeft(node2);</span><br><span class="line">root.setRight(node3);</span><br><span class="line">node2.setLeft(node4);</span><br><span class="line">node2.setRight(node5);</span><br><span class="line">node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试中序线索化</span></span><br><span class="line">ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">threadedBinaryTree.setRoot(root);</span><br><span class="line">threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试: 以10号节点测试</span></span><br><span class="line">HeroNode leftNode = node5.getLeft();</span><br><span class="line">HeroNode rightNode = node5.getRight();</span><br><span class="line">System.out.println(<span class="string">"10号结点的前驱结点是 ="</span> + leftNode); <span class="comment">// 3</span></span><br><span class="line">System.out.println(<span class="string">"10号结点的后继结点是="</span> + rightNode); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当线索化二叉树后，能在使用原来的遍历方法</span></span><br><span class="line"><span class="comment">// threadedBinaryTree.infixOrder();</span></span><br><span class="line">System.out.println(<span class="string">"使用线索化的方式遍历 线索化二叉树"</span>);</span><br><span class="line">threadedBinaryTree.threadedList(); <span class="comment">// 8, 3, 10, 1, 14, 6</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义ThreadedBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了实现线索化，需要创建要给指向当前结点的前驱结点的指针</span></span><br><span class="line"><span class="comment">//在递归进行线索化时，pre 总是保留前一个结点</span></span><br><span class="line"><span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载一把threadedNodes方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.threadedNodes(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历线索化二叉树的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line">HeroNode node = root;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 循环的找到leftType == 1的结点，第一个找到就是8结点</span></span><br><span class="line"><span class="comment">// 后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化</span></span><br><span class="line"><span class="comment">// 处理后的有效结点</span></span><br><span class="line"><span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">node = node.getLeft();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印当前这个结点</span></span><br><span class="line">System.out.println(node);</span><br><span class="line"><span class="comment">// 如果当前结点的右指针指向的是后继结点,就一直输出</span></span><br><span class="line"><span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 获取到当前结点的后继结点</span></span><br><span class="line">node = node.getRight();</span><br><span class="line">System.out.println(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 替换这个遍历的结点</span></span><br><span class="line">node = node.getRight();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写对二叉树进行中序线索化的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 就是当前需要线索化的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果node==null, 不能线索化</span></span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(一)先线索化左子树</span></span><br><span class="line">threadedNodes(node.getLeft());</span><br><span class="line"><span class="comment">//(二)线索化当前结点[有难度]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理当前结点的前驱结点</span></span><br><span class="line"><span class="comment">//以8结点来理解 8没有前驱节点，所以为空</span></span><br><span class="line"><span class="comment">//8结点的.left = null , 8结点的.leftType = 1</span></span><br><span class="line"><span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//让当前结点的左指针指向前驱结点 </span></span><br><span class="line">node.setLeft(pre); </span><br><span class="line"><span class="comment">//修改当前结点的左指针的类型,指向前驱结点</span></span><br><span class="line">node.setLeftType(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理后继结点</span></span><br><span class="line"><span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//让前驱结点的右指针指向当前结点</span></span><br><span class="line">pre.setRight(node);</span><br><span class="line"><span class="comment">//修改前驱结点的右指针类型</span></span><br><span class="line">pre.setRightType(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">pre = node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(三)在线索化右子树</span></span><br><span class="line">threadedNodes(node.getRight());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点</span></span><br><span class="line"><span class="comment">//2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> leftType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rightType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.left = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-顺序存储二叉树</title>
      <link href="/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="顺序存储二叉树的概念"><a href="#顺序存储二叉树的概念" class="headerlink" title="顺序存储二叉树的概念"></a>顺序存储二叉树的概念</h2><h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><p>从数据存储来看，数组存储方式和树的存储方式可以相互转换，即 <strong>数组可以转换成树， 树也可以转换成数组</strong>，<br>看下面的示意图。</p><p><img data-src="1.png" alt="1.png"></p><h3 id="要求"><a href="#要求" class="headerlink" title="要求:"></a>要求:</h3><p>1) 右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]<br>2) 要求在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历</p><h3 id="顺序存储二叉树的特点"><a href="#顺序存储二叉树的特点" class="headerlink" title="顺序存储二叉树的特点:"></a>顺序存储二叉树的特点:</h3><p>1) 顺序二叉树通常只考虑完全二叉树<br><strong>2) 第 n 个元素的左子节点为 2 * n + 1</strong><br><strong>3) 第 n 个元素的右子节点为 2 * n + 2</strong><br><strong>4) 第 n 个元素的父节点为 (n-1) / 2</strong><br>5) n : 表示二叉树中的第几个元素(按 <strong>0</strong> 开始编号如图所示)</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求:"></a>需求:</h3><p> 给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为<br>1,2,4,5,3,6,7</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="comment">//创建一个 ArrBinaryTree</span></span><br><span class="line">ArrBinaryTree arrBinaryTree = <span class="keyword">new</span> ArrBinaryTree(arr);</span><br><span class="line">arrBinaryTree.preOrder(); <span class="comment">// 1,2,4,5,3,6,7</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个ArrBinaryTree, 实现顺序存储二叉树遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTree</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存储数据结点的数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.arr = arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载preOrder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个方法，完成顺序存储二叉树的前序遍历</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 数组的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果数组为空，或者 arr.length = 0</span></span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length ==<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"数组为空，不能按照二叉树的前序遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出当前这个元素</span></span><br><span class="line">System.out.println(arr[index]);</span><br><span class="line"><span class="comment">//向左递归遍历</span></span><br><span class="line"><span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">preOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向右递归遍历</span></span><br><span class="line"><span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList主要方法和扩容机制</title>
      <link href="/2020/04/09/ArrayList%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/04/09/ArrayList%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList简介："><a href="#ArrayList简介：" class="headerlink" title="ArrayList简介："></a>ArrayList简介：</h2><p>  ArrayList实现了List接口它是一个可调整大小的数组可以用来存放各种形式的数据。并提供了包括CRUD在内的多种方法可以对数据进行操作但是它不是线程安全的，外ArrayList按照插入的顺序来存放数据。</p><h3 id="ArrayList的主要成员变量："><a href="#ArrayList的主要成员变量：" class="headerlink" title="ArrayList的主要成员变量："></a>ArrayList的主要成员变量：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//数组默认初始容量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//定义一个空的数组实例以供其他需要用到空数组的地方调用 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//定义一个空数组，跟前面的区别就是这个空数组是用来判断ArrayList第一添加数据的时候要扩容多少。默认的构造器情况下返回这个空数组 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;<span class="comment">//数据存的地方它的容量就是这个数组的长度，同时只要是使用默认构造器（DEFAULTCAPACITY_EMPTY_ELEMENTDATA ）第一次添加数据的时候容量扩容为DEFAULT_CAPACITY = 10 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//当前数组的长度</span></span><br></pre></td></tr></table></figure><h3 id="ArrayList的构造方法有三种："><a href="#ArrayList的构造方法有三种：" class="headerlink" title="ArrayList的构造方法有三种："></a>ArrayList的构造方法有三种：</h3><p><img data-src="1.png" alt="1.png"></p><p>第一个构造方法用来返回一个初始容量为10的数组（具体过程后面会提到），第二个用来生成一个带数据的ArrayList这边不再赘述，第三个构造方法就是自定义初始容量。下面我将根据默认的构造方法来展开下文。</p><p>可以看到默认的构造器就是用了参数DEFAULTCAPACITY_EMPTY_ELEMENTDATA返回了一个空的数组，所以这边我们可以了解到ArrayList在创建的时候如果没有指定初始容量的话就会返回一个长度为0的空数组。下面我想从ArrayList的扩容机制开始解析，因为在所有添加数据的操作上面都要需要判断当前数组容量是否足以容纳新的数据，如果不够的话就需要进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="扩容机制："><a href="#扩容机制：" class="headerlink" title="扩容机制："></a>扩容机制：</h2><p>ArrayList扩容的核心从ensureCapacityInternal方法说起。可以看到前面介绍成员变量的提到的ArrayList有两个默认的空数组：</p><p><strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA：</strong>是用来使用默认构造方法时候返回的空数组。如果第一次添加数据的话那么数组扩容长度为DEFAULT_CAPACITY=10。</p><p><strong>EMPTY_ELEMENTDATA：</strong>出现在需要用到空数组的地方，其中一处就是使用自定义初始容量构造方法时候如果你指定初始容量为0的时候就会返回。</p><p>从下面可以看到如果是使用了空数组EMPTY_ELEMENTDATA话，那么不会返回默认的初始容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断当前数组是否是默认构造方法生成的空数组，如果是的话minCapacity=10反之则根据原来的值传入下一个方法去完成下一步的扩容判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//minCapacitt表示修改后的数组容量，minCapacity = size + 1 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断看看是否需要扩容</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面谈谈ensureExplicitCapacity方法（modCount设计到Java的快速报错机制后面会谈到），可以看到如果修改后的数组容量大于当前的数组长度那么就需要调用grow进行扩容，反之则不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//判断当前ArrayList是否需要进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快速报错机制</span></span><br><span class="line">    modCount++;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后看下ArrayList扩容的核心方法grow()，下面将针对三种情况对该方法进行解析：</p><ol><li>当前数组是由默认构造方法生成的空数组并且第一次添加数据。此时minCapacity等于默认的容量（10）那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。而后的数组扩容才是按照当前容量的1.5倍进行扩容；</li><li>当前数组是由自定义初始容量构造方法创建并且指定初始容量为0。此时minCapacity等于1那么根据下面逻辑可以看到最后数组的容量会从0变成1。这边可以看到一个严重的问题，一旦我们执行了初始容量为0，那么根据下面的算法前四次扩容每次都 +1，在第5次添加数据进行扩容的时候才是按照当前容量的1.5倍进行扩容。</li><li>当扩容量（newCapacity）大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值（溢出为负数）那么抛出OutOfMemoryError（内存溢出）否则的话根据与MAX_ARRAY_SIZE的比较情况确定是返回Integer最大值还是MAX_ARRAY_SIZE。这边也可以看到ArrayList允许的最大容量就是Integer的最大值（-2的31次方~2的31次方减1）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList扩容的核心方法，此方法用来决定扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h2 id="Java容器的快速报错机制ConcurrentModificationException："><a href="#Java容器的快速报错机制ConcurrentModificationException：" class="headerlink" title="Java容器的快速报错机制ConcurrentModificationException："></a>Java容器的快速报错机制ConcurrentModificationException：</h2><p>Java容器有一种保护机制，能够防止多个进程同时修改同一个容器的内容。如果你在迭代遍历某个容器的过程中，另一个进程介入其中，并且插入，删除或修改此容器的某个对象，就会立刻抛出ConcurrentModificationException。</p><p>前文提到的迭代遍历指的就是使用迭代器Iterator(ListIterator)或者forEach语法，实际上一个类要使用forEach就必须实现Iterable接口并且重写它的Iterator方法所以forEach本质上还是使用Iterator。</p><p><img data-src="2.png" alt="2.png"></p><p> 从下面方法可以看到在迭代遍历的过程中都调用了方法checkForComodification来判断当前ArrayList是否是同步的。现在来举一个栗子，假设你往一个Integer类型的ArrayList插入了10条数据，那么每操作一次modCount（继承自父类AbstractList）就加一所以就变成10，而当你对这个集合进行遍历的时候就把modCount传到expectedModCount这个变量里，然后ArrayList在checkForComodification中通过判断两个变量是否相等来确认当前集合是否是同步的，如果不同步就抛出ConcurrentModificationException。所谓的不同步指的就是，如果你在遍历的过程中对ArrayList集合本身进行add,remove等操作时候就会发生。当然如果你用的是Iterator那么使用它的remove是允许的因为此时你直接操作的不是ArrayList集合而是它的Iterator对象。在代码后面将贴出前面提到的三种情况。此外在多线程也会存在这种情况，但是如果你在多线程中使用CopyOnWriteArrayList就可以避免了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// 下一个要返回的索引</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 返回最后一个元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">//防止篇幅过长省去了其中代码</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//防止篇幅过长省去其中代码</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一种情况使用Iterator：</strong></p><p><img data-src="3.png" alt="3.png"></p><p><strong>第二种情况使用forEach：</strong></p><p><img data-src="4.png" alt="4.png"></p><p><strong>第三种情况使用Iterator自身删除数据：</strong></p><p><img data-src="5.png" alt="5.png"></p><h2 id="ArrayList的主要方法："><a href="#ArrayList的主要方法：" class="headerlink" title="ArrayList的主要方法："></a>ArrayList的主要方法：</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p><img data-src="6.png" alt="6.png"></p><p><strong>1.add(E e)</strong></p><p>​    从add(E e)方法可以看到每次添加数据ArrayList都会先调用ensureCapacityInternal来判断是否需要扩容，接着再插入数据并且每次末尾插入，所以ArrayList是按插入的顺序排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.add(int index,E element)</strong></p><p>add(int index,E element)与前面的add只多了一个参数index，index表示你要插入的位置。此时会先判断是否会出现数组越界，然后再调用ensureCapacityInternal方法紧接着可以看到调用了System.arraycopy方法来进行操作因为该方法为本地方法（native）所以并不是用Java来实现的。根据这个方法的参数解释我们可以了解到ArrayList每次指定位置添加数据的时候都会进行数组的复制，复制的过程为把相对于当前插入位置（index）后面的数据都向后移动一位（如下图所示）。因此我们说ArrayList在对数据的插入上效率比较差，随着数据量的增大花费的时间越多。这也是我们常说的ArrayList在随机插入数据的效率上比不上LinkedList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index表示element要插入的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断插入的位置是否当前数组长度或是小于0,是的话会抛出IndexOutOfBoundsException</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"> </span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//每一次插入数据都要把相对于当前index后面的数据向后移动一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*src - 源数组</span></span><br><span class="line"><span class="comment">  srcPos - 源数组中的起始位置 </span></span><br><span class="line"><span class="comment">  dest - 目标数组</span></span><br><span class="line"><span class="comment">  destPos - 目的地数据中的起始位置</span></span><br><span class="line"><span class="comment">  length - 要复制的数组元素的数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,  <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p><img data-src="7.png" alt="7.png"></p><p><strong>3.addAll(Collection&lt;? extends E&gt; c)</strong></p><p>下面看看addAll的两个方法。首先可以看到接受的参数对象为一个集合类型。如果你试图把跟当前类型不同的集合添加进来的话有两种情况会发生：</p><p><strong>第一种</strong>：如果你用了泛型，那么你在试图把Integer的类型的集合addAll到String类型的集合中就会在编译器抛出错误信息。</p><p><strong>第二种：</strong>如果你不使用泛型（Object），那么你可以在一个String类型的集合中，放入Integer，类对象等等。但是当你遍历ArrayList集合要取出当中的数据进行操作的时候，除非你每次强制转换都正确，不然就会抛出ClassCastException。所以这也是使用泛型的一个好处之一吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.addAll(int index, Collection&lt;? extends E&gt; c)</strong></p><p>接下来可以看到addAll方法也提供了一个随机插入的方法。这跟前文提到的add大相径庭这边就不再赘述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"> </span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"> </span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p><img data-src="8.png" alt="8.png"></p><p>可以看到jdk1.8新增了一个方法removeIf (实现Collection接口),下面将按照顺序来依次解析。</p><p>​    <strong>1.remobe(int index)</strong></p><p>很明显remove在删除的时候也用了System的本地方法arraycopy，跟前文add不同的是它把相对于插入位置的后几位数据全部向前移动一位并且，此外该方法会返回被删掉的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//防止数组越界</span></span><br><span class="line">    </span><br><span class="line">    modCount++;<span class="comment">//用于快速报错机制</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work 消除过期对象的引用</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>2.remove(Object o)</strong></p><p>接着看看ArrayLsit对Object对象的remove，从方法中可以看到ArrayList在对Object对象删除操作上区分开了Null，重点要注意的是在对非空对象进行删除的时候ArrayList是调用了equals来匹配数组中的数据。也就是说<strong>如果你的集合（不局限于ArrayList）是对类进行操作，而你的类没有重写hashCode以及equals，那么你通过该方法来删除数据都是无法成功的，总之如果你要在集合中对类对象进行操作就需要重写上述的两个方法。此外就算你ArrayList中存有多个相同的Obejct对象，执行该方法也只会删除一次。</strong>或许有人会有疑问，既然使用equals那直接重写equals不就好了何必跟着重写hashCode呢？答案是如果你只重写equals是可以完成删除操作，但是你重写equals没有重写hashCode那么你在使用散列数据结构HashMap，HashSet对该类进行操作的话会出错（jdk1.8 HashMap工作原理(Get,Put)和扩容机制）。而<strong>在Object规范中提到的第二点要求就是如果两个对象经过equals比较后相同，那么他们的hashCode一定相同。所以这就是为什么要hashCode跟euqals两者同时重写。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//对传进来的对象进行区分处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">             <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 fastRemove(index);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//只删除一次就返回</span></span><br><span class="line">             &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">             <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                 fastRemove(index);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work 消除过期对象的引用</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从测试用例可以看到，如果我们的对象没有重写hashCode以及equals的话，那么是没有办法完成操作的。因为每一次创建的对象他们的首地址都是不同的，那么在remove的时候ArrayList就会匹配不到。</p><p><img data-src="9.png" alt="9.png"></p><p> 如果当我们对类进行hashCode以及equals重写之后可以看到，以及可以正常删除数据。这边可涉及到hashCode以及equals的重写规范在此处不再赘述。</p><p><img data-src="10.png" alt="10.png"></p><p><strong>3.removeAll(Collection&lt;?&gt; c)</strong></p><p>可以看到removeAll是针对集合进行删除，首先会对集合参数进行NPE判断接着可以看到ArrayList通过contains方法来对两个集合数据进行循环比较。contains实际上就是调用indexOf方法而indexOf方法又是调用的equals。紧接着拿到匹配的数据进行删除，值得一提的是这个方法可以删掉所有匹配的数据，源码后面是测试用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);<span class="comment">//判空,是的话抛出空指针异常</span></span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];<span class="comment">//拿到所有c容器中跟当前ArrayList匹配的数据</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;<span class="comment">//删除</span></span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="comment">//缩减篇幅删去代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img data-src="11.png" alt="11.png"></p><p><strong>4.removeIf(Predicate&lt;? super E&gt; filter)</strong></p><p>接着看看jdk1.8中新增的方法，支持使用Lambda表达式。下面来解析一下，首先可以看到用到了BitSet，它的底层数据结构就是一个long[]数组，而long是64位的可以用来存储大的内容。所以这个方法应该也是针对需要对大量对象操作才使用的吧，不然就有点浪费空间了。源码下面是实例可以看到通过lambda表达式可以很容易的完成过滤。针对代码中调用nextClearBit这个方法就是用来返回下标索引，当中用到了一堆的移位操作符，这边就不再赘述。</p><p><img data-src="12.png" alt="12.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="comment">// figure out which elements are to be removed</span></span><br><span class="line">    <span class="comment">// any exception thrown from the filter predicate at this stage</span></span><br><span class="line">    <span class="comment">// will leave the collection unmodified</span></span><br><span class="line">    <span class="keyword">int</span> removeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> BitSet removeSet = <span class="keyword">new</span> BitSet(size);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">final</span> E element = (E) elementData[i];</span><br><span class="line">        <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">            removeSet.set(i);<span class="comment">//匹配出所有要删除的数据下标并放入BitSet中</span></span><br><span class="line">            removeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;<span class="comment">//快速报错机制</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// shift surviving elements left over the spaces left by removed elements</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> anyToRemove = removeCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newSize = size - removeCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">            i = removeSet.nextClearBit(i);</span><br><span class="line">            elementData[j] = elementData[i];<span class="comment">//覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">            elementData[k] = <span class="keyword">null</span>;  <span class="comment">// Let gc do its work</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size = newSize;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> anyToRemove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="13.png" alt="13.png"></p><p><strong>5.removeRange(int fromIndex, int toIndex)</strong></p><p>最后一种removeRange因为是protected类型的所以其他包中没有继承它的类无法直接调用，这边就不演示了。</p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p><img data-src="14.png" alt="14.png"></p><p>ArrayList就提供了set这个方法来更新数组中的数据，具体过程如此简单，不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检查IndexOutOfBoundsException</span></span><br><span class="line"> </span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p><img data-src="15.png" alt="15.png"></p><p>跟更新数据一样，ArrayList也只提供了get方法来进行数据获取。没有什么好说的，自己看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检查IndexOutOfBoundsException</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现本地缓存和分布式缓存？</title>
      <link href="/2020/04/08/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
      <url>/2020/04/08/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>缓存（Cache）是指将程序或系统中常用的数据对象存储在像内存这样特定的介质中，以避免在每次程序调用时，重新创建或组织数据所带来的性能损耗，从而提高了系统的整体运行速度。</p><p>以目前的系统架构来说，用户的请求一般会先经过缓存系统，如果缓存中没有相关的数据，就会在其他系统中查询到相应的数据并保存在缓存中，最后返回给调用方。</p><p>缓存既然如此重要，那本课时我们就来重点看一下，应该如何实现本地缓存和分布式缓存？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>本地缓存是指程序级别的缓存组件，它的特点是本地缓存和应用程序会运行在同一个进程中，所以本地缓存的操作会非常快，因为在同一个进程内也意味着不会有网络上的延迟和开销。</p><p>本地缓存适用于单节点非集群的应用场景，它的优点是快，缺点是多程序无法共享缓存，比如分布式用户Session会话信息保存，由于每次用户访问的服务器可能是不同的，如果不能共享缓存，那么就意味着每次的请求操作都有可能被系统阻止，因为会话信息只保存在某一个服务器上，当请求没有被转发到这台存储了用户信息的服务器时，就会被认为是非登录的违规操作。</p><p>除此之外，无法共享缓存可能会造成系统资源的浪费，这是因为每个系统都单独维护了一份属于自己的缓存，而同一份缓存有可能被多个系统单独进行存储，从而浪费了系统资源。</p><p><strong>分布式缓存是指将应用系统和缓存组件进行分离的缓存机制</strong>，这样多个应用系统就可以共享一套缓存数据了，它的特点是共享缓存服务和可集群部署，为缓存系统提供了高可用的运行环境，以及缓存共享的程序运行机制。本地缓存可以使用EhCache和Google的Guava来实现，而分布式缓存可以使用Redis或Memcached来实现。</p><p>由于Redis本身就是独立的缓存系统，因此可以作为第三方来提供共享的数据缓存，而Redis的分布式支持主从、哨兵和集群的模式，所以它就可以支持分布式的缓存，而Memcached的情况也是类似的。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>本课时的面试题显然不只是为了问你如何实现本地缓存和分布式缓存这么简单，主要考察的是你对缓存系统的理解，以及对缓存本质原理的洞察，和缓存相关的面试题还有这些：</p><ul><li>更加深入的谈谈 EhCache和Guava。</li><li>如何自己手动实现一个缓存系统？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-EhCache和Guava的使用及特点分析"><a href="#1-EhCache和Guava的使用及特点分析" class="headerlink" title="1.EhCache和Guava的使用及特点分析"></a>1.EhCache和Guava的使用及特点分析</h3><p>EhCache是目前比较流行的开源缓存框架，是用纯Java语言实现的简单、快速的Cache组件。</p><p>EhCache 支持内存缓存和磁盘缓存，支持LRU（Least Recently Used，最近很少使用）、LFU（Least Frequently Used，最近不常被使用）和FIFO（First In First Out，先进先出）等多种淘汰算法，并且支持分布式的缓存系统。</p><p>EhCache最初是独立的本地缓存框架组件，在后期的发展中（从1.2版）开始支持分布式缓存，分布式缓存主要支持RMI、JGroups、EhCache Server等方式。</p><h4 id="LRU和LFU的区别"><a href="#LRU和LFU的区别" class="headerlink" title="LRU和LFU的区别"></a>LRU和LFU的区别</h4><p>LRU算法有一个缺点，比如说很久没有使用的一个键值，如果最近被访问了一次，那么即使它是使用次数最少的缓存，它也不会被淘汰；而LFU算法解决了偶尔被访问一次之后，数据就不会被淘汰的问题，它是根据总访问次数来淘汰数据的，其核心思想是“如果数据过去被访问多次，那么将来它被访问次数也会比较多”。因此LFU可以理解为比LRU更加合理的淘汰算法。</p><h4 id="EhCache-基础使用"><a href="#EhCache-基础使用" class="headerlink" title="EhCache 基础使用"></a>EhCache 基础使用</h4><p>首先，需要在项目中添加EhCache框架，如果为Maven项目，则需要在pom.xml中添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.ehcache/ehcache --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>无配置参数的 EhCache 3.x 使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.ehcache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.ehcache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.ehcache.config.builders.CacheConfigurationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.ehcache.config.builders.CacheManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.ehcache.config.builders.ResourcePoolsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EhCacheExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建缓存管理器</span></span><br><span class="line">        CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build();</span><br><span class="line">        <span class="comment">// 初始化 EhCache</span></span><br><span class="line">        cacheManager.init();</span><br><span class="line">        <span class="comment">// 创建缓存（存储器）</span></span><br><span class="line">        Cache&lt;String, String&gt; myCache = cacheManager.createCache(<span class="string">"MYCACHE"</span>,</span><br><span class="line">                                                                 CacheConfigurationBuilder.newCacheConfigurationBuilder(</span><br><span class="line">                                                                     String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">ResourcePoolsBuilder</span>.<span class="title">heap</span>(10)))</span>; <span class="comment">// 设置缓存的最大容量</span></span><br><span class="line">        <span class="comment">// 设置缓存</span></span><br><span class="line">        myCache.put(<span class="string">"key"</span>, <span class="string">"Hello,Java."</span>);</span><br><span class="line">        <span class="comment">// 读取缓存</span></span><br><span class="line">        String value = myCache.get(<span class="string">"key"</span>);</span><br><span class="line">        <span class="comment">// 输出缓存</span></span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">// 关闭缓存</span></span><br><span class="line">        cacheManager.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>CacheManager：是缓存管理器，可以通过单例或者多例的方式创建，也是Ehcache的入口类；</li><li>Cache：每个CacheManager 可以管理多个Cache，每个Cache 可以采用hash的方式存储多个元素。</li></ul><p>它们的关系如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p>更多使用方法，<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=59#/detail/pc?id=1769" target="_blank" rel="noopener">请参考官方文档</a></p><p>EhCache的特点是，它使用起来比较简单，并且本身的jar包不是不大，简单的配置之后就可以正常使用了。EhCache的使用比较灵活，它支持多种缓存策略的配置，它同时支持内存和磁盘缓存两种方式，在EhCache1.2之后也开始支持分布式缓存了。</p><p>Guava Cache是Google 开源的Guava里的一个子功能，它是一个内存型的本地缓存实现方案，提供了线程安全的缓存操作机制。</p><p>Guava Cache 的架构设计灵感来源于ConcurrentHashMap，它使用了多个segments方式的细粒度锁，在保证线程安全的同时，支持了高并发的使用场景。Guava Cache 类似于Map集合的方式对键值对进行操作，只不过多了过期淘汰等处理逻辑。</p><p>在使用 Guava Cache 之前，我们需要先在 pom.xml 中添加 Guava 框架，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.2-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Guava Cache 的创建有两种方式，一种是 LoadingCache，另一种是 Callable，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.cache.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建方式一：LoadingCache</span></span><br><span class="line">        LoadingCache&lt;String, String&gt; loadCache = CacheBuilder.newBuilder()</span><br><span class="line">            <span class="comment">// 并发级别设置为 5，是指可以同时写缓存的线程数</span></span><br><span class="line">                .concurrencyLevel(<span class="number">5</span>)</span><br><span class="line">            <span class="comment">// 设置 8 秒钟过期</span></span><br><span class="line">                .expireAfterWrite(<span class="number">8</span>, TimeUnit.SECONDS)</span><br><span class="line">            <span class="comment">//设置缓存容器的初始容量为 10</span></span><br><span class="line">                .initialCapacity(<span class="number">10</span>)</span><br><span class="line">            <span class="comment">// 设置缓存最大容量为 100，超过之后就会按照 LRU 算法移除缓存项</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">            <span class="comment">// 设置要统计缓存的命中率</span></span><br><span class="line">                .recordStats()</span><br><span class="line">            <span class="comment">// 设置缓存的移除通知</span></span><br><span class="line">                .removalListener(<span class="keyword">new</span> RemovalListener&lt;Object, Object&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;Object, Object&gt; notification)</span> </span>&#123;</span><br><span class="line">                        System.out.println(notification.getKey() + <span class="string">" was removed, cause is "</span> + notification.getCause());</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 指定 CacheLoader，缓存不存在时，可自动加载缓存</span></span><br><span class="line">            .build(</span><br><span class="line">                        <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                <span class="comment">// 自动加载缓存的业务</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="string">"cache-value:"</span> + key;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 设置缓存</span></span><br><span class="line">        loadCache.put(<span class="string">"c1"</span>, <span class="string">"Hello, c1."</span>);</span><br><span class="line">        <span class="comment">// 查询缓存</span></span><br><span class="line">        String val = loadCache.get(<span class="string">"c1"</span>);</span><br><span class="line">        System.out.println(val);</span><br><span class="line">        <span class="comment">// 查询不存在的缓存</span></span><br><span class="line">        String noval = loadCache.get(<span class="string">"noval"</span>);</span><br><span class="line">        System.out.println(noval);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建方式二：Callable</span></span><br><span class="line">        Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">            .maximumSize(<span class="number">2</span>) <span class="comment">// 设置缓存最大长度</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 设置缓存</span></span><br><span class="line">        cache.put(<span class="string">"k1"</span>, <span class="string">"Hello, k1."</span>);</span><br><span class="line">        <span class="comment">// 查询缓存</span></span><br><span class="line">        String value = cache.get(<span class="string">"k1"</span>, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 缓存不存在时，执行</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"nil"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 输出缓存值</span></span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">// 查询缓存</span></span><br><span class="line">        String nokey = cache.get(<span class="string">"nokey"</span>, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 缓存不存在时，执行</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"nil"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="comment">// 输出缓存值</span></span><br><span class="line">        System.out.println(nokey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello, c1.</span><br><span class="line">cache-value:noval</span><br><span class="line">Hello, k1.</span><br><span class="line">nil</span><br></pre></td></tr></table></figure><p>可以看出Guava Cache 使用了编程式的build 生成器进行创建和管理，让使用者可以更加灵活地操纵代码，并且Guava Cache提供了灵活多样的个性化配置，以适应各种使用场景。</p><h3 id="2-手动实现一个缓存系统"><a href="#2-手动实现一个缓存系统" class="headerlink" title="2.手动实现一个缓存系统"></a>2.手动实现一个缓存系统</h3><p>上面我们讲了通过EhCache和Guava实现缓存的方式，接下来我们来看看自己如何自定义一个缓存系统，当然这里说的是自己手动实现一个本地缓存。</p><p>要自定义一个缓存，首先要考虑的是数据类型，我们可以使用Map 集合中的HashMap、Hashtable<br>或ConcurrentHashMap来实现，非并发情况下我们可以使用HashMap，并发情况下可以使用</p><p>Hashtable 或 ConcurrentHashMap，由于ConcurrentHashMap的性能比Hashtable的高，因此在高并发环境下我们可以倾向于选择 ConcurrentHashMap，不过它们对元素的操作都是类似的。</p><p>选定了数据类型之后，我们还需要考虑缓存过期和缓存淘汰等问题，在这里我们可以借鉴Redis对待过期键的处理策略。</p><p>目前比较常见的过期策略有以下三种：</p><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><p><strong>定时删除</strong>是指在设置键值的过期时间时，创建一个定时事件，当到达过期时间后，事件处理器会执行删除过期键的操作。它的优点是可以及时的释放内存空间，缺点是需要开启多个延迟执行事件来处理清除任务，这样就会造成大量任务事件堆积，占用了很多系统资源。</p><p><strong>惰性删除</strong>不会主动删除过期键，而是在每次请求时才会判断此值是否过期，如果过期则删除键值，否则就返回null。它的优点是只会占用少量的系统资源，缺点是清除不够及时，会造成一定的空间浪费。</p><p><strong>定期删除</strong>是指每隔一段时间检查一次数据库，随机删除一些过期键值。</p><p>Redis 使用的是定期删除和惰性删除这两种策略，我们本课时也会参照这两种策略。</p><p>先来说一下自定义缓存的实现思路，首先需要定义一个存放缓存值的实体类，这个类里包含了缓存的相关信息，比如缓存的key和value，缓存的存入时间、最后使用时间和命中次数（预留字段，用于支持LFU缓存淘汰），再使用ConcurrentHashMap保存缓存的key和value对象（缓存值的实体类），然后再新增一个缓存操作的工具类，用于添加和删除缓存，最后再缓存启动时，开启一个无限循环的线程用于检测并删除过期的缓存，实现代码如下。</p><p>首先，定义一个缓存值实体类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">CacheValue</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存键</span></span><br><span class="line">    <span class="keyword">private</span> Object key;</span><br><span class="line">    <span class="comment">// 缓存值</span></span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">    <span class="comment">// 最后访问时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTime;</span><br><span class="line">    <span class="comment">// 创建时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> writeTime;</span><br><span class="line">    <span class="comment">// 存活时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime;</span><br><span class="line">    <span class="comment">// 命中次数</span></span><br><span class="line">    <span class="keyword">private</span> Integer hitCount;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(CacheValue o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hitCount.compareTo(o.hitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个全局缓存对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache 全局类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheGlobal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 全局缓存对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConcurrentMap&lt;String, MyCache&gt; concurrentMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义过期缓存检测类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过期缓存检测线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpireThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 每十秒检测一次</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="comment">// 缓存检测和清除的方法</span></span><br><span class="line">                expireCache();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存检测和清除的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expireCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"检测缓存是否过期缓存"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : CacheGlobal.concurrentMap.keySet()) &#123;</span><br><span class="line">            MyCache cache = CacheGlobal.concurrentMap.get(key);</span><br><span class="line">            <span class="comment">// 当前时间 - 写入时间</span></span><br><span class="line">            <span class="keyword">long</span> timoutTime = TimeUnit.NANOSECONDS.toSeconds(</span><br><span class="line">                System.nanoTime() - cache.getWriteTime());</span><br><span class="line">            <span class="keyword">if</span> (cache.getExpireTime() &gt; timoutTime) &#123;</span><br><span class="line">                <span class="comment">// 没过期</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清除过期缓存</span></span><br><span class="line">            CacheGlobal.concurrentMap.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们要新增一个缓存操作的工具类，用于查询和存入缓存，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存操作工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断，借助 commons-lang3</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(key)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 当缓存存在时，更新缓存</span></span><br><span class="line">        <span class="keyword">if</span> (CacheGlobal.concurrentMap.containsKey(key)) &#123;</span><br><span class="line">            MyCache cache = CacheGlobal.concurrentMap.get(key);</span><br><span class="line">            cache.setHitCount(cache.getHitCount() + <span class="number">1</span>);</span><br><span class="line">            cache.setWriteTime(System.currentTimeMillis());</span><br><span class="line">            cache.setLastTime(System.currentTimeMillis());</span><br><span class="line">            cache.setExpireTime(expire);</span><br><span class="line">            cache.setValue(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建缓存</span></span><br><span class="line">        MyCache cache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        cache.setKey(key);</span><br><span class="line">        cache.setValue(value);</span><br><span class="line">        cache.setWriteTime(System.currentTimeMillis());</span><br><span class="line">        cache.setLastTime(System.currentTimeMillis());</span><br><span class="line">        cache.setHitCount(<span class="number">1</span>);</span><br><span class="line">        cache.setExpireTime(expire);</span><br><span class="line">        CacheGlobal.concurrentMap.put(key, cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(key)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 字典中不存在</span></span><br><span class="line">        <span class="keyword">if</span> (CacheGlobal.concurrentMap.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!CacheGlobal.concurrentMap.containsKey(key)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        MyCache cache = CacheGlobal.concurrentMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 惰性删除，判断缓存是否过期</span></span><br><span class="line">        <span class="keyword">long</span> timoutTime = TimeUnit.NANOSECONDS.toSeconds(</span><br><span class="line">            System.nanoTime() - cache.getWriteTime());</span><br><span class="line">        <span class="keyword">if</span> (cache.getExpireTime() &lt;= timoutTime) &#123;</span><br><span class="line">            <span class="comment">// 缓存过期</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除过期缓存</span></span><br><span class="line">        CacheGlobal.concurrentMap.remove(key);</span><br><span class="line">        cache.setHitCount(cache.getHitCount() + <span class="number">1</span>);</span><br><span class="line">        cache.setLastTime(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> cache.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是调用缓存的测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CacheUtils cache = <span class="keyword">new</span> CacheUtils();</span><br><span class="line">        <span class="comment">// 存入缓存</span></span><br><span class="line">        cache.put(<span class="string">"key"</span>, <span class="string">"老王"</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 查询缓存</span></span><br><span class="line">        String val = (String) cache.get(<span class="string">"key"</span>);</span><br><span class="line">        System.out.println(val);</span><br><span class="line">        <span class="comment">// 查询不存在的缓存</span></span><br><span class="line">        String noval = (String) cache.get(<span class="string">"noval"</span>);</span><br><span class="line">        System.out.println(noval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">老王</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>到目前为止，自定义缓存系统就已经实现完了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时讲解了本地缓存和分布式缓存这两个概念和实现的具体方式，其中本地缓存可以通过自己手动编码或借助 Guava Cache来实现，而分布式缓存可以使用Redis或EhCache来实现。此外，本课时重点演示了手动实现缓存代码的方式和实现思路，并使用定期删除和惰性删除策略来实现缓存的清除，希望学完本课时后能对你有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理是如何实现的？JDK Proxy 和 CGLib 有什么区别？</title>
      <link href="/2020/04/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84JDK-Proxy-%E5%92%8C-CGLib-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/04/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84JDK-Proxy-%E5%92%8C-CGLib-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>90%的程序员都直接或者间接的使用过动态代理，无论是日志框架或Spring框架，它们都包含了动态代理的实现代码。动态代理是程序在运行期间动态构建代理对象和动态调用代理方法的一种机制。</p><p>我们本课时的面试题是，如何实现动态代理？JDK Proxy和CGLib有什么区别？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>动态代理的常用实现方式是反射。<strong>反射机制</strong>是指程序在运行期间可以访问、检测和修改其本身状态或行为的一种能力，使用反射我们可以调用任意一个类对象，以及类对象中包含的属性及方法。</p><p>但动态代理不止有反射一种实现方式，例如，动态代理可以通过CGLib来实现，而CGLib是基于ASM（一个Java字节码操作框架）而非反射实现的。简单来说，动态代理是一种行为方式，而反射或ASM只是它的一种实现手段而已。</p><p>JDK Proxy和CGLib的区别主要体现在以下几个方面：</p><ul><li>JDK Proxy是Java 语言自带的功能，无需通过加载第三方类实现；</li><li>Java对JDKProxy提供了稳定的支持，并且会持续的升级和更新JDK Proxy，例如Java8版本中的JDK Proxy性能相比于之前版本提升了很多；</li><li>JDK Proxy 是通过拦截器加反射的方式实现的；</li><li>JDK Proxy 只能代理继承接口的类；</li><li>JDK Proxy 实现和调用起来比较简单；</li><li>CGLib是第三方提供的工具，基于ASM实现的，性能比较高；</li><li>CGLib无需通过接口来实现，它是通过实现子类的方式来完成调用的。</li></ul><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>本课时考察的是你对反射、动态代理及CGLib的了解，很多人经常会把反射和动态代理划为等号，但从严格意义上来说，这种想法是不正确的，真正能搞懂它们之间的关系，也体现了你扎实Java的基本功。和这个问题相关的知识点，还有以下几个：</p><ul><li>你对JDKProxy和CGLib的掌握程度。</li><li>Lombok是通过反射实现的吗？</li><li>动态代理和静态代理有什么区别？</li><li>动态代理的使用场景有哪些？</li><li>Spring中的动态代理是通过什么方式实现的？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-JDK-Proxy-和CGLib的使用及代码分析"><a href="#1-JDK-Proxy-和CGLib的使用及代码分析" class="headerlink" title="1.JDK Proxy 和CGLib的使用及代码分析"></a>1.JDK Proxy 和CGLib的使用及代码分析</h3><h4 id="JDK-Proxy-动态代理实现"><a href="#JDK-Proxy-动态代理实现" class="headerlink" title="JDK Proxy 动态代理实现"></a>JDK Proxy 动态代理实现</h4><p>JDK Proxy 动态代理的实现无需引用第三方类，只需要实现InvocationHandler接口，重写invoke0方法即可，整个实现代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK Proxy 相关示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"The bus is running."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"The taxi is running."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDK Proxy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object target; <span class="comment">// 代理对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取到代理对象</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.target = target;</span><br><span class="line">            <span class="comment">// 取得代理对象</span></span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                                          target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行代理方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> proxy  代理对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> method 代理方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> args   方法的参数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"动态代理之前的业务处理."</span>);</span><br><span class="line">            Object result = method.invoke(target, args); <span class="comment">// 执行调用方法（此方法执行前后，可以进行相关业务处理）</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行 JDK Proxy</span></span><br><span class="line">        JDKProxy jdkProxy = <span class="keyword">new</span> JDKProxy();</span><br><span class="line">        Car carInstance = (Car) jdkProxy.getInstance(<span class="keyword">new</span> Taxi());</span><br><span class="line">        carInstance.running();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动态代理之前的业务处理.</span><br><span class="line">The taxi is running.</span><br></pre></td></tr></table></figure><p>可以看出JDK Proxy 实现动态代理的核心是实现Invocation 接口，我们查看Invocation的源码，会发现里面其实只有一个invoke()方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为在动态代理中有一个重要的角色也就是代理器，它用于统一管理被代理的对象，显然<br>InvocationHandler 就是这个代理器，而invoke()方法则是触发代理的执行方法，我们通过实现<br>Invocation 接口来拥有动态代理的能力。</p><h4 id="CGLib的实现"><a href="#CGLib的实现" class="headerlink" title="CGLib的实现"></a>CGLib的实现</h4><p>在使用CGLib之前，我们要先在项目中引入CGLib框架，在pom.xml中添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CGLib 实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lagou.interview;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"The car is running."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CGLib 代理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object target; <span class="comment">// 代理对象</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.target = target;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            <span class="comment">// 设置父类为实例类</span></span><br><span class="line">            enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">            <span class="comment">// 回调方法</span></span><br><span class="line">            enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 创建代理对象</span></span><br><span class="line">            <span class="keyword">return</span> enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"方法调用前业务处理."</span>);</span><br><span class="line">            Object result = methodProxy.invokeSuper(o, objects); <span class="comment">// 执行方法调用</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 CGLib 的方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 CGLib 代理类</span></span><br><span class="line">        CGLibProxy proxy = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line">        <span class="comment">// 初始化代理对象</span></span><br><span class="line">        Car car = (Car) proxy.getInstance(<span class="keyword">new</span> Car());</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        car.running();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法调用前业务处理.</span><br><span class="line">The car is running.</span><br></pre></td></tr></table></figure><p>可以看出CGLib和JDK Proxy的实现代码比较类似，都是通过实现代理器的接口，再调用某一个方法完成动态代理的，唯一不同的是，CGLib在初始化被代理类时，是通过Enhancer 对象把代理对象设置为被代理类的子类来实现动态代理的。因此被代理类不能被关键字final修饰，如果被final修饰，再使用Enhancer设置父类时会报错，动态代理的构建会失败。</p><h3 id="2-Lombok-原理分析"><a href="#2-Lombok-原理分析" class="headerlink" title="2.Lombok 原理分析"></a>2.Lombok 原理分析</h3><p>在开始讲Lombok的原理之前，我们先来简单地介绍一下Lombok，它属于Java的一个热门工具类，使用它可以有效的解决代码工程中那些繁琐又重复的代码，如Setter、Getter、toString、<br>equals和hashCode等等，向这种方法都可以使用Lombok 注解来完成。</p><p>例如，我们使用比较多的Setter和Getter方法，在没有使用Lombok之前，代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 Lombok 之后，代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出Lombok 让代码简单和优雅了很多。<br>小贴士：如果在项目中使用了Lombok的Getter和Setter 注解，那么想要在编码阶段成功调用对象的set或get方法，我们需要在IDE中安装Lombok 插件才行，比如ldea的插件如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p>接下来讲讲Lombok的原理。</p><p>Lombok 的实现和反射没有任何关系，前面我们说了反射是程序在运行期的一种自省（introspect）<br>能力，而Lombok的实现是在编译期就完成了，为什么这么说呢？</p><p>回到我们刚才Setter/Getter的方法，当我们打开Person的编译类就会发现，使用了Lombok的<br>@Data注解后的源码竟然是这样的：</p><p><img data-src="2.png" alt="2.png"></p><p>可以看出Lombok是在编译期就为我们生成了对应的字节码。</p><p>其实Lombok 是基于Java 1.6实现的JSR269：Pluggable Annotation Processing APl来实现的，也就是通过编译期自定义注解处理器来实现的，它的执行步骤如下：</p><p><img data-src="3.png" alt="3.png"></p><p>从流程图中可以看出，在编译期阶段，当Java 源码被抽象成语法树（AST）之后，Lombok会根据自己的注解处理器动态修改AST，增加新的代码（节点），在这一切执行之后就生成了最终的字节码（.class）文件，这就是Lombok的执行原理。</p><h3 id="3-动态代理知识点扩充"><a href="#3-动态代理知识点扩充" class="headerlink" title="3.动态代理知识点扩充"></a>3.动态代理知识点扩充</h3><p>当面试官问动态代理的时候，经常会问到它和静态代理的区别？静态代理其实就是事先写好代理类，可以手工编写也可以使用工具生成，但它的缺点是每个业务类都要对应一个代理类，特别不灵活也不方便，于是就有了动态代理。</p><p>动态代理的常见使用场景有RPC框架的封装、AOP（面向切面编程）的实现、JDBC的连接等。</p><p>Spring 框架中同时使用了两种动态代理JDK Proxy和CGLib，当Bean 实现了接口时，Spring就会使用JDK Proxy，在没有实现接口时就会使用CGLib，我们也可以在配置中指定强制使用CGLib，只需要在Spring 配置中添加&lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们介绍了JDK Proxy和CGLib的区别，JDK Proxy是Java语言内置的动态代理，必须要通过实现接口的方式来代理相关的类，而CGLib是第三方提供的基于ASM的高效动态代理类，它通过实现被代理类的子类来实现动态代理的功能，因此被代理的类不能使用final修饰。<br>除了JDKProxy和CGLib之外，我们还讲了Java中常用的工具类Lombok的实现原理，它其实和反射是没有任何关系的；最后讲了动态代理的使用场景以及Spring中动态代理的实现方式，希望本文可以帮助到你。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-二叉树</title>
      <link href="/2020/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="为什么需要树这种数据结构"><a href="#为什么需要树这种数据结构" class="headerlink" title="为什么需要树这种数据结构"></a>为什么需要树这种数据结构</h2><h3 id="1-数组存储方式的分析"><a href="#1-数组存储方式的分析" class="headerlink" title="1.数组存储方式的分析"></a>1.数组存储方式的分析</h3><p><strong>优点</strong>：通过 <strong>下标方式访问元素</strong>，速度快。对于有序数组，还可使用 <strong>二分查找</strong>提高检索速度。<br><strong>缺点：</strong>如果要检索具体某个值，或者 <strong>插入值( 按一定顺序) 会整体移动</strong>，效率较低 [示意图]<br>画出操作示意图：</p><p><img data-src="1.png" alt="1.png"></p><h3 id="2-链式存储方式的分析"><a href="#2-链式存储方式的分析" class="headerlink" title="2.链式存储方式的分析"></a>2.链式存储方式的分析</h3><p><strong>优点：</strong>在一定程度上对数组存储方式有优化(比如： <strong>插入</strong>一个数值节点，只需要将插入节点，链接到链表中即可，<br><strong>删除</strong>效率也很好)。<br><strong>缺点：</strong>在进行 <strong>检索时</strong>，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 【示意图】<br>操作示意图：</p><p><img data-src="2.png" alt="2.png"></p><h3 id="3-树存储方式的分析"><a href="#3-树存储方式的分析" class="headerlink" title="3.树存储方式的分析"></a>3.树存储方式的分析</h3><p>能提高数据 <strong>存储 ， 读取</strong>的效率, 比如利用  <strong>二叉排序树</strong>(Binary Sort Tree)，既可以保证数据的检索速度，同时也<br>可以保证数据的 <strong>插入，删除，修改</strong>的速度。【示意图,后面详讲】<br><strong>案例:</strong> [7, 3, 10, 1, 5, 9, 12]</p><p><img data-src="3.png" alt="3.png"></p><h2 id="树的常用语"><a href="#树的常用语" class="headerlink" title="树的常用语"></a>树的常用语</h2><p><img data-src="4.png" alt="4.png"></p><p>树的常用术语(结合示意图理解):</p><ol><li>节点</li><li>根节点</li><li>父节点</li><li>子节点</li><li>叶子节点 (没有子节点的节点)</li><li>节点的权(节点值)</li><li>路径(从 root 节点找到该节点的路线)</li><li>层</li><li>子树</li><li>树的高度(最大层数)</li><li>森林 :多颗子树构成森林</li></ol><h2 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h2><ol><li>树有很多种，每个节点 最多只能有两个子节点的一种形式称为二叉树。</li><li>二叉树的子节点分为左节点和右节点</li><li>示意图</li></ol><p><img data-src="5.png" alt="5.png"></p><p>   4.如果该二叉树的所有 叶子节点都在 最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。</p><p><img data-src="6.png" alt="6.png"></p><p>   5.如果该二叉树的所有 叶子节点都在 最后一层或者 倒数第二层，而且最后一层的叶子节点在左边连续，倒数第   二层的叶子节点在右边连续，我们称为完全二叉树</p><p><img data-src="7.png" alt="7.png"></p><h2 id="二叉树遍历的说明"><a href="#二叉树遍历的说明" class="headerlink" title="二叉树遍历的说明"></a>二叉树遍历的说明</h2><ul><li>前序遍历: 先输出父节点，再遍历左子树和右子树</li><li>中序遍历: 先遍历左子树，再输出父节点，再遍历右子树</li><li>后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点</li></ul><p><strong>小结:</strong> 看输出父节点的顺序，就确定是前序，中序还是后序</p><h2 id="二叉树遍历应用实例-前序-中序-后序"><a href="#二叉树遍历应用实例-前序-中序-后序" class="headerlink" title="二叉树遍历应用实例(前序,中序,后序)"></a>二叉树遍历应用实例(前序,中序,后序)</h2><p><img data-src="8.png" alt="8.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先需要创建一颗二叉树</span></span><br><span class="line">BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line"><span class="comment">// 创建需要的结点</span></span><br><span class="line">HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"吴用"</span>);</span><br><span class="line">HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>);</span><br><span class="line">HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">"关胜"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">root.setLeft(node2);</span><br><span class="line">root.setRight(node3);</span><br><span class="line">node3.setRight(node4);</span><br><span class="line">node3.setLeft(node5);</span><br><span class="line">binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">System.out.println(<span class="string">"前序遍历"</span>); <span class="comment">// 1,2,3,5,4</span></span><br><span class="line">binaryTree.preOrder();</span><br><span class="line"><span class="comment">//测试 </span></span><br><span class="line">System.out.println(<span class="string">"中序遍历"</span>);</span><br><span class="line">binaryTree.infixOrder(); <span class="comment">// 2,1,5,3,4</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">System.out.println(<span class="string">"后序遍历"</span>);</span><br><span class="line">binaryTree.postOrder(); <span class="comment">// 2,5,4,3,1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.preOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.postOrder();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.left = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写前序遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>); <span class="comment">// 先输出父结点</span></span><br><span class="line"><span class="comment">// 递归向左子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归向右子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 递归向左子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出父结点</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 递归向右子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.postOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.postOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树-查找指定节点"><a href="#二叉树-查找指定节点" class="headerlink" title="二叉树-查找指定节点"></a>二叉树-查找指定节点</h2><p><strong>要求</strong></p><p>1) 请编写前序查找，中序查找和后序查找的方法。<br>2) 并分别使用三种查找方式，查找 heroNO = 5 的节点<br>3) 并分析各种查找方式，分别比较了多少次<br>4) 思路分析图解</p><p><img data-src="9.png" alt="9.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先需要创建一颗二叉树</span></span><br><span class="line">BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line"><span class="comment">// 创建需要的结点</span></span><br><span class="line">HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"吴用"</span>);</span><br><span class="line">HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>);</span><br><span class="line">HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">"关胜"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">root.setLeft(node2);</span><br><span class="line">root.setRight(node3);</span><br><span class="line">node3.setRight(node4);</span><br><span class="line">node3.setLeft(node5);</span><br><span class="line">binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="comment">//前序遍历的次数 ：4 </span></span><br><span class="line">System.out.println(<span class="string">"前序遍历方式~~~"</span>);</span><br><span class="line">HeroNode resNode = binaryTree.preOrderSearch(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">"找到了，信息为 no=%d name=%s"</span>, resNode.getNo(), resNode.getName());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"没有找到 no = %d 的英雄"</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历查找</span></span><br><span class="line"><span class="comment">// 中序遍历3次</span></span><br><span class="line">System.out.println(<span class="string">"中序遍历方式~~~"</span>);</span><br><span class="line">HeroNode resNode2 = binaryTree.infixOrderSearch(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (resNode2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">"找到了，信息为 no=%d name=%s"</span>, resNode2.getNo(), resNode2.getName());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"没有找到 no = %d 的英雄"</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line"><span class="comment">// 后序遍历查找</span></span><br><span class="line"><span class="comment">// 后序遍历查找的次数 2次</span></span><br><span class="line">System.out.println(<span class="string">"后序遍历方式~~~"</span>);</span><br><span class="line">HeroNode resNode3 = binaryTree.postOrderSearch(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (resNode3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">"找到了，信息为 no=%d name=%s"</span>, resNode3.getNo(), resNode3.getName());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"没有找到 no = %d 的英雄"</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.root.postOrderSearch(no);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.left = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历查找</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> no 查找no</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到就返回该Node ,如果没有找到返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"进入前序遍历"</span>);</span><br><span class="line"><span class="comment">//比较当前节点是不是</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line"><span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line"><span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"进入中序遍历"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前结点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;<span class="comment">// 说明在左子树找到</span></span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果左子树没有找到，则向右子树递归进行后序遍历查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"进入后序查找"</span>);</span><br><span class="line"><span class="comment">// 如果左右子树都没有找到，就比较当前结点是不是</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树-删除节点"><a href="#二叉树-删除节点" class="headerlink" title="二叉树-删除节点"></a>二叉树-删除节点</h2><p>要求</p><p>1) 如果删除的节点是叶子节点，则删除该节点<br>2) 如果删除的节点是非叶子节点，则删除该子树.<br>3) 测试，删除掉 5 号叶子节点 和 3 号子树.<br>4) 完成删除思路分析</p><p><img data-src="10.png" alt="10.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先需要创建一颗二叉树</span></span><br><span class="line">BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line"><span class="comment">// 创建需要的结点</span></span><br><span class="line">HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"吴用"</span>);</span><br><span class="line">HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>);</span><br><span class="line">HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">"关胜"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">root.setLeft(node2);</span><br><span class="line">root.setRight(node3);</span><br><span class="line">node3.setRight(node4);</span><br><span class="line">node3.setLeft(node5);</span><br><span class="line">binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"删除前,前序遍历"</span>);</span><br><span class="line">binaryTree.preOrder(); <span class="comment">//  1,2,3,5,4</span></span><br><span class="line">binaryTree.delNode(<span class="number">5</span>);</span><br><span class="line">binaryTree.delNode(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"删除后，前序遍历"</span>);</span><br><span class="line">binaryTree.preOrder(); <span class="comment">// 1,2,3,4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line"><span class="keyword">if</span> (root.getNo() == no) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 递归删除</span></span><br><span class="line">root.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"空树，不能删除~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.preOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.postOrder();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.left = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写前序遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>); <span class="comment">// 先输出父结点</span></span><br><span class="line"><span class="comment">// 递归向左子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归向右子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 递归向左子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出父结点</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 递归向右子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.postOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.postOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归删除节点</span></span><br><span class="line"><span class="comment">// 1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line"><span class="comment">// 2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no)&#123;</span><br><span class="line"><span class="keyword">this</span>.left =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-哈希表</title>
      <link href="/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表的基本介绍"><a href="#哈希表的基本介绍" class="headerlink" title="哈希表的基本介绍"></a>哈希表的基本介绍</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通<br>过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组<br>叫做散列表。</p><p><img data-src="1.png" alt="1.png"></p><p><img data-src="2.png" alt="2.png"></p><h2 id="google-公司的一个上机题"><a href="#google-公司的一个上机题" class="headerlink" title="google 公司的一个上机题:"></a>google 公司的一个上机题:</h2><p>有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的 id 时,<br>要求查找到该员工的 所有信息.</p><p><strong>要求:</strong></p><ol><li>不使用数据库,,速度越快越好=&gt;哈希表(散列)</li><li>添加时，保证按照 id 从低到高插入 [课后思考： 如果 id  不是从低到高插入，但要求各条链表仍是从低到<br>高，怎么解决?]</li><li>使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息]</li><li>思路分析并画出示意图</li></ol><p><img data-src="3.png" alt="3.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建哈希表</span></span><br><span class="line">HashTab hashTab = <span class="keyword">new</span> HashTab(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个简单的菜单</span></span><br><span class="line">String key = <span class="string">""</span>;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"add:  添加雇员"</span>);</span><br><span class="line">System.out.println(<span class="string">"list: 显示雇员"</span>);</span><br><span class="line">System.out.println(<span class="string">"find: 查找雇员"</span>);</span><br><span class="line">System.out.println(<span class="string">"delete: 删除雇员"</span>);</span><br><span class="line">System.out.println(<span class="string">"exit: 退出系统"</span>);</span><br><span class="line"></span><br><span class="line">key = scanner.next();</span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">System.out.println(<span class="string">"输入id"</span>);</span><br><span class="line"><span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">"输入名字"</span>);</span><br><span class="line">String name = scanner.next();</span><br><span class="line"><span class="comment">// 创建 雇员</span></span><br><span class="line">Emp emp = <span class="keyword">new</span> Emp(id, name);</span><br><span class="line">hashTab.add(emp);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"list"</span>:</span><br><span class="line">hashTab.list();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"find"</span>:</span><br><span class="line">System.out.println(<span class="string">"请输入要查找的id"</span>);</span><br><span class="line">id = scanner.nextInt();</span><br><span class="line"> hashTab.findEmpById(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"delete"</span>:</span><br><span class="line">System.out.println(<span class="string">"请输入要删除的id"</span>);</span><br><span class="line">id = scanner.nextInt();</span><br><span class="line"> hashTab.delEmpById(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">scanner.close();</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示一个雇员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> Emp next;<span class="comment">// next 默认为空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HashTable 管理多条链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTab</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// 表示共有多少条链表</span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.size = size;</span><br><span class="line"><span class="comment">// 初始化 empLinkedListArr</span></span><br><span class="line">empLinkedListArray = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line"><span class="comment">//不要忘了分别初始化每个链表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">empLinkedListArray[i] = <span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加雇员</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据员工的id 得到该员工应当添加到哪条链表</span></span><br><span class="line"><span class="keyword">int</span> empLinkedListNo = hashFun(emp.id);</span><br><span class="line"><span class="comment">// 将emp加入到对应的链表中</span></span><br><span class="line">empLinkedListArray[empLinkedListNo].add(emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个散列函数 使用一个简单的取模法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id % size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的链表,遍历hashtab</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">empLinkedListArray[i].list(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据输入的id,查找雇员</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据员工的id 得到该员工应当添加到哪条链表</span></span><br><span class="line"><span class="keyword">int</span> empLinkedListNo = hashFun(id);</span><br><span class="line">Emp emp = empLinkedListArray[empLinkedListNo].findEmpById(id);</span><br><span class="line"><span class="keyword">if</span>(emp != <span class="keyword">null</span>) &#123;<span class="comment">//找到</span></span><br><span class="line">System.out.printf(<span class="string">"在第%d条链表中找到 雇员 %s id = %d\n"</span>, (empLinkedListNo + <span class="number">1</span>),emp.name, id);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"在哈希表中，没有找到该雇员~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据输入的id,删除雇员</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据员工的id 得到该员工应当添加到哪条链表</span></span><br><span class="line"><span class="keyword">int</span> empLinkedListNo = hashFun(id);</span><br><span class="line"><span class="keyword">boolean</span> flag = empLinkedListArray[empLinkedListNo].delEmpById(id);</span><br><span class="line"><span class="keyword">if</span> (flag ) &#123;<span class="comment">// 找到</span></span><br><span class="line">System.out.printf(<span class="string">"在第%d条链表中删除 雇员  id = %d\n"</span>, (empLinkedListNo + <span class="number">1</span>), id);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"在哈希表中，没有找到该雇员~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建EmpLinkedList，表示链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">// 头指针，指向第一个雇员 所以这个链表的head是有效的 指向第一个Emp</span></span><br><span class="line"><span class="keyword">public</span> Emp head;<span class="comment">// 默认为空</span></span><br><span class="line"><span class="comment">// 添加雇员到链表</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大</span></span><br><span class="line"><span class="comment">// 因此我们将该雇员直接加入到本链表的最后即可</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果是添加第一个雇员</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">head = emp;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后</span></span><br><span class="line">Emp curEmp = head;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (curEmp != <span class="keyword">null</span> &amp;&amp; curEmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curEmp = curEmp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出时直接将emp 加入链表</span></span><br><span class="line">curEmp.next = emp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表的雇员信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;<span class="comment">// 链表为空</span></span><br><span class="line">System.out.println(<span class="string">"第 "</span> + (no + <span class="number">1</span>) + <span class="string">" 链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">"第 "</span> + (no + <span class="number">1</span>) + <span class="string">" 链表的信息为"</span>);</span><br><span class="line">Emp curEmp = head; <span class="comment">// 辅助指针</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">" =&gt; id=%d name=%s\t"</span>, curEmp.id, curEmp.name);</span><br><span class="line"><span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curEmp = curEmp.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据id查找雇员</span></span><br><span class="line"><span class="comment">//如果查找到，就返回Emp, 如果没有找到，就返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找辅助指针</span></span><br><span class="line">Emp curEmp = head;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (curEmp.id == id) &#123;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//这时curEmp就指向要查找的雇员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出</span></span><br><span class="line"><span class="keyword">if</span>(curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明遍历当前链表没有找到该雇员</span></span><br><span class="line">curEmp = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curEmp = curEmp.next;<span class="comment">//以后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> curEmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head.id == id) &#123;</span><br><span class="line">head =head.next;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找辅助指针</span></span><br><span class="line">Emp curEmp = head;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (curEmp.next.id == id) &#123;</span><br><span class="line"><span class="keyword">if</span> (curEmp.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">curEmp.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">curEmp.next = curEmp.next.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出</span></span><br><span class="line"><span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明遍历当前链表没有找到该雇员</span></span><br><span class="line">curEmp = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">curEmp = curEmp.next;<span class="comment">// 以后</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-斐波那契查找</title>
      <link href="/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="斐波那契-黄金分割法-查找基本介绍"><a href="#斐波那契-黄金分割法-查找基本介绍" class="headerlink" title="斐波那契(黄金分割法)查找基本介绍:"></a>斐波那契(黄金分割法)查找基本介绍:</h2><ol><li>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位<br>数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神<br>奇的数字，会带来意向不大的效果。</li><li>斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值<br>0.618</li></ol><h2 id="斐波那契-黄金分割法-原理"><a href="#斐波那契-黄金分割法-原理" class="headerlink" title="斐波那契(黄金分割法)原理:"></a>斐波那契(黄金分割法)原理:</h2><p>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位<br>于黄金分割点附近，即 mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示</p><p><img data-src="1.png" alt="1.png"></p><h3 id="对-F-k-1-1-的理解："><a href="#对-F-k-1-1-的理解：" class="headerlink" title="对 F(k-1)-1  的理解："></a>对 F(k-1)-1  的理解：</h3><ol><li>由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：<br>只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间位置为 mid=low+F(k-1)-1</li><li>类似的，每一子段也可以用相同的方式分割</li><li>但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使<br>得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置），<br>都赋为 n 位置的值即可。while(n&gt;fib(k)-1)     k++;</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSearch</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize =<span class="number">20</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">89</span>,<span class="number">1000</span>,<span class="number">1234</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"index="</span> + fibSearch(arr, <span class="number">89</span>));<span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为后面的公式 mid=low+F(k-1)-1,需要使用到斐波那契数列 ，所以 需要先获取到一个斐波那契数列</span></span><br><span class="line"><span class="comment">//非递归的方式 得到一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line"><span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写斐波那契查找算法</span></span><br><span class="line"><span class="comment">//非递归的方式</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 需要查找的关键码（值）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回对应下标 如果没有返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = a.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//表示斐波那契分割数值的下标 即公式中的k</span></span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>;<span class="comment">//存放mid</span></span><br><span class="line"><span class="keyword">int</span> f[]=fib();<span class="comment">//获取到斐波那契数列</span></span><br><span class="line"><span class="comment">//获取到k</span></span><br><span class="line"><span class="comment">// 获取斐波那契分割数值下标 </span></span><br><span class="line"><span class="keyword">while</span> (high &gt;f[k]-<span class="number">1</span> ) &#123;<span class="comment">//这里的 k 值只要能使得 F[k]-1 恰好大于或等于 顺序表长度 即可</span></span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span></span><br><span class="line"><span class="comment">//不足的部分会使用0填充</span></span><br><span class="line"><span class="keyword">int</span>[] temp = Arrays.copyOf(a, f[k]-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//实际上需要使用a数组的最后的数 填充 temp</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = high+<span class="number">1</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">temp[i] = a[high];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用while来循环处理，找到我们的数 key</span></span><br><span class="line"><span class="keyword">while</span> (low&lt;=high) &#123;<span class="comment">// 只要这个条件满足，就可以找</span></span><br><span class="line">mid = low+f[k-<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (key &lt; temp[mid]) &#123;<span class="comment">//说明继续向左侧查找</span></span><br><span class="line">high = mid-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//为什么是 k--</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line"><span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line"><span class="comment">//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]</span></span><br><span class="line"><span class="comment">//即 在 f[k-1] 的前面继续查找 k--</span></span><br><span class="line"><span class="comment">//即下次循环 mid = f[k-1-1]-1</span></span><br><span class="line">k--;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; temp[mid]) &#123; <span class="comment">// 我们应该继续向数组的后面查找(右边)</span></span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//为什么是k -=2</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line"><span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line"><span class="comment">//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-2] = f[k-3] + f[k-4]</span></span><br><span class="line"><span class="comment">//4. 即在f[k-2] 的前面进行查找 k -=2</span></span><br><span class="line"><span class="comment">//5. 即下次循环 mid = f[k - 1 - 2] - 1</span></span><br><span class="line">k-=<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123; <span class="comment">//找到</span></span><br><span class="line"><span class="comment">//需要确定，返回的是哪个下标</span></span><br><span class="line"><span class="keyword">if</span>(mid &lt;= high) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-插值查找</title>
      <link href="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="插值查找算法"><a href="#插值查找算法" class="headerlink" title="插值查找算法"></a>插值查找算法</h2><ul><li><p>插值查找原理介绍:插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。</p></li><li><p>将折半查找中的求 mid 索引的公式 , low 表示左边索引 left, high 表示右边索引 right.<br>key 就是前面我们讲的 findVal</p><p><img data-src="1.png" alt="1.png"></p></li><li><p>int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;/<em>插值索引</em>/<br>对应前面的代码公式：<br>int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])</p></li><li><p>举例说明插值查找算法 1-100 的数组</p></li></ul><p><img data-src="2.png" alt="2.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertValueSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">arr[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> index = insertValueSearch(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, <span class="number">50</span>);</span><br><span class="line">System.out.println(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写插值查找算法</span></span><br><span class="line"><span class="comment">//说明：插值查找算法，也要求数组是有序的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> findVal 查找值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到，就返回对应的下标，如果没有找到，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"插值查找次数~~"</span>);</span><br><span class="line"><span class="comment">//注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要</span></span><br><span class="line"><span class="comment">//否则我们得到的 mid 可能越界</span></span><br><span class="line"><span class="keyword">if</span> (left&gt;right || findVal &lt;arr[left] || findVal&gt;arr[right] ) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = left+(right-left)*(findVal-arr[left])/(arr[right]-arr[left]);</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"><span class="keyword">if</span> (findVal&gt;midVal) &#123;<span class="comment">//向右递归</span></span><br><span class="line"><span class="keyword">return</span> insertValueSearch(arr, mid+<span class="number">1</span>, right, findVal);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123;</span><br><span class="line"><span class="keyword">return</span> insertValueSearch(arr, left, mid-<span class="number">1</span>, findVal);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是等差数列 只需一次查找！！ 斜率。</p><h2 id="插值查找注意事项："><a href="#插值查找注意事项：" class="headerlink" title="插值查找注意事项："></a>插值查找注意事项：</h2><ol><li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快.</li><li>关键字分布不均匀的情况下，该方法不一定比折半查找要好</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-二分查找</title>
      <link href="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h1><h2 id="二分查找："><a href="#二分查找：" class="headerlink" title="二分查找："></a>二分查找：</h2><p>请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下<br>标，如果没有就提示”没有这个数”。</p><h2 id="二分查找算法的思路"><a href="#二分查找算法的思路" class="headerlink" title="二分查找算法的思路"></a>二分查找算法的思路</h2><p><img data-src="1.png" alt="1.png"></p><h2 id="递归实现二分查找"><a href="#递归实现二分查找" class="headerlink" title="递归实现二分查找"></a>递归实现二分查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>,<span class="number">1000</span>, <span class="number">1234</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> resIndex = binarySearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line"> System.out.println(<span class="string">"resIndex="</span> + resIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> findVal 要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到就返回下标，如果没找到就返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归结束条件</span></span><br><span class="line"><span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line"><span class="keyword">if</span> (left&gt;right || findVal &lt;arr[left] || findVal&gt;arr[right] ) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"><span class="keyword">if</span> (findVal&gt;midVal) &#123;<span class="comment">//需要向右递归 </span></span><br><span class="line"><span class="keyword">return</span> binarySearch(arr, mid+<span class="number">1</span>, right, findVal);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (findVal&lt;midVal) &#123;</span><br><span class="line"><span class="keyword">return</span> binarySearch(arr, left, mid-<span class="number">1</span>, findVal);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h2><p> {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 完成一个课后思考题:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 课后思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，</span></span><br><span class="line"><span class="comment"> * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路分析 </span></span><br><span class="line"><span class="comment"> * 1. 在找到mid 索引值，不要马上返回 </span></span><br><span class="line"><span class="comment"> * 2. 向mid 索引值的左边扫描，将所有满足 1000，的元素的下标，加入到集合ArrayList </span></span><br><span class="line"><span class="comment"> * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment"> * 4. 将Arraylist返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归结束条件</span></span><br><span class="line"><span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right || findVal &lt; arr[left] || findVal &gt; arr[right]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"><span class="keyword">if</span> (findVal &gt; midVal) &#123;<span class="comment">// 需要向右递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch2(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123;</span><br><span class="line"><span class="keyword">return</span> binarySearch2(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">List&lt;Integer&gt; resIndexlist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="keyword">int</span> temp =  mid-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; <span class="number">0</span> || arr[temp] != findVal) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则就把temp放入到集合中</span></span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp = temp-<span class="number">1</span>;<span class="comment">//temp左移</span></span><br><span class="line">&#125;</span><br><span class="line">resIndexlist.add(mid);<span class="comment">//中间的mid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始向右扫描</span></span><br><span class="line">temp = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp &gt; arr.length-<span class="number">1</span> || arr[temp] != findVal) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp = temp+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resIndexlist;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-线性查找</title>
      <link href="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">9</span>, <span class="number">11</span>, -<span class="number">1</span>, <span class="number">34</span>, <span class="number">89</span> &#125;;<span class="comment">// 没有顺序的数组</span></span><br><span class="line"><span class="keyword">int</span> index = seqSearch(arr, -<span class="number">11</span>);</span><br><span class="line"><span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"没有找到到"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"找到，下标为="</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里我们实现的线性查找是找到一个满足条件的值，就返回</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线性查找是逐一比对，发现有相同值，就返回下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == value) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-基数排序</title>
      <link href="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="基数排序-桶排序-介绍"><a href="#基数排序-桶排序-介绍" class="headerlink" title="基数排序(桶排序)介绍:"></a>基数排序(桶排序)介绍:</h2><ol><li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</li><li>基数排序法是属于稳定性的排序，基数排序法的是效率高的 稳定性排序法</li><li>基数排序(Radix Sort)是桶排序的扩展</li><li>基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个<br>位数分别比较。</li></ol><h2 id="基数排序基本思想"><a href="#基数排序基本思想" class="headerlink" title="基数排序基本思想"></a>基数排序基本思想</h2><p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。<br>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><h2 id="基数排序图文说明"><a href="#基数排序图文说明" class="headerlink" title="基数排序图文说明"></a>基数排序图文说明</h2><p>将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序</p><p>第一轮</p><p><img data-src="1.png" alt="1.png"></p><p>第二轮</p><p><img data-src="2.png" alt="2.png"></p><p>第三轮</p><p><img data-src="3.png" alt="3.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span> &#125;;</span><br><span class="line">radixSort(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 第1轮(针对每个元素的个位进行排序处理)</span></span><br><span class="line"><span class="comment">// 定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. 二维数组包含10个一维数组</span></span><br><span class="line"><span class="comment">// 2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line"><span class="comment">// 3. 名明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line"><span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"><span class="comment">// 为了记录每个桶中实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line"><span class="comment">// 可以这里理解</span></span><br><span class="line"><span class="comment">// 比如：bucketElementCounts[0] , 记录的就是 bucket[0] 桶的放入数据个数</span></span><br><span class="line"><span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 找到数组中最大的数</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到是几位数</span></span><br><span class="line"><span class="keyword">int</span> maxLength = (max + <span class="string">""</span>).length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line"><span class="comment">// 取出每个元素的个位的值</span></span><br><span class="line"><span class="keyword">int</span> digitOfElement = arr[j] / n % <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 放入到对应的桶中</span></span><br><span class="line">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">bucketElementCounts[digitOfElement]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line"><span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="keyword">if</span> (bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line"><span class="comment">// 取出元素放入到arr</span></span><br><span class="line">arr[index++] = bucket[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"排序后"</span> + Arrays.toString(arr));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第1轮(针对每个元素的个位进行排序处理)</span></span><br><span class="line"><span class="comment">for(int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">//取出每个元素的个位的值</span></span><br><span class="line"><span class="comment">int digitOfElement = arr[j] / 1 % 10;</span></span><br><span class="line"><span class="comment">//放入到对应的桶中</span></span><br><span class="line"><span class="comment">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">bucketElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line"><span class="comment">int index = 0;</span></span><br><span class="line"><span class="comment">//遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="comment">for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="comment">if(bucketElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">//循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line"><span class="comment">for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">//取出元素放入到arr</span></span><br><span class="line"><span class="comment">arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line"><span class="comment">bucketElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">System.out.println("第1轮，对个位的排序处理 arr =" + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//==========================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第2轮(针对每个元素的十位进行排序处理)</span></span><br><span class="line"><span class="comment">for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">// 取出每个元素的十位的值</span></span><br><span class="line"><span class="comment">int digitOfElement = arr[j] / 10  % 10; //748 / 10 =&gt; 74 % 10 =&gt; 4</span></span><br><span class="line"><span class="comment">// 放入到对应的桶中</span></span><br><span class="line"><span class="comment">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">bucketElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line"><span class="comment">index = 0;</span></span><br><span class="line"><span class="comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="comment">for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="comment">if (bucketElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line"><span class="comment">for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">// 取出元素放入到arr</span></span><br><span class="line"><span class="comment">arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line"><span class="comment">bucketElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">System.out.println("第2轮，对个位的排序处理 arr =" + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第3轮(针对每个元素的百位进行排序处理)</span></span><br><span class="line"><span class="comment">for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">// 取出每个元素的百位的值</span></span><br><span class="line"><span class="comment">int digitOfElement = arr[j] / 100 % 10; // 748 / 100 =&gt; 7 % 10 = 7</span></span><br><span class="line"><span class="comment">// 放入到对应的桶中</span></span><br><span class="line"><span class="comment">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">bucketElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line"><span class="comment">index = 0;</span></span><br><span class="line"><span class="comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="comment">for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="comment">if (bucketElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line"><span class="comment">for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">// 取出元素放入到arr</span></span><br><span class="line"><span class="comment">arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line"><span class="comment">bucketElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">System.out.println("第3轮，对个位的排序处理 arr =" + Arrays.toString(arr)); */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8000000条数据不到1秒！</p><p>再大会有内存溢出的可能  OutOfMempryError</p><h2 id="基数排序的说明"><a href="#基数排序的说明" class="headerlink" title="基数排序的说明:"></a>基数排序的说明:</h2><ol><li>基数排序是对传统桶排序的扩展，速度很快.</li><li>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。</li><li>基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些<br>记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且 r[i]在 r[j]之前，而在排序后的序列中，r[i]仍在 r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的]rv</li><li>有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9" target="_blank" rel="noopener">https://code.i-harness.com/zh-CN/q/e98fa9</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-归并排序</title>
      <link href="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序介绍"><a href="#归并排序介绍" class="headerlink" title="归并排序介绍:"></a>归并排序介绍:</h2><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的 <strong>分治 （divide-and-conquer ）策略</strong>（分治法将问题分(divide)成一些 <strong>小的问题然后递归求解</strong>，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><h2 id="归并排序思想示意图-1-基本思想"><a href="#归并排序思想示意图-1-基本思想" class="headerlink" title="归并排序思想示意图 1-基本思想:"></a>归并排序思想示意图 1-基本思想:</h2><p><img data-src="1.png" alt="1.png"></p><h2 id="归并排序思想示意图-2-合并相邻有序子序列"><a href="#归并排序思想示意图-2-合并相邻有序子序列" class="headerlink" title="归并排序思想示意图 2-合并相邻有序子序列:"></a>归并排序思想示意图 2-合并相邻有序子序列:</h2><p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将<br>[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤</p><p><img data-src="2.png" alt="2.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int arr[]=&#123;8,4,5,7,1,3,6,2&#125;;</span></span><br><span class="line"><span class="comment">int temp[] = new int[arr.length]; //归并排序需要一个额外空间</span></span><br><span class="line"><span class="comment"> mergeSort(arr, 0, arr.length - 1, temp);*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试快排的执行速度</span></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8000000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; <span class="comment">// 归并排序需要一个额外空间</span></span><br><span class="line">mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"><span class="comment">// System.out.println("归并排序后=" + Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分+合的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start&lt;end) &#123;<span class="comment">//当子序列中只有一个元素时结束递归</span></span><br><span class="line"><span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line"><span class="comment">//向左递归进行分解</span></span><br><span class="line">mergeSort(arr, start, mid, temp);<span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line"><span class="comment">//向右递归分解</span></span><br><span class="line">mergeSort(arr, mid+<span class="number">1</span>, end, temp);<span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line">merge(arr, start, mid, end, temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//合并的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid 中间索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp 做中转的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = left; <span class="comment">//初始化i，左边有序序列的初始索引</span></span><br><span class="line"><span class="keyword">int</span> j = mid+<span class="number">1</span>; <span class="comment">//初始化j，表示右边有序序列的初始索引</span></span><br><span class="line"><span class="keyword">int</span> t= <span class="number">0</span>; <span class="comment">//指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. </span></span><br><span class="line"><span class="comment">//先把左右两边的数据（此时已经有序），按照规则 填充到 temp数组，</span></span><br><span class="line"><span class="comment">//直到左右两边的有序序列 有一边处理完毕为止</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line"><span class="comment">// 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line"><span class="comment">// 即将左边的当前元素，填充到 temp数组</span></span><br><span class="line"><span class="comment">// 然后 t++, i++</span></span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">temp[t] = arr[i];</span><br><span class="line">i++;</span><br><span class="line">t++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 反之,将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">temp[t] = arr[j];</span><br><span class="line">j++;</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="comment">//把有剩余的一边的数据依次全部填充到temp</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid) &#123;</span><br><span class="line">temp[t] = arr[i];</span><br><span class="line">i++;</span><br><span class="line">t++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j&lt;=right) &#123;</span><br><span class="line">temp[t] = arr[j];</span><br><span class="line">j++;</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="comment">//将temp数组的元素重新copy到 arr</span></span><br><span class="line"><span class="comment">//注意，并不是每次都拷贝所有 </span></span><br><span class="line"><span class="comment">//temp长度和原数组一样，每次只用了其中一部分，不能全覆盖</span></span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tempLeft = left;</span><br><span class="line"><span class="comment">//第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3</span></span><br><span class="line"><span class="comment">//最后一次 tempLeft = 0  right = 7</span></span><br><span class="line"><span class="keyword">while</span> (tempLeft &lt;= right) &#123;</span><br><span class="line">arr[tempLeft] = temp[t];</span><br><span class="line">t++;</span><br><span class="line">tempLeft++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8000000条数据 1秒</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深克隆和浅克隆有什么区别？它的实现方式有哪些？</title>
      <link href="/2020/04/03/%E6%B7%B1%E5%85%8B%E9%9A%86%E5%92%8C%E6%B5%85%E5%85%8B%E9%9A%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
      <url>/2020/04/03/%E6%B7%B1%E5%85%8B%E9%9A%86%E5%92%8C%E6%B5%85%E5%85%8B%E9%9A%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<p>使用克隆可以为我们快速地构建出一个已有对象的副本，它属于Java基础的一部分，也是面试中常被问到的知识点之一。<br>我们本课时的面试题是，什么是浅克隆和深克隆？如何实现克隆？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p><strong>浅克隆（Shadow Clone）</strong>是把原型对象中成员变量为值类型的属性都复制给克隆对象，把原型对象中成员变量为引用类型的引用地址也复制给克隆对象，也就是原型对象中如果有成员变量为引用对象，则此引用对象的地址是共享给原型对象和克隆对象的。</p><p>简单来说就是浅克隆只会复制原型对象，但不会复制它所引用的对象，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p><strong>深克隆（Deep Clone）</strong>是将原型对象中的所有类型，无论是值类型还是引用类型，都复制一份给克隆对象，也就是说深克隆会把原型对象和原型对象所引用的对象，都复制一份给克隆对象，如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><p>在Java 语言中要实现克隆则需要实现Cloneable接口，并重写Object类中的clone0方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被赋值对象</span></span><br><span class="line">        People p1 = <span class="keyword">new</span> People();</span><br><span class="line">        p1.setId(<span class="number">1</span>);</span><br><span class="line">        p1.setName(<span class="string">"Java"</span>);</span><br><span class="line">        <span class="comment">// 克隆 p1 对象</span></span><br><span class="line">        People p2 = (People) p1.clone();</span><br><span class="line">        <span class="comment">// 打印名称</span></span><br><span class="line">        System.out.println(<span class="string">"p2:"</span> + p2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性</span></span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写 clone 方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行的结果为：</p><p><strong>p2:Java</strong></p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>克隆相关的面试题不算太难，但因为使用频率不高，因此很容易被人忽略，面试官通常会在一面或者二面的时候问到此知识点，和它相关的面试题还有以下这些：</p><ul><li>在java.lang.Object中对clone0方法的约定有哪些？</li><li>Arrays.copyOf0是深克隆还是浅克隆？</li><li>深克隆的实现方式有几种？</li><li>Java中的克隆为什么要设计成，既要实现空接口Cloneable，还要重写Object的clone0方法？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p><strong>clone（）源码分析</strong><br>要想真正的了解克隆，首先要从它的源码入手，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Creates and returns a copy of this object.The precise meaning</span></span><br><span class="line"><span class="comment">*of "copy"may depend on the class of the object.The general</span></span><br><span class="line"><span class="comment">*intent is that,for any object &#123;<span class="doctag">@code</span> x&#125;,the expression:</span></span><br><span class="line"><span class="comment">*&lt;blockquote〉</span></span><br><span class="line"><span class="comment">*&lt;pre&gt;</span></span><br><span class="line"><span class="comment">*x.clone()!=x〈/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">*will be true,and that the expression:</span></span><br><span class="line"><span class="comment">*&lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">*&lt;pre&gt;</span></span><br><span class="line"><span class="comment">*x.clone).getClass()==x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">*will be &#123;<span class="doctag">@code</span> true&#125;,but these are not absolute requirements.</span></span><br><span class="line"><span class="comment">*While it is typically the case that:</span></span><br><span class="line"><span class="comment">*&lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">*&lt;pre&gt;</span></span><br><span class="line"><span class="comment">*x.clone().equals(x)〈/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">*will be &#123;<span class="doctag">@code</span> true&#125;,this is not an absolute requirement.</span></span><br><span class="line"><span class="comment">*&lt;p&gt;</span></span><br><span class="line"><span class="comment">* By convention, the returned object should be obtained by calling</span></span><br><span class="line"><span class="comment">*&#123;@ code super. clone&#125;. If a class and all of its superclasses (except</span></span><br><span class="line"><span class="comment">*&#123;@ code Object&#125;) obey this convention, it will be the case that</span></span><br><span class="line"><span class="comment">*&#123;@ code x. clone). getClass)==x. getClass)&#125;.</span></span><br><span class="line"><span class="comment">*&lt;p&gt;</span></span><br><span class="line"><span class="comment">* By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment">* of this object (which is being cloned). To achieve this independence,</span></span><br><span class="line"><span class="comment">* it may be necessary to modify one or more fields of the object returned</span></span><br><span class="line"><span class="comment">* by &#123;@ code super. clone] before returning it. Typically, this means</span></span><br><span class="line"><span class="comment">* copying any mutable objects that comprise the internal "deep structure"</span></span><br><span class="line"><span class="comment">* of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment">* objects with references to the copies. If a class contains only</span></span><br><span class="line"><span class="comment">* primitive fields or references to immutable objects, then it is usually</span></span><br><span class="line"><span class="comment">* the case that no fields in the object returned by &#123;@ code super. clone&#125;</span></span><br><span class="line"><span class="comment">* need to be modified.</span></span><br><span class="line"><span class="comment">*&lt;p&gt;</span></span><br><span class="line"><span class="comment">protected native Object clone() throws CloneNotSupportedException;</span></span><br></pre></td></tr></table></figure><p>从以上源码的注释信息中我们可以看出，Object对clone0方法的约定有三条：</p><ul><li>对于所有对象来说，x.clone0！=x应当返回true，因为克隆对象与原对象不是同一个对象；</li><li>对于所有对象来说，x.clone0.getClass0==x.getClass0应当返回true，因为克隆对象与原对象的类型是一样的；</li><li>对于所有对象来说，x.clone0.equals（x）应当返回true，因为使用equals 比较时，它们的值都是相同的。</li></ul><p>除了注释信息外，我们看clone0的实现方法，发现clone0是使用native修饰的本地方法，因此执行的性能会很高，并且它返回的类型为Object，因此在调用克隆之后要把对象强转为目标类型才行。</p><h2 id="Arrays-copyOf-）"><a href="#Arrays-copyOf-）" class="headerlink" title="Arrays.copyOf(）"></a>Arrays.copyOf(）</h2><p>如果是数组类型，我们可以直接使用Arrays.copyOf()来实现克隆，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums1 = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">Integer[] nums2 = Arrays.copyOf(nums1, nums1.length);</span><br><span class="line"><span class="comment">// 修改克隆对象的第一个元素的值</span></span><br><span class="line">nums2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"nums1:"</span> + Arrays.toString(nums2));</span><br><span class="line">System.out.println(<span class="string">"nums2:"</span> + Arrays.toString(nums2));</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p><strong>nums1:[5, 5, 7, 9]</strong><br><strong>nums2:[5, 5, 7, 9]</strong></p><p>从结果可以看出，我们在修改克隆对象的第一个元素之后，原型对象的第一个元素也跟着被修改了，这说明Arrays.copyOf0其实是一个浅克隆。</p><p>你可能也发现了，数组中存储的明明是值类型，克隆之后应该是复制相关的值属性才对，但是数组比较特殊，因为数组本身就是引用类型，因此在使用Arrays.copyOf()其实只是把引用地址复制了一份给克隆对象，如果修改了它的引用对象，那么指向它的（引用地址）所有对象都会发生改变，因此看到的结果是，修改了克隆对象的第一个元素，原型对象也跟着被修改了。</p><h2 id="深克隆实现方式汇总"><a href="#深克隆实现方式汇总" class="headerlink" title="深克隆实现方式汇总"></a>深克隆实现方式汇总</h2><p>深克隆的实现方式有很多种，大体可以分为以下几类：</p><ul><li>所有对象都实现克隆方法；</li><li>通过构造方法实现深克隆；</li><li>使用JDK自带的字节流实现深克隆；</li><li>使用第三方工具实现深克隆，比如Apache Commons Lang；</li><li>使用JSON工具类实现深克隆，比如Gson、FastJSON等。</li></ul><p>接下来我们分别来实现以上这些方式，在开始之前先定义一个公共的用户类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address; <span class="comment">// 包含 Address 引用对象</span></span><br><span class="line">    <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出在 People 对象中包含了一个引用对象 Address。</p><h3 id="1-所有对象都实现克隆"><a href="#1-所有对象都实现克隆" class="headerlink" title="1.所有对象都实现克隆"></a>1.所有对象都实现克隆</h3><p>这种方式我们需要修改People和Address类，让它们都实现Cloneable的接口，让所有的引用对象都实现克隆，从而实现People类的深克隆，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被赋值对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        <span class="comment">// 克隆 p1 对象</span></span><br><span class="line">        People p2 = p1.clone();</span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                            <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写 clone 方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> People <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">             People people = (People) <span class="keyword">super</span>.clone();</span><br><span class="line">             people.setAddress(<span class="keyword">this</span>.address.clone()); <span class="comment">// 引用类型克隆赋值</span></span><br><span class="line">             <span class="keyword">return</span> people;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写 clone 方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Address <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p><strong>p1:西安 p2:北京</strong></p><p>从结果可以看出，当我们修改了原型对象的引用属性之后，并没有影响克隆对象，这说明此对象已经实现了深克隆。</p><h3 id="2-通过构造方法实现深克隆"><a href="#2-通过构造方法实现深克隆" class="headerlink" title="2.通过构造方法实现深克隆"></a>2.通过构造方法实现深克隆</h3><p>《Effective Java》中推荐使用构造器（Copy Constructor）来实现深克隆，如果构造器的参数为基本数据类型或字符串类型则直接赋值，如果是对象类型，则需要重新new一个对象，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用构造函数克隆对象</span></span><br><span class="line">         People p2 = <span class="keyword">new</span> People(p1.getId(), p1.getName(),</span><br><span class="line">                                <span class="keyword">new</span> Address(p1.getAddress().getId(), p1.getAddress().getCity()));</span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                           <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p><strong>p1:西安 p2:北京</strong></p><p>从结果可以看出，当我们修改了原型对象的引用属性之后，并没有影响克隆对象，这说明此对象已经实现了深克隆。</p><h3 id="3-通过字节流实现深克隆"><a href="#3-通过字节流实现深克隆" class="headerlink" title="3.通过字节流实现深克隆"></a>3.通过字节流实现深克隆</h3><p>通过JDK自带的字节流实现深克隆的方式，是先将要原型对象写入到内存中的字节流，然后再从这个字节流中读出刚刚存储的信息，来作为一个新的对象返回，那么这个新对象和原型对象就不存在任何地址上的共享，这样就实现了深克隆，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">         <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过字节流实现克隆</span></span><br><span class="line">        People p2 = (People) StreamClone.clone(p1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                           <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过字节流实现克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamClone</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(People obj)</span> </span>&#123;</span><br><span class="line">            T cloneObj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 写入字节流</span></span><br><span class="line">                ByteArrayOutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bo);</span><br><span class="line">                oos.writeObject(obj);</span><br><span class="line">                oos.close();</span><br><span class="line">                <span class="comment">// 分配内存,写入原始对象,生成新对象</span></span><br><span class="line">                ByteArrayInputStream bi = <span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());<span class="comment">//获取上面的输出字节流</span></span><br><span class="line">                ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</span><br><span class="line">                <span class="comment">// 返回生成的新对象</span></span><br><span class="line">                cloneObj = (T) oi.readObject();</span><br><span class="line">                oi.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cloneObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p><strong>p1:西安 p2:北京</strong></p><p>此方式需要注意的是，由于是通过字节流序列化实现的深克隆，因此每个对象必须能被序列化，必须实现Serializable接口，标识自己可以被序列化，否则会抛出异常（java.io.NotSerializableException）。</p><h3 id="4-通过第三方工具实现深克隆"><a href="#4-通过第三方工具实现深克隆" class="headerlink" title="4.通过第三方工具实现深克隆"></a>4.通过第三方工具实现深克隆</h3><p>本课时使用 Apache Commons Lang 来实现深克隆，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.SerializationUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深克隆实现方式四：通过 apache.commons.lang 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FourthExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 apache.commons.lang 克隆对象</span></span><br><span class="line">        People p2 = (People) SerializationUtils.clone(p1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                           <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p><strong>p1:西安 p2:北京</strong></p><p>可以看出此方法和第三种实现方式类似，都需要实现 Serializable 接口，都是通过字节流的方式实现的，只不过这种实现方式是第三方提供了现成的方法，让我们可以直接调用。</p><h3 id="5-通过-JSON-工具类实现深克隆"><a href="#5-通过-JSON-工具类实现深克隆" class="headerlink" title="5.通过 JSON 工具类实现深克隆"></a>5.通过 JSON 工具类实现深克隆</h3><p>本课时我们使用 Google 提供的 JSON 转化工具 Gson 来实现，其他 JSON 转化工具类也是类似的，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深克隆实现方式五：通过 JSON 工具实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FifthExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 Gson 克隆对象</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        People p2 = gson.fromJson(gson.toJson(p1), People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                           <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p><strong>p1:西安 p2:北京</strong></p><p>使用JSON工具类会先把对象转化成字符串，再从字符串转化成新的对象，因为新对象是从字符串转化而来的，因此不会和原型对象有任何的关联，这样就实现了深克隆，其他类似的JSON工具类实现方式也是一样的。</p><h2 id="克隆设计理念猜想"><a href="#克隆设计理念猜想" class="headerlink" title="克隆设计理念猜想"></a>克隆设计理念猜想</h2><p>对于克隆为什么要这样设计，官方没有直接给出答案，我们只能凭借一些经验和源码文档来试着回答一下这个问题。Java 中实现克隆需要两个主要的步骤，一是实现Cloneable空接口，二是重写Object 的clone0方法再调用父类的克隆方法（super.clone()），那为什么要这么做？</p><p>从源码中可以看出Cloneable 接口诞生的比较早，JDK1.0就已经存在了，因此从那个时候就已经有克隆方法了，那我们怎么来标识一个类级别对象拥有克隆方法呢？克隆虽然重要，但我们不能给每个类都默认加上克隆，这显然是不合适的，那我们能使用的手段就只有这几个了：</p><ul><li>在类上新增标识，此标识用于声明某个类拥有克隆的功能，像final关键字一样；</li><li>使用Java中的注解；</li><li>实现某个接口；</li><li>继承某个类。</li></ul><p>先说第一个，为了一个重要但不常用的克隆功能，单独新增一个类标识，这显然不合适；再说第二个，因为克隆功能出现的比较早，那时候还没有注解功能，因此也不能使用；第三点基本满足我们的需求，第四点和第一点比较类似，为了一个克隆功能需要牺牲一个基类，并且Java只能单继承，因此这个方案也不合适。采用排除法，无疑使用实现接口的方式是那时最合理的方案了，而且在Java 语言中一个类可以实现多个接口。</p><p><strong>那为什么要在Object 中添加一个clone()方法呢？</strong></p><p>因为clone()方法语义的特殊性，因此最好能有JVM的直接支持，既然要JVM直接支持，就要找一个API来把这个方法暴露出来才行，最直接的做法就是把它放入到一个所有类的基类Object中，这样所有类就可以很方便地调用到了。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-快速排序</title>
      <link href="/2020/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序法介绍"><a href="#快速排序法介绍" class="headerlink" title="快速排序法介绍:"></a>快速排序法介绍:</h2><p>快速排序（Quicksort）是对 <strong>冒泡排序</strong>的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两<br>部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排<br>序， <strong>整个排序过程可以递归进行</strong>，以此达到整个数据变成有序序列。</p><h2 id="快速排序法示意图"><a href="#快速排序法示意图" class="headerlink" title="快速排序法示意图:"></a>快速排序法示意图:</h2><p><img data-src="1.png" alt="1.png"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>定义两个指针 分别指向传进来的左右两个位置</li><li>定义中间的基准数，下面会按照这个基准数进行排序</li><li>从左侧一直往基准数的位置找，直到有一个数大于或者等于基准数停止，同样 右侧一直找到一个小于等于基准数的位置。</li><li>判断一下这两个指针指向的位置是否相等，若相等则表示 此时基准数左边 和右边 已经排序完成了</li><li>若不等，则将找到的两个位置的数进行交换</li><li>交换后判断换好的的 两个数 是否等于基准数，若左侧等于基准数 则r- - ，反之 若右侧的数等于基准数 则 l++。</li><li>至此 一轮比较结束，但要判断一下 两个指针是否相等，若相等，将两个指针分别往前移动一位。</li><li>左侧和右侧分别开始递归，左侧是 left—–r  右侧是 l—–right</li><li>排序完成</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;-<span class="number">9</span>,<span class="number">78</span>,<span class="number">0</span>,<span class="number">23</span>,-<span class="number">567</span>,<span class="number">70</span>, -<span class="number">1</span>,<span class="number">900</span>, <span class="number">4561</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line">quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"排序后"</span>);</span><br><span class="line">System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//测试快排的执行速度</span></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="comment">int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("排序前");</span></span><br><span class="line"><span class="comment">Date data1 = new Date();</span></span><br><span class="line"><span class="comment">SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");</span></span><br><span class="line"><span class="comment">String date1Str = simpleDateFormat.format(data1);</span></span><br><span class="line"><span class="comment">System.out.println("排序前的时间是=" + date1Str);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">quickSort(arr, 0, arr.length-1);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Date data2 = new Date();</span></span><br><span class="line"><span class="comment">String date2Str = simpleDateFormat.format(data2);</span></span><br><span class="line"><span class="comment">System.out.println("排序前的时间是=" + date2Str);</span></span><br><span class="line"><span class="comment">//System.out.println("arr=" + Arrays.toString(arr));*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = left; <span class="comment">//左下标</span></span><br><span class="line"><span class="keyword">int</span> r = right; <span class="comment">//右下标</span></span><br><span class="line"><span class="comment">//pivot 中轴值</span></span><br><span class="line"><span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">//临时变量，作为交换时使用</span></span><br><span class="line"><span class="comment">//while循环的目的是让比pivot 值小放到左边</span></span><br><span class="line"><span class="comment">//比pivot 值大放到右边</span></span><br><span class="line"><span class="keyword">while</span>( l &lt; r) &#123; </span><br><span class="line"><span class="comment">//在pivot的左边一直找,找到大于等于pivot值,才退出</span></span><br><span class="line"><span class="keyword">while</span>( arr[l] &lt; pivot) &#123;</span><br><span class="line">l += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在pivot的右边一直找,找到小于等于pivot值,才退出</span></span><br><span class="line"><span class="keyword">while</span>(arr[r] &gt; pivot) &#123;</span><br><span class="line">r -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果l == r说明pivot 的左右两的值，已经按照左边全部是</span></span><br><span class="line"><span class="comment">//小于等于pivot值，右边全部是大于等于pivot值</span></span><br><span class="line"><span class="keyword">if</span>( l == r) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line">temp = arr[l];</span><br><span class="line">arr[l] = arr[r];</span><br><span class="line">arr[r] = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移</span></span><br><span class="line"><span class="comment">//为了处理左侧有序，右侧还无序的情况</span></span><br><span class="line"><span class="keyword">if</span>(arr[l] == pivot) &#123;</span><br><span class="line">r -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移</span></span><br><span class="line"><span class="keyword">if</span>(arr[r] == pivot) &#123;</span><br><span class="line">l += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span></span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">l += <span class="number">1</span>;</span><br><span class="line">r -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向左递归</span></span><br><span class="line"><span class="keyword">if</span>(left &lt; r) &#123;</span><br><span class="line">quickSort(arr, left, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向右递归</span></span><br><span class="line"><span class="keyword">if</span>(right &gt; l) &#123;</span><br><span class="line">quickSort(arr, l, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8000000条数据 1 秒</p><h3 id="更简单的代码"><a href="#更简单的代码" class="headerlink" title="更简单的代码"></a>更简单的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSortDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line">quickSort(<span class="number">0</span>, arr.length-<span class="number">1</span>,arr);</span><br><span class="line">System.out.println(<span class="string">"排序后"</span>);</span><br><span class="line">System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line"><span class="keyword">int</span> temp = arr[left];</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">while</span> ( i &lt; j) &#123;</span><br><span class="line"><span class="comment">//右边依次向左递减</span></span><br><span class="line"><span class="keyword">while</span> (j&gt;i &amp;&amp; arr[j] &gt;= temp) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左边依次向右递增</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;j &amp;&amp; arr[i] &lt;= temp) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">t=arr[j];</span><br><span class="line">arr[j] = arr[i];</span><br><span class="line">arr[i] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[left] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line"></span><br><span class="line">quickSort(left, i-<span class="number">1</span>, arr);</span><br><span class="line">quickSort(j+<span class="number">1</span>, right, arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-希尔排序</title>
      <link href="/2020/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="希尔排序法介绍"><a href="#希尔排序法介绍" class="headerlink" title="希尔排序法介绍"></a>希尔排序法介绍</h2><p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种 <strong>插入排序</strong>，它是简单插入排序经过改进之后的一个 <strong>更高效的版本</strong>，也称为 <strong>缩小增量排序</strong>。</p><h2 id="希尔排序法基本思想"><a href="#希尔排序法基本思想" class="headerlink" title="希尔排序法基本思想"></a>希尔排序法基本思想</h2><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含<br>的关键词越来越多， <strong>当增量减至 1  时</strong>，整个文件恰被分成一组，算法便终止</p><h2 id="希尔排序法的示意图"><a href="#希尔排序法的示意图" class="headerlink" title="希尔排序法的示意图"></a>希尔排序法的示意图</h2><p><img data-src="1.png" alt="1.png"></p><p><img data-src="2.png" alt="2.png"></p><h2 id="交换法实现"><a href="#交换法实现" class="headerlink" title="交换法实现"></a>交换法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int arr[] = &#123;8,9,1,7,2,3,5,4,6,0&#125;;</span></span><br><span class="line"><span class="comment">//shellSort2(arr);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line">shellSort(arr); <span class="comment">//交换式</span></span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用逐步推导的方式来编写希尔排序</span></span><br><span class="line"><span class="comment">// 希尔排序时， 对有序序列在插入时采用交换法, </span></span><br><span class="line"><span class="comment">// 思路(算法) ===&gt; 代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 根据前面的逐步分析，使用循环处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="comment">// 遍历各组中所有的元素(共gap组，每组有个元素), 步长gap</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line"><span class="comment">// 如果当前这个元素大于加上这个步长后的那个元素，说明交换</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + gap];</span><br><span class="line">arr[j + gap] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// System.out.println("希尔排序第" + (++count) + "轮 =" + Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//希尔排序的第一轮排序</span></span><br><span class="line"><span class="comment">//因为第1轮排序是将10个数据分成了5组</span></span><br><span class="line"><span class="comment">int temp = 0;</span></span><br><span class="line"><span class="comment">for(int i = 5;i&lt;arr.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//遍历各组中所有的元素（共5组，每组2个元素） 步长是5</span></span><br><span class="line"><span class="comment">for(int j=i-5;j&gt;=0;j-=5)&#123;</span></span><br><span class="line"><span class="comment">//如果当前这个元素大于加上这个步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">if (arr[j]&gt;arr[j+5]) &#123;</span></span><br><span class="line"><span class="comment">temp = arr[j];</span></span><br><span class="line"><span class="comment">arr[j] = arr[j+5];</span></span><br><span class="line"><span class="comment">arr[j+5]=temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">System.out.println("希尔排序1轮后=" + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">// 希尔排序的第2轮排序</span></span><br><span class="line"><span class="comment">// 因为第2轮排序，是将10个数据分成了 5/2 = 2组</span></span><br><span class="line"><span class="comment">for (int i = 2; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line"><span class="comment">for (int j = i - 2; j &gt;= 0; j -= 2) &#123;</span></span><br><span class="line"><span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">if (arr[j] &gt; arr[j + 2]) &#123;</span></span><br><span class="line"><span class="comment">temp = arr[j];</span></span><br><span class="line"><span class="comment">arr[j] = arr[j + 2];</span></span><br><span class="line"><span class="comment">arr[j + 2] = temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("希尔排序2轮后=" + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 希尔排序的第3轮排序</span></span><br><span class="line"><span class="comment">// 因为第3轮排序，是将10个数据分成了 2/2 = 1组</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line"><span class="comment">for (int j = i - 1; j &gt;= 0; j -= 1) &#123;</span></span><br><span class="line"><span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">if (arr[j] &gt; arr[j + 1]) &#123;</span></span><br><span class="line"><span class="comment">temp = arr[j];</span></span><br><span class="line"><span class="comment">arr[j] = arr[j + 1];</span></span><br><span class="line"><span class="comment">arr[j + 1] = temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("希尔排序3轮后=" + Arrays.toString(arr));*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>80000个数据大概7秒</p><h2 id="移位法实现"><a href="#移位法实现" class="headerlink" title="移位法实现"></a>移位法实现</h2><p>先分组再插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int arr[] = &#123;8,9,1,7,2,3,5,4,6,0&#125;;</span></span><br><span class="line"><span class="comment">//shellSort2(arr);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line">shellSort2(arr);<span class="comment">// 移位方式</span></span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对交换式的希尔排序进行优化-&gt;移位法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据前面的逐步分析，使用循环处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j =i;</span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[j-gap]) &#123;</span><br><span class="line"><span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line"><span class="comment">//移动</span></span><br><span class="line">arr[j] = arr[j-gap];</span><br><span class="line">j-=gap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当退出while后，就给temp找到插入的位置</span></span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// System.out.println("希尔排序后"  + Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>80000个数据不到1秒  8000000个数据  2秒</strong>    ！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-插入排序</title>
      <link href="/2020/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="插入排序法介绍"><a href="#插入排序法介绍" class="headerlink" title="插入排序法介绍:"></a>插入排序法介绍:</h2><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</p><h2 id="插入排序法思想"><a href="#插入排序法思想" class="headerlink" title="插入排序法思想:"></a>插入排序法思想:</h2><p>插入排序（Insertion Sorting）的基本思想是：把 <strong>n  个待排序的元素看成为一个有序表和一个无序表</strong>，开始时有序表中只包含一个元素，无序表中包含有 <strong>n-1  个元素</strong>，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p><h2 id="插入排序思路图"><a href="#插入排序思路图" class="headerlink" title="插入排序思路图:"></a>插入排序思路图:</h2><p><img data-src="1.png" alt="1.png"></p><h2 id="插入排序法应用实例"><a href="#插入排序法应用实例" class="headerlink" title="插入排序法应用实例:"></a>插入排序法应用实例:</h2><p>有一群小牛, 考试成绩分别是 101, 34, 119, 1 请从小到大排序</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">89</span> &#125;;</span><br><span class="line">insertSort(arr); <span class="comment">//调用插入排序算法s</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="comment">int[] arr = new int[80000];</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; 80000; i++) &#123;</span></span><br><span class="line"><span class="comment">arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("插入排序前");</span></span><br><span class="line"><span class="comment">Date data1 = new Date();</span></span><br><span class="line"><span class="comment">SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");</span></span><br><span class="line"><span class="comment">String date1Str = simpleDateFormat.format(data1);</span></span><br><span class="line"><span class="comment">System.out.println("排序前的时间是=" + date1Str);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">insertSort(arr); // 调用插入排序算法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Date data2 = new Date();</span></span><br><span class="line"><span class="comment">String date2Str = simpleDateFormat.format(data2);</span></span><br><span class="line"><span class="comment">System.out.println("排序前的时间是=" + date2Str);*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> insertVal = arr[i];</span><br><span class="line"><span class="keyword">int</span> insertIndex = i-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal&lt;arr[insertIndex]) &#123;</span><br><span class="line">arr[insertIndex+<span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">insertIndex--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line"><span class="comment">// 这里我们判断是否需要赋值</span></span><br><span class="line"><span class="keyword">if</span> (insertIndex+<span class="number">1</span> != i) &#123;</span><br><span class="line">arr[insertIndex+<span class="number">1</span>] = insertVal;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"第"</span>+i+<span class="string">"轮插入"</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 使用逐步推导的方式来讲解，便利理解</span></span><br><span class="line"><span class="comment">// 第1轮 &#123;101, 34, 119, 1&#125;; =&gt; &#123;34, 101, 119, 1&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// &#123;101, 34, 119, 1&#125;; =&gt; &#123;101,101,119,1&#125;</span></span><br><span class="line"><span class="comment">// 定义待插入的数</span></span><br><span class="line"><span class="comment">int insertVal = arr[1];</span></span><br><span class="line"><span class="comment">int insertIndex = 1 - 1; // 即arr[1]的前面这个数的下标</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line"><span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line"><span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line"><span class="comment">while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex]</span></span><br><span class="line"><span class="comment">insertIndex--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line"><span class="comment">// 举例：理解不了，我们一会 debug</span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第1轮插入");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">// 第2轮</span></span><br><span class="line"><span class="comment">insertVal = arr[2];</span></span><br><span class="line"><span class="comment">insertIndex = 2 - 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex]</span></span><br><span class="line"><span class="comment">insertIndex--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment">System.out.println("第2轮插入");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 第3轮</span></span><br><span class="line"><span class="comment">insertVal = arr[3];</span></span><br><span class="line"><span class="comment">insertIndex = 3 - 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex]</span></span><br><span class="line"><span class="comment">insertIndex--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment">System.out.println("第3轮插入");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>80000条数据用时两秒</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】的集成</title>
      <link href="/2020/03/31/MyBatis%E7%9A%84%E9%9B%86%E6%88%90/"/>
      <url>/2020/03/31/MyBatis%E7%9A%84%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="基本准备"><a href="#基本准备" class="headerlink" title="基本准备"></a>基本准备</h2><h3 id="创建Dynamic-Web-Project"><a href="#创建Dynamic-Web-Project" class="headerlink" title="创建Dynamic Web Project"></a>创建Dynamic Web Project</h3><h3 id="引入相关jar包"><a href="#引入相关jar包" class="headerlink" title="引入相关jar包"></a>引入相关jar包</h3><ul><li>Spring框架相关jar包</li><li>MyBatis连接Spring相关jar包</li><li>连接MySQL驱动包</li><li>JSTL标签库包</li></ul><p><img data-src="1.png" alt="1.png"></p><h3 id="添加db-properties文件，该属性文件配置连接数据库相关信息"><a href="#添加db-properties文件，该属性文件配置连接数据库相关信息" class="headerlink" title="添加db.properties文件，该属性文件配置连接数据库相关信息"></a>添加db.properties文件，该属性文件配置连接数据库相关信息</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatisdemo_db?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><h3 id="添加Spring配置文件，在src中新增applicationContext-xml，并引入该属性文件"><a href="#添加Spring配置文件，在src中新增applicationContext-xml，并引入该属性文件" class="headerlink" title="添加Spring配置文件，在src中新增applicationContext.xml，并引入该属性文件"></a>添加Spring配置文件，在src中新增applicationContext.xml，并引入该属性文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入数据库连接信息的属性文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在Spring配置文件中添加DataSource的配置，PooledDataSource为MyBatis实现的数据库连接池"><a href="#在Spring配置文件中添加DataSource的配置，PooledDataSource为MyBatis实现的数据库连接池" class="headerlink" title="在Spring配置文件中添加DataSource的配置，PooledDataSource为MyBatis实现的数据库连接池"></a>在Spring配置文件中添加DataSource的配置，PooledDataSource为MyBatis实现的数据库连接池</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.ibatis.datasource.pooled.PooledDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;user&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在Spring配置文件中添加SqlSessionFactoryBean，用来创建SqlSessionFactory对象"><a href="#在Spring配置文件中添加SqlSessionFactoryBean，用来创建SqlSessionFactory对象" class="headerlink" title="在Spring配置文件中添加SqlSessionFactoryBean，用来创建SqlSessionFactory对象"></a>在Spring配置文件中添加SqlSessionFactoryBean，用来创建SqlSessionFactory对象</h3><ul><li>configLocation：用于指定MyBatis的mybatis.xml配置文件的路径</li><li>dataSource：用于配置数据源，该属性为必选项，可以直接引用已经配置好的dataSource数据库连接池</li><li>mapperLocations：扫描XML映射文件的路径</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载mybatis配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载mapper.xml路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:top/hiasenna/mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在Spring配置文件中添加MapperScannerConfigurer，自动扫描所有的Mapper接口"><a href="#在Spring配置文件中添加MapperScannerConfigurer，自动扫描所有的Mapper接口" class="headerlink" title="在Spring配置文件中添加MapperScannerConfigurer，自动扫描所有的Mapper接口"></a>在Spring配置文件中添加MapperScannerConfigurer，自动扫描所有的Mapper接口</h3><ul><li>basePackage：用于配置基本的包路径</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"top.hiasenna.mapper"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring公共配置 <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Spring上下文的注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用annotation 自动注册bean, 并保证@Required、@Autowired的属性被注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span></span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 属性文件位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span></span></span><br><span class="line"><span class="tag"><span class="attr">location</span>=<span class="string">"classpath:*.properties"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载mybatis配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载mapper.xml路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:top/hiasenna/mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"top.hiasenna.mapper"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="spring-mvc-xml"><a href="#spring-mvc-xml" class="headerlink" title="spring-mvc.xml"></a>spring-mvc.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span></span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将无法mapping到Controller的path交给default servlet handler处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/static/"</span> <span class="attr">mapping</span>=<span class="string">"/static/**"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义JSP文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用annotation定义事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span></span></span><br><span class="line"><span class="tag"><span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>mybatis_spring<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="mybatis-xml"><a href="#mybatis-xml" class="headerlink" title="mybatis.xml"></a>mybatis.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打印SQL语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="dbinfo-properties"><a href="#dbinfo-properties" class="headerlink" title="dbinfo.properties"></a>dbinfo.properties</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql</span></span><br><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatisdemo_db?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈你对锁的理解？如何手动模拟一个死锁？</title>
      <link href="/2020/03/30/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81/"/>
      <url>/2020/03/30/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>在并发编程中有两个重要的概念：<strong>线程和锁</strong>，多线程是一把双刃剑，它在提高程序性能的同时，也带来了编码的复杂性，对开发者的要求也提高了一个档次。而锁的出现就是为了保障多线程在同时操作一组资源时的数据一致性，当我们给资源加上锁之后，只有拥有此锁的线程才能操作此资源，而其他线程只能排队等待使用此锁。当然，在所有的面试中也都少不了关于“锁”方面的相关问题。</p><p>我们本课时的面试题是，如何手动模拟一个死锁？谈谈你对锁的理解？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>死锁是指两个线程同时占用两个资源，又在彼此等待对方释放锁资源，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p>死锁的代码演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        deadLock(); <span class="comment">// 死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 线程一拥有 lock1 试图获取 lock2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"获取 lock1 成功"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 试图获取锁 lock2</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        <span class="comment">// 线程二拥有 lock2 试图获取 lock1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"获取 lock2 成功"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 试图获取锁 lock1</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取 lock1 成功</span><br><span class="line">获取 lock2 成功</span><br></pre></td></tr></table></figure><p>可以看出当我们使用线程一拥有锁 lock1的同时试图获取lock2，而线程二在拥有lock2的同时试图获取lock1，这样就会造成彼此都在等待对方释放资源，于是就形成了<strong>死锁</strong>。</p><p>锁是指在并发编程中，当有多个线程同时操作一个资源时，为了保证数据操作的正确性，我们需要让多线程排队一个一个的操作此资源，而这个过程就是给资源加锁和释放锁的过程，就好像去公共厕所一样，必须一个一个排队使用，并且在使用时需要锁门和开门一样。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>锁的概念不止出现在Java语言中，比如乐观锁和悲观锁其实很早就存在于数据库中了。锁的概念其实不难理解，但要真正的了解锁的原理和实现过程，才能打动面试官。</p><p>和锁相关的面试问题，还有以下几个：</p><ul><li>什么是乐观锁和悲观锁？它们的应用都有哪些？乐观锁有什么问题？</li><li>什么是可重入锁？用代码如何实现？它的实现原理是什么？</li><li>什么是共享锁和独占锁？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-悲观锁和乐观锁"><a href="#1-悲观锁和乐观锁" class="headerlink" title="1.悲观锁和乐观锁"></a>1.悲观锁和乐观锁</h3><p>悲观锁指的是数据对外界的修改采取保守策略，它认为线程很容易会把数据修改掉，因此在整个数据被修改的过程中都会采取锁定状态，直到一个线程使用完，其他线程才可以继续使用。</p><p>我们来看一下悲观锁的实现流程，以synchronized为例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (LockExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"lock"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用反编译工具查到的结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"LockExample.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">lagou</span>.<span class="title">interview</span>.<span class="title">ext</span>.<span class="title">LockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> com.lagou.interview.ext.LockExample();</span><br><span class="line">    Code:</span><br><span class="line">    <span class="number">0</span>: aload_0</span><br><span class="line">        1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">    0: ldc           #2                  // class com/lagou/interview/ext/LockExample</span><br><span class="line">        <span class="number">2</span>: dup</span><br><span class="line">        <span class="number">3</span>: astore_1</span><br><span class="line">        <span class="number">4</span>: monitorenter <span class="comment">// 加锁</span></span><br><span class="line">        5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        8: ldc           #4                  // String lock</span><br><span class="line">        10:invokevirtual#5//Methodjava/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="number">14</span>: monitorexit <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">        <span class="number">18</span>: astore_2</span><br><span class="line">        <span class="number">19</span>: aload_1</span><br><span class="line">        <span class="number">20</span>: monitorexit</span><br><span class="line">        <span class="number">21</span>: aload_2</span><br><span class="line">        <span class="number">22</span>: athrow</span><br><span class="line">        <span class="number">23</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">          from    to  target type</span><br><span class="line">           <span class="number">5</span>    <span class="number">15</span>    <span class="number">18</span>   any</span><br><span class="line">          <span class="number">18</span>    <span class="number">21</span>    <span class="number">18</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出被synchronized 修饰的代码块，在执行之前先使用monitorenter 指令加锁，然后在执行结束之后再使用monitorexit 指令释放锁资源，在整个执行期间此代码都是锁定的状态，这就是<strong>典型悲观锁的实现流程</strong>。</p><p>乐观锁和悲观锁的概念恰好相反，乐观锁认为一般情况下数据在修改时不会出现冲突，所以在数据访问之前不会加锁，只是在数据提交更改时，才会对数据进行检测。</p><p>Java 中的乐观锁大部分都是通过CAS（Compare And Swap，比较并交换）操作实现的，CAS是一个多线程同步的原子指令，CAS操作包含三个重要的信息，即内存位置、预期原值和新值。如果内存位置的值和预期的原值相等的话，那么就可以把该位置的值更新为新值，否则不做任何修改，我们在第05课时讲解 ReentrantLock时知道了它也是通过CAS实现的。Lock是乐观锁的典型实现案例。</p><p>CAS可能会造成ABA的问题，ABA问题指的是，线程拿到了最初的预期原值A，然而在将要进行<br>CAS的时候，被其他线程抢占了执行权，把此值从A变成了B，然后其他线程又把此值从B变成了A，然而此时的A值已经并非原来的A值了，但最初的线程并不知道这个情况，在它进行CAS的时候，只对比了预期原值为A就进行了修改，这就造成了ABA的问题。</p><p>以警匪剧为例，假如某人把装了100W现金的箱子放在了家里，几分钟之后要拿它去赎人，然而在趁他不注意的时候，进来了一个小偷，用空箱子换走了装满钱的箱子，当某人进来之后看到箱子还是一模一样的，他会以为这就是原来的箱子，就拿着它去赎人了，这种情况肯定有问题，因为箱子已经是空的了，这就是ABA的问题。</p><p>ABA的常见处理方式是添加版本号，每次修改之后更新版本号，拿上面的例子来说，假如每次移动箱子之后，箱子的位置就会发生变化，而这个变化的位置就相当于“版本号”，当某人进来之后发现箱子的位置发生了变化就知道有人动了手脚，就会放弃原有的计划，这样就解决了ABA的问题。</p><p>JDK在1.5时提供了AtomicStampedReference 类也可以解决ABA的问题，此类维护了一个“版本号”Stamp，每次在比较时不止比较当前值还比较版本号，这样就解决了ABA的问题。<br>相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp; <span class="comment">// “版本号”</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较并设置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp, // 原版本号</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123; <span class="comment">// 新版本号</span></span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//.......省略其他源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出它在修改时会进行原值比较和版本号比较，当比较成功之后会修改值并修改版本号。</p><p><strong>小贴士</strong>：乐观锁有一个优点，它在提交的时候才进行锁定的，因此不会造成死锁。</p><h3 id="2-可重入锁"><a href="#2-可重入锁" class="headerlink" title="2.可重入锁"></a>2.可重入锁</h3><p>可重入锁也叫递归锁，指的是同一个线程，如果外面的函数拥有此锁之后，内层的函数也可以继续获取该锁。在Java 语言中ReentrantLock和synchronized都是可重入锁。</p><p>下面我们用synchronized来演示一下什么是可重入锁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        reentrantA(); <span class="comment">// 可重入锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重入锁 A 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reentrantA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"：执行 reentrantA"</span>);</span><br><span class="line">        reentrantB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重入锁 B 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reentrantB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"：执行 reentrantB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的执行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main：执行 reentrantA</span><br><span class="line">main：执行 reentrantB</span><br></pre></td></tr></table></figure><p>从结果可以看出reentrantA 方法和reentrantB方法的执行线程都是“main”，我们调用了reentrantA方法，它的方法中嵌套了reentrantB，如果synchronized是不可重入的话，那么线程会被一直堵塞。</p><p>可重入锁的实现原理，是在锁内部存储了一个线程标识，用于判断当前的锁属于哪个线程，并且锁的内部维护了一个计数器，当锁空闲时此计数器的值为0，当被线程占用和重入时分别加1，当锁被释放时计数器减1，直到减到0时表示此锁为空闲状态。</p><h3 id="3-共享锁和独占锁"><a href="#3-共享锁和独占锁" class="headerlink" title="3.共享锁和独占锁"></a>3.共享锁和独占锁</h3><p>只能被单线程持有的锁叫<strong>独占锁</strong>，可以被多线程持有的锁叫<strong>共享锁</strong>。</p><p>独占锁指的是在任何时候最多只能有一个线程持有该锁，比如 ReentrantLock 就是独占锁，而<br>ReadWriteLock 读写锁允许同一时间内有多个线程进行读操作，它就属于共享锁。</p><p>独占锁可以理解为悲观锁，当每次访问资源时都要加上互斥锁，而共享锁可以理解为乐观锁，它放宽了加锁的条件，允许多线程同时访问该资源。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们讲了悲观锁和乐观锁，其中悲观锁的典型应用为synchronized，而ReentrantLock为乐观锁的典型应用，乐观锁可能会导致ABA的问题，常见的解决方案是添加版本号来防止ABA问题的发生；同时，还讲了可重入锁，在Java中，synchronized和ReentrantLock 都是可重入锁；最后讲了独占锁和共享锁，其中独占锁可以理解为悲观锁，而共享锁可以理解为乐观锁。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-选择排序</title>
      <link href="/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到<br>排序的目的。</p><h2 id="选择排序思想"><a href="#选择排序思想" class="headerlink" title="选择排序思想:"></a>选择排序思想:</h2><p>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0]<del>arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]</del>arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]<del>arr[n-1]中选取最小值，与 arr[2]交换，…，第 i 次从 arr[i-1]</del>arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p><h2 id="选择排序思路分析图"><a href="#选择排序思路分析图" class="headerlink" title="选择排序思路分析图:"></a>选择排序思路分析图:</h2><p><img data-src="1.png" alt="1.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> [] arr = &#123;<span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">90</span>, <span class="number">123</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">selectSort(arr);</span><br><span class="line">System.out.println(<span class="string">"排序后"</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="comment">//int[] arr = new int[80000];</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; 80000; i++) &#123;</span></span><br><span class="line"><span class="comment">//arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//System.out.println("排序前");</span></span><br><span class="line"><span class="comment">//// System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Date data1 = new Date();</span></span><br><span class="line"><span class="comment">//SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");</span></span><br><span class="line"><span class="comment">//String date1Str = simpleDateFormat.format(data1);</span></span><br><span class="line"><span class="comment">//System.out.println("排序前的时间是=" + date1Str);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//selectSort(arr);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Date data2 = new Date();</span></span><br><span class="line"><span class="comment">//String date2Str = simpleDateFormat.format(data2);</span></span><br><span class="line"><span class="comment">//System.out.println("排序前的时间是=" + date2Str);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">//选择排序时间复杂度是 O(n^2)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> minIndex = i;</span><br><span class="line"><span class="keyword">int</span> min = arr[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (min&gt;arr[j]) &#123;</span><br><span class="line">min=arr[j];</span><br><span class="line">minIndex=j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line"><span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">arr[minIndex] = arr[i];</span><br><span class="line">arr[i]=min;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"轮后~~"</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));<span class="comment">// 1, 34, 119, 101</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//使用逐步推导的方式来，讲解选择排序</span></span><br><span class="line"><span class="comment">//第1轮</span></span><br><span class="line"><span class="comment">//原始的数组 ： 101, 34, 119, 1</span></span><br><span class="line"><span class="comment">//第一轮排序 :   1, 34, 119, 101</span></span><br><span class="line"><span class="comment">//算法 先简单--》 做复杂， 就是可以把一个复杂的算法，拆分成简单的问题-》逐步解决</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第1轮</span></span><br><span class="line"><span class="comment">int minIndex = 0;</span></span><br><span class="line"><span class="comment">int min = arr[0];</span></span><br><span class="line"><span class="comment">for(int j = 0 + 1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">if (min &gt; arr[j]) &#123; //说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">min = arr[j]; //重置min</span></span><br><span class="line"><span class="comment">minIndex = j; //重置minIndex</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//将最小值，放在arr[0], 即交换</span></span><br><span class="line"><span class="comment">if(minIndex != 0) &#123;</span></span><br><span class="line"><span class="comment">arr[minIndex] = arr[0];</span></span><br><span class="line"><span class="comment">arr[0] = min;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第1轮后~~");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));// 1, 34, 119, 101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第2轮</span></span><br><span class="line"><span class="comment">minIndex = 1;</span></span><br><span class="line"><span class="comment">min = arr[1];</span></span><br><span class="line"><span class="comment">for (int j = 1 + 1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">min = arr[j]; // 重置min</span></span><br><span class="line"><span class="comment">minIndex = j; // 重置minIndex</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line"><span class="comment">if(minIndex != 1) &#123;</span></span><br><span class="line"><span class="comment">arr[minIndex] = arr[1];</span></span><br><span class="line"><span class="comment">arr[1] = min;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第2轮后~~");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));// 1, 34, 119, 101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第3轮</span></span><br><span class="line"><span class="comment">minIndex = 2;</span></span><br><span class="line"><span class="comment">min = arr[2];</span></span><br><span class="line"><span class="comment">for (int j = 2 + 1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">min = arr[j]; // 重置min</span></span><br><span class="line"><span class="comment">minIndex = j; // 重置minIndex</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line"><span class="comment">if (minIndex != 2) &#123;</span></span><br><span class="line"><span class="comment">arr[minIndex] = arr[2];</span></span><br><span class="line"><span class="comment">arr[2] = min;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第3轮后~~");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));// 1, 34, 101, 119 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>80000条数据大概需要<strong>2</strong>秒钟</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-冒泡排序</title>
      <link href="/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）, 依<strong>次比较</strong><br><strong>相邻元素的值，若发现逆序则交换</strong>，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p><p><strong>优化：</strong></p><p>因为排序的过程中，各元素不断接近自己的位置， <strong>如果一趟比较下来没有进行过交换 ， 就说明序列有序</strong>，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行)</p><h2 id="演示冒泡过程的例子-图解"><a href="#演示冒泡过程的例子-图解" class="headerlink" title="演示冒泡过程的例子(图解)"></a>演示冒泡过程的例子(图解)</h2><p><img data-src="1.png" alt="1.png"></p><p>小结上面的图解过程:</p><ol><li>一共进行 数组的大小-1 次 大的循环</li><li>每一趟排序的次数在逐渐的减少</li><li>如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"> System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line"> System.out.println(Arrays.toString(arr));</span><br><span class="line"> bubbleSort(arr);</span><br><span class="line"> System.out.println(<span class="string">"趟排序后的数组"</span>);</span><br><span class="line"> System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">// 测试一下冒泡排序的速度O(n^2), 给80000个数据，测试</span></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="comment">//int[] arr = new int[80000];</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; 80000; i++) &#123;</span></span><br><span class="line"><span class="comment">//arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Date data1 = new Date();</span></span><br><span class="line"><span class="comment">//SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");</span></span><br><span class="line"><span class="comment">//String date1Str = simpleDateFormat.format(data1);</span></span><br><span class="line"><span class="comment">//System.out.println("排序前的时间是=" + date1Str);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// 测试冒泡排序</span></span><br><span class="line"><span class="comment">//bubbleSort(arr);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Date data2 = new Date();</span></span><br><span class="line"><span class="comment">//String date2Str = simpleDateFormat.format(data2);</span></span><br><span class="line"><span class="comment">//System.out.println("排序后的时间是=" + date2Str);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">// 交换用</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line"><span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123; <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">flag = <span class="keyword">false</span>; <span class="comment">// 重置flag!!!, 进行下次判断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// System.out.println("第" + (i + 1) + "趟排序后的数组");</span></span><br><span class="line"><span class="comment">// System.out.println(Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>80000条数据大概需要<strong>10</strong>秒钟</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-排序算法介绍</title>
      <link href="/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法的介绍"><a href="#排序算法的介绍" class="headerlink" title="排序算法的介绍"></a>排序算法的介绍</h2><p>排序也称排序算法(SortAlgorithm)，排序是将 一组数据，依 指定的顺序进行 排列的过程。</p><h2 id="相关术语解释："><a href="#相关术语解释：" class="headerlink" title="相关术语解释："></a>相关术语解释：</h2><ol><li>稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</li><li>不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 不占用额外内存</li><li>Out-place: 占用额外内存</li></ol><h2 id="排序的分类："><a href="#排序的分类：" class="headerlink" title="排序的分类："></a>排序的分类：</h2><ol><li>内部排序:<br>指将需要处理的所有数据都加载到 内部存储器( 内存)中进行排序。</li><li>外部排序法：<br>数据量过大，无法全部加载到内存中，需要借助 外部存储( 文件等)进行排序。</li><li>常见的排序算法分类</li></ol><p><img data-src="1.png" alt="1.png"></p><h2 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h2><h3 id="度量一个程序-算法-执行时间的两种方法"><a href="#度量一个程序-算法-执行时间的两种方法" class="headerlink" title="度量一个程序(算法)执行时间的两种方法"></a>度量一个程序(算法)执行时间的两种方法</h3><h4 id="事后统计的方法"><a href="#事后统计的方法" class="headerlink" title="事后统计的方法"></a>事后统计的方法</h4><p>这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所<br>得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</p><h4 id="事前估算的方法"><a href="#事前估算的方法" class="headerlink" title="事前估算的方法"></a>事前估算的方法</h4><p>通过分析某个算法的 时间复杂度来判断哪个算法更优.</p><h3 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间<br>就多。 <strong>一个算法中的语句执行次数称为语句频度或时间频度</strong>。记为 T(n)</p><h4 id="举例说明-基本案例"><a href="#举例说明-基本案例" class="headerlink" title="举例说明-基本案例"></a>举例说明-基本案例</h4><p>比如计算 1-100 所有数字之和, 我们设计两种算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//使用for循环计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=end;i++)&#123;</span><br><span class="line">    total+=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T(n)=n+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//直接计算</span></span><br><span class="line">total = (<span class="number">1</span>+end)*end/<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">T(n)=<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="举例说明-忽略常数项"><a href="#举例说明-忽略常数项" class="headerlink" title="举例说明-忽略常数项"></a>举例说明-忽略常数项</h4><p><img data-src="2.png" alt="2.png"></p><p>结论: </p><ol><li>2n+20 和 2n 随着 n 变大，执行曲线无限接近, 20 可以忽略</li><li>3n+10 和 3n 随着 n 变大，执行曲线无限接近, 10 可以忽略</li></ol><h4 id="举例说明-忽略低次项"><a href="#举例说明-忽略低次项" class="headerlink" title="举例说明-忽略低次项"></a>举例说明-忽略低次项</h4><p><img data-src="3.png" alt="3.png"></p><p>结论:</p><ol><li>2n^2+3n+10 和 2n^2 随着 n 变大, 执行曲线无限接近, 可以忽略 3n+10</li><li>n^2+5n+20 和 n^2 随着 n 变大,执行曲线无限接近, 可以忽略 5n+20</li></ol><h4 id="举例说明-忽略系数"><a href="#举例说明-忽略系数" class="headerlink" title="举例说明-忽略系数"></a>举例说明-忽略系数</h4><p><img data-src="4.png" alt="4.png"></p><p>结论:</p><ol><li>随着 n 值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明 这种情况下, 5 和 3 可以忽略。</li><li>而 n^3+5n 和 6n^3+4n ，执行曲线分离，说明多少次方式关键</li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol><li>一般情况下， <strong>算法中的基本操作语句的重复执行次数是问题规模 n  的某个函数</strong>，用 T(n)表示，若有某个辅<br>助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。记作 <strong>T(n)= Ｏ( f(n) )</strong>，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。</li><li>T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同，但时间复杂<br>度相同，都为 <strong>O(n² ²)</strong>。</li><li>计算时间复杂度的方法：<ul><li>用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1</li><li>修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n²</li><li>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li></ul></li></ol><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><ol><li>常数阶 O(1)</li><li>对数阶 O(log2n)</li><li>线性阶 O(n)</li><li>线性对数阶 O(nlog2n)</li><li>平方阶 O(n^2)</li><li>立方阶 O(n^3) </li><li>k 次方阶 O(n^k)</li><li>指数阶 O(2^n)</li></ol><p><img data-src="5.png" alt="5.png"></p><p><strong>说明：</strong></p><ol><li>常见的算法时间复杂度由小到大依次为：<strong>Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n^2)＜Ο(n^3)＜ Ο(n^k) ＜</strong> <strong>Ο(2^n)</strong> ，随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低</li><li>从图中可见，我们应该尽可能避免使用指数阶的算法</li></ol><h2 id="算法的空间复杂度简介"><a href="#算法的空间复杂度简介" class="headerlink" title="算法的空间复杂度简介"></a>算法的空间复杂度简介</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。</li><li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如快速排序和 归并排序算法,  基数排序就属于这种情况。</li><li>在做算法分析时，主要讨论的是时间复杂度。 从用户使用体验上看 ， 更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)</li></ol><h2 id="八种排序算法的时间复杂度"><a href="#八种排序算法的时间复杂度" class="headerlink" title="八种排序算法的时间复杂度"></a>八种排序算法的时间复杂度</h2><h3 id="1、稳定性"><a href="#1、稳定性" class="headerlink" title="1、稳定性"></a>1、稳定性</h3><p>归并排序、冒泡排序、插入排序。基数排序是稳定的</p><p>选择排序、快速排序、希尔排序、堆排序是不稳定的</p><h3 id="2、时间复杂度"><a href="#2、时间复杂度" class="headerlink" title="2、时间复杂度"></a>2、时间复杂度</h3><p>最基础的四个算法：冒泡、选择、插入、快排中，快排的时间复杂度最小O(n*log2n)，其他都是O（n2）</p><table><thead><tr><th>排序法</th><th>平均时间</th><th>最差情形</th><th>稳定度</th><th>额外空间</th><th>备注</th></tr></thead><tbody><tr><td>冒泡</td><td>O(n2)</td><td>O(n2)</td><td>稳定</td><td>O(1)</td><td>n小时较好</td></tr><tr><td>交换</td><td>O(n2)</td><td>O(n2)</td><td>不稳定</td><td>O(1)</td><td>n小时较好</td></tr><tr><td>选择</td><td>O(n2)</td><td>O(n2)</td><td>不稳定</td><td>O(1)</td><td>n小时较好</td></tr><tr><td>插入</td><td>O(n2)</td><td>O(n2)</td><td>稳定</td><td>O(1)</td><td>大部分已排序时较好</td></tr><tr><td>基数</td><td>O(logRB)</td><td>O(logRB)</td><td>稳定</td><td>O(n)</td><td>B是真数(0-9)，R是基数(个十百)</td></tr><tr><td>Shell</td><td>O(nlogn)</td><td>O(ns) 1&lt;s&lt;2</td><td>不稳定</td><td>O(1)</td><td>s是所选分组</td></tr><tr><td>快速</td><td>O(nlogn)</td><td>O(n2)</td><td>不稳定</td><td>O(nlogn)</td><td>n大时较好</td></tr><tr><td>归并</td><td>O(nlogn)</td><td>O(nlogn)</td><td>稳定</td><td>O(1)</td><td>n大时较好</td></tr><tr><td>堆</td><td>O(nlogn)</td><td>O(nlogn)</td><td>不稳定</td><td>O(1)</td><td>n大时较好</td></tr></tbody></table><h3 id="3-排序算法的思想："><a href="#3-排序算法的思想：" class="headerlink" title="3.排序算法的思想："></a>3.排序算法的思想：</h3><h4 id="1-冒泡排序："><a href="#1-冒泡排序：" class="headerlink" title="(1)冒泡排序："></a>(1)冒泡排序：</h4><p>是相邻元素之间的比较和交换，两重循环O(n2)；所以，如果两个相邻元素相等，是不会交换的。所以它是一种稳定的排序方法</p><h4 id="2-选择排序："><a href="#2-选择排序：" class="headerlink" title="(2)选择排序："></a>(2)选择排序：</h4><p>每个元素都与第一个元素相比，产生交换，两重循环O(n2)；举个栗子，5 8 5 2 9，第一遍之后，2会与5交换，那么原序列中两个5的顺序就被破坏了。所以不是稳定的排序算法</p><h4 id="3-插入排序："><a href="#3-插入排序：" class="headerlink" title="(3)插入排序："></a>(3)插入排序：</h4><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。刚开始这个小序列只包含第一个元素，事件复杂度O(n2)。比较是从这个小序列的末尾开始的。想要插入的元素和小序列的最大者开始比起，如果比它大则直接插在其后面，否则一直往前找它该插入的位置。如果遇见了一个和插入元素相等的，则把插入元素放在这个相等元素的后面。所以相等元素间的顺序没有改变，是稳定的。</p><h4 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="(4)快速排序"></a>(4)快速排序</h4><p>​    快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j]交换的时刻。</p><h4 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="(5)归并排序"></a>(5)归并排序</h4><p>​    归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p><h4 id="6-基数排序"><a href="#6-基数排序" class="headerlink" title="(6)基数排序"></a>(6)基数排序</h4><p>   基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。</p><h4 id="7-希尔排序-shell"><a href="#7-希尔排序-shell" class="headerlink" title="(7)希尔排序(shell)"></a>(7)希尔排序(shell)</h4><p>​    希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p><h4 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="(8)堆排序"></a>(8)堆排序</h4><p>   我们知道堆的结构是节点i的孩子为2<em>i和2</em>i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n/2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-八皇后问题</title>
      <link href="/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="八皇后问题算法思路分析"><a href="#八皇后问题算法思路分析" class="headerlink" title="八皇后问题算法思路分析"></a>八皇后问题算法思路分析</h2><ol><li>第一个皇后先放第一行第一列</li><li>第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都<br>放完，找到一个合适</li><li>继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确<br>解</li><li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</li><li>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤</li></ol><p>说明：<br>理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] =<br>{0 , 4, 7, 5, 2, 6, 1, 3} //对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第 i+1 个皇后，放在第 i+1<br>行的第 val+1 列</p><p>示意图：</p><p><img data-src="1.png" alt="1.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个max表示共有多少个皇后</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组array, 保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125;</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> judgeCount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试一把 ， 8皇后是否正确</span></span><br><span class="line">Queen8 Queen8 = <span class="keyword">new</span> Queen8();</span><br><span class="line">Queen8.check(<span class="number">0</span>);</span><br><span class="line">System.out.printf(<span class="string">"一共有%d解法"</span>, count);</span><br><span class="line">System.out.printf(<span class="string">"一共判断冲突的次数%d次"</span>, judgeCount); <span class="comment">// 1.5w</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个方法，放置第n个皇后</span></span><br><span class="line"><span class="comment">// 特别注意： check 是 每一次递归时，进入到check中都有 for(int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == max) &#123; <span class="comment">// n = 8 , 其实8个皇后就既然放好</span></span><br><span class="line">print();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次放入皇后，并判断是否冲突</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line"><span class="comment">// 先把当前这个皇后 n , 放到该行的第1列</span></span><br><span class="line">array[n] = i;</span><br><span class="line"><span class="comment">// 判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line"><span class="keyword">if</span> (judge(n)) &#123; <span class="comment">// 不冲突</span></span><br><span class="line"><span class="comment">// 接着放n+1个皇后,即开始递归</span></span><br><span class="line">check(n + <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> *            表示第n个皇后</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">judgeCount++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. array[i] == array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列</span></span><br><span class="line"><span class="comment">// 2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线 </span></span><br><span class="line"><span class="comment">// n = 1 放置第 2列 1 n = 1 array[1] = 1</span></span><br><span class="line"><span class="comment">// Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1</span></span><br><span class="line"><span class="comment">// 3. 判断是否在同一行, 没有必要，n 每次都在递增</span></span><br><span class="line"><span class="keyword">if</span> (array[i] == array[n] || Math.abs(n-i)==Math.abs(array[n]-array[i])) &#123;<span class="comment">//横坐标差值==纵坐标差值</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">System.out.print(array[i] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-迷宫递归</title>
      <link href="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%B7%E5%AE%AB%E9%80%92%E5%BD%92/"/>
      <url>/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%B7%E5%AE%AB%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先创建一个二维数组 模拟一个迷宫</span></span><br><span class="line"><span class="comment">// 地图</span></span><br><span class="line"><span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line"><span class="comment">// 使用1 表示墙</span></span><br><span class="line"><span class="comment">// 上下全部置为1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左右全部置为1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置挡板, 1 表示</span></span><br><span class="line">map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 输出地图</span></span><br><span class="line">System.out.println(<span class="string">"地图的情况"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">System.out.print(map[i][j] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用递归回溯给小球找路</span></span><br><span class="line">setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//setWay2(map, 1, 1);</span></span><br><span class="line"><span class="comment">// 输出新的地图, 小球走过，并标识过的递归</span></span><br><span class="line">System.out.println(<span class="string">"小球走过，并标识过的 地图的情况"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">System.out.print(map[i][j] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用递归回溯来给小球找路</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. map 表示地图</span></span><br><span class="line"><span class="comment">// 2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line"><span class="comment">// 3. 如果小球能到 map[6][5] 位置，则说明通路找到.</span></span><br><span class="line"><span class="comment">// 4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通</span></span><br><span class="line"><span class="comment">// 5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment"> *            表示地图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> *            从哪个位置开始找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到通路，就返回true, 否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;<span class="comment">// 如果当前这个点还没有走过</span></span><br><span class="line"><span class="comment">// 按照策略 下-&gt;右-&gt;上-&gt;左 走</span></span><br><span class="line">map[i][j] = <span class="number">2</span>;<span class="comment">// 假定该点可以走通</span></span><br><span class="line"><span class="keyword">if</span> (setWay(map, i + <span class="number">1</span>, j)) &#123;<span class="comment">// 向下走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j + <span class="number">1</span>)) &#123;<span class="comment">// 向右走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i - <span class="number">1</span>, j)) &#123;<span class="comment">// 上</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j - <span class="number">1</span>)) &#123; <span class="comment">// 向左走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 说明该点是走不通，是死路</span></span><br><span class="line">map[i][j] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改找路的策略，改成 上-&gt;右-&gt;下-&gt;左</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay2</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123; <span class="comment">// 通路已经找到ok</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123; <span class="comment">// 如果当前这个点还没有走过</span></span><br><span class="line"><span class="comment">// 按照策略 上-&gt;右-&gt;下-&gt;左</span></span><br><span class="line">map[i][j] = <span class="number">2</span>; <span class="comment">// 假定该点是可以走通.</span></span><br><span class="line"><span class="keyword">if</span> (setWay2(map, i - <span class="number">1</span>, j)) &#123;<span class="comment">// 向上走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j + <span class="number">1</span>)) &#123; <span class="comment">// 向右走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i + <span class="number">1</span>, j)) &#123; <span class="comment">// 向下</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j - <span class="number">1</span>)) &#123; <span class="comment">// 向左走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 说明该点是走不通，是死路</span></span><br><span class="line">map[i][j] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img data-src="1.png" alt="1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-逆波兰计算器</title>
      <link href="/2020/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2020/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img data-src="1.png" alt="1.png"></p><h2 id="代码实现-只是整数"><a href="#代码实现-只是整数" class="headerlink" title="代码实现(只是整数)"></a>代码实现(只是整数)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成将一个中缀表达式转成后缀表达式的功能</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. 1+((2+3)×4)-5 =&gt; 转成 1 2 3 + 4 × + 5 –</span></span><br><span class="line"><span class="comment">// 2. 因为直接对str 进行操作，不方便，因此 先将 "1+((2+3)×4)-5" =》 中缀的表达式对应的List</span></span><br><span class="line"><span class="comment">// 即 "1+((2+3)×4)-5" =&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line"><span class="comment">// 3. 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line"><span class="comment">// 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList</span></span><br><span class="line"><span class="comment">// [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line">String expression = <span class="string">"10+((2+3)*4)-5"</span>;<span class="comment">// 注意表达式</span></span><br><span class="line">List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">System.out.println(<span class="string">"中缀表达式对应的List="</span> + infixExpressionList); <span class="comment">// ArrayList</span></span><br><span class="line"><span class="comment">// [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">List&lt;String&gt; suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList);</span><br><span class="line">System.out.println(<span class="string">"后缀表达式对应的List"</span> + suffixExpreesionList); <span class="comment">//ArrayList [1,2,3,+,4,*,+,5,–] </span></span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">"expression=%d"</span>, calculate(suffixExpreesionList)); <span class="comment">// ?</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * // 先定义一个逆波兰表达式 // (3+4)*5-6 =&gt;3 4 + 5 * 6 - // 为了方便，逆波兰表达式的数字和符号用空格隔开</span></span><br><span class="line"><span class="comment"> * String suffixExpression = "30 4 + 5 * 6 -"; // 思路 // 1. 先将</span></span><br><span class="line"><span class="comment"> * "3 4 + 5 × 6 - " =&gt; 放到ArrayList中 // 2. 将 ArrayList 传递给一个方法，遍历</span></span><br><span class="line"><span class="comment"> * ArrayList 配合栈 完成计算 List&lt;String&gt; list =</span></span><br><span class="line"><span class="comment"> * getListString(suffixExpression); System.out.println("list=" + list);</span></span><br><span class="line"><span class="comment"> * int res = calculate(list); System.out.println("计算结果是：" + res);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：将 中缀表达式转成对应的List</span></span><br><span class="line"><span class="comment">// s="1+((2+3)×4)-5";</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixExpressionList</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义一个List,存放中缀表达式 对应的内容</span></span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 这是一个指针，用于遍历 中缀表达式字符串</span></span><br><span class="line">String str;<span class="comment">// 对多位数的拼接</span></span><br><span class="line"><span class="keyword">char</span> c;<span class="comment">// 每遍历到一个字符就放入到c中</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 如果c是一个非数字，我需要加入到ls</span></span><br><span class="line"><span class="keyword">if</span> ((c = s.charAt(i)) &lt; <span class="number">48</span> || (c = s.charAt(i)) &gt; <span class="number">57</span>) &#123;</span><br><span class="line"><span class="comment">// 此时c不是一个数</span></span><br><span class="line">ls.add(<span class="string">""</span> + c);</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果是一个数，需要考虑是不是多位数</span></span><br><span class="line">str = <span class="string">""</span>;<span class="comment">// 先将str置成空串</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= <span class="number">48</span> &amp;&amp; (c = s.charAt(i)) &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">str += c;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">ls.add(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; s.length());</span><br><span class="line"><span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line"><span class="comment">// 方法：将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpreesionList</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义两个栈</span></span><br><span class="line">Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;String&gt;();<span class="comment">// 符号栈</span></span><br><span class="line"><span class="comment">// 说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span></span><br><span class="line"><span class="comment">// 因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2</span></span><br><span class="line"><span class="comment">// Stack&lt;String&gt; s2 = new Stack&lt;String&gt;(); // 储存中间结果的栈s2</span></span><br><span class="line">List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 储存中间结果的Lists2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历ls</span></span><br><span class="line"><span class="keyword">for</span>(String item: ls) &#123;</span><br><span class="line"><span class="comment">//如果是一个数，加入s2</span></span><br><span class="line"><span class="keyword">if</span>(item.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">s2.add(item);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">")"</span>)) &#123;</span><br><span class="line"><span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line"><span class="keyword">while</span>(!s1.peek().equals(<span class="string">"("</span>))&#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">s1.pop();<span class="comment">// 将 ( 弹出 s1栈， 消除小括号</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较</span></span><br><span class="line"><span class="keyword">while</span> (s1.size()!=<span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item)) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还需将 item 压入栈顶</span></span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将s1中剩余的运算符依次弹出并加入s2</span></span><br><span class="line"><span class="keyword">while</span>(s1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s2; <span class="comment">//注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将 suffixExpression 分割</span></span><br><span class="line">String[] split = suffixExpression.split(<span class="string">" "</span>);</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">list.add(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成对逆波兰表达式的运算</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1)从左至右扫描，将3和4压入堆栈； 2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment"> * 3)将5入栈； 4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 5)将6入栈；</span></span><br><span class="line"><span class="comment"> * 6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个栈,只需要一个栈即可</span></span><br><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line"><span class="comment">// 这里使用正则表达式来取出数</span></span><br><span class="line"><span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>)) &#123;<span class="comment">// 匹配的是多位数</span></span><br><span class="line">stack.push(item);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// pop出两个数，并运算， 再入栈</span></span><br><span class="line"><span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line"><span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (item.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">res = num1 + num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">res = num1 - num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">res = num1 * num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">res = num1 / num2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"运算符有误"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把结果 入栈</span></span><br><span class="line">stack.push(<span class="string">""</span> + res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后留在stack中的数据是运算结果</span></span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个类 Operation 可以返回一个运算符 对应的优先级</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (operation) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">result = ADD;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">result = SUB;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">result = MUL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">result = DIV;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"不存在该运算符"</span> + operation);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整版-精确到小数点"><a href="#完整版-精确到小数点" class="headerlink" title="完整版(精确到小数点)"></a>完整版(精确到小数点)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePolishMultiCalc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 + - * / ( ) 运算符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String SYMBOL = <span class="string">"\\+|-|\\*|/|\\(|\\)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEFT = <span class="string">"("</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RIGHT = <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ADD = <span class="string">"+"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MINUS= <span class="string">"-"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TIMES = <span class="string">"*"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIVISION = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加減 + -</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_01 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘除 * /</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_02 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 括号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_HIGH = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; data = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去除所有空白符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceAllBlank</span><span class="params">(String s )</span></span>&#123;</span><br><span class="line">        <span class="comment">// \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]</span></span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">"\\s+"</span>,<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是数字 int double long float</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">"^[-\\+]?[.\\d]*$"</span>);</span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是运算符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymbol</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(SYMBOL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配运算等级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calcLevel</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"+"</span>.equals(s) || <span class="string">"-"</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_01;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(s) || <span class="string">"/"</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_02;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LEVEL_HIGH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">doMatch</span> <span class="params">(String s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s.trim())) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data is empty"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!isNumber(s.charAt(<span class="number">0</span>)+<span class="string">""</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data illeagle,start not with a number"</span>);</span><br><span class="line"></span><br><span class="line">        s = replaceAllBlank(s);</span><br><span class="line"></span><br><span class="line">        String each;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(s.charAt(i)+<span class="string">""</span>))&#123;</span><br><span class="line">                each = s.charAt(i)+<span class="string">""</span>;</span><br><span class="line">                <span class="comment">//栈为空，(操作符，或者 操作符优先级大于栈顶优先级 &amp;&amp; 操作符优先级不是( )的优先级 及是 ) 不能直接入栈</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || LEFT.equals(each)</span><br><span class="line">                        || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH))&#123;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>( !stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                    <span class="comment">//栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()) )&#123;</span><br><span class="line">                        <span class="keyword">if</span>(calcLevel(stack.peek()) == LEVEL_HIGH)&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(RIGHT.equals(each))&#123;</span><br><span class="line">                    <span class="comment">// ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(LEVEL_HIGH == calcLevel(stack.peek()))&#123;</span><br><span class="line">                            stack.pop();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                start = i ;    <span class="comment">//前一个运算符的位置</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( i == s.length()-<span class="number">1</span> || isSymbol(s.charAt(i+<span class="number">1</span>)+<span class="string">""</span>) )&#123;</span><br><span class="line">                each = start == <span class="number">0</span> ? s.substring(start,i+<span class="number">1</span>) : s.substring(start+<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isNumber(each)) &#123;</span><br><span class="line">                    data.add(each);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data not match number"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列</span></span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        data.addAll(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line"></span><br><span class="line">        System.out.println(data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算出结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">doCalc</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        Double d = <span class="number">0</span>d;</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="keyword">null</span> || list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(list);</span><br><span class="line">            d = Double.valueOf(list.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list1.add(list.get(i));</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(list.get(i)))&#123;</span><br><span class="line">                Double d1 = doTheMath(list.get(i - <span class="number">2</span>), list.get(i - <span class="number">1</span>), list.get(i));</span><br><span class="line">                list1.remove(i);</span><br><span class="line">                list1.remove(i-<span class="number">1</span>);</span><br><span class="line">                list1.set(i-<span class="number">2</span>,d1+<span class="string">""</span>);</span><br><span class="line">                list1.addAll(list.subList(i+<span class="number">1</span>,list.size()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doCalc(list1);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">doTheMath</span><span class="params">(String s1,String s2,String symbol)</span></span>&#123;</span><br><span class="line">        Double result ;</span><br><span class="line">        <span class="keyword">switch</span> (symbol)&#123;</span><br><span class="line">            <span class="keyword">case</span> ADD : result = Double.valueOf(s1) + Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : result = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String math = "9+(3-1)*3+10/2";</span></span><br><span class="line">        String math = <span class="string">"12.8 + (2 - 3.55)*4+10/5.0"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doCalc(doMatch(math));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】注解</title>
      <link href="/2020/03/27/MyBatis%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/03/27/MyBatis%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>MyBatis注解方式就是将SQL语句直接写在映射接口上</p><ul><li>优点：对于需求简单的系统，效率较高</li><li>缺点：当SQL发生变化时，需要重新编译代码</li></ul><p>一般情况下不建议使用注解方式</p><p><strong>使用注解方式时，在主配置文件中关联映射配置时应该使用如下方法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.mybatis.mapper.UserMapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Select注解"><a href="#Select注解" class="headerlink" title="@Select注解"></a>@Select注解</h2><h4 id="在映射接口的查询方法上添加如下注解"><a href="#在映射接口的查询方法上添加如下注解" class="headerlink" title="在映射接口的查询方法上添加如下注解"></a>在映射接口的查询方法上添加如下注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select id, user_name userName, password"</span></span><br><span class="line">         + <span class="string">" from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>@Select注解的参数为字符串类型</strong></p><p>用resultMap方式解决表<strong>字段名与属性名不一致</strong>问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results</span>(&#123;</span><br><span class="line">    <span class="meta">@Result</span>(property=<span class="string">"id"</span>, column=<span class="string">"id"</span>, id=<span class="keyword">true</span>),</span><br><span class="line">    <span class="meta">@Result</span>(property=<span class="string">"userName"</span>, column=<span class="string">"user_name"</span>),</span><br><span class="line">    <span class="meta">@Result</span>(property=<span class="string">"password"</span>, column=<span class="string">"password"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select id, user_name, password"</span></span><br><span class="line">         + <span class="string">" from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>注解@Results对应XML中的resultMap元素</p><p>注解@Result对应XML中的result元素，当参数中出现id=true时，就对应了id元素</p><p>从MyBatis3.3.1开始，映射接口中的多个方法可以共用@Results注解，首先要在@Results注解中加上id属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results</span>(id = <span class="string">"userResult"</span>, value= &#123;</span><br><span class="line">    <span class="meta">@Result</span>(property=<span class="string">"id"</span>,column=<span class="string">"id"</span>,id=<span class="keyword">true</span>),</span><br><span class="line">    <span class="meta">@Result</span>(property=<span class="string">"userName"</span>, column=<span class="string">"user_name"</span>),</span><br><span class="line">    <span class="meta">@Result</span>(property=<span class="string">"password"</span>, column=<span class="string">"password"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select id, user_name, password"</span></span><br><span class="line">         + <span class="string">" from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>在映射接口中添加查询方法，通过@ResultMap注解共用@Results注解</p><p>@ResultMap中参数的值与@Results注解中id属性的值一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResultMap</span>(<span class="string">"userResult"</span>)</span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectAllUsers</span><span class="params">()</span> </span>;</span><br></pre></td></tr></table></figure><h2 id="Insert注解"><a href="#Insert注解" class="headerlink" title="@Insert注解"></a>@Insert注解</h2><h4 id="在映射接口的插入方法上添加如下注解"><a href="#在映射接口的插入方法上添加如下注解" class="headerlink" title="在映射接口的插入方法上添加如下注解"></a>在映射接口的插入方法上添加如下注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into user(id, user_name, password)"</span></span><br><span class="line">        + <span class="string">"value(#&#123;id&#125;, #&#123;userName&#125;, #&#123;password&#125;)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>@Insert注解的参数为字符串类型</strong></p><h4 id="如果需要返回自增主键，需要增加-Options注解"><a href="#如果需要返回自增主键，需要增加-Options注解" class="headerlink" title="如果需要返回自增主键，需要增加@Options注解"></a>如果需要返回自增主键，需要增加@Options注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into user(id, user_name, password)"</span></span><br><span class="line">        + <span class="string">"value(#&#123;id&#125;, #&#123;userName&#125;, #&#123;password&#125;)"</span>)</span><br><span class="line"><span class="meta">@Options</span>(useGeneratedKeys = <span class="keyword">true</span>, keyProperty = <span class="string">"id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>useGeneratedKeys和keyProperty属性同XML中相同</p><h4 id="如果需要返回非自增主键，需要使用-SelectKey注解"><a href="#如果需要返回非自增主键，需要使用-SelectKey注解" class="headerlink" title="如果需要返回非自增主键，需要使用@SelectKey注解"></a>如果需要返回非自增主键，需要使用@SelectKey注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into user(id, user_name, password)"</span></span><br><span class="line">        + <span class="string">"value(#&#123;id&#125;, #&#123;userName&#125;, #&#123;password&#125;)"</span>)</span><br><span class="line"><span class="meta">@SelectKey</span>(statement = <span class="string">"SELECT LAST_INSERT_ID()"</span>,</span><br><span class="line">               keyProperty = <span class="string">"id"</span>,</span><br><span class="line">               resultType = Integer<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">               <span class="title">before</span> </span>= <span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>@SelectKey注解与前面的selectKey元素基本一致，其中before为false时功能等同于order=”AFTER”，before为true时功能等同于order=”BEFORE”</p><h2 id="Update注解"><a href="#Update注解" class="headerlink" title="@Update注解"></a>@Update注解</h2><h4 id="在映射接口的更新方法上添加如下注解"><a href="#在映射接口的更新方法上添加如下注解" class="headerlink" title="在映射接口的更新方法上添加如下注解"></a>在映射接口的更新方法上添加如下注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update</span>(<span class="string">"update user set user_name=#&#123;userName&#125;,"</span></span><br><span class="line">        + <span class="string">"password=#&#123;password&#125; "</span></span><br><span class="line">        + <span class="string">"where id=#&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateById</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>@Update注解的参数为字符串类型</strong></p><h2 id="Delete注解"><a href="#Delete注解" class="headerlink" title="@Delete注解"></a>@Delete注解</h2><h4 id="在映射接口的删除方法上添加如下注解"><a href="#在映射接口的删除方法上添加如下注解" class="headerlink" title="在映射接口的删除方法上添加如下注解"></a>在映射接口的删除方法上添加如下注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Delete</span>(<span class="string">"delete from user where id=#&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>@Delete注解的参数为字符串类型</strong></p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】其他配置</title>
      <link href="/2020/03/27/MyBatis%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/27/MyBatis%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis配置优化"><a href="#MyBatis配置优化" class="headerlink" title="MyBatis配置优化"></a>MyBatis配置优化</h1><p>MyBatis配置文件的元素结构如下：</p><p>configuration（配置）</p><ul><li><p>properties（属性）</p></li><li><p>settings（设置）</p></li><li><p>typeAliases（类型别名）</p></li><li><p>plugins（插件）</p></li><li><p>environments（环境配置）</p><ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li><p>mappers（映射器）</p></li></ul><h2 id="配置别名（typealiases）"><a href="#配置别名（typealiases）" class="headerlink" title="配置别名（typealiases）"></a>配置别名（typealiases）</h2><p>类型别名是为Java 类型命名一个短的名字。它只和XML配置有关, 只用来减少类完全限定名的多余部分。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"net.onest.entity.User"</span> <span class="attr">alias</span>=<span class="string">"User"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的JavaBean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"net.onest.entity"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据源配置（db-properties）"><a href="#数据源配置（db-properties）" class="headerlink" title="数据源配置（db.properties）"></a>数据源配置（db.properties）</h2><p>将数据库配置单独方法一个Java属性文件中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure><p>使用properties元素在mybatis.xml配置文件中引用Java属性文件中的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用properties文件 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"> <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">         ……        </span><br><span class="line">     <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在dataSource中采用${name}的形式引用属性文件中定义的参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="MyBatis中-和-的异同"><a href="#MyBatis中-和-的异同" class="headerlink" title="MyBatis中$和#的异同"></a>MyBatis中$和#的异同</h3><ul><li>可以获取对象中的属性值，${userName}和#{userName}相同</li><li>#可以防止SQL注入，解析时会把所有使用#的地方变成？占位符，再设置参数的值</li><li>$在解析时，会直接使用传入的参数作为字符串直接填充到SQL语句中，会导致SQL注入</li><li>#会把传入的参数使用引号括起来，$则不会</li><li>$一般用传入数据库相关参数，如数据库表名、字段名</li></ul><h1 id="MyBatis分页插件"><a href="#MyBatis分页插件" class="headerlink" title="MyBatis分页插件"></a>MyBatis分页插件</h1><ul><li>MyBatis中要想实现分页功能，需要使用limit子句实现分页的SQL语句，比较麻烦</li><li>PageHelper插件能方便解决MyBatis分页问题，其GitHub源码地址：</li><li><a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">https</a><a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">://github.com/pagehelper/Mybatis-PageHelper</a></li></ul><h2 id="PageHelper使用方法"><a href="#PageHelper使用方法" class="headerlink" title="PageHelper使用方法"></a>PageHelper使用方法</h2><ol><li>引入PageHelper的jar包 pagehelper-xxx.jar jsqlparser-xx.jar</li><li>在MyBatis的XML配置文件中配置拦截器插件</li><li>调用PageHelper类的方法实现分页功能</li></ol><h3 id="在MyBatis的XML配置文件中配置拦截器插件"><a href="#在MyBatis的XML配置文件中配置拦截器插件" class="headerlink" title="在MyBatis的XML配置文件中配置拦截器插件"></a>在MyBatis的XML配置文件中配置拦截器插件</h3><ul><li>MyBatis允许使用插件来拦截方法的调用，如update、query、commit、rollback等方法</li><li>实现插件时，只需定义类实现MyBatis的Interceptor接口，并指定想要拦截的方法名即可</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="调用PageHelper类的方法实现分页功能"><a href="#调用PageHelper类的方法实现分页功能" class="headerlink" title="调用PageHelper类的方法实现分页功能"></a>调用PageHelper类的方法实现分页功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">List&lt;User&gt; users = userMapper.findAllUsers();</span><br></pre></td></tr></table></figure><p>调用PageHelper的startPage静态方法之后，跟在后面的第一个<strong>查询方法</strong>将进行分页查询</p><p>分页查询时，查询方法返回的List对象实际上是Page&lt;E&gt;类型，如果需要取得分页信息，需要将结果强制类型转换为Page&lt;E&gt;类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;User&gt; userPages = (Page&lt;User&gt;)users;</span><br><span class="line">System.out.println(userPages.getTotal());<span class="comment">//总条数</span></span><br><span class="line">System.out.println(userPages.getPageNum());<span class="comment">//当前页数</span></span><br><span class="line">System.out.println(userPages.getPageSize());<span class="comment">//每页条数</span></span><br><span class="line">System.out.println(userPages.getPages());<span class="comment">//总页数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized和ReentrantLock的实现原理是什么它们有什么区别</title>
      <link href="/2020/03/26/synchronized%E5%92%8CReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/03/26/synchronized%E5%92%8CReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>在JDK1.5之前共享对象的协调机制只有 synchronized和 volatile，在JDK1.5中增加了新的机制<br>ReentrantLock，该机制的诞生并不是为了替代synchronized，而是在synchronized不适用的情况下，提供一种可以选择的高级功能。</p><p>我们本课时的面试题是，synchronized和ReentrantLock是如何实现的？它们有什么区别？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a><strong>典型回答</strong></h2><p>synchronized 属于独占式悲观锁，是通过JVM隐式实现的，synchronized只允许同一时刻只有一个线程操作资源。<br>在Java中每个对象都隐式包含一个monitor（监视器）对象，加锁的过程其实就是竞争monitor的过程，当线程进入字节码 monitorenter 指令之后，线程将持有monitor对象，执行monitorexit时释放 monitor对象，当其他线程没有拿到monitor对象时，则需要阻塞等待获取该对象。</p><p>ReentrantLock 是Lock的默认实现方式之一，它是基于AQS（Abstract Queued Synchronizer，队列同步器）实现的，它默认是通过非公平锁实现的，在它的内部有一个state的状态字段用于表示锁是否被占用，如果是0则表示锁未被占用，此时线程就可以把state改为1，并成功获得锁，而其他未获得锁的线程只能去排队等待获取锁资源。</p><p>synchronized和ReentrantLock都提供了锁的功能，具备互斥性和不可见性。在JDK1.5中<br>synchronized 的性能远远低于ReentrantLock，但在JDK 1.6之后synchronized的性能略低于<br>ReentrantLock，它的区别如下：</p><ul><li>synchronized是JVM隐式实现的，而ReentrantLock是Java 语言提供的APl；</li><li>ReentrantLock 可设置为公平锁，而synchronized却不行；</li><li>ReentrantLock 只能修饰代码块，而synchronized可以用于修饰方法、修饰代码块等；</li><li>ReentrantLock 需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而synchronized 无需手动释放锁；</li><li>ReentrantLock 可以知道是否成功获得了锁，而synchronized却不行。</li></ul><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>synchronized 和ReentrantLock 是比线程池还要高频的面试问题，因为它包含了更多的知识点，且涉及到的知识点更加深入，对面试者的要求也更高，前面我们简要地介绍了synchronized和ReentrantLock的概念及执行原理，但很多大厂会更加深入的追问更多关于它们的实现细节，比如：</p><ul><li>ReentrantLock的具体实现细节是什么？</li><li>JDK1.6时锁做了哪些优化？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="ReentrantLock-源码分析"><a href="#ReentrantLock-源码分析" class="headerlink" title="ReentrantLock 源码分析"></a>ReentrantLock 源码分析</h3><p>本课时从源码出发来解密 ReentrantLock 的具体实现细节，首先来看ReentrantLock的两个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(); <span class="comment">// 非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参的构造函数创建了一个非公平锁，用户也可以根据第二个构造函数，设置一个boolean类型的值，来决定是否使用公平锁来实现线程的调度。</p><h3 id="公平锁VS非公平锁"><a href="#公平锁VS非公平锁" class="headerlink" title="公平锁VS非公平锁"></a>公平锁VS非公平锁</h3><p>公平锁的含义是线程需要按照请求的顺序来获得锁；而非公平锁则允许“插队”的情况存在，所谓的“插队”指的是，线程在发送请求的同时该锁的状态恰好变成了可用，那么此线程就可以跳过队列中所有排队的线程直接拥有该锁。</p><p>而公平锁由于有挂起和恢复所以存在一定的开销，因此性能不如非公平锁，所以ReentrantLock和synchronized 默认都是非公平锁的实现方式。</p><p>ReentrantLock 是通过lock()来获取锁，并通过unlock()释放锁，使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">//......业务处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock中的lock()是通过sync.lock()实现的，但Sync类中的lock()是一个抽象方法，需要子类NonfairSync或FairSync去实现，NonfairSync中的lock()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 将当前线程设置为此锁的持有者</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FairSync中的lock()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出非公平锁比公平锁只是多了一行compareAndSetState方法，该方法是尝试将 state值由0置换为1，如果设置成功的话，则说明当前没有其他线程持有该锁，不用再去排队了，可直接占用该锁，否则，则需要通过acquire方法去排队。</p><p>acquire源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire 方法尝试获取锁，如果获取锁失败，则把它加入到阻塞队列中，来看tryAcquire的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 公平锁比非公平锁多了一行代码 !hasQueuedPredecessors() </span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//尝试获取锁</span></span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">// 获取成功，标记被抢占</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc); <span class="comment">// set state=state+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于此方法来说，公平锁比非公平锁只多一行代码!hasQueuedPredecessors()，它用来查看队列中是否有比它等待时间更久的线程，如果没有，就尝试一下是否能获取到锁，如果获取成功，则标记为已经被占用。</p><p>如果获取锁失败，则调用addWaiter方法把线程包装成Node对象，同时放入到队列中，但<br>addWaiter 方法并不会尝试获取锁，acquireQueued方法才会尝试获取锁，如果获取失败，则此节点会被挂起，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列中的线程尝试获取锁，失败则会被挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">// 获取锁是否成功的状态标识</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">// 线程是否被中断</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前一个节点（前驱节点）</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 当前节点为头节点的下一个节点时，有权尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node); <span class="comment">// 获取成功，将当前节点设置为 head 节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// 原 head 节点出队，等待被 GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">// 获取成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断获取锁失败后是否可以挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 线程若被中断，返回 true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会使用for（;;）无限循环的方式来尝试获取锁，若获取失败，则调用<br>shouldParkAfterFailedAcquire方法，尝试挂起当前线程，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断线程是否可以被挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得前驱节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的状态为 SIGNAL，当前线程可以被挂起（阻塞）</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 若前驱节点状态为 CANCELLED，那就一直往前找，直到找到一个正常等待的状态为止</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 并将当前节点排在它后边</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 把前驱节点的状态修改为 SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程入列被挂起的前提条件是，前驱节点的状态为SIGNAL，SIGNAL状态的含义是后继节点处于等待状态，当前节点释放锁后将会唤醒后继节点。所以在上面这段代码中，会先判断前驱节点的状态，如果为SIGNAL，则当前线程可以被挂起并返回true；如果前驱节点的状态&gt;0，则表示前驱节点取消了，这时候需要一直往前找，直到找到最近一个正常等待的前驱节点，然后把它作为自己的前驱节点；如果前驱节点正常（未取消），则修改前驱节点状态为SIGNAL。</p><p>到这里整个加锁的流程就已经走完了，最后的情况是，没有拿到锁的线程会在队列中被挂起，直到拥有锁的线程释放锁之后，才会去唤醒其他的线程去获取锁资源，整个运行流程如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p>unlock 相比于 lock 来说就简单很多了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放成功</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁的释放流程为，先调用tryRelease方法尝试释放锁，如果释放成功，则查看头结点的状态是否为<br>SIGNAL，如果是，则唤醒头结点的下个节点关联的线程；如果释放锁失败，则返回false。</p><p>tryRelease源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试释放当前线程占有的锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 释放锁后的状态，0 表示释放锁成功</span></span><br><span class="line">    <span class="comment">// 如果拥有锁的线程不是当前线程的话抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 锁被成功释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">// 清空独占线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c); <span class="comment">// 更新 state 值，0 表示为释放锁成功</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在tryRelease方法中，会先判断当前的线程是不是占用锁的线程，如果不是的话，则会抛出异常；如果是的话，则先计算锁的状态值 getState()-releases是否为0，如果为0，则表示可以正常的释放锁，然后清空独占的线程，最后会更新锁的状态并返回执行结果。</p><h3 id="JDK1-6锁优化"><a href="#JDK1-6锁优化" class="headerlink" title="JDK1.6锁优化"></a>JDK1.6锁优化</h3><p><strong>自适应自旋锁</strong></p><p>JDK1.5在升级为JDK1.6时，HotSpot 虚拟机团队在锁的优化上下了很大功夫，比如实现了自适应式自旋锁、锁升级等。</p><p>JDK 1.6引入了自适应式自旋锁意味着自旋的时间不再是固定的时间了，比如在同一个锁对象上，如果通过自旋等待成功获取了锁，那么虚拟机就会认为，它下一次很有可能也会成功（通过自旋获取到锁，因此允许自旋等待的时间会相对的比较长，而当某个锁通过自旋很少成功获得过锁，那么以后在获取该锁时，可能会直接忽略掉自旋的过程，以避免浪费CPU的资源，这就是自适应自旋锁的功能。</p><p><strong>锁升级</strong><br>锁升级其实就是从偏向锁到轻量级锁再到重量级锁升级的过程，这是JDK1.6提供的优化功能，也称之为锁膨胀。</p><p><strong>偏向锁</strong>是指在无竞争的情况下设置的一种锁状态。偏向锁的意思是它会偏向于第一个获取它的线程，当锁对象第一次被获取到之后，会在此对象头中设置标示为“01”，表示偏向锁的模式，并且在对象头中记录此线程的ID，这种情况下，如果是持有偏向锁的线程每次在进入的话，不再进行任何同步操作，如Locking、Unlocking等，直到另一个线程尝试获取此锁的时候，偏向锁模式才会结束，偏向锁可以提高带有同步但无竞争的程序性能。但如果在多数锁总会被不同的线程访问时，偏向锁模式就比较多余了，此时可以通过-XX:-UseBiasedLocking来禁用偏向锁以提高性能。</p><p><strong>轻量锁</strong>是相对于重量锁而言的，在JDK1.6之前，synchronized是通过操作系统的互斥量（mutex lock）来实现的，这种实现方式需要在用户态和核心态之间做转换，有很大的性能消耗，这种传统实现锁的方式被称之为<strong>重量锁</strong>。</p><p>而<strong>轻量锁</strong>是通过比较并交换（CAS，Compare and Swap）来实现的，它对比的是线程和对象的<br>Mark Word（对象头中的一个区域），如果更新成功则表示当前线程成功拥有此锁；如果失败，虚拟机会先检查对象的Mark Word是否指向当前线程的栈帧，如果是，则说明当前线程已经拥有此锁，否则，则说明此锁已经被其他线程占用了。当两个以上的线程争抢此锁时，轻量级锁就膨胀为重量级锁，这就是锁升级的过程，也是JDK1.6锁优化的内容。</p><p><strong>小结</strong></p><p>本课时首先讲了synchronized和ReentrantLock的实现过程，然后讲了 synchronized和ReentrantLock 的区别，最后通过源码的方式讲了ReentrantLock加锁和解锁的执行流程。接着又讲了JDK1.6中的锁优化，包括自适应式自旋锁的实现过程，以及synchronized的三种锁状态和锁升级的执行流程。<br>synchronized刚开始为偏向锁，随着锁竞争越来越激烈，会升级为轻量级锁和重量级锁。如果大多数锁被不同的线程所争抢就不建议使用偏向锁了。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer算法题</title>
      <link href="/2020/03/25/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2020/03/25/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数组中重复的数字"><a href="#1-数组中重复的数字" class="headerlink" title="1.数组中重复的数字"></a>1.数组中重复的数字</h3><p><strong>题目描述</strong></p><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!set.add(numbers[i])) &#123;</span><br><span class="line">duplication[<span class="number">0</span>]= numbers[i];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】缓存配置</title>
      <link href="/2020/03/25/MyBatis%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/25/MyBatis%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>使用缓存可以使应用更快地获取数据，避免频繁的数据库交互，MyBatis将数据缓存设计成两级结构，分为一级缓存、二级缓存：</p><ul><li>一级缓存是SqlSession会话级别的缓存，位于表示一次数据库会话的SqlSession对象之中，又被称之为本地缓存。</li><li>二级缓存是Application级别的缓存，它的作用范围是整个应用程序。</li></ul><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>一级缓存是MyBatis内部实现的一个特性，用户不能配置，默认情况下自动支持的缓存</p><p>MyBatis会在SqlSession对象中创建一个本地缓存(local cache)。对于每一次查询，都会根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中，就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。</p><h3 id="一级缓存的工作流程："><a href="#一级缓存的工作流程：" class="headerlink" title="一级缓存的工作流程："></a>一级缓存的工作流程：</h3><p><img data-src="1.png" alt="1.png"></p><h3 id="一级缓存的生命周期"><a href="#一级缓存的生命周期" class="headerlink" title="一级缓存的生命周期"></a>一级缓存的生命周期</h3><ul><li>MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象；当会话结束时，SqlSession对象也一并释放掉。</li><li>如果SqlSession调用了close()方法，会释放掉一级缓存，一级缓存将不可用；</li><li>如果SqlSession调用了clearCache()，会清空缓存，但是该对象仍可使用；</li><li>在SqlSession中执行了任何一个update操作、insert操作、delete操作，都会清空缓存，但是该对象可以继续使用；</li></ul><h3 id="判断两次查询是否相同"><a href="#判断两次查询是否相同" class="headerlink" title="判断两次查询是否相同"></a>判断两次查询是否相同</h3><p>MyBatis中，如果以下条件都一样，那么就认为它们是完全相同的两次查询：</p><ul><li>传入的 statementId </li><li>查询时要求的结果集中的结果范围 </li><li>这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串</li><li>传递给java.sql.Statement要设置的参数值</li></ul><h3 id="SqlSession的一级缓存性能问题"><a href="#SqlSession的一级缓存性能问题" class="headerlink" title="SqlSession的一级缓存性能问题"></a>SqlSession的一级缓存性能问题</h3><ul><li>MyBatis对会话（Session）级别的一级缓存设计的比较简单，就简单地使用了HashMap来维护，并没有对HashMap的容量和大小进行限制。</li><li>一级缓存是一个粗粒度的缓存，没有更新缓存和缓存过期的概念</li></ul><h3 id="根据一级缓存的特性，在使用的过程中，应该注意以下两点"><a href="#根据一级缓存的特性，在使用的过程中，应该注意以下两点" class="headerlink" title="根据一级缓存的特性，在使用的过程中，应该注意以下两点"></a>根据一级缓存的特性，在使用的过程中，应该注意以下两点</h3><ol><li>对于数据变化频率很大，并且要求高时效准确性的数据，我们使用SqlSession查询的时候，可以手动地适时清空SqlSession中的缓存</li><li>对于只执行或者频繁执行大范围的select操作的SqlSession对象，SqlSession对象的生存时间不应过长。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SqlSession session=MybatisUtil.openSqlSession();</span><br><span class="line"><span class="comment">//一级缓存生效</span></span><br><span class="line">UserMapper userMapper=session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">User user=userMapper.findById(<span class="number">1</span>);</span><br><span class="line">User user2=userMapper.findById(<span class="number">1</span>);<span class="comment">//完全相同命中</span></span><br><span class="line"><span class="comment">//User user3=userMapper.findByUserName("zs");//更改不命中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空缓存增、改、删、手动清空</span></span><br><span class="line"><span class="comment">/*userMapper.insertUser(user);//缓存也会清空</span></span><br><span class="line"><span class="comment">session.commit();*/</span></span><br><span class="line"><span class="comment">//session.clearCache();清空缓存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SqlSession session2=MybatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper2=session2.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">userMapper2.findById(<span class="number">1</span>);<span class="comment">//不同session中不会命中一级缓存</span></span><br><span class="line">userMapper2.updateUser(<span class="string">"ww"</span>, <span class="number">1</span>);</span><br><span class="line">session2.commit();</span><br><span class="line">session2.close();</span><br><span class="line"><span class="comment">//出现数据不准确的情况</span></span><br><span class="line">User user4=userMapper.findById(<span class="number">1</span>);</span><br><span class="line">session.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><h3 id="开启二级缓存"><a href="#开启二级缓存" class="headerlink" title="开启二级缓存"></a>开启二级缓存</h3><p>MyBatis的二级缓存默认为开启状态，在主配置文件中，settings配置中有一个参数cacheEnable，当把该参数的值设置为false时，可关闭二级缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnable"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>MyBatis的二级缓存是和命名空间绑定的，即二级缓存需要配置在映射文件中，有两种配置方式</p><ul><li>为每一个Mapper分配一个Cache缓存对象（使用&lt;cache&gt;元素配置）</li><li>多个Mapper共用一个Cache缓存对象（使用&lt;cache-ref&gt;元素配置）；</li></ul><p>1、保证二级缓存的全局配置开启，并且使用二级缓存的实体类要实现Serializable接口</p><p>2、给UserMapper.xml开启二级缓存，在mapper元素中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="默认的二级缓存效果如下"><a href="#默认的二级缓存效果如下" class="headerlink" title="默认的二级缓存效果如下:"></a>默认的二级缓存效果如下:</h3><ul><li>映射语句文件中的所有 select 语句将会被缓存</li><li>映射语句文件中的所有 insert，update和delete语句会刷新缓存</li><li>缓存会使用 Least Recently Used（LRU，最近最少使用的）算法来收回</li><li>根据时间表（比如 no Flush Interval，没有刷新间隔）, 缓存不会以任何时间顺序来刷新</li><li>缓存会存储集合或对象（无论查询方法返回什么类型）的 1024 个引用</li><li>缓存会被视为是 read/write（可读/可写）的缓存，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改</li></ul><h3 id="刷新和置换策略"><a href="#刷新和置换策略" class="headerlink" title="刷新和置换策略"></a>刷新和置换策略</h3><p>MyBatis主要提供了以下几个刷新和置换策略：</p><ul><li>LRU（Least Recently Used）：最近最少使用算法，移除最长时间不被使用的对象，这是默认值     </li><li>FIFO（First in first out）：先进先出算法，移除最先进入缓存中的对象</li><li>flushInterval：刷新间隔，会以指定的某一个时间间隔将缓存中的数据清空，不设置时仅仅在调用语句时刷新</li><li>size：可以缓存的对象数目，默认值为1024</li><li>readOnly：只读属性，只读的缓存会给调用者返回缓存对象的相同实例，因此这些对象不能被修改；可读写的缓存会返回缓存对象的拷贝，这种方式更安全，因此默认值是false</li></ul><p>以上效果都可以通过cache元素的属性来修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">    <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这个配置创建了一个 FIFO 缓存，并每隔 60 秒刷新，存储结果对象的 512 个引用，而且返回的对象被认为是只读的，因此在不同线程中的调用者之间修改它们会导致冲突</p><h3 id="多个Mapper公用一个Cache缓存"><a href="#多个Mapper公用一个Cache缓存" class="headerlink" title="多个Mapper公用一个Cache缓存"></a>多个Mapper公用一个Cache缓存</h3><p>如果想让多个Mapper公用一个Cache缓存，可以使用&lt;cache-ref namespace=””&gt;元素配置参照缓存，这样不仅能减少配置项，还能解决脏读问题</p><p><img data-src="2.png" alt="2.png"></p><h3 id="MyBatis中开启二级缓存之后，一级缓存和二级缓存的使用顺序为："><a href="#MyBatis中开启二级缓存之后，一级缓存和二级缓存的使用顺序为：" class="headerlink" title="MyBatis中开启二级缓存之后，一级缓存和二级缓存的使用顺序为："></a>MyBatis中开启二级缓存之后，一级缓存和二级缓存的使用顺序为：</h3><p><strong>二级缓存-&gt;一级缓存-&gt;数据库</strong></p><p><img data-src="3.png" alt="3.png"></p><h2 id="集成EhCache缓存"><a href="#集成EhCache缓存" class="headerlink" title="集成EhCache缓存"></a>集成EhCache缓存</h2><p>MyBatis对二级缓存的设计非常灵活，在MyBatis中使用二级缓存有三个选择</p><ul><li>它自己内部基于HashMap实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等</li><li>MyBatis还允许用户自定义Cache接口实现，然后将Cache实现类配置在&lt;cache  type=””&gt;type属性上即可</li><li>MyBatis还支持第三方缓存框架（EhCache、Redis）的集成</li></ul><p>EhCache是一个纯粹的Java进程内的缓存框架，主要特征</p><ul><li>快速、简单</li><li>提供多种缓存策略</li><li>缓存数据有内存和磁盘两种</li></ul><p>MyBatis集成EhCache框架jar包下载地址为：<a href="https://github.com/mybatis/ehcache-cache/releases" target="_blank" rel="noopener">https://github.com/mybatis/ehcache-cache/releases</a></p><h3 id="MyBatis集成EhCache框架的步骤为："><a href="#MyBatis集成EhCache框架的步骤为：" class="headerlink" title="MyBatis集成EhCache框架的步骤为："></a>MyBatis集成EhCache框架的步骤为：</h3><ol><li>添加jar包，并添加到项目的Build Path</li><li>在resources目录下添加ehcache.xml配置文件</li><li>修改映射接口中的缓存配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"org.mybatis.caches.ehcache.LoggingEhcache"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>EhCache提供了2个可选的缓存实现</p><ul><li>org.mybatis.caches.ehcache.EhcacheCache</li><li>org.mybatis.caches.ehcache.LoggingEhcache</li></ul><p>ehcache.xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"../config/ehcache.xsd"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--当二级缓存的对象 超过内存限制时（缓存对象的个数&gt;maxElementsInMemory），存放入的硬盘文件  --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"F:\Ehcache"</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     maxElementsInMemory:设置 在内存中缓存 对象的个数</span></span><br><span class="line"><span class="comment">    maxElementsOnDisk：设置 在硬盘中缓存 对象的个数</span></span><br><span class="line"><span class="comment">    eternal：设置缓存是否 永远不过期</span></span><br><span class="line"><span class="comment">    overflowToDisk：当内存中缓存的对象个数 超过</span></span><br><span class="line"><span class="comment">    maxElementsInMemory的时候，是否转移到硬盘中</span></span><br><span class="line"><span class="comment">    timeToIdleSeconds：当2次访问 超过该值的时候，将缓存对象失效</span></span><br><span class="line"><span class="comment">    timeToLiveSeconds：一个缓存对象 最多存放的时间（生命周期）</span></span><br><span class="line"><span class="comment">    diskExpiryThreadIntervalSeconds：设置每隔多长时间，通过一个线程来清理硬盘中的缓存</span></span><br><span class="line"><span class="comment">    memoryStoreEvictionPolicy：当超过缓存对象的最大值时，处理的策略；LRU，FIFO,LFU</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">maxElementsOnDisk</span>=<span class="string">"1000000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeToIdleSeconds</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeToLiveSeconds</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="脏数据的产生和避免"><a href="#脏数据的产生和避免" class="headerlink" title="脏数据的产生和避免"></a>脏数据的产生和避免</h2><h3 id="二级缓存中脏数据产生的原因"><a href="#二级缓存中脏数据产生的原因" class="headerlink" title="二级缓存中脏数据产生的原因"></a>二级缓存中脏数据产生的原因</h3><ul><li>通常情况下每个Mapper映射文件都有自己的二级缓存</li><li>有些查询需要关联多张表</li><li>涉及这多张表的增删改查操作通常不在一个映射文件中</li><li>当数据有变化时，多表查询的缓存不一定会清空，这种情况下就会出现脏数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession1 = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper = sqlSession1.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(userMapper.findUserAndOrdersById(<span class="number">1</span>));</span><br><span class="line">sqlSession1.close();</span><br><span class="line">SqlSession sqlSession2 = MyBatisUtil.openSqlSession();</span><br><span class="line">OrderMapper orderMapper = sqlSession2.getMapper(OrderMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">orderMapper.deleteOrderById(<span class="number">1</span>);</span><br><span class="line">sqlSession2.commit();</span><br><span class="line">sqlSession2.close();</span><br><span class="line">SqlSession sqlSession3 = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper2 = sqlSession3.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(userMapper2 .findUserAndOrdersById(<span class="number">1</span>));</span><br><span class="line">sqlSession3.close();</span><br></pre></td></tr></table></figure><h3 id="可以使用参照缓存来避免脏数据的产生，通常是让几个会关联的ER表使用同一个二级缓存"><a href="#可以使用参照缓存来避免脏数据的产生，通常是让几个会关联的ER表使用同一个二级缓存" class="headerlink" title="可以使用参照缓存来避免脏数据的产生，通常是让几个会关联的ER表使用同一个二级缓存"></a>可以使用参照缓存来避免脏数据的产生，通常是让几个会关联的ER表使用同一个二级缓存</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"net.onest.mapper.UserMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】动态SQL</title>
      <link href="/2020/03/24/MyBatis%E5%8A%A8%E6%80%81SQL/"/>
      <url>/2020/03/24/MyBatis%E5%8A%A8%E6%80%81SQL/</url>
      
        <content type="html"><![CDATA[<h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><h3 id="映射器接口中方法的参数情况"><a href="#映射器接口中方法的参数情况" class="headerlink" title="映射器接口中方法的参数情况"></a>映射器接口中方法的参数情况</h3><ul><li>当根据单个条件查询时，可以直接以该条件为参数</li><li>当根据多个条件查询时，可以将JavaBean作为参数</li><li>当根据多个条件查询且多个条件不属于某一个JavaBean时，可以Map类型作为参数，且通过Map中的key值来映射XML中SQL使用的参数的名字</li><li>如果要使用多个参数，必须使用@Param注解指定参数名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByNameAndPassword</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Param(<span class="string">"name"</span>)</span>String name, </span></span><br><span class="line"><span class="function">            @<span class="title">Param</span><span class="params">(<span class="string">"password"</span>)</span>String password)</span>;</span><br></pre></td></tr></table></figure><ul><li>映射文件中可以引用@Param注解中指定的参数名称</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByNameAndPassword"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    select * from user where </span><br><span class="line">    user_name = #&#123;name&#125;</span><br><span class="line">    and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="MyBatis动态SQL"><a href="#MyBatis动态SQL" class="headerlink" title="MyBatis动态SQL"></a>MyBatis动态SQL</h2><p>MyBatis 的一个强大的特性之一就是它的动态 SQL 能力。也就是可以根据不同的条件拼接SQL语句。以下是动态SQL在XML中支持的几种元素</p><ul><li>if</li><li>choose (when, otherwise) </li><li>trim (where, set) </li><li>foreach </li><li>bind</li></ul><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><strong>if元素通常用于where语句中，通过判断参数值来决定是否使用某个查询条件</strong></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设现在有一个需求：实现一个用户管理高级查询功能，根据用户输入的条件去检索用户信息</p><p><strong>创建实体类User和映射器接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">//省略构造方法</span></span><br><span class="line">    <span class="comment">//省略getter、setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射器接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User findUserByPhoneOrEmail</span><br><span class="line">         (Map&lt;String, String&gt; map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不使用动态SQL时，实现上述需求的映射文件如下：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByPhoneOrEmail"</span>    </span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">"com.mybatis.mapper.User"</span>&gt;</span></span><br><span class="line">        select id, user_name userName, </span><br><span class="line">            password, phone, email </span><br><span class="line">        from user </span><br><span class="line">        where phone = #&#123;phone&#125; and email = #&#123;email&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>调用该方法时，传入的Map类型的实际参数中，必须存在phone和email这两个key值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; user = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">user.put(<span class="string">"phone"</span>, <span class="string">"123456789"</span>);</span><br><span class="line">user.put(<span class="string">"email"</span>, <span class="string">"test@163.com"</span>); userMapper.findUserByPhoneOrEmail(user);</span><br></pre></td></tr></table></figure><p><strong>不使用动态SQL时，只有同时输入phone和email两个条件时，才能查出正确结果，此时需要if元素来解决这个问题</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByPhoneOrEmail"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">     select id, user_name userName, password, phone, email   </span><br><span class="line">  from user where 1 = 1</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"phone != null and !phone.equals('')"</span>&gt;</span></span><br><span class="line">      and phone = #&#123;phone&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null and !email.equals('')"</span>&gt;</span></span><br><span class="line">      and email = #&#123;email&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>test属性的值为符合<strong>ONGL（Object-Graph Navigation Language对象图导航语言）</strong>要求的判断表达式，表达式中能够出现<strong>方法调用</strong>，但是结果只能为true或者false</p><p>MyBatis常用的ONGL表达式中可以使用的操作符如下：</p><table><thead><tr><th><strong>Java</strong>常用操作符</th><th>+、-、*、/、%、==、!=、&amp;&amp;、||、!、点、[ ]</th></tr></thead><tbody><tr><td><strong>自己特有的操作符</strong></td><td><strong>or、and、eq、neq、lt、lte、gt、gte、not</strong></td></tr></tbody></table><p>如果不想让where条件中出现“1=1”这种表达式时，就需要使用<strong>where</strong>元素</p><p><strong>where元素的作用</strong>：如果该元素中有内容，就在生成SQL语句时加上where条件，如果该元素的内容以AND或者OR开头，就去除这两个单词。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByPhoneOrEmail"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    select id, user_name userName, password, phone, email   </span><br><span class="line">    from user </span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"phone != null and !phone.equals('')"</span>&gt;</span></span><br><span class="line">            and phone = #&#123;phone&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null and !email.equals('')"</span>&gt;</span></span><br><span class="line">            and email = #&#123;email&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="练习1：使用if元素实现动态列更新，即更新用户信息时，只更新有变化的字段"><a href="#练习1：使用if元素实现动态列更新，即更新用户信息时，只更新有变化的字段" class="headerlink" title="练习1：使用if元素实现动态列更新，即更新用户信息时，只更新有变化的字段"></a>练习1：使用if元素实现动态列更新，即更新用户信息时，只更新有变化的字段</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUserByIdSelective"</span>&gt;</span></span><br><span class="line">     update user set </span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null and !userName.equals('')"</span>&gt;</span></span><br><span class="line">         user_name = #&#123;userName&#125;,</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">     ……</span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null and !email.equals('')"</span>&gt;</span></span><br><span class="line">         email = #&#123;email&#125;,</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">     id = #&#123;id&#125;</span><br><span class="line">     where id = #&#123;id&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现动态列更新时，可以使用set元素</p><p><strong>set元素作用</strong>：当该元素有内容时，生成SQL语句时就加上set语句；当set元素的内容以逗号结尾时，去掉逗号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUserByIdSelective"</span>&gt;</span></span><br><span class="line">    update user </span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null and !userName.equals('')"</span>&gt;</span></span><br><span class="line">        user_name = #&#123;userName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password != null and !password.equals('')"</span>&gt;</span></span><br><span class="line">        password = #&#123;password&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"phone != null and !phone.equals('')"</span>&gt;</span></span><br><span class="line">        phone = #&#123;phone&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null and !email.equals('')"</span>&gt;</span></span><br><span class="line">        email = #&#123;email&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span> </span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="练习2：插入用户信息时，如果邮箱为空，就使用数据库中设置的默认值，而不要传入空值"><a href="#练习2：插入用户信息时，如果邮箱为空，就使用数据库中设置的默认值，而不要传入空值" class="headerlink" title="练习2：插入用户信息时，如果邮箱为空，就使用数据库中设置的默认值，而不要传入空值"></a>练习2：插入用户信息时，如果邮箱为空，就使用数据库中设置的默认值，而不要传入空值</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span>&gt;</span></span><br><span class="line">     insert into user(user_name, password, phone</span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null and !email.equals('')"</span>&gt;</span></span><br><span class="line">     ,email</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">     ) values(#&#123;userName&#125;, #&#123;password&#125;, #&#123;phone&#125;</span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null and !email.equals('')"</span>&gt;</span></span><br><span class="line">     ,#&#123;email&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span>)</span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h3><p>choose元素中包含when和otherwise两个子元素</p><ul><li>一个choose元素中至少有一个when子元素</li><li>一个choose元素中可以包含0个或1个otherwise子元素</li></ul><p>使用choose元素可以实现类似if…else…的逻辑</p><h4 id="练习1：当实现查询时，如果id属性有值就使用id查询，如果id没有值在去根据用户名查询"><a href="#练习1：当实现查询时，如果id属性有值就使用id查询，如果id没有值在去根据用户名查询" class="headerlink" title="练习1：当实现查询时，如果id属性有值就使用id查询，如果id没有值在去根据用户名查询"></a>练习1：当实现查询时，如果id属性有值就使用id查询，如果id没有值在去根据用户名查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByIdOrName"</span> <span class="attr">resultType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">select id, user_name userName, password, phone, email</span><br><span class="line">from user where 1 = 1</span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"id != null and id != ''"</span>&gt;</span></span><br><span class="line">and id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"userName != null and userName != ''"</span>&gt;</span></span><br><span class="line">and user_name = #&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">and 1 = 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>trim元素可以实现where和set元素的功能</p><p>trim元素对应的where功能的实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">prefixOverrides</span>=<span class="string">"AND |OR "</span>&gt;</span>……<span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>trim元素对应的set功能的实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"set"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span>……<span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>trim元素的属性，都在<strong>trim元素包含内容时</strong>起作用：</p><ul><li>prefix：给内容增加该属性指定的前缀</li><li>prefixOverrides：把内容中匹配的前缀字符串去掉</li><li>suffix：给内容增加该属性指定的后缀</li><li>suffixOverrides：把内容中匹配的后缀字符串去掉</li></ul><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>foreach可以对数组、Map或实现了Iterable接口（如：List、Set）的对象进行遍历</p><p>映射接口中添加如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByIdList</span><span class="params">(List&lt;Integer&gt; idList)</span></span>;</span><br></pre></td></tr></table></figure><p>映射文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByIdList"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">     select id, user_name userName, password, phone, email</span><br><span class="line">     from user</span><br><span class="line">     where id in</span><br><span class="line">     <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> </span></span><br><span class="line"><span class="tag">              <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">index</span>=<span class="string">"i"</span>&gt;</span></span><br><span class="line">         #&#123;id&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="foreach各个属性的含义"><a href="#foreach各个属性的含义" class="headerlink" title="foreach各个属性的含义"></a>foreach各个属性的含义</h4><table><thead><tr><th align="center"><strong>属性</strong></th><th align="left"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center"><strong>collection</strong></td><td align="left"><strong>必填，值为要迭代循环的属性名</strong></td></tr><tr><td align="center"><strong>item</strong></td><td align="left"><strong>变量名，值为从迭代对象中取出的每一个值</strong></td></tr><tr><td align="center"><strong>index</strong></td><td align="left"><strong>索引的属性名，在遍历集合、数组时为当前索引值，当遍历Map时，该值为Map的key值</strong></td></tr><tr><td align="center"><strong>open</strong></td><td align="left"><strong>整个循环内容开头的字符串</strong></td></tr><tr><td align="center"><strong>close</strong></td><td align="left"><strong>整个循环内容结尾的字符串</strong></td></tr><tr><td align="center"><strong>separator</strong></td><td align="left"><strong>每次循环的分隔符</strong></td></tr></tbody></table><p>collection属性的取值有多种情况:</p><ul><li>当参数为List集合时，collection取值为list</li><li>当参数为数组时，collection取值为array</li><li>当参数为Map类型时，collection取值默认情况下为_parameter，也可以使用@Param注解指定名字，collection取值为该注解指定的名字</li></ul><p>foreach还能实现批量插入。目前支持批量插入的数据库有DB2、SQL Server 2008及以上版本、MySQL等</p><p>在映射接口中添加批量插入的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertList</span><span class="params">(List&lt;User&gt; users)</span></span>;</span><br></pre></td></tr></table></figure><p>使用foreach实现批量插入功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertList"</span>&gt;</span></span><br><span class="line">     insert into user(user_name, password, phone, email)</span><br><span class="line">     values</span><br><span class="line">     <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"user"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">     (#&#123;user.userName&#125;, #&#123;user.password&#125;,</span><br><span class="line">     #&#123;user.phone&#125;, #&#123;user.email&#125;)</span><br><span class="line">     <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MySQL数据库还支持批量插入后，返回所有记录的主键的操作，MyBatis要想实现此功能，需要修改XML映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertList"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">     insert into user(user_name, password, phone, email)</span><br><span class="line">     values</span><br><span class="line">     <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"user"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">     (#&#123;user.userName&#125;, #&#123;user.password&#125;,</span><br><span class="line">     #&#123;user.phone&#125;, #&#123;user.email&#125;)</span><br><span class="line">     <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>foreach实现动态更新，当参数是Map类型时，foreach元素的index属性值对应的不是索引值，而是Map中的key</p><p>实现通过指定的列名和对应的值去更新数据，在映射接口中添加如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure><p>这里key作为列名，对应的值作为该列的值，通过foreach将需要更新的字段拼接在SQL语句中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByMap"</span>&gt;</span></span><br><span class="line">    update user set</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"_parameter"</span> <span class="attr">item</span>=<span class="string">"value"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">index</span>=<span class="string">"key"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        $&#123;key&#125; = #&#123;value&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述方法在调用时，Map类型的实参中的key值要与表中字段名对应</p><p>也可以将映射器接口中方法的参数添加@Param注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateByMap</span><span class="params">(@Param(<span class="string">"map"</span>)</span>Map&lt;String, </span></span><br><span class="line"><span class="function">    Object&gt; map)</span>;</span><br></pre></td></tr></table></figure><p>映射文件修改如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByMap"</span>&gt;</span></span><br><span class="line">    update user set</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"map"</span> <span class="attr">item</span>=<span class="string">"value"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">index</span>=<span class="string">"key"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        $&#123;key&#125; = #&#123;value&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    where id = #&#123;map.id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="扩展：bind用法"><a href="#扩展：bind用法" class="headerlink" title="扩展：bind用法"></a>扩展：bind用法</h3><p>bind可以使用OGNL表达式创建一个变量并将其绑定到上下文中。如：在模糊查询中可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserLike</span><span class="params">(@Param(<span class="string">"name"</span>)</span>String name)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserLike"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"'%' + name + '%'"</span>/&gt;</span></span><br><span class="line">   select * from user </span><br><span class="line">       where user_name like #&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-栈</title>
      <link href="/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88/"/>
      <url>/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="1-栈的一个实际需求"><a href="#1-栈的一个实际需求" class="headerlink" title="1.栈的一个实际需求"></a>1.栈的一个实际需求</h2><p>请输入一个表达式<br>计算式:[7*2*2-5+1-5+3-3]  点击计算</p><h2 id="2-栈的介绍"><a href="#2-栈的介绍" class="headerlink" title="2.栈的介绍"></a>2.栈的介绍</h2><ol><li>栈的英文为(stack)</li><li>栈是一个 <strong>先入后出</strong>(FILO-First In Last Out) 的有序列表。</li><li>栈(stack) 是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。 。 允许插入和删除的一端，为 <strong>变化的一端，称为栈顶(Top)</strong> ，另一端为 <strong>固定的一端，称为栈底(Bottom)</strong> 。</li><li>根据栈的定义可知 ， 最先放入栈中元素在栈底 ， 最后放入的元素在栈顶 ， 而删除元素刚好相反 ， 最后放入的元素最先删除，最先放入的元素最后删除</li><li>图解方式说明出栈(pop) 和入栈(push)</li></ol><h2 id="3-栈的应用场景"><a href="#3-栈的应用场景" class="headerlink" title="3.栈的应用场景"></a>3.栈的应用场景</h2><ol><li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。</li><li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆<br>栈中。</li><li>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</li><li>二叉树的遍历。</li><li>图形的深度优先(depth 一 first)搜索法。</li></ol><h2 id="4-数组实现栈"><a href="#4-数组实现栈" class="headerlink" title="4.数组实现栈"></a>4.数组实现栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试一下ArrayStack 是否正确</span></span><br><span class="line"><span class="comment">// 先创建一个ArrayStack对象-&gt;表示栈</span></span><br><span class="line">ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">String key = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">boolean</span> loop = <span class="keyword">true</span>; <span class="comment">// 控制是否退出菜单</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (loop) &#123;</span><br><span class="line">System.out.println(<span class="string">"show: 表示显示栈"</span>);</span><br><span class="line">System.out.println(<span class="string">"exit: 退出程序"</span>);</span><br><span class="line">System.out.println(<span class="string">"push: 表示添加数据到栈(入栈)"</span>);</span><br><span class="line">System.out.println(<span class="string">"pop: 表示从栈取出数据(出栈)"</span>);</span><br><span class="line">System.out.println(<span class="string">"请输入你的选择"</span>);</span><br><span class="line">key = scanner.next();</span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">stack.list();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">System.out.println(<span class="string">"请输入一个数"</span>);</span><br><span class="line"><span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">stack.push(value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"pop"</span>:</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = stack.pop();</span><br><span class="line">System.out.printf(<span class="string">"出栈的数据是 %d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">scanner.close();</span><br><span class="line">loop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"程序退出~~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">// 栈的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">// 用数组模拟栈，数据就放在 数组中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先判断是否满</span></span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line">stack[top] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line"><span class="keyword">new</span> RuntimeException(<span class="string">"栈空,没有数据~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> value = stack[top];</span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历显示栈 从栈顶开始显示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈空，没有数据~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">System.out.printf(<span class="string">"stack[%d]=%d\n"</span>, i, stack[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-栈实现综合计算器-中缀表达式"><a href="#5-栈实现综合计算器-中缀表达式" class="headerlink" title="5.栈实现综合计算器(中缀表达式)"></a>5.栈实现综合计算器(中缀表达式)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据前面的思路，完成表达式的运算</span></span><br><span class="line">String expression = <span class="string">"70+2*6-4"</span>;</span><br><span class="line"><span class="comment">// 定义两个栈 数栈 符号栈</span></span><br><span class="line">ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(<span class="number">20</span>);</span><br><span class="line">ArrayStack2 operStack = <span class="keyword">new</span> ArrayStack2(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 定义需要的相关变量</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 用于辅助扫描</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> oper = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">' '</span>;<span class="comment">// 将每次扫描得到的char保存到ch</span></span><br><span class="line">String keepNum = <span class="string">""</span>; <span class="comment">// 用于拼接 多位数</span></span><br><span class="line"><span class="comment">// 开始循环扫描expression</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 依次得到expression 的每一个字符</span></span><br><span class="line">ch = expression.charAt(index);</span><br><span class="line"><span class="comment">// 判断ch是什么，然后做相应的处理</span></span><br><span class="line"><span class="keyword">if</span> (operStack.isOper(ch)) &#123;</span><br><span class="line"><span class="comment">// 判断当前的符号栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (!operStack.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数</span></span><br><span class="line"><span class="comment">// 再从符号栈pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的操作符入符号栈</span></span><br><span class="line"><span class="keyword">if</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">num1 = numStack.pop();</span><br><span class="line">num2 = numStack.pop();</span><br><span class="line">oper = operStack.pop();</span><br><span class="line">res = numStack.cal(num1, num2, oper);</span><br><span class="line"><span class="comment">// 运算后把结果入数栈</span></span><br><span class="line">numStack.push(res);</span><br><span class="line"><span class="comment">// 把当前的操作符入符号栈</span></span><br><span class="line">operStack.push(ch);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果当前的操作符的优先级大于栈中的操作符，就直接入栈</span></span><br><span class="line">operStack.push(ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 若符号栈为空 直接入栈</span></span><br><span class="line">operStack.push(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 分析思路</span></span><br><span class="line"><span class="comment">// 1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span></span><br><span class="line"><span class="comment">// 2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line"><span class="comment">// 3. 因此我们需要定义一个变量 字符串，用于拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理多位数</span></span><br><span class="line">keepNum += ch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果ch已经是expression的最后一位，就直接入栈</span></span><br><span class="line"><span class="keyword">if</span> (index == expression.length() - <span class="number">1</span>) &#123;</span><br><span class="line">numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈</span></span><br><span class="line"><span class="comment">// 注意是看后一位，不是index++</span></span><br><span class="line"><span class="keyword">if</span> (operStack.isOper(expression.substring(index + <span class="number">1</span>, index + <span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line"><span class="comment">// 如果后一位是运算符，则入栈 keepNum = "1" 或者 "123"</span></span><br><span class="line">numStack.push(Integer.parseInt(keepNum));</span><br><span class="line"><span class="comment">// 重要的!!!!!!, keepNum清空</span></span><br><span class="line">keepNum = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让index加1 并判断是否扫描到expression最后</span></span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= expression.length()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当表达式扫描完毕，就顺序地从数栈和符号栈中 pop 出相应的数和符号 ，并运算</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 如果符号栈为空，则计算到最后的结果了 数栈中只有一个结果</span></span><br><span class="line"><span class="keyword">if</span> (operStack.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">num1 = numStack.pop();</span><br><span class="line">num2 = numStack.pop();</span><br><span class="line">oper = operStack.pop();</span><br><span class="line">res = numStack.cal(num1, num2, oper);</span><br><span class="line">numStack.push(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将数栈的最后数 pop 出 就是结果</span></span><br><span class="line"><span class="keyword">int</span> res2 = numStack.pop();</span><br><span class="line">System.out.printf(<span class="string">"表达式: %s = %d"</span>, expression, res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个栈</span></span><br><span class="line"><span class="comment">// 需要扩展一些功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack2</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">// 栈的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">// 用数组模拟栈，数据就放在 数组中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayStack2</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先判断是否满</span></span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line">stack[top] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line"><span class="keyword">new</span> RuntimeException(<span class="string">"栈空,没有数据~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> value = stack[top];</span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加一个方法 可以返回当前栈顶的值 但是不是pop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> stack[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历显示栈 从栈顶开始显示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈空，没有数据~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">System.out.printf(<span class="string">"stack[%d]=%d\n"</span>, i, stack[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回运算符的优先级，优先级是程序员来确定的，优先级使用数字表示</span></span><br><span class="line"><span class="comment">// 数字越大，则优先级就越高</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oper == <span class="string">'*'</span> || oper == <span class="string">'/'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">'+'</span> || oper == <span class="string">'-'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是不是一个运算符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val == <span class="string">'+'</span> || val == <span class="string">'-'</span> || val == <span class="string">'*'</span> || val == <span class="string">'/'</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">// 用于存放计算的结果</span></span><br><span class="line"><span class="keyword">switch</span> (oper) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">res = num1 + num2;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">res = num2 - num1; <span class="comment">// 注意运算顺序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">res = num1 * num2;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">res = num2 / num1; <span class="comment">// 顺序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-前缀、后缀、中缀表达式"><a href="#6-前缀、后缀、中缀表达式" class="headerlink" title="6.前缀、后缀、中缀表达式"></a>6.前缀、后缀、中缀表达式</h2><p>三种表达形式，分别为 前缀、后缀 、中缀 表达式。</p><h3 id="前缀表达式："><a href="#前缀表达式：" class="headerlink" title="前缀表达式："></a>前缀表达式：</h3><p>操作符写在操作数的前面，这种方法经常用在计算机上，特别是 编译器的设计。其特点是：从右往左扫描表达式，遇到数字就进栈，遇到操作符就就将将栈顶的两个数字出栈，并进行相应的操作运算，之后将运算结果再进栈。重复上面操作，直至扫描结束。</p><p>比如现在有 前缀表达式 ： -*+ABC/D+EF 。具体过程：</p><p>1.先将 E 和 F 进栈，扫描到 + 号，将 E 和 F 出栈并相加得到 (E+F),再将它进栈。</p><p>2.将 D 进栈，扫描到 / 号 将 D 和 （E+F）出栈，并进行 D/(E+F)运算，然后把结果进栈。</p><p>3.将 A B C 进栈，现在栈顶两个元素是 A 和 B ，扫描到 + 号，将 A B 出栈，并且 进行 A+B 运算，再进栈。</p><p>4.扫描到 * 号，现在栈顶两个元素是（A+B）和 C 所以进行 （A+B）*C 运算，再进栈。</p><p>5扫描到 - 号，此时栈顶两个元素是 （A+B）<em>C 和 D/(E+F)，出栈，进行（A+B）</em>C -D/(E+F)运算，再进栈。</p><p>6.扫描结束 所以运算结果是 （A+B）*C - D/(E+F)</p><h3 id="中缀表达式："><a href="#中缀表达式：" class="headerlink" title="中缀表达式："></a>中缀表达式：</h3><p>其实就是我们平时的算法表达式形式 比如上面的 （A+B）*C - D/(E+F) 就是中缀表达式。</p><h3 id="后缀表达式："><a href="#后缀表达式：" class="headerlink" title="后缀表达式："></a>后缀表达式：</h3><p>跟前缀表达式相反，它将数字写在操作符的前面。我们从左向右扫描即可。</p><p>例如 现在有 后缀表达式  AB+C*DEF+/-  。具体过程：</p><ol><li>A 和 B 进栈，扫描到 + 号，A B出栈并且进行 A+B操作运算，然后再进栈。</li><li>C 进栈，扫描到 * 号，出栈，进行 （A+B）*C操作，再进栈。</li><li>将D E F 进栈，扫描到 + 号 将 E 和 F出栈并且进行 E+F 操作，进栈。</li><li>扫描到 / 号 将 （E+F）和D出栈，进行 （E+F）/D 操作，再进栈</li><li>扫描到 - 号 ，将 （A+B）<em>C 和 （E+F）/D出栈，进行 （A+B）</em>C -（E+F）/D 运算，再进栈。</li><li>扫描结束，所以结果是 （A+B）*C -（E+F）/D</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-约瑟夫环</title>
      <link href="/2020/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
      <url>/2020/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述</strong>：编号为 1-N 的 N 个士兵围坐在一起形成一个圆圈，从编号为 1 的士兵开始依次报数（1，2，3…这样依次报），数到 m 的 士兵会被杀死出列，之后的士兵再从 1 开始报数。直到最后剩下一士兵，求这个士兵的编号。</p><h3 id="1、方法一：数组"><a href="#1、方法一：数组" class="headerlink" title="1、方法一：数组"></a>1、方法一：数组</h3><p>在大一第一次遇到这个题的时候，我是用数组做的，我猜绝大多数人也都知道怎么做。方法是这样的：</p><p>用一个数组来存放 1，2，3 … n 这 n 个编号，如图（这里我们假设n = 6, m = 3）</p><p><img data-src="3.png" alt="3.png"></p><p>然后不停着遍历数组，对于被选中的编号，我们就做一个标记，例如编号 arr[2] = 3 被选中了，那么我们可以做一个标记，例如让 arr[2] = -1，来表示 arr[2] 存放的编号已经出局的了。</p><p><img data-src="4.png" alt="4.png"></p><p>然后就按照这种方法，不停着遍历数组，不停着做标记，直到数组中只有一个元素是非 -1 的，这样，剩下的那个元素就是我们要找的元素了。</p><p><img data-src="5.png" alt="5.png"></p><p>这种方法简单吗？思路简单，但是编码却没那么简单，临界条件特别多，每次遍历到数组最后一个元素的时候，还得重新设置下标为 0，并且遍历的时候还得判断该元素时候是否是 -1。感兴趣的可以动手写一下代码，用这种数组的方式做，千万不要觉得很简单，编码这个过程还是挺考验人的。</p><p>这种做法的时间复杂度是 O(n * m), 空间复杂度是 O(n);</p><h3 id="2、方法二：环形链表"><a href="#2、方法二：环形链表" class="headerlink" title="2、方法二：环形链表"></a>2、方法二：环形链表</h3><p>学过链表的人，估计都会用链表来处理约瑟夫环问题，用链表来处理其实和上面处理的思路差不多，只是用链表来处理的时候，对于被选中的编号，不再是<strong>做标记</strong>，而是<strong>直接移除</strong>，因为从链表移除一个元素的时间复杂度很低，为 O(1)。当然，上面数组的方法你也可以采用移除的方式，不过数组移除的时间复杂度为 O(n)。所以采用链表的解决方法如下：</p><p>1、先创建一个环形链表来存放元素：</p><p><img data-src="1.png" alt="1.png"></p><p>2、然后一边遍历链表一遍删除，直到链表只剩下一个节点</p><p><img data-src="2.png" alt="2.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> date;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span> || n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">// 创建环形链表</span></span><br><span class="line">        Node head = createLinkedList(n);</span><br><span class="line">        <span class="comment">// 遍历删除</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;<span class="comment">//前驱节点</span></span><br><span class="line">        <span class="keyword">while</span> (head.next != head) &#123;</span><br><span class="line">            <span class="comment">// 删除节点</span></span><br><span class="line">            <span class="keyword">if</span> (count == m) &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">                cur = pre.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">createLinkedList</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Node tmp = <span class="keyword">new</span> Node(i);</span><br><span class="line">            next.next = tmp;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 头尾串联</span></span><br><span class="line">        next.next = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这种方法估计是最多人用的，时间复杂度为 O(n * m),空间复杂度是 O(n)。</p><h3 id="3、方法三：递归"><a href="#3、方法三：递归" class="headerlink" title="3、方法三：递归"></a>3、方法三：递归</h3><p>其实这道题还可以用递归来解决，递归是思路是<strong>每次我们删除了某一个士兵之后，我们就对这些士兵重新编号，然后我们的难点就是找出删除前和删除后士兵编号的映射关系</strong>。</p><p>我们定义递归函数 f(n，m) 的返回结果是存活士兵的编号，显然当 n = 1 时，f(n, m) = 1。假如我们能够找出 f(n，m) 和 f(n-1，m) 之间的关系的话，我们就可以用递归的方式来解决了。我们假设人员数为 n, 报数到 m 的人就自杀。则刚开始的编号为</p><p>…<br>1<br>…<br>m - 2</p><p>m - 1</p><p>m</p><p>m + 1</p><p>m + 2<br>…<br>n<br>…</p><p>进行了一次删除之后，删除了编号为 m 的节点。删除之后，就只剩下 n - 1 个节点了，删除前和删除之后的编号转换关系为：</p><p>删除前     —     删除后</p><p>…          —      …</p><p>m - 2     —     n - 2</p><p>m - 1    —      n - 1</p><p>m         —-    无(因为编号被删除了)</p><p>m + 1     —     1(因为下次就从这里报数了)</p><p>m + 2     —-     2</p><p>…         —-         …</p><p>新的环中只有 n - 1 个节点。且删除前编号为 m + 1, m + 2, m + 3 的节点成了删除后编号为 1， 2， 3 的节点。</p><p>假设 old 为删除之前的节点编号， new 为删除了一个节点之后的编号，则 old 与 new 之间的关系为 old = (new + m - 1) % n + 1。</p><p>这样，我们就得出 f(n, m) 与 f(n - 1, m)之间的关系了，而 f(1, m) = 1.所以我们可以采用递归的方式来做。代码如下：</p><p><strong>注</strong>：有些人可能会疑惑为什么不是 old = (new + m ) % n 呢？主要是因为编号是从 1 开始的，而不是从 0 开始的。如果 new + m == n的话，会导致最后的计算结果为 old = 0。所以 old = (new + m - 1) % n + 1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)   <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> (f(n - <span class="number">1</span>, m) + m - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两行代码搞定，而且时间复杂度是 O(n)，空间复杂度是O(1)，牛逼！那如果你想跟别人说，我想一行代码解决约瑟夫问题呢？答是没问题的，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? n : (f(n - <span class="number">1</span>, m) + m - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="另一版本约瑟夫"><a href="#另一版本约瑟夫" class="headerlink" title="另一版本约瑟夫"></a>另一版本约瑟夫</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Josephu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试一把看看构建环形链表，和遍历是否ok</span></span><br><span class="line">CircleSingleLinkedList circleSingleLinkedList = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">circleSingleLinkedList.addBoy(<span class="number">5</span>);<span class="comment">// 加入5个小孩节点</span></span><br><span class="line">circleSingleLinkedList.showBoy();</span><br><span class="line"><span class="comment">// 测试一把小孩出圈是否正确</span></span><br><span class="line">circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line"><span class="comment">// String str = "7*2*2-5+1-5+3-3";</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形的单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个fitst节点，当前没有编号</span></span><br><span class="line"><span class="keyword">private</span> Boy first = <span class="keyword">new</span> Boy(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加小孩节点，构建成一个环形链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 数据校验</span></span><br><span class="line"><span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"nums的值不正确"</span>.</span><br><span class="line">&#125;</span><br><span class="line">Boy curBoy = <span class="keyword">null</span>;<span class="comment">// 辅助指针，帮助构建环形链表</span></span><br><span class="line"><span class="comment">// 循环创建环形列表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line"><span class="comment">// 根据编号，创建小孩节点</span></span><br><span class="line">Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line"><span class="comment">// 如果是第一个小孩</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">first = boy;</span><br><span class="line">first.setNext(first);<span class="comment">// 构成环</span></span><br><span class="line">curBoy = first;<span class="comment">// 让curBoy指向第一个小孩</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">curBoy.setNext(boy);</span><br><span class="line">boy.setNext(first);</span><br><span class="line">curBoy = boy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"没有任何小孩~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">Boy curBoy = first;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">"小孩的编号 %d \n"</span>, curBoy.getNo());</span><br><span class="line"><span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">// 说明已经遍历完毕</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curBoy = curBoy.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startNo</span></span><br><span class="line"><span class="comment"> *            表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> countNum</span></span><br><span class="line"><span class="comment"> *            表示数几下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> *            表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先对数据校验</span></span><br><span class="line"><span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">System.out.println(<span class="string">"参数输入有误， 请重新输入"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建要给辅助指针,帮助完成小孩出圈</span></span><br><span class="line">Boy helper = first;</span><br><span class="line"><span class="comment">// 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (helper.getNext() == first) &#123;<span class="comment">// 说明helper指向最后小孩节点</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">helper = helper.getNext();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小孩报数前，先让 first 和 helper 移动 k - 1次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startNo - <span class="number">1</span>; i++) &#123;</span><br><span class="line">first = first.getNext();</span><br><span class="line">helper = helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当小孩报数时，让first 和 helper 指针同时 的移动 m - 1 次, 然后出圈</span></span><br><span class="line"><span class="comment">// 这里是一个循环操作，知道圈中只有一个节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (helper == first) &#123;<span class="comment">// 说明圈中只有一人</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让 first 和 helper 指针同时 的移动 countNum - 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countNum - <span class="number">1</span>; j++) &#123;</span><br><span class="line">first = first.getNext();</span><br><span class="line">helper = helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时first指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">System.out.printf(<span class="string">"小孩%d出圈\n"</span>, first.getNo());</span><br><span class="line"><span class="comment">// 这时将first指向的小孩节点出圈</span></span><br><span class="line">first = first.getNext();</span><br><span class="line">helper.setNext(first);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">"最后留在圈中的小孩编号%d \n"</span>, first.getNo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;<span class="comment">// 编号</span></span><br><span class="line"><span class="keyword">private</span> Boy next; <span class="comment">// 指向下一个节点,默认null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-双向链表</title>
      <link href="/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>双向链表的每一个结点都有一条指向其后继结点的next链和一条指向其前结点的pre链。双向链表既可以从第一项开始遍历也可以从最后一项开始往前遍历，双向链表可以用下图表示：</p><p><img data-src="1.png" alt="1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">System.out.println(<span class="string">"双向链表的测试"</span>);</span><br><span class="line"><span class="comment">// 先创建节点</span></span><br><span class="line">HeroNode2 hero1 = <span class="keyword">new</span> HeroNode2(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">HeroNode2 hero2 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">HeroNode2 hero3 = <span class="keyword">new</span> HeroNode2(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">HeroNode2 hero4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"><span class="comment">// 创建一个双向链表</span></span><br><span class="line">DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line"><span class="comment">// doubleLinkedList.add(hero1);</span></span><br><span class="line"><span class="comment">// doubleLinkedList.add(hero2);</span></span><br><span class="line"><span class="comment">// doubleLinkedList.add(hero3);</span></span><br><span class="line"><span class="comment">// doubleLinkedList.add(hero4);</span></span><br><span class="line"></span><br><span class="line">doubleLinkedList.addByOrder(hero4);</span><br><span class="line">doubleLinkedList.addByOrder(hero3);</span><br><span class="line">doubleLinkedList.addByOrder(hero2);</span><br><span class="line">doubleLinkedList.addByOrder(hero1);</span><br><span class="line"></span><br><span class="line">doubleLinkedList.list();</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">HeroNode2 newHeroNode = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"公孙胜"</span>, <span class="string">"入云龙"</span>);</span><br><span class="line">doubleLinkedList.update(newHeroNode);</span><br><span class="line">System.out.println(<span class="string">"修改后的链表情况"</span>);</span><br><span class="line">doubleLinkedList.list();</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"删除后的链表情况~~"</span>);</span><br><span class="line">doubleLinkedList.list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个双向链表的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双向链表中删除一个节点</span></span><br><span class="line"><span class="comment">// 说明：对于双向链表 可以直接找到要删除的这个节点，找到后自我删除即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断当前链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空，不能删除"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助指针</span></span><br><span class="line">HeroNode2 temp = head.next;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 已经到链表最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">temp.pre.next = temp.next;</span><br><span class="line"><span class="comment">// 如果是最后一个节点就不需要执行下面这行代码 否则空指针</span></span><br><span class="line"><span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">temp.next.pre = temp.pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>, no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeroNode2 temp = head.next;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line"><span class="comment">// 找到位置</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">temp.name = newHeroNode.name;</span><br><span class="line">temp.nickname = newHeroNode.nickname;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个节点到双向链表的最后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line">HeroNode2 temp = head;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出while循环 ，temp就指向了链表的最后</span></span><br><span class="line"><span class="comment">// 形成一个双向链表</span></span><br><span class="line">temp.next = heroNode;</span><br><span class="line">heroNode.pre = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">// (如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line"><span class="comment">// 因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span></span><br><span class="line">HeroNode2 temp = head;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">// 位置找到了</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">flag = <span class="keyword">true</span>;<span class="comment">// 说明编号存在S</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;<span class="comment">// 否则后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断flag 的值</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123; <span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">System.out.printf(<span class="string">"准备插入的英雄的编号 %d 已经存在了, 不能加入\n"</span>, heroNode.no);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 插入到链表中, temp的后面</span></span><br><span class="line"><span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">heroNode.next = temp.next;</span><br><span class="line">temp.next.pre = heroNode;</span><br><span class="line">&#125;</span><br><span class="line">heroNode.pre = temp;</span><br><span class="line">temp.next = heroNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">HeroNode2 temp = head.next;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(temp);</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HeroNode2节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String nickname;</span><br><span class="line"><span class="keyword">public</span> HeroNode2 next; <span class="comment">// 指向下一个节点</span></span><br><span class="line"><span class="keyword">public</span> HeroNode2 pre; <span class="comment">// 指向前一个节点</span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了显示方法，我们重新toString</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode2 [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span> + nickname + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解 ThreadPoolExecutor 的参数含义及源码执行流程？</title>
      <link href="/2020/03/20/ThreadPoolExecutor-%E7%9A%84%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89%E5%8F%8A%E6%BA%90%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/03/20/ThreadPoolExecutor-%E7%9A%84%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89%E5%8F%8A%E6%BA%90%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="第04讲：详解-ThreadPoolExecutor的参数含义及源码执行流程？"><a href="#第04讲：详解-ThreadPoolExecutor的参数含义及源码执行流程？" class="headerlink" title="第04讲：详解 ThreadPoolExecutor的参数含义及源码执行流程？"></a>第04讲：详解 ThreadPoolExecutor的参数含义及源码执行流程？</h2><p>线程池是为了避免线程频繁的创建和销毁带来的性能消耗，而建立的一种池化技术，它是把已创建的线程放入“池”中，当有任务来临时就可以重用已有的线程，无需等待创建的过程，这样就可以有效提高程序的响应速度。但如果要说线程池的话一定离不开ThreadPoolExecutor，在阿里巴巴的《Java 开发手册》中是这样规定线程池的：<br>线程池不允许使用Executors 去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>说明：Executors 返回的线程池对象的弊端如下：<br>1）FixedThreadPool和 SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。<br>2）Cached ThreadPool 和ScheduledThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。<br>其实当我们去看Executors的源码会发现，Executors.newFixedThreadPool0、<br>Executors.newSingle ThreadExecutor）和Executors.newCachedThreadPool0等方法的底层都是通过ThreadPoolExecutor 实现的，所以本课时我们就重点来了解一下ThreadPoolExecutor的相关知识，比如它有哪些核心的参数？它是如何工作的？</p><h3 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h3><p>ThreadPoolExecutor的核心参数指的是它在构建时需要传递的参数，其构造方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        <span class="comment">// maximumPoolSize 必须大于 0，且必须大于 corePoolSize</span></span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span>?<span class="keyword">null</span>:AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第1个参数：<strong>corePoolSize</strong> 表示线程池的常驻核心线程数。如果设置为0，则表示在没有任何任务时，销毁线程池；如果大于0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程（创建和销毁的原因会在本课时的下半部分讲到）；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值。</p><p>第2个参数：<strong>maximumPoolSize</strong>表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于0，也必须大于等于corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到。</p><p>第3个参数：<strong>keepAliveTime</strong>表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于corePoolSize为止，如果maximumPoolSize等于corePoolSize，那么线程池在空闲的时候也不会销毁任何线程。</p><p>第4个参数：<strong>unit</strong> 表示存活时间的单位，它是配合keepAliveTime参数共同使用的。</p><p>第5个参数：<strong>workQueue</strong>表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行。</p><p>第6个参数：<strong>threadFactory</strong>表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Executors.defaultThreadFactory() 为默认的线程创建工厂 </span></span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认的线程创建工厂，需要实现 ThreadFactory 接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">    </span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">        Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">            poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">"-thread-"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon()) </span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>); <span class="comment">// 创建一个非守护线程</span></span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY); <span class="comment">// 线程优先级设置为默认值</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以自定义一个线程工厂，通过实现<strong>ThreadFactory</strong> 接口来完成，这样就可以自定义线程的名称或线程执行的优先级了。<br>第7个参数：<strong>RejectedExecutionHandler</strong> 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。<br>线程池的工作流程要从它的执行方法<strong>execute()</strong>说起，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前工作的线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 创建新的线程执行此任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查线程池是否处于运行状态，如果是则把任务添加到队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再出检查线程池是否处于运行状态，防止在第一次校验通过后线程池关闭</span></span><br><span class="line">        <span class="comment">// 如果是非运行状态，则将刚加入队列的任务移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池的线程数为 0 时（当 corePoolSize 设置为 0 时会发生）    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 新建线程执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 核心线程都在忙且队列都已爆满，尝试新启动一个线程执行失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) </span><br><span class="line">        <span class="comment">// 执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<strong>addWorker(Runnable firstTask，boolean core)</strong>方法的参数说明如下：</p><ul><li><strong>firstTask</strong>，线程应首先运行的任务，如果没有则可以设置为null；</li><li><strong>core</strong>，判断是否可以创建线程的阀值（最大值），如果等于true则表示使用corePoolSize作为阀值，false 则表示使用maximumPoolSize作为阀值。</li></ul><p><strong>考点分析</strong><br>本课时的这道面试题考察的是你对于线程池和ThreadPoolExecutor的掌握程度，也属于Java的基础知识，几乎所有的面试都会被问到，其中线程池任务执行的主要流程，可以参考以下流程图：</p><p><img data-src="1.png" alt="1.png"></p><p>与ThreadPoolExecutor 相关的面试题还有以下几个：</p><ul><li>ThreadPoolExecutor的执行方法有几种？它们有什么区别？</li><li>什么是线程的拒绝策略？</li><li>拒绝策略的分类有哪些？</li><li>如何自定义拒绝策略？</li><li>ThreadPoolExecutor 能不能实现扩展？如何实现扩展？</li></ul><h3 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h3><h4 id="execute（）VS-submit（）"><a href="#execute（）VS-submit（）" class="headerlink" title="execute（）VS submit（）"></a>execute（）VS submit（）</h4><p>execute(）和submit(）都是用来执行线程池任务的，它们最主要的区别是，submit）方法可以接收线程池执行的返回值，而 execute0不能接收返回值。<br>来看两个方法的且体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10L</span>,                                                    TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">20</span>));</span><br><span class="line"><span class="comment">// execute 使用</span></span><br><span class="line">executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, execute."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// submit 使用</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, submit."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><p>Hello，submit.</p><p>Hello，execute.</p><p>Success</p><p>从以上结果可以看出submit()方法可以配合Futrue来接收线程执行的返回值。它们的另一个区别是<br>execute()方法属于Executor 接口的方法，而submit()方法则是属于ExecutorService接口的方法，它们的继承关系如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><h4 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h4><p>当线程池中的任务队列已经被存满，再有任务添加时会先判断当前线程池中的线程数是否大于等于线程池的最大值，如果是，则会触发线程池的拒绝策略。</p><p>Java自带的拒绝策略有4种：</p><ul><li>AbortPolicy，终止策略，线程池会抛出异常并终止执行，它是默认的拒绝策略；</li><li>CallerRunsPolicy，把任务交给当前线程来执行；</li><li>DiscardPolicy，忽略此任务（最新的任务）；</li><li>DiscardOldestPolicy，忽略最早的任务（最先加入队列的任务）。</li></ul><p>例如，我们来演示一个AbortPolicy的拒绝策略，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>,                                                    TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),                                          <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()); <span class="comment">// 添加 AbortPolicy 拒绝策略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果：<br>pool-1-thread-1<br>pool-1-thread-1<br>pool-1-thread-1<br>pool-1-thread-3<br>pool-1-thread-2<br>Exception in thread”main”java.util.concurrent.RejectedExecutionException:Task com.lagou.interview.ThreadPoolExample$$Lambda$1/1096979270@448139f0 rejected from java.util.concurrent.ThreadPoolExecutor@7cca494b[Running，pool size=3，active threads=<br>3，queued tasks=2，completed tasks=0]</p><p>at<br>java. util. concurrent. ThreadPoolExecutor$AbortPolicy. rejectedExecution(ThreadPoolExecutorj ava:2063)<br>at java. util. concurrent. ThreadPoolExecutor. reject(ThreadPoolExecutor java:830)<br>at java. util. concurrent. ThreadPoolExecutor. execute(ThreadPoolExecutor, java:1379)<br>at com. lagou. interview. ThreadPoolExample. rejected(ThreadPoolExample. java:35)<br>at com. lagou. interview. ThreadPoolExample. main(ThreadPoolExample, java:26)</p><p>可以看出当第6个任务来的时候，线程池则执行了AbortPolicy 拒绝策略，抛出了异常。因为队列最多存储2个任务，最大可以创建3个线程来执行任务（2+3=5），所以当第6个任务来的时候，此线程池就“忙”不过来了。</p><h4 id="自定义拒绝策略"><a href="#自定义拒绝策略" class="headerlink" title="自定义拒绝策略"></a>自定义拒绝策略</h4><p>自定义拒绝策略只需要新建一个RejectedExecutionHandler对象，然后重写它的<br>rejectedExecution0方法即可，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>,                                              TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">                   <span class="keyword">new</span> RejectedExecutionHandler() &#123;  <span class="comment">// 添加自定义拒绝策略</span></span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 业务处理方法</span></span><br><span class="line">                     System.out.println(<span class="string">"执行自定义拒绝策略"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行的结果如下：</p><p>执行自定义拒绝策略<br>pool-1-thread-2</p><p>pool-1-thread-3</p><p>pool-1-thread-1</p><p>pool-1-thread-1</p><p>pool-1-thread-2<br>可以看出线程池执行了自定义的拒绝策略，我们可以在rejectedExecution中添加自己业务处理的代码。</p><h4 id="ThreadPoolExecutor-扩展"><a href="#ThreadPoolExecutor-扩展" class="headerlink" title="ThreadPoolExecutor 扩展"></a>ThreadPoolExecutor 扩展</h4><p>ThreadPoolExecutor 的扩展主要是通过重写它的beforeExecute）和afterExecute0方法实现的，我们可以在扩展方法中添加日志或者实现数据统计，比如统计线程的执行时间，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExtend</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span>&#123;</span><br><span class="line">      <span class="comment">// 线程池扩展调用</span></span><br><span class="line">        MyThreadPoolExecutor executor = <span class="keyword">new</span> MyThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">                     TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                Thread.currentThread().getName();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池扩展</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存线程执行开始时间</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; localTime = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 开始执行之前</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> t 线程</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">            Long sTime = System.nanoTime(); <span class="comment">// 开始时间 (单位：纳秒)</span></span><br><span class="line">            localTime.set(sTime);</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s | before | time=%s"</span>,</span><br><span class="line">                    t.getName(), sTime));</span><br><span class="line">            <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行完成之后</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> t 抛出的异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">            Long eTime = System.nanoTime(); <span class="comment">// 结束时间 (单位：纳秒)</span></span><br><span class="line">            Long totalTime = eTime - localTime.get(); <span class="comment">// 执行总时间</span></span><br><span class="line">            System.out.println(String.format(<span class="string">"%s | after | time=%s | 耗时：%s 毫秒"</span>,                          Thread.currentThread().getName(), eTime, (totalTime / <span class="number">1000000.0</span>)));</span><br><span class="line">            <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果如下所示：</p><p>pool-1-thread-1|before l time=4570298843700</p><p>pool-1-thread-2|before ltime=4570298840000</p><p>pool-1-thread-1|afterl time=4570327059500|耗时：28.2158毫秒</p><p>pool-1-thread-2l afterltime=4570327138100|耗时：28.2981毫秒</p><p>pool-1-thread-1|before ltime=4570328467800</p><p>pool-1-thread-1| after| time=4570328636800|耗时：0.169毫秒</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>最后我们总结一下：线程池的使用必须要通过 ThreadPoolExecutor 的方式来创建，这样才可以更加明确线程池的运行规则，规避资源耗尽的风险。同时，也介绍了ThreadPoolExecutor的七大核心参数，包括核心线程数和最大线程数之间的区别，当线程池的任务队列没有可用空间且线程池的线程数量已经达到了最大线程数时，则会执行拒绝策略，Java自动的拒绝策略有4种，用户也可以通过重写rejectedExecution() 来自定义拒绝策略，我们还可以通过重写beforeExecute0和afterExecute0来实现ThreadPoolExecutor的扩展功能。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】关联映射</title>
      <link href="/2020/03/20/MyBatis%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/20/MyBatis%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="一对一映射"><a href="#一对一映射" class="headerlink" title="一对一映射"></a>一对一映射</h2><p>在某网络购物系统中，一个用户只能拥有一个购物车，用户与购物车的关系可以设计为一对一关系</p><h3 id="数据库表结构（唯一外键关联）"><a href="#数据库表结构（唯一外键关联）" class="headerlink" title="数据库表结构（唯一外键关联）"></a>数据库表结构（唯一外键关联）</h3><p><img data-src="1.png" alt="1.png"></p><h3 id="创建两个实体类和映射接口"><a href="#创建两个实体类和映射接口" class="headerlink" title="创建两个实体类和映射接口"></a>创建两个实体类和映射接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> ShoppingCart shoppingCart;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> user_id;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现根据用户id查询出所有用户信息，包括该用户的购物车信息"><a href="#实现根据用户id查询出所有用户信息，包括该用户的购物车信息" class="headerlink" title="实现根据用户id查询出所有用户信息，包括该用户的购物车信息"></a>实现根据用户id查询出所有用户信息，包括该用户的购物车信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserAndShoppingCartById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyBatis中处理一对一关联关系"><a href="#MyBatis中处理一对一关联关系" class="headerlink" title="MyBatis中处理一对一关联关系"></a>MyBatis中处理一对一关联关系</h3><h4 id="方式一：使用自动映射处理一对一关系，也就是通过别名自动将值匹配到对应的字段上"><a href="#方式一：使用自动映射处理一对一关系，也就是通过别名自动将值匹配到对应的字段上" class="headerlink" title="方式一：使用自动映射处理一对一关系，也就是通过别名自动将值匹配到对应的字段上"></a>方式一：使用自动映射处理一对一关系，也就是通过别名自动将值匹配到对应的字段上</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndShoppingCartById"</span> <span class="attr">resultType</span>=<span class="string">"top.hiasenna.entity.User"</span>&gt;</span></span><br><span class="line">select u.id,username,password,sc.cart_id "shoppingCart.id",price "shoppingCart.price"</span><br><span class="line">from user u </span><br><span class="line">left join shoppingcart sc on u.id=sc.user_id</span><br><span class="line">where u.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复杂的属性映射时，可以多层嵌套，比如将shopping_cart表中的cart_id字段映射到shoppingCart.id属性上</p><h4 id="方式二：在XML映射文件中配置结果映射"><a href="#方式二：在XML映射文件中配置结果映射" class="headerlink" title="方式二：在XML映射文件中配置结果映射"></a>方式二：在XML映射文件中配置结果映射</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"top.hiasenna.entity.User"</span> <span class="attr">id</span>=<span class="string">"userShoppingCartMap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"shoppingCart.id"</span> <span class="attr">column</span>=<span class="string">"cart_id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"shoppingCart.price"</span> <span class="attr">column</span>=<span class="string">"price"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndShoppingCartById2"</span> <span class="attr">resultMap</span>=<span class="string">"userShoppingCartMap"</span>&gt;</span></span><br><span class="line">select u.id, u.username, u.password,</span><br><span class="line">s.cart_id, s.price</span><br><span class="line">from user u</span><br><span class="line">left join shoppingcart s on u.id = s.user_id</span><br><span class="line">where u.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用这种方式同自动映射方式相似之处为，ShoppingCart中的属性配置部分使用了”shoppingCart.”前缀</p><h4 id="方式三：association元素用于和一个复杂的类型进行关联"><a href="#方式三：association元素用于和一个复杂的类型进行关联" class="headerlink" title="方式三：association元素用于和一个复杂的类型进行关联"></a>方式三：association元素用于和一个复杂的类型进行关联</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"top.hiasenna.entity.User"</span> <span class="attr">id</span>=<span class="string">"userShoppingCartMap2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"shoppingCart"</span> <span class="attr">javaType</span>=<span class="string">"top.hiasenna.entity.ShoppingCart"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"cart_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"price"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndShoppingCartById3"</span> <span class="attr">resultMap</span>=<span class="string">"userShoppingCartMap2"</span>&gt;</span></span><br><span class="line">select u.id,u.username, u.password,s.cart_id, s.price</span><br><span class="line">from user u</span><br><span class="line">left join</span><br><span class="line">shoppingcart s on u.id = s.user_id</span><br><span class="line">where u.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>association元素包含以下属性</p><ul><li>property：对应实体类中的属性名，必填项</li><li>javaType：属性对应的java类型，可选项</li><li>resultMap：可以直接使用现有的resultMap，而不需要在这里配置，可选项</li></ul><h4 id="方式四：association元素的嵌套查询"><a href="#方式四：association元素的嵌套查询" class="headerlink" title="方式四：association元素的嵌套查询"></a>方式四：association元素的嵌套查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"top.hiasenna.entity.User"</span> <span class="attr">id</span>=<span class="string">"userShoppingCartMap3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"shoppingCart"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">column</span>=<span class="string">"&#123;user_id=id&#125;"</span> <span class="attr">select</span>=<span class="string">"top.hiasenna.mapper.ShoppingCartMapper.findShoppingCartById"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>association元素的嵌套查询常用的属性如下</p><ul><li>select：另一个查询映射的statement id，MyBatis会额外执行这个查询获取嵌套对象</li><li>column：列名，将主查询中列的结果作为嵌套查询的参数，如column=“{prop1=col1,prop2=col2}”，其中prop1和prop2将作为嵌套查询的参数</li><li>fetchType：数据加载方式，可选值为lazy和eager，分别为延迟加载和积极加载，会覆盖全局的lazyLoadingEnable配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndShoppingCartById4"</span> <span class="attr">resultMap</span>=<span class="string">"userShoppingCartMap3"</span>&gt;</span></span><br><span class="line">select id,</span><br><span class="line">username, password</span><br><span class="line">from user </span><br><span class="line">where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>此处查询语句只包含user表，购物车信息需要在ShoppingCartMapper.xml中配置findShoppingCartById方法进行查询</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"top.hiasenna.entity.ShoppingCart"</span> <span class="attr">id</span>=<span class="string">"shoppingCartMap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"cart_id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"price"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findShoppingCartById"</span> <span class="attr">resultMap</span>=<span class="string">"shoppingCartMap"</span>&gt;</span></span><br><span class="line">select * from shoppingcart where user_id=#&#123;user_id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>嵌套查询会多执行SQL，当查询N条数据时，就会出现N+1次查询问题</p><p>为了解决N+1次查询问题，可以设置延迟加载策略，将association元素的fetchType属性设置为lazy</p><p>在MyBatis主配置文件中有两个延时加载相关settings设置</p><table><thead><tr><th align="center"><strong>设置项</strong></th><th align="center"><strong>描述</strong></th><th align="center"><strong>有效值</strong></th><th align="center"><strong>默认值</strong></th></tr></thead><tbody><tr><td align="center"><strong>lazyLoadingEnabled</strong></td><td align="center"><strong>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 可通过设置fetchType属性来覆盖该项的开关状态</strong></td><td align="center"><strong>true |false</strong></td><td align="center"><strong>false</strong></td></tr><tr><td align="center"><strong>aggressiveLazyLoading</strong></td><td align="center"><strong>当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载</strong></td><td align="center"><strong>true |false</strong></td><td align="center"><strong>false</strong></td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置为延迟加载的对象，默认情况下，当调用该对象的equals、hashCode、toString、clone方法时，就会加载该对象的全部数据</p><h4 id="对比四种方式"><a href="#对比四种方式" class="headerlink" title="对比四种方式"></a>对比四种方式</h4><ul><li>前面的三种方式都属于“关联的嵌套结果映射“,即通过一次SQL查询根据表或指定的属性映射到不同的对象中</li><li>最后一种方式属于“关联的嵌套查询”，利用简单的SQL语句，通过多次查询得到想要的结果，可实现延迟加载效果</li></ul><h2 id="一对多关联映射"><a href="#一对多关联映射" class="headerlink" title="一对多关联映射"></a>一对多关联映射</h2><h3 id="MyBatis中处理一对多关联关系"><a href="#MyBatis中处理一对多关联关系" class="headerlink" title="MyBatis中处理一对多关联关系"></a>MyBatis中处理一对多关联关系</h3><h4 id="方式一：与association类似，集合的嵌套结果映射就是指通过一次SQL查询得到所有的结果"><a href="#方式一：与association类似，集合的嵌套结果映射就是指通过一次SQL查询得到所有的结果" class="headerlink" title="方式一：与association类似，集合的嵌套结果映射就是指通过一次SQL查询得到所有的结果"></a>方式一：与association类似，集合的嵌套结果映射就是指通过一次SQL查询得到所有的结果</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.User"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong>由于此映射会频繁用到，可以将其单独配置，后面可以直接通过id引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.User"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"userAndOrderListMap"</span> <span class="attr">extends</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderList"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">ofType</span>=<span class="string">"com.mybatis.entity.Order"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"order_id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"price"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>resultMap元素中的extends属性可以实现结果映射的继承</li><li>collection的ofType属性指定集合中元素的类型，必选项</li></ul><p>查询映射配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndOrderListById"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">resultMap</span>=<span class="string">"userAndOrderListMap"</span>&gt;</span></span><br><span class="line">    select u.id, u.user_name, u.password,</span><br><span class="line">    o.order_id, o.price</span><br><span class="line">    from user u</span><br><span class="line">    left join orders o on u.id = o.user_id</span><br><span class="line">    where u.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="方式二：集合的嵌套查询同样会执行额外的SQL查询"><a href="#方式二：集合的嵌套查询同样会执行额外的SQL查询" class="headerlink" title="方式二：集合的嵌套查询同样会执行额外的SQL查询"></a>方式二：集合的嵌套查询同样会执行额外的SQL查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.User"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"userAndOrderListMap"</span> <span class="attr">extends</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderList"</span> <span class="attr">column</span>=<span class="string">"&#123;uid=id&#125;"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ofType</span>=<span class="string">"com.mybatis.entity.Order"</span>       <span class="attr">select</span>=<span class="string">"com.mybatis.mapper.OrderMapper.findOrdersByUserId"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndOrderListById"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">resultMap</span>=<span class="string">"userAndOrderListMap"</span>&gt;</span></span><br><span class="line">    select * from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>OrderMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.Order"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"orderMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"order_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"price"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOrdersByUserId"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">resultMap</span>=<span class="string">"orderMap"</span>&gt;</span></span><br><span class="line">    select * from orders where user_id = #&#123;uid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="对比两种方式"><a href="#对比两种方式" class="headerlink" title="对比两种方式"></a>对比两种方式</h4><ul><li>第一种方式属于“关联的嵌套结果映射“,即通过一次SQL查询根据表或指定的属性映射到不同的对象中</li><li>第二种方式属于“关联的嵌套查询”，利用简单的SQL语句，通过多次查询得到想要的结果，也可以实现延迟加载效果</li></ul><h2 id="鉴别器映射"><a href="#鉴别器映射" class="headerlink" title="鉴别器映射"></a>鉴别器映射</h2><ul><li>有时一个单独的数据库查询会返回很多种不同数据类型的结果集。discriminator鉴别器元素可以用来处理这种情况</li><li>以Hibernate中继承映射为例</li></ul><p><img data-src="2.png" alt="2.png"></p><p>数据库表结构</p><p><img data-src="3.png" alt="3.png"></p><h4 id="创建实体类（省略）、映射接口和映射文件"><a href="#创建实体类（省略）、映射接口和映射文件" class="headerlink" title="创建实体类（省略）、映射接口和映射文件"></a>创建实体类（省略）、映射接口和映射文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">findEmployeeById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.Employee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">"EmployeeMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用resultMap的extends属性来映射两个子类的属性"><a href="#使用resultMap的extends属性来映射两个子类的属性" class="headerlink" title="使用resultMap的extends属性来映射两个子类的属性"></a>使用resultMap的extends属性来映射两个子类的属性</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.HourlyEmployee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"HourlyMap"</span> <span class="attr">extends</span>=<span class="string">"EmployeeMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"rate"</span> <span class="attr">column</span>=<span class="string">"rate"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.SalariedEmployee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"SalaryMap"</span> <span class="attr">extends</span>=<span class="string">"EmployeeMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"salary"</span> <span class="attr">column</span>=<span class="string">"salary"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用discriminator元素映射employee-type字段"><a href="#使用discriminator元素映射employee-type字段" class="headerlink" title="使用discriminator元素映射employee_type字段"></a>使用discriminator元素映射employee_type字段</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.Employee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">"selectMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">column</span>=<span class="string">"employee_type"</span>   </span></span><br><span class="line"><span class="tag">        <span class="attr">javaType</span>=<span class="string">"String"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"HE"</span> <span class="attr">resultMap</span>=<span class="string">"HourlyMap"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"SE"</span> <span class="attr">resultMap</span>=<span class="string">"SalaryMap"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>discriminator元素常用的两个属性如下：</p><ul><li>column：该属性用于设置需要进行鉴别比较值的列</li><li>javaType：该属性用于指定列的类型</li></ul><p>discriminator元素可以有1个或者多个case子元素，case元素包含三个属性</p><ul><li>value：该值用来匹配column指定字段的值</li><li>resultMap：当value值和column的值匹配时的结果映射，优先级高于resultType</li><li>resultType：当value值和column的值匹配时的结果类型</li></ul>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-单链表</title>
      <link href="/2020/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="链表-Linked-List-介绍"><a href="#链表-Linked-List-介绍" class="headerlink" title="链表(Linked List)介绍"></a>链表(Linked List)介绍</h2><p>链表是有序的列表，但是它在内存中是存储如下</p><p><img data-src="1.png" alt="1.png"></p><ol><li>链表是以节点的方式来存储,</li><li>每个节点包含 data 域， next 域：指向下一个节点</li><li>如图：发现<strong>链表的各个节点不一定是连续存储</strong></li><li>链表分 <strong>带头节点的链表和 没有头节点的链表</strong>，根据实际的需求来确定</li></ol><h2 id="单链表的应用实例"><a href="#单链表的应用实例" class="headerlink" title="单链表的应用实例"></a>单链表的应用实例</h2><p>使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建要给链表</span></span><br><span class="line">SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入</span></span><br><span class="line"><span class="comment">// singleLinkedList.add(hero1);</span></span><br><span class="line"><span class="comment">// singleLinkedList.add(hero4);</span></span><br><span class="line"><span class="comment">// singleLinkedList.add(hero2);</span></span><br><span class="line"><span class="comment">// singleLinkedList.add(hero3);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入按照编号的顺序</span></span><br><span class="line">singleLinkedList.addByOrder(hero1);</span><br><span class="line">singleLinkedList.addByOrder(hero4);</span><br><span class="line">singleLinkedList.addByOrder(hero2);</span><br><span class="line">singleLinkedList.addByOrder(hero3);</span><br><span class="line"></span><br><span class="line">singleLinkedList.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试修改节点的代码</span></span><br><span class="line"><span class="comment">// HeroNode newHeroNode = new HeroNode(2, "小卢", "玉麒麟~~");</span></span><br><span class="line"><span class="comment">// singleLinkedList.update(newHeroNode);</span></span><br><span class="line"><span class="comment">// 显示一把</span></span><br><span class="line"><span class="comment">// singleLinkedList.list();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个节点</span></span><br><span class="line">singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line">singleLinkedList.del(<span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">"删除后的链表情况~~"</span>);</span><br><span class="line">singleLinkedList.list();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义SingleLinkedList 管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回头节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加节点到单向链表</span></span><br><span class="line"><span class="comment">// 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">// 1. 找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">// 2. 将最后这个节点的next 指向 新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="comment">// 找到链表的最后</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有找到最后, 将将temp后移</span></span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line"><span class="comment">// 将最后这个节点的next 指向 新的节点</span></span><br><span class="line">temp.next = heroNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">// (如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line"><span class="comment">// 因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span></span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">// 位置找到了</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">flag = <span class="keyword">true</span>;<span class="comment">// 说明编号存在S</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;<span class="comment">// 否则后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断flag 的值</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123; <span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">System.out.printf(<span class="string">"准备插入的英雄的编号 %d 已经存在了, 不能加入\n"</span>, heroNode.no);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 插入到链表中, temp的后面</span></span><br><span class="line">heroNode.next = temp.next;</span><br><span class="line">temp.next = heroNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改节点的信息，根据no编号来修改，即no编号不能改</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. 根据 newHeroNode 的 no 来修改即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到需要修改的节点, 根据no编号</span></span><br><span class="line"><span class="comment">// 定义一个辅助变量</span></span><br><span class="line">HeroNode temp = head.next;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 表示是否找到该节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">// 遍历完链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line"><span class="comment">// 找到节点了</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据flag 判断是否找到要修改的节点</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="comment">// 更新信息</span></span><br><span class="line">temp.name = newHeroNode.name;</span><br><span class="line">temp.nickname = newHeroNode.nickname;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line"><span class="comment">// 2. 说明我们在比较时，是temp.next.no 和 需要删除的节点的no比较</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 已经到链表的最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line"><span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">temp.next = temp.next.next;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>, no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示链表[遍历]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">HeroNode temp = head.next;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 判断是否到链表最后</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出节点的信息</span></span><br><span class="line">System.out.println(temp);</span><br><span class="line"><span class="comment">// 将temp后移， 一定小心</span></span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HeroNode节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String nickname;</span><br><span class="line"><span class="keyword">public</span> HeroNode next; <span class="comment">// 指向下一个节点</span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了显示方法，我们重新toString</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span> + nickname + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="1-获取到单链表的节点的个数-如果是带头结点的链表，需求不统计头节点"><a href="#1-获取到单链表的节点的个数-如果是带头结点的链表，需求不统计头节点" class="headerlink" title="1.获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)"></a>1.获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 空链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">HeroNode node = head.next;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">length++;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-查找单链表中的倒数第k个结点-【新浪面试题】"><a href="#2-查找单链表中的倒数第k个结点-【新浪面试题】" class="headerlink" title="2.查找单链表中的倒数第k个结点 【新浪面试题】"></a>2.查找单链表中的倒数第k个结点 【新浪面试题】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 1. 编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">// 2. index 表示是倒数第index个节点</span></span><br><span class="line"><span class="comment">// 3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span></span><br><span class="line"><span class="comment">// 4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span></span><br><span class="line"><span class="comment">// 5. 如果找到了，则返回该节点，否则返回nulll</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 空链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size = getLength(head);</span><br><span class="line"><span class="comment">// 第二次遍历 size-index 位置，就是我们倒数的第K个节点</span></span><br><span class="line"><span class="comment">// 先做一个index的校验</span></span><br><span class="line"><span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-将单链表反转"><a href="#3-将单链表反转" class="headerlink" title="3. 将单链表反转"></a>3. 将单链表反转</h4><p><img data-src="3.png" alt="3.png"></p><h5 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line">HeroNode next = <span class="keyword">null</span>;<span class="comment">// 指向当前节点[cur]的下一个节点</span></span><br><span class="line">HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">// 遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span></span><br><span class="line"><span class="comment">// 动脑筋</span></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">next = cur.next;<span class="comment">// 先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">cur.next = reverseHead.next;<span class="comment">// 将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">reverseHead.next = cur; <span class="comment">// 将cur 连接到新的链表上</span></span><br><span class="line">cur = next;<span class="comment">// 让cur后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将head.next 指向 reverseHead.next , 实现单链表的反转</span></span><br><span class="line">head.next = reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式2：从尾到头打印单链表-Stack-栈"><a href="#方式2：从尾到头打印单链表-Stack-栈" class="headerlink" title="方式2：从尾到头打印单链表[Stack 栈]"></a>方式2：从尾到头打印单链表[Stack 栈]</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//空链表，不能打印</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建要给一个栈，将各个节点压入栈</span></span><br><span class="line">Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;HeroNode&gt;();</span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line"><span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">stack.push(cur);</span><br><span class="line">cur=cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"><a href="#4-将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。" class="headerlink" title="4.将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"></a>4.将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 类似归并排序中的合并过程</span></span><br><span class="line">        <span class="comment">//虚拟头结点</span></span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任一为空，直接连接另一条链表</span></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur.next = l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-环形队列</title>
      <link href="/2020/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/"/>
      <url>/2020/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h2><h3 id="分析示意图"><a href="#分析示意图" class="headerlink" title="分析示意图"></a>分析示意图</h3><p><img data-src="1.png" alt="1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试一把</span></span><br><span class="line">System.out.println(<span class="string">"测试数组模拟环形队列的案例~~~"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形队列</span></span><br><span class="line">CircleArray queue = <span class="keyword">new</span> CircleArray(<span class="number">4</span>); <span class="comment">// 说明设置4, 其队列的有效数据最大是3</span></span><br><span class="line"><span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">// 接收用户输入</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line"><span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 输出一个菜单</span></span><br><span class="line"><span class="keyword">while</span> (loop) &#123;</span><br><span class="line">System.out.println(<span class="string">"s(show): 显示队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"e(exit): 退出程序"</span>);</span><br><span class="line">System.out.println(<span class="string">"a(add): 添加数据到队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"g(get): 从队列取出数据"</span>);</span><br><span class="line">System.out.println(<span class="string">"h(head): 查看队列头的数据"</span>);</span><br><span class="line">key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">// 接收一个字符</span></span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">queue.showQueue();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">System.out.println(<span class="string">"输出一个数"</span>);</span><br><span class="line"><span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">queue.addQueue(value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'g'</span>: <span class="comment">// 取出数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">// 查看队列头的数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>: <span class="comment">// 退出</span></span><br><span class="line">scanner.close();</span><br><span class="line">loop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line"><span class="comment">// front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素</span></span><br><span class="line"><span class="comment">// front 的初始值 = 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line"><span class="comment">// rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span></span><br><span class="line"><span class="comment">// rear 的初始值 = 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"><span class="comment">// 创建队列的构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">maxSize = maxsize;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">front = <span class="number">0</span>;</span><br><span class="line">rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据到队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列已满，不能加入数据"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[rear] = n;</span><br><span class="line"><span class="comment">// 将 rear 后移, 这里必须考虑取模</span></span><br><span class="line">rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列的数据，出队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 通过抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，不能取数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里需要分析出 front是指向队列的第一个元素</span></span><br><span class="line"><span class="comment">// 1. 先把 front 对应的值保留到一个临时变量</span></span><br><span class="line"><span class="comment">// 2. 将 front 后移, 考虑取模</span></span><br><span class="line"><span class="comment">// 3. 将临时保存的变量返回</span></span><br><span class="line"><span class="keyword">int</span> value = arr[front];</span><br><span class="line">front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size(); i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出当前队列有效数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// rear = 2</span></span><br><span class="line"><span class="comment">// front = 1</span></span><br><span class="line"><span class="comment">// maxSize = 3</span></span><br><span class="line"><span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程的状态有哪些？它是如何工作的？</title>
      <link href="/2020/03/19/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
      <url>/2020/03/19/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>线程（Thread）是并发编程的基础，也是程序执行的最小单元，它依托进程而存在。一个进程中可以包含多个线程，多线程可以共享一块内存空间和一组系统资源，因此线程之间的切换更加节省资源、<br>更加轻量化，也因此被称为轻量级的进程。</p><p>当然，线程也是面试中常被问到的一个知识点，是程序员必备的基础技能，使用它可以有效地提高程序的整体运行速度。</p><p>本课时的面试问题是，线程的状态有哪些？它是如何工作的？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>线程的状态在JDK1.5之后以枚举的方式被定义在Thread的源码中，它总共包含以下6个状态：</p><ul><li>NEW，新建状态，线程被创建出来，但尚未启动时的线程状态；</li><li>RUNNABLE，就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配CPU资源；</li><li>BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行synchronized代码块或者使用synchronized标记的方法；</li><li>WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了Object.wait0方法，那它就在等待另一个线程调用Object.notify0或<br>Object.notifyAll0方法；</li><li>TIMED WAITING，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法Object.wait（long timeout）和Thread.join（long timeout）等这些方法时，它才会进入此状态；</li><li>TERMINATED，终止状态，表示线程已经执行完成。</li></ul><p>线程状态的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建状态，线程被创建出来，但尚未启动时的线程状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 就绪状态，表示可以运行的线程状态，但它在排队等待来自操作系统的 CPU 资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞等待锁的线程状态，表示正在处于阻塞状态的线程</span></span><br><span class="line"><span class="comment">     * 正在等待监视器锁，比如等待执行 synchronized 代码块或者</span></span><br><span class="line"><span class="comment">     * 使用 synchronized 标记的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作。</span></span><br><span class="line"><span class="comment">     * 例如，一个线程调用了 Object.wait() 它在等待另一个线程调用</span></span><br><span class="line"><span class="comment"> * Object.notify() 或 Object.notifyAll()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计时等待状态，和等待状态 (WAITING) 类似，只是多了超时时间，比如</span></span><br><span class="line"><span class="comment">     * 调用了有超时时间设置的方法 Object.wait(long timeout) 和 </span></span><br><span class="line"><span class="comment">     * Thread.join(long timeout) 就会进入此状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 终止状态，表示线程已经执行完成</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>线程的工作模式是，首先先要创建线程并指定线程需要执行的业务方法，然后再调用线程的 start()方法，此时线程就从NEW（新建）状态变成了RUNNABLE（就绪）状态，此时线程会判断要执行的方法中有没有synchronized同步代码块，如果有并且其他线程也在使用此锁，那么线程就会变为<br>BLOCKED（阻塞等待）状态，当其他线程使用完此锁之后，线程会继续执行剩余的方法。</p><p>当遇到Object.wait()或Thread.join()方法时，线程会变为WAITING（等待状态）状态，如果是带了超时时间的等待方法，那么线程会进入TIMED WAITING（计时等待）状态，当有其他线程执行了<br>notify()或notifyAll()方法之后，线程被唤醒继续执行剩余的业务方法，直到方法执行完成为止，此时整个线程的流程就执行完了，执行流程如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p><strong>考点分析</strong></p><p>线程一般会作为并发编程的起始问题，用于引出更多的关于并发编程的面试问题。当然对于线程的掌握程度也决定了你对并发编程的掌握程度，通常面试官还会问：</p><ul><li><p>BLOCKED（阻塞等待）和WAITING（等待）有什么区别？</p></li><li><p>start()方法和run()方法有什么区别？</p></li><li><p>线程的优先级有什么用？该如何设置？</p></li><li><p>线程的常用方法有哪些？</p><p>接下来我们一起来看这些问题的答案。</p></li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-BLOCKED和WAITING的区别"><a href="#1-BLOCKED和WAITING的区别" class="headerlink" title="1.BLOCKED和WAITING的区别"></a>1.BLOCKED和WAITING的区别</h3><p>虽然BLOCKED和WAITING都有等待的含义，但二者有着本质的区别，首先它们状态形成的调用方法不同，其次BLOCKED可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；而WAITING则是因为自身调用了Object.wait()或着是Thread.join()又或者是LockSupport.park()而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了Object.wait()而进入WAITING状态之后，则需要等待另一个线程执行<br>Object.notify()或Object.notifyAll()才能被唤醒。</p><h3 id="2-start-和run-的区别"><a href="#2-start-和run-的区别" class="headerlink" title="2.start()和run()的区别"></a>2.start()和run()的区别</h3><p>首先从Thread 源码来看，start()方法属于Thread 自身的方法，并且使用了synchronized来保证线程安全，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态验证，不等于 NEW 的状态会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    <span class="comment">// 通知线程组，此线程即将启动</span></span><br><span class="line">group.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">// 不处理任何异常，如果 start0 抛出异常，则它将被传递到调用堆栈上</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run()方法为Runnable的抽象方法，必须由调用类重写此方法，重写的run()方法其实就是此线程要执行的业务方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 忽略其他方法......</span></span><br><span class="line">  <span class="keyword">private</span> Runnable target;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">          target.run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从执行的效果来说，start()方法可以开启多线程，让线程从NEW状态转换成RUNNABLE状态，而<br>run()方法只是一个普通的方法。</p><p>其次，它们可调用的次数不同，start()方法不能被多次调用，否则会抛出<br>java.lang.llegalStateException；而 run()方法可以进行多次调用，因为它只是一个普通的方法而已。</p><h3 id="3-线程优先级"><a href="#3-线程优先级" class="headerlink" title="3.线程优先级"></a>3.线程优先级</h3><p>在Thread 源码中和线程优先级相关的属性有3个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程可以拥有的最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程可以拥有的最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>线程的优先级可以理解为线程抢占CPU时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。<br>在程序中我们可以通过Thread.setPriority()来设置优先级，setPriority()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="comment">// 先验证优先级的合理性</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优先级如果超过线程组的最高优先级，则把优先级设置为线程组的最高优先级</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-线程的常用方法"><a href="#4-线程的常用方法" class="headerlink" title="4.线程的常用方法"></a>4.线程的常用方法</h3><p>线程的常用方法有以下几个。</p><h4 id="（1）join-）"><a href="#（1）join-）" class="headerlink" title="（1）join(）"></a>（1）join(）</h4><p>在一个线程中调用other.join()，这时候当前线程会让出执行权给other线程，直到other 线程执行完或者过了超时时间之后再继续执行当前线程，join()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 超时时间不能小于 0</span></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等于 0 表示无限等待，直到线程执行完为之</span></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断子线程 (其他线程) 为活跃线程，则一直等待</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 循环判断</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出join()方法底层还是通过wait()方法来实现的。<br>例如，在未使用join()时，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程睡眠："</span> + i + <span class="string">"秒。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start(); <span class="comment">// 开启线程</span></span><br><span class="line">        <span class="comment">// 主线程执行</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">             System.out.println(<span class="string">"主线程睡眠："</span> + i + <span class="string">"秒。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：<br>主线程睡眠：1秒。<br>子线程睡眠：1秒。<br>主线程睡眠：2秒。<br>子线程睡眠：2秒。<br>主线程睡眠：3秒。<br>子线程睡眠：3秒。<br>子线程睡眠：4秒。<br>子线程睡眠：5秒。<br>从结果可以看出，在未使用join()时主子线程会交替执行。<br>然后我们再把join()方法加入到代码中，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程睡眠："</span> + i + <span class="string">"秒。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start(); <span class="comment">// 开启线程</span></span><br><span class="line">        thread.join(<span class="number">2000</span>); <span class="comment">// 等待子线程先执行 2 秒钟</span></span><br><span class="line">        <span class="comment">// 主线程执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"主线程睡眠："</span> + i + <span class="string">"秒。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：<br>子线程睡眠：1秒。<br>子线程睡眠：2秒。<br>主线程睡眠：1秒。/∥thread.join(2000)；等待2秒之后，主线程和子线程再交替执行子线程睡眠：3秒。<br>主线程睡眠：2秒。<br>子线程睡眠：4秒。<br>子线程睡眠：5秒。<br>主线程睡眠：3秒。<br>从执行结果可以看出，添加join()方法之后，主线程会先等子线程执行2秒之后才继续执行。</p><h4 id="（2）yield"><a href="#（2）yield" class="headerlink" title="（2）yield()"></a>（2）yield()</h4><p>看Thread的源码可以知道 yield()为本地方法，也就是说yield()是由C或C++实现的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>yield()方法表示给线程调度器一个当前线程愿意出让CPU使用权的暗示，但是线程调度器可能会忽略这个暗示。<br>比如我们执行这段包含了yield()方法的代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程："</span> +</span><br><span class="line">                        Thread.currentThread().getName() + <span class="string">" I："</span> + i);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(runnable, <span class="string">"T1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(runnable, <span class="string">"T2"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把这段代码执行多次之后会发现，每次执行的结果都不相同，这是因为yield()执行非常不稳定，线程调度器不一定会采纳 yield()出让CPU使用权的建议，从而导致了这样的结果。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-队列</title>
      <link href="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/"/>
      <url>/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="数组模拟队列思路"><a href="#数组模拟队列思路" class="headerlink" title="数组模拟队列思路"></a>数组模拟队列思路</h2><p><img data-src="1.png" alt="1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQArrayQueueDemoueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试一把</span></span><br><span class="line"><span class="comment">// 创建一个队列</span></span><br><span class="line">ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">// 接收用户输入</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line"><span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 输出一个菜单</span></span><br><span class="line"><span class="keyword">while</span> (loop) &#123;</span><br><span class="line">System.out.println(<span class="string">"s(show): 显示队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"e(exit): 退出程序"</span>);</span><br><span class="line">System.out.println(<span class="string">"a(add): 添加数据到队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"g(get): 从队列取出数据"</span>);</span><br><span class="line">System.out.println(<span class="string">"h(head): 查看队列头的数据"</span>);</span><br><span class="line">key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">// 接收一个字符</span></span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">queue.showQueue();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">System.out.println(<span class="string">"输出一个数"</span>);</span><br><span class="line"><span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">queue.addQueue(value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'g'</span>: <span class="comment">// 取出数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">// 查看队列头的数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>: <span class="comment">// 退出</span></span><br><span class="line">scanner.close();</span><br><span class="line">loop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front; <span class="comment">// 队列头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"><span class="comment">// 创建队列的构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSize = maxsize;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">front = -<span class="number">1</span>;<span class="comment">// 指向队列头部，分析出front是指向队列头的前一个位置.</span></span><br><span class="line">rear = -<span class="number">1</span>;<span class="comment">// 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据到队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列已满，不能加入数据"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">rear++;</span><br><span class="line">arr[rear] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列的数据，出队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 通过抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，不能取数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line">front++;</span><br><span class="line"><span class="keyword">return</span> arr[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议和三次握手四次挥手</title>
      <link href="/2020/03/18/TCPIP%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2020/03/18/TCPIP%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>在计算机网络的基本概念中，分层次的体系结构是最基本的。计算机网络体系结构的抽象概念较多，在学习时要多思考。这些概念对后面的学习很有帮助。</p><h3 id="网络协议是什么？"><a href="#网络协议是什么？" class="headerlink" title="网络协议是什么？"></a>网络协议是什么？</h3><p>在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p><h3 id="为什么要对网络协议分层？"><a href="#为什么要对网络协议分层？" class="headerlink" title="为什么要对网络协议分层？"></a>为什么要对网络协议分层？</h3><ul><li>简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。</li><li>灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。</li><li>易于实现和维护。</li><li>促进标准化工作。分开后，每层功能可以相对简单地被描述。</li></ul><p>网络协议分层的缺点： 功能可能出现在多个层里，产生了额外开销。</p><p>为了使不同体系结构的计算机网络都能互联，国际标准化组织 ISO 于1977年提出了一个试图使各种计算机在世界范围内互联成网的标准框架，即著名的开放系统互联基本参考模型 OSI/RM，简称为OSI。</p><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用，TCP/IP 体系结构则不同，但它现在却得到了非常广泛的应用。TCP/IP 是一个四层体系结构，它包含应用层，运输层，网际层和网络接口层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题），不过从实质上讲，TCP/IP 只有最上面的三层，因为最下面的网络接口层并没有什么具体内容，因此在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚，有时为了方便，也可把最底下两层称为网络接口层。</p><p>四层协议，五层协议和七层协议的关系如下：</p><ul><li>TCP/IP是一个四层的体系结构，主要包括：应用层、运输层、网际层和网络接口层。</li><li>五层协议的体系结构主要包括：应用层、运输层、网络层，数据链路层和物理层。</li><li>OSI七层协议模型主要包括是：应用层（Application）、表示层（Presentation）、会话层（Session）、运输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</li></ul><p><img data-src="1.png" alt="1.png"></p><p>注：五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p><h2 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p><p>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的<strong>数据传输服务</strong>。应用进程利用该服务传送应用层报文。</p><p>运输层主要使用一下两种协议</p><ol><li>传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。</li><li>用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li></ol><table><thead><tr><th align="center"></th><th align="center"><strong>UDP</strong></th><th align="center"><strong>TCP</strong></th></tr></thead><tbody><tr><td align="center">是否连接</td><td align="center">无连接</td><td align="center">面向连接</td></tr><tr><td align="center">是否可靠</td><td align="center">不可靠传输，不使用流量控制和拥塞控制</td><td align="center">可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="center">连接对象个数</td><td align="center">支持一对一，一对多，多对一和多对多交互通信</td><td align="center">只能是一对一通信</td></tr><tr><td align="center">传输方式</td><td align="center">面向报文</td><td align="center">面向字节流</td></tr><tr><td align="center">首部开销</td><td align="center">首部开销小，仅8字节</td><td align="center">首部最小20字节，最大60字节</td></tr><tr><td align="center">场景</td><td align="center">适用于实时应用（IP电话、视频会议、直播等）</td><td align="center">适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><p><strong>每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</strong></p><p>运行在<code>TCP协议</code>上的协议:</p><ul><li><code>HTTP（Hypertext Transfer Protocol，超文本传输协议)</code>，主要用于普通浏览。</li><li><code>HTTPS（HTTP over SSL，安全超文本传输协议）</code>,HTTP协议的安全版本。</li><li><code>FTP（File Transfer Protocol，文件传输协议）</code>，用于文件传输。</li><li><code>POP3（Post Office Protocol, version 3，邮局协议</code>），收邮件用。</li><li><code>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</code>，用来发送电子邮件。</li><li><code>TELNET（Teletype over the Network，网络电传</code>），通过一个终端（terminal）登陆到网络。</li><li><code>SSH（Secure Shell，用于替代安全性差的TELNET）</code>，用于加密安全登陆用。</li></ul><p>运行在<code>UDP协议</code>上的协议：</p><ul><li><code>BOOTP（Boot Protocol，启动协议）</code>，应用于无盘设备。</li><li><code>NTP（Network Time Protocol，网络时间协议）</code>，用于网络同步。</li><li><code>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）</code>，动态配置IP地址。</li></ul><p>运行在<code>TCP</code>和<code>UDP</code>协议上：</p><ul><li><code>DNS（Domain Name Service，域名服务）</code>，用于完成地址查找，邮件转发等工作。</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p><p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。</p><p>一般的web应用的通信传输流是这样的：</p><p><img data-src="2.jpg" alt="2.jpg"></p><p>发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><h3 id="TCP-IP-协议族-1"><a href="#TCP-IP-协议族-1" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h3><p>在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族。</p><p><img data-src="3.jpg" alt="3.jpg"></p><p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。因为该协定家族的两个核心协定：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。</p><p>划重点：</p><p><code>TCP（传输控制协议）和IP（网际协议）</code> 是最先定义的两个核心协议，所以才统称为<code>TCP/IP协议族</code></p><h2 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h2><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。</p><p><strong>通过三次握手建立一个链接，通过四次挥手来关闭一个连接</strong>。</p><p><strong>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据</strong>。</p><h3 id="TCP报文的头部结构"><a href="#TCP报文的头部结构" class="headerlink" title="TCP报文的头部结构"></a>TCP报文的头部结构</h3><p>在了解TCP连接之前先来了解一下TCP报文的头部结构。</p><p><img data-src="4.jpg" alt="4.jpg"></p><p>上图中有几个字段需要重点介绍下：</p><p>（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p><p>（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。</p><p>（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p><ul><li>ACK：确认序号有效。</li><li>FIN：释放一个连接。</li><li>PSH：接收方应该尽快将这个报文交给应用层。</li><li>RST：重置连接。</li><li>SYN：发起一个新连接。</li><li>URG：紧急指针（urgent pointer）有效。</li></ul><p>需要注意的是：</p><ul><li>不要将确认序号ack与标志位中的ACK搞混了。</li><li>确认方ack=发起方seq+1，两端配对。</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><code>三次握手的本质是确认通信双方收发数据的能力</code></p><p>首先，我让信使运输一份信件给对方，<strong>对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的</strong>。</p><p>于是他给我回信，<strong>我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以</strong>。</p><p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，<strong>他若收到了，他便清楚了他的发件能力和我的收件能力是可以的</strong>。</p><p>这，就是三次握手，这样说，你理解了吗？</p><p><img data-src="5.jpg" alt="5.jpg"></p><ul><li><code>第一次握手</code>：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。</li><li><code>第二次握手</code>：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</li><li><code>第三次握手</code>：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><code>四次挥手的目的是关闭一个连接</code></p><p><img data-src="6.jpg" alt="6.jpg"></p><p>比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p><ul><li><code>第一次挥手</code>：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</li><li><code>第二次挥手</code>：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</li><li><code>第三次挥手</code>：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。</li><li><code>第四次挥手</code>：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</li></ul><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="为什么TCP连接的时候是3次？2次不可以吗？"><a href="#为什么TCP连接的时候是3次？2次不可以吗？" class="headerlink" title="为什么TCP连接的时候是3次？2次不可以吗？"></a>为什么TCP连接的时候是3次？2次不可以吗？</h3><p>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p><p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p><h3 id="为什么TCP连接的时候是3次，关闭的时候却是4次？"><a href="#为什么TCP连接的时候是3次，关闭的时候却是4次？" class="headerlink" title="为什么TCP连接的时候是3次，关闭的时候却是4次？"></a>为什么TCP连接的时候是3次，关闭的时候却是4次？</h3><p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p><h3 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h3><p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h3 id="什么是HTTP，HTTP-与-HTTPS-的区别"><a href="#什么是HTTP，HTTP-与-HTTPS-的区别" class="headerlink" title="什么是HTTP，HTTP 与 HTTPS 的区别"></a>什么是HTTP，HTTP 与 HTTPS 的区别</h3><p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</p><table><thead><tr><th>·······</th><th align="center">HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>协议</td><td align="center">运行在 TCP 之上，明文传输，<strong>客户端与服务器端都无法验证对方的身份</strong></td><td>身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， <strong>是添加了加密和认证机制的 HTTP</strong>。</td></tr><tr><td>端口</td><td align="center">80</td><td>443</td></tr><tr><td>资源消耗</td><td align="center">较少</td><td>由于加解密处理，会消耗更多的 CPU 和内存资源</td></tr><tr><td>开销</td><td align="center">无需证书</td><td>需要证书，而证书一般需要向认证机构购买</td></tr><tr><td>加密机制</td><td align="center">无</td><td>共享密钥加密和公开密钥加密并用的混合加密机制</td></tr><tr><td>安全性</td><td align="center">弱</td><td>由于加密机制，安全性强</td></tr></tbody></table><h3 id="常用HTTP状态码"><a href="#常用HTTP状态码" class="headerlink" title="常用HTTP状态码"></a>常用HTTP状态码</h3><p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</p><p>状态码的类别：</p><table><thead><tr><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码） 接受的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码） 请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码） 需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码） 服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码） 服务器处理请求出错</td></tr></tbody></table><p>常用HTTP状态码：</p><table><thead><tr><th>2XX</th><th>成功（这系列表明请求被正常处理了）</th></tr></thead><tbody><tr><td>200</td><td>OK，表示从客户端发来的请求在服务器端被正确处理</td></tr><tr><td>204</td><td>No content，表示请求成功，但响应报文不含实体的主体部分</td></tr><tr><td>206</td><td>Partial Content，进行范围请求成功</td></tr></tbody></table><table><thead><tr><th>3XX</th><th>重定向（表明浏览器要执行特殊处理）</th></tr></thead><tbody><tr><td>301</td><td>moved permanently，永久性重定向，表示资源已被分配了新的 URL</td></tr><tr><td>302</td><td>found，临时性重定向，表示资源临时被分配了新的 URL</td></tr><tr><td>303</td><td>see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求）</td></tr><tr><td>304</td><td>not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）</td></tr><tr><td>307</td><td>temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</td></tr></tbody></table><table><thead><tr><th>4XX</th><th>客户端错误</th></tr></thead><tbody><tr><td>400</td><td>bad request，请求报文存在语法错误</td></tr><tr><td>401</td><td>unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</td></tr><tr><td>403</td><td>forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述</td></tr><tr><td>404</td><td>not found，表示在服务器上没有找到请求的资源</td></tr></tbody></table><table><thead><tr><th>5XX</th><th>服务器错误</th></tr></thead><tbody><tr><td>500</td><td>internal sever error，表示服务器端在执行请求时发生了错误</td></tr><tr><td>501</td><td>Not Implemented，表示服务器不支持当前请求所需要的某个功能</td></tr><tr><td>503</td><td>service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</td></tr></tbody></table><h3 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h3><p>说道GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。</p><p>HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。</p><p>HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理解为，对服务器资源的查，改，增，删。</p><ul><li>GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。</li><li>POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。</li><li>PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。</li><li>DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。</li></ul><p><strong>GET和POST区别</strong></p><ol><li><p>Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。</p></li><li><p>Get请求提交的url中的数据最多只能是2048字节，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。</p></li><li><p>Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。</p></li><li><p>Get执行效率却比Post方法好。Get是form提交的默认方法。</p></li><li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p></li></ol><h3 id="什么是对称加密与非对称加密"><a href="#什么是对称加密与非对称加密" class="headerlink" title="什么是对称加密与非对称加密"></a>什么是对称加密与非对称加密</h3><p>对称密钥加密是指加密和解密使用同一个密钥的方式，<strong>这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</strong></p><p>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。<br>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢。</p><h3 id="什么是HTTP2"><a href="#什么是HTTP2" class="headerlink" title="什么是HTTP2"></a>什么是HTTP2</h3><p>HTTP2 可以提高了网页的性能。</p><p>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六个），当在请求很多资源的时候，由于队头阻塞当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。</p><p>HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。</p><h3 id="Session、Cookie和Token的主要区别"><a href="#Session、Cookie和Token的主要区别" class="headerlink" title="Session、Cookie和Token的主要区别"></a>Session、Cookie和Token的主要区别</h3><p>HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。</p><p><strong>什么是cookie</strong></p><p>cookie是由Web服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。</p><p><strong>什么是session</strong></p><p>session是依赖Cookie实现的。session是服务器端对象</p><p>session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认为浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输 cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p><p><strong>cookie与session区别</strong></p><ul><li>存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；</li><li>存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制</li><li>占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li></ul><p><strong>什么是Token</strong></p><p>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p><p>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p><p>使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p><p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</p><p><strong>session与token区别</strong></p><ul><li>session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；</li><li>session存储在服务器端，token存储在客户端</li><li>token提供认证和授权功能，作为身份认证，token安全性比session好；</li><li>session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</li></ul><h3 id="Servlet是线程安全的吗"><a href="#Servlet是线程安全的吗" class="headerlink" title="Servlet是线程安全的吗"></a>Servlet是线程安全的吗</h3><p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong></p><p>解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。</p><p>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p><h3 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h3><p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求<strong>HttpServletRequest</strong>，在<strong>doGet()</strong>，<strong>doPost()中做相应的处理，并将回应HttpServletResponse</strong>反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。</p><p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p><ul><li><p><strong>void init(ServletConfig config) throws ServletException</strong></p></li><li><p><strong>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</strong></p></li><li><p><strong>void destory()</strong></p></li><li><p>java.lang.String getServletInfo()</p></li><li><p>ServletConfig getServletConfig()</p></li></ul><p><strong>生命周期：</strong></p><p><strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；</p><p>请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；</p><p>当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。</p><p><strong>init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p><h3 id="如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="如果客户端禁止 cookie 能实现 session 还能用吗？"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h3><p>Cookie 与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。</p><p>但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</p><p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p><ol><li>手动通过URL传值、隐藏表单传递Session ID。</li><li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】的CRUD操作</title>
      <link href="/2020/03/18/MyBatis%E7%9A%84CRUD%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/03/18/MyBatis%E7%9A%84CRUD%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="动态代理机制"><a href="#动态代理机制" class="headerlink" title="动态代理机制"></a>动态代理机制</h3><h4 id="MyBatis和数据库的交互有两种方式："><a href="#MyBatis和数据库的交互有两种方式：" class="headerlink" title="MyBatis和数据库的交互有两种方式："></a>MyBatis和数据库的交互有两种方式：</h4><h5 id="使用传统的MyBatis提供的API"><a href="#使用传统的MyBatis提供的API" class="headerlink" title="使用传统的MyBatis提供的API"></a>使用传统的MyBatis提供的API</h5><p>使用传统的MyBatis提供的API ，需要传递Statement Id 和查询参数给 SqlSession 对象，MyBatis 提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作</p><h5 id="使用Mapper接口"><a href="#使用Mapper接口" class="headerlink" title="使用Mapper接口"></a>使用Mapper接口</h5><p>使用Mapper接口，MyBatis 将配置文件中的每一个&lt;mapper&gt; 元素抽象为一个 Mapper 接口，而这个接口中声明的方法和&lt;mapper&gt; 元素中的&lt;select|update|delete|insert&gt; 子元素相对应</p><h4 id="为什么Mapper接口中的抽象方法，没有自己定义实现类却能被正常调用呢？"><a href="#为什么Mapper接口中的抽象方法，没有自己定义实现类却能被正常调用呢？" class="headerlink" title="为什么Mapper接口中的抽象方法，没有自己定义实现类却能被正常调用呢？"></a>为什么Mapper接口中的抽象方法，没有自己定义实现类却能被正常调用呢？</h4><ul><li>MyBatis在Mapper接口上使用了动态代理</li><li>代理机制是Java中常用的设计模式，分为静态代理和动态代理。</li></ul><p><strong>静态代理</strong>：在程序编译时已经将接口、代理类和被代理类等确定下来</p><p><strong>动态代理</strong>：代理类在程序运行期间动态创建</p><h4 id="Java中动态代理的实现"><a href="#Java中动态代理的实现" class="headerlink" title="Java中动态代理的实现"></a>Java中动态代理的实现</h4><p>在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p><p><img data-src="1.png" alt="1.png"></p><ul><li>通过sqlSession.getMapper(XXXMapper.class) 方法，MyBatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个Mapper 实例</li><li>使用Mapper 接口的某一个方法时，MyBatis 会调用MapperProxy类的invoke()方法</li><li>底层还是通过SqlSession的select、update、delete、insert等方法来实现对数据库的操作</li></ul><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><h4 id="单条插入"><a href="#单条插入" class="headerlink" title="单条插入"></a>单条插入</h4><p>在映射器接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>在映射文件中添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">    insert into USER(id,user_name,password) </span><br><span class="line">    values(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;) </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>insert元素，用于映射插入语句</strong></p><ul><li>id属性：命名空间中的唯一标识符，为Mapper接口中的方法名</li><li>parameterType：指定了方法的参数类型，为可选项可以省略</li><li>元素的内容为插入的SQL语句</li><li>#{id}：MyBatis SQL中使用预编译参数的一种方式，当实际参数为JavaBean对象时，大括号中的id是其属性名</li></ul><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">User u = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"张三"</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">int</span> num = userMapper.insert(u);</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><p><strong>insert方法的返回值num是执行插入语句所影响的行数</strong></p><h4 id="使用JDBC方式返回主键自增的值"><a href="#使用JDBC方式返回主键自增的值" class="headerlink" title="使用JDBC方式返回主键自增的值"></a>使用JDBC方式返回主键自增的值</h4><ul><li>如果数据库设计时，主键字段为自动增长，那么需要插入的User对象的id属性值可以为null</li><li>如果想在执行插入操作以后返回表中的主键值，需要在映射文件中insert元素中加上如下两个属性</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    insert into USER(id,user_name,password) </span><br><span class="line">    values(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;) </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>useGeneratedKeys属性仅对 insert 和 update 有用，这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键</li><li>keyProperty  属性仅对 insert 和 update 有用，唯一标记一个属性，获得的主键值将会赋值给该属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = userMapper.insert(u);</span><br><span class="line">System.out.println(u.getId());</span><br></pre></td></tr></table></figure><h4 id="使用selectKey返回主键的值"><a href="#使用selectKey返回主键的值" class="headerlink" title="使用selectKey返回主键的值"></a>使用selectKey返回主键的值</h4><p>对于一些不提供主键自增功能的数据库，如Oracle，需要使用selectKey标签来获取主键的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    insert into USER(id,user_name,password) </span><br><span class="line">    values(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;) </span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">order</span>=<span class="string">"AFTER"</span>&gt;</span></span><br><span class="line">        SELECT LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>keyProperty属性表示主键所对应的属性名</p></li><li><p>resultType属性用于设置返回值类型</p></li><li><p>在MySQL中order属性设置为after，表示当前记录的主键值在insert语句执行成功后才能获取到，Oracle中设置为before</p></li><li><p>selectKey元素中的内容是一个独立的SQL语句，在MySQL中SELECT LAST_INSERT_ID()用于获取数据库中最后插入的数据的主键值</p></li><li><p>在Oracle中应该使用SELECT SEQ_ID.nextval from dual 用来获取序列中的一个值</p></li></ul><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><h4 id="普通查询"><a href="#普通查询" class="headerlink" title="普通查询"></a>普通查询</h4><p>根据用户id查询单条记录，在映射器接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>当实体类的属性名与数据库表的字段名一一对应时，映射代码如下所示：select元素用于映射查询语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">resultType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">    select * from USER where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">User u = userMapper.selectById(<span class="number">10</span>);</span><br><span class="line">System.out.println(u);</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><p>当实体类属性名与表字段不一致时，可以使用resultMap元素映射其对应关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.User"</span> <span class="attr">id</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    select * from USER where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>resultMap是一种很重要的配置结果映射的方法</strong></p><ul><li>id属性：必填，是结果映射的唯一标识，与select元素中resultMap属性的值一致</li><li>type属性：必填，用于指定查询结果所映射到的Java对象类型</li><li>id子元素：配置id对应的column（字段名）和property（属性名）</li><li>result子元素：配置普通结果对应的字段名和属性名</li></ul><p>当实体类属性与表字段不一致时，也可以通过设置别名进行映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAllUsers"</span> <span class="attr">resultType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">    select id,</span><br><span class="line">        user_name userName,</span><br><span class="line">        password</span><br><span class="line">    from USER</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="模糊查询like"><a href="#模糊查询like" class="headerlink" title="模糊查询like"></a>模糊查询like</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findLike"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    select * from user where user_name like "%"#&#123;name&#125;"%"</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表达式: user_name like”%”#{name}”%” #起到<strong>占位符</strong>的作用</p><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>在映射器接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateById</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>在映射文件中添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateById"</span>&gt;</span></span><br><span class="line">    update user </span><br><span class="line">    set user_name = #&#123;userName&#125;,</span><br><span class="line">        password = #&#123;password&#125;</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line">User u = <span class="keyword">new</span> User();</span><br><span class="line">u.setId(<span class="number">10</span>);</span><br><span class="line">u.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">u.setPassword(<span class="string">"123456"</span>);</span><br><span class="line"><span class="keyword">int</span> num = userMapper.updateById(u);</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除同更新操作类似，在映射器接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>在映射文件中添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteById"</span>&gt;</span></span><br><span class="line">    delete from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line"><span class="keyword">int</span> num = userMapper.deleteById(<span class="number">10</span>);</span><br><span class="line">System.out.println(num);</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】框架概述</title>
      <link href="/2020/03/17/MyBatis%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/03/17/MyBatis%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="MyBatis使用流程"><a href="#MyBatis使用流程" class="headerlink" title="MyBatis使用流程"></a>MyBatis使用流程</h3><ol><li>创建一个Java Project</li><li>导入MyBatis需要的jar包(mybatis-xxx.jar)</li><li>创建MyBatis的主配置文件mybatis.xml</li><li>创建实体类和映射器接口</li><li>创建MyBatis的SQL映射XML文件</li><li>将SQL映射文件与主配置文件进行关联</li><li>编写代码进行测试</li></ol><h3 id="GitHub源码"><a href="#GitHub源码" class="headerlink" title="GitHub源码"></a>GitHub源码</h3><p><a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">https</a><a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">://</a><a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">github.com/mybatis/mybatis-3</a></p><h3 id="MyBatis中文手册："><a href="#MyBatis中文手册：" class="headerlink" title="MyBatis中文手册："></a>MyBatis中文手册：</h3><p><a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">http</a><a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">://www.mybatis.org/mybatis-3/zh/index.html</a></p><h3 id="MyBatis核心XML配置文件"><a href="#MyBatis核心XML配置文件" class="headerlink" title="MyBatis核心XML配置文件"></a>MyBatis核心XML配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>  <span class="attr">resource</span>=<span class="string">"dbinfo.properties"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打印SQL语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 配置数据库信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.connectUrl&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.user&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.pwd&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>settings</strong>是 MyBatis 中极为重要的调整设置，可以用来配置全局参数，它们会改变 MyBatis 的运行时行为</p><ul><li>logImpl设置用来指定MyBatis 所用日志的具体实现，未指定时将自动查找。如果设置为<strong>STDOUT_LOGGING</strong>则表示在控制台显示SQL语句</li><li><a href="https://blog.csdn.net/u014231523/article/details/53056032" target="_blank" rel="noopener">https://blog.csdn.net/u014231523/article/details/53056032</a></li></ul><p>配置环境（<strong>environments</strong>）</p><ul><li>MyBatis 可以配置成适应多种环境，也就是配置多个environment子元素，这种机制有助于将<br>SQL<br>映射应用于多种数据库之中</li><li><strong>注意：</strong>environments的default属性取值要和其中一个environment的id属性取值一致</li></ul><p><strong>transactionManager</strong> 元素的type属性表示事务管理器类型，在MyBatis中有两种类型：</p><ul><li><strong>JDBC</strong> 这种方式是直接使用了JDBC的事务提交和回滚设置</li><li>MANAGED(托管)这种方式从来不提交或回滚一个连接。而是让容器来管理事务的整个生命周期(比如<br>Spring) </li></ul><p><strong>dataSource</strong>元素中主要配置了 JDBC 连接对象的资源，它的type属性表示数据源类型，内建的数据源类型有三种：</p><ul><li>UNPOOLED:每次被请求时简单打开和关闭连接</li><li><strong>POOLED</strong>：这是JDBC连接对象的数据库连接池的实现,用来避免创建新的连接实例 </li><li>JNDI：这个数据源的实现是为了使用如Spring或应用服务器这类的容器</li></ul><h3 id="MyBatis主要的类层次结构"><a href="#MyBatis主要的类层次结构" class="headerlink" title="MyBatis主要的类层次结构"></a>MyBatis主要的类层次结构</h3><p><img data-src="1.png" alt="1.png"></p><ul><li>每一个MyBatis的应用程序都以一个SqlSessionFactory 对象的实例为核心 。 </li><li>SqlSessionFactory对象的实例可以通过SqlSessionFactoryBuilder对象来获得 。</li><li>SqlSessionFactoryBuilder对象可以从 XML 配置文件中构建 SqlSessionFactory对象。 </li><li>通过SqlSessionFactory对象，可以获得SqlSession的实例。</li><li>SqlSession 对象完全包含以数据库为背景的所有执行 SQL 操作的方法。你可以用 SqlSession 实例来直接执行已映射的 SQL 语句 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is =     </span><br><span class="line">                Resources.getResourceAsStream(<span class="string">"mybatis.xml"</span>);</span><br><span class="line">            factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">openSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>dbinfo.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">db.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">db.connectUrl</span>=<span class="string">jdbc:mysql://localhost:3306/mybatisdemo_db?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.pwd</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>mybatis.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"dbinfo.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打印SQL语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置数据库信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driver&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.connectUrl&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.user&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.pwd&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"top/hiasenna/mapper/userMapper.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtil</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sessionFactory;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream is = Resources.getResourceAsStream(<span class="string">"mybatis.xml"</span>);</span><br><span class="line">sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">is.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">openSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sessionFactory.openSession();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User [id="</span> + id + <span class="string">", username="</span> + username + <span class="string">", password="</span> + password + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>userMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.hiasenna.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAll"</span> <span class="attr">resultType</span>=<span class="string">"top.hiasenna.entity.User"</span>&gt;</span></span><br><span class="line">select * from user </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">queryUser();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queryUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//List&lt;User&gt; users = session.selectList("top.hiasenna.mapper.UserMapper.selectAll");</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line"><span class="keyword">for</span>(User u : users) &#123;</span><br><span class="line">    System.out.println(u);</span><br><span class="line">&#125;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】检索方式与检索策略</title>
      <link href="/2020/03/17/hibernate%E6%A3%80%E7%B4%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5/"/>
      <url>/2020/03/17/hibernate%E6%A3%80%E7%B4%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>Hibernate的Session在加载Java对象时，一般都会把这个对象相关联的其他Java对象也都加载到缓存中，以方便程序的调用。但很多情况下，我们不需要加载太多无用的对象到缓存中，一来会占用大量的内存，二来会增加数据库的访问次数，使得程序的运行效率降低。为了合理的使用缓存，Hibernate提供了不同的检索策略来解决这些问题。</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h1><p>在说检索策略之前，先了解一下检索策略的作用域，它分为：类级别和关联级别。类级别的作用域在检索数据时，检索的数据只包含一个类对象，不涉及与该类关联的其他对象。关联级别的作用域检索的数据包含相关联的多个类的对象，例如，Customer对象与Orders对象存在关系，检索到一个Customer对象后，还会涉及与之关联的Orders对象。</p><p><img data-src="1.png" alt="1"></p><h1 id="检索策略"><a href="#检索策略" class="headerlink" title="检索策略"></a><strong>检索策略</strong></h1><p>Hibernate的检索策略分为三种，立即检索、延迟检索、左外连接检索。</p><h3 id="立即检索"><a href="#立即检索" class="headerlink" title="立即检索"></a><strong>立即检索</strong></h3><p> 采用立即检索策略，会把被检索的对象，以及和这个对象关联的一对多对象都加载到缓存中。Session的get方法就使用的立即检索策略。这种策略的优点在于，频繁使用的对象会被加载到缓存中，程序调用很方便，也很及时。缺点就是，占用的内存过多，而且数据库访问的次数也会很频繁，效率低下。</p><h3 id="延迟检索"><a href="#延迟检索" class="headerlink" title="延迟检索"></a><strong>延迟检索</strong></h3><p>采用延迟检索策略，就不会加载关联对象的内容。直到第一次调用关联对象时，才去加载关联对象。在不涉及关联类操作时，延迟检索策略只适用于Session的load方法。涉及关联类操作时，延迟检索策略也能够适用于get，list等操作。</p><p>在类级别操作时， 延迟检索策略，只加载类的OID不加载类的其他属性，只用当第一次访问其他属性时，才回访问数据库去加载内容。（这里使用了CGLIB生成了类的代理类）</p><p>在关联级别操作时，延迟检索策略，只加载类本身，不加载关联类，直到第一次调用关联对象时，才去加载关联对象。</p><p>程序模式都是用延迟加载策略。如果需要指定使用延迟加载策略。在配置文件中设置&lt;class&gt;的lazy=true，、&lt;set&gt;的lazy=true或extra（增强延迟）&lt;many-to-one&gt;的lazy=proxy和no-proxy。</p><p>  这种策略的优点在于，由程序决定加载哪些类和内容，而不必全部都加载，避免了内存的大量占用和数据库的频繁访问。缺点就是在Session关闭后，就不能访问关联类对象了。 需要确保Session一直处于打开状态，调用关联对象，最后在关闭Session对象。</p><h3 id="左外连接检索"><a href="#左外连接检索" class="headerlink" title="左外连接检索"></a><strong>左外连接检索</strong></h3><p>采用左外连接检索，能够使用sql的外连接查询，将需要加载的关联对象加载在缓存中。&lt;set&gt;fetch设置为join，&lt;many-to-one&gt;的fetch设置为join。</p><p>这种策略的优点在于，对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象。使用了外连接，select语句数目少。缺点就是可能会加载应用程序不需要访问的对象，白白浪费许多内存空间。复杂的数据库表连接也会影响检索性能。</p><p><img data-src="2.png" alt="2"></p><h1 id="检索方式"><a href="#检索方式" class="headerlink" title="检索方式"></a><strong>检索方式</strong></h1><p> Hibernate提供的检索方式为5种，分为导航对象图检索方式、OID检索方式、HQL检索方式、QBC检索方式、本地SQL检索方式。</p><h3 id="导航对象图检索方式"><a href="#导航对象图检索方式" class="headerlink" title="导航对象图检索方式"></a><strong>导航对象图检索方式</strong></h3><p>利用类与类之间的关系来检索对象。譬如我们要查找一份订单，就可以由订单对象自动导航找到订单所属的客户对象。当然，前提是必须在对象-关系映射文件上配置了它们的多对一的关系。</p><h3 id="OID检索方式"><a href="#OID检索方式" class="headerlink" title="OID检索方式"></a><strong>OID检索方式</strong></h3><p>主要指用Session的get()和load()方法加载某条记录对应的对象。</p><h3 id="HQL检索方式"><a href="#HQL检索方式" class="headerlink" title="HQL检索方式"></a><strong>HQL检索方式</strong></h3><p> HQL（Hibernate Query Language）是面向对象的查询语言，它和SQL查询语言有些相似。在Hibernate提供的各种检索方式中，HQL是使用最广的一种检索方式。它具有以下功能：</p><p>&emsp;    在查询语句中设定各种查询条件。</p><p>&emsp;    支持投影查询，即仅检索出对象的部分属性。<br>&emsp;    支持分页查询。<br>&emsp;    支持分组查询，允许使用group by和having关键字。<br>&emsp;    提供内置聚集函数，如sum()、min()和max()。<br>&emsp;    能够调用用户定义的SQL函数。<br>&emsp;    支持子查询，即嵌套查询。<br>&emsp;    支持动态绑定参数。</p><p>   Session类的Qurey接口支持HQL检索方式，它提供了以上列出的各种查询功能。</p><p><strong>注:</strong>Qurey接口支持方法链编程风格，它的set方法都返回自身实例，而不是返回void类型。方法链编程风格能使程序代码更加简洁。</p><p><strong>例：</strong></p><p>检索USER 表的所有记录</p><p>—-HQL语句中关键字大小写无关，但习惯将关键字小写。</p><p>—-from 关键字后面是类名不是数据库表名，类名需区分大小写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Query query = session.createQuery(<span class="string">"from User"</span>);</span><br><span class="line">List userList = query.list();</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"select u from User u"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">List userList = query.list();</span><br></pre></td></tr></table></figure><p>where 子句</p><p>—where子句中给出的是类的属性名而不是数据库表字段名，其中属性名必须区分大小写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from User where userName='张三'"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">List userList = query.list();</span><br></pre></td></tr></table></figure><p>HQL支持的各种运算符</p><table><thead><tr><th align="center"><strong>程序中指定的连接类型</strong></th><th align="center"><strong>HQL**</strong>运算符**</th></tr></thead><tbody><tr><td align="center">比较运算符</td><td align="center">=、&lt;&gt;、&gt;=、&lt;=、&gt;、&lt;、is null、is not null</td></tr><tr><td align="center">范围运算符</td><td align="center">in、not in、between…and、not between…and</td></tr><tr><td align="center">字符串模式匹配运算符</td><td align="center">like</td></tr><tr><td align="center">逻辑运算符</td><td align="center">and、or、not</td></tr></tbody></table><h4 id="HQL检索单个对象"><a href="#HQL检索单个对象" class="headerlink" title="HQL检索单个对象"></a>HQL检索单个对象</h4><p>list()：返回List类型的查询结果，返回所有满足条件的对象。</p><p>uniqueResult()：返回单个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Query query = session.createQuery(<span class="string">"from User u</span></span><br><span class="line"><span class="string">                      where u.userName='张三'"</span>);</span><br><span class="line">User user = (User)query.uniqueResult();</span><br></pre></td></tr></table></figure><h4 id="HQL参数绑定"><a href="#HQL参数绑定" class="headerlink" title="HQL参数绑定"></a>HQL参数绑定</h4><h5 id="在HQL查询语句中按照参数位置绑定参数"><a href="#在HQL查询语句中按照参数位置绑定参数" class="headerlink" title="在HQL查询语句中按照参数位置绑定参数"></a>在HQL查询语句中按照参数位置绑定参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from User u where u.userName=?"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">query.setParameter(<span class="number">0</span>, <span class="string">"张三"</span>);</span><br><span class="line">List&lt;User&gt; userList = query.list();</span><br></pre></td></tr></table></figure><h5 id="在HQL查询语句中按参数名称绑定参数。"><a href="#在HQL查询语句中按参数名称绑定参数。" class="headerlink" title="在HQL查询语句中按参数名称绑定参数。"></a>在HQL查询语句中按参数名称绑定参数。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from User u </span></span><br><span class="line"><span class="string">        where u.userName=:name"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">query.setParameter(<span class="string">"name"</span>, <span class="string">"张三"</span>);</span><br><span class="line">List&lt;User&gt; userList = query.list();</span><br></pre></td></tr></table></figure><h5 id="HQL的绑定参数方法"><a href="#HQL的绑定参数方法" class="headerlink" title="HQL的绑定参数方法"></a>HQL的绑定参数方法</h5><p>setParamter() 绑定任意类型的参数。</p><p>setProperties(Object bean) 用于把命名参数与一个对象的属性值绑定，并且参数名称要与对象属性名称一致。</p><p>setProperties(Map bean)用于把命名参数与一个Map类型的对象的value值绑定，并且参数名称要与Map类型的对象的key值一致。</p><h4 id="HQL实体更新"><a href="#HQL实体更新" class="headerlink" title="HQL实体更新"></a>HQL实体更新</h4><h5 id="不使用HQL的实体更新。"><a href="#不使用HQL的实体更新。" class="headerlink" title="不使用HQL的实体更新。"></a>不使用HQL的实体更新。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">User user = (User) session.get(User<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line">user.setUserName(<span class="string">"Tom"</span>);</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><h5 id="HQL实现实体更新的方式"><a href="#HQL实现实体更新的方式" class="headerlink" title="HQL实现实体更新的方式"></a>HQL实现实体更新的方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">String hql = <span class="string">"update User set userName='Tom' </span></span><br><span class="line"><span class="string">        where id=2"</span>; </span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line"><span class="keyword">int</span> ret = query.executeUpdate();</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><h4 id="HQL实体删除"><a href="#HQL实体删除" class="headerlink" title="HQL实体删除"></a>HQL实体删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">String hql = <span class="string">"delete from User where id = 1"</span>;</span><br><span class="line">Query query  = session.createQuery(hql);</span><br><span class="line"><span class="keyword">int</span> ret = query.executeUpdate();</span><br><span class="line">tx .commit();</span><br></pre></td></tr></table></figure><h4 id="HQL子查询"><a href="#HQL子查询" class="headerlink" title="HQL子查询"></a>HQL子查询</h4><p>HQL支持在 where 子句中嵌入子查询语句，并且子查询语句必须放在括号内。</p><p>查询订单数量大于0的所有用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> u </span><br><span class="line"><span class="keyword">where</span> <span class="number">0</span>&lt;(<span class="keyword">select</span> <span class="keyword">count</span>(o) <span class="keyword">from</span> orders o </span><br><span class="line">         <span class="keyword">where</span> u.id=o.userId )</span><br></pre></td></tr></table></figure><p>如果HQL子查询的是集合，HQL提供了一组操作集合的函数:</p><p>size()，获得集合中元素的个数；</p><p>maxIndex()，对于建立索引的集合，获得最大索引值；</p><p>minIndex()，对于建立索引的集合，获得最小索引值；</p><p>elements()，获得集合中所有元素。</p><h3 id="QBC检索方式"><a href="#QBC检索方式" class="headerlink" title="QBC检索方式"></a><strong>QBC检索方式</strong></h3><p>采用HQL检索方式时，在应用程序中需要定义基于字符串形式的HQL查询语句。QBC API提供了检索对象的另一种方式，它主要由Criteria接口、Criterion接口和Expression类组成，它支持在运行时动态生成查询语句。</p><p>检索姓名为张三 的所有用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria=session.createCriteria(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Criterion c1= Restrictions.eq(<span class="string">"userName"</span>, <span class="string">"张三"</span>);</span><br><span class="line">criteria.add(c1);</span><br><span class="line">List result = criteria.list();</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>运算类型</strong></th><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>范围运算符</td><td>Restrictions.in</td><td>等于列表中的某个值</td></tr><tr><td></td><td>Restrictions.not(Restrictions.in)</td><td>不等于列表中的任意值</td></tr><tr><td></td><td>Restrictions.between</td><td>大于等于值1小于等于值2</td></tr><tr><td>字符串模糊匹配</td><td>Restrictions.like</td><td>字符串模糊匹配   like</td></tr><tr><td>逻辑运算符</td><td>Restrictions.and</td><td>逻辑与</td></tr><tr><td></td><td>Restrictions.or</td><td>逻辑或</td></tr><tr><td></td><td>Restrictions.not</td><td>逻辑非</td></tr><tr><td>比较运算符</td><td>Restrictions.eq</td><td>等于</td></tr><tr><td></td><td>Restrictions.ne</td><td>不等于</td></tr><tr><td></td><td>Restrictions.gt</td><td>大于</td></tr><tr><td></td><td>Restrictions.ge</td><td>大于等于</td></tr><tr><td></td><td>Restrictions.lt</td><td>小于</td></tr><tr><td></td><td>Restrictions.le</td><td>小于等于</td></tr><tr><td></td><td>Restrictions.isNull</td><td>等于空值</td></tr><tr><td></td><td>Restrictions.isNotNull</td><td>非空值</td></tr></tbody></table><h3 id="本地SQL检索方式"><a href="#本地SQL检索方式" class="headerlink" title="本地SQL检索方式"></a><strong>本地SQL检索方式</strong></h3><p>采用HQL或QBC检索方式时，Hibernate生成标准的SQL查询语句，使用于所有的数据库平台，因此这两种检索方式都是跨平台的。有的应用程序可能需要根据底层数据库的SQL方言，来生成一些特殊的查询语句。在这种情况下，可以利用Hibernate提供的SQL检索方式。</p><p>查询所有的用户信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from  user"</span>;</span><br><span class="line">NativeQuery query = session.createNativeQuery(sql, </span><br><span class="line">    User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">List list = query.list();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-稀疏数组</title>
      <link href="/2020/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2020/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。<br>稀疏数组的处理方法是:</p><p>1) 记录数组 一共有几行几列，有多少个不同的值<br>2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而 缩小程序的规模</p><p><img data-src="1.png" alt="1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line"><span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表示蓝子</span></span><br><span class="line"><span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 输出原始的二维数组</span></span><br><span class="line">System.out.println(<span class="string">"原始的二维数组~~"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将二维数组 转 稀疏数组</span></span><br><span class="line"><span class="comment">// 1. 先遍历二维数组 得到非0数据的个数</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line"><span class="keyword">if</span> (data != <span class="number">0</span>) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line"><span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二维数组，将非0的值存放到 sparseArr中</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"得到稀疏数组为~~~~"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int [11][11] 2.</span></span><br><span class="line"><span class="comment"> * 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"><span class="keyword">int</span> chessRow = sparseArr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> chessCol = sparseArr[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[chessRow][chessCol];</span><br><span class="line"><span class="comment">// 2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]]=sparseArr[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img data-src="2.png" alt="2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】操作持久化对象</title>
      <link href="/2020/03/16/hibernate%E6%93%8D%E4%BD%9C%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/16/hibernate%E6%93%8D%E4%BD%9C%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="一-Session缓存"><a href="#一-Session缓存" class="headerlink" title="一.Session缓存"></a>一.Session缓存</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li>缓存介于应用程序和永久性存储源之间，其作用是降低应用程序直接读写永久性存储源的频率，从而提高应用的运行效率。</li><li>缓存内的数据是永久性存储源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件同步缓存和永久性存储源的数据。</li></ul><p><img data-src="1.png" alt="1.png"></p><h4 id="Session缓存"><a href="#Session缓存" class="headerlink" title="Session缓存"></a>Session缓存</h4><p>Session 接口的实现类 SessionImpl 中定义了一系列的 Java 集合，这些集合构成了 Session 的缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Session session = sessionFactory.openSession(); </span><br><span class="line">......</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><h4 id="Session缓存的工作过程"><a href="#Session缓存的工作过程" class="headerlink" title="Session缓存的工作过程"></a>Session缓存的工作过程</h4><p>当 Session 执行查询方法时，先从 Session 缓存中读取据，如果缓存中有则直接读取，如果缓存中没有，从数据库中查询并加载到 Session 缓存中，再从缓存中读取。</p><p>当 Session 执行 save()、update() 方法时，将对象持久化到数据库中并将对象加载到 Session 缓存中。</p><p><img data-src="2.png" alt="2.png"></p><h4 id="Session实现缓存"><a href="#Session实现缓存" class="headerlink" title="Session实现缓存"></a>Session实现缓存</h4><p><img data-src="3.gif" alt="3.gif"></p><h4 id="Session清理缓存"><a href="#Session清理缓存" class="headerlink" title="Session清理缓存"></a>Session清理缓存</h4><p>Session在某一时间点按照缓存中对象的属性变化来同步更新数据库的这一过程被称为 <strong>Session</strong> <strong>清理缓存</strong>。</p><p><strong>缓存清理的时间点：</strong></p><ul><li>当调用 transaction.commit() 方法时，会先清理缓存，再向数据库提交事务；</li><li>当显式调用 Session.flush() 方法时，会清理缓存；</li><li>当调用 Session 的查询（不包括 load() 和 get() )方法时，如果缓存中对象的属性有变化则清理缓存。</li></ul><h4 id="Session对象快照"><a href="#Session对象快照" class="headerlink" title="Session对象快照"></a>Session对象快照</h4><p><img data-src="4.gif" alt="4.gif"></p><h4 id="Session清理缓存的模式"><a href="#Session清理缓存的模式" class="headerlink" title="Session清理缓存的模式"></a>Session清理缓存的模式</h4><p>setHibernateFlushMode() 用于设定 Session 清理缓存的模式。</p><table><thead><tr><th align="center"><strong>清理缓存模式</strong></th><th align="center"><strong>Session的查询方法</strong></th><th align="center"><strong>commit()</strong></th><th align="center"><strong>flush()</strong></th></tr></thead><tbody><tr><td align="center">FlushMode.ALWAYS</td><td align="center">清理</td><td align="center">清理</td><td align="center">清理</td></tr><tr><td align="center">FlushMode.AUTO</td><td align="center">缓存中对象的属性有变化时清理，没变化不清理</td><td align="center">清理</td><td align="center">清理</td></tr><tr><td align="center">FlushMode.COMMIT</td><td align="center">不清理</td><td align="center">清理</td><td align="center">清理</td></tr><tr><td align="center">FlushMode.MANUAL</td><td align="center">不清理</td><td align="center">不清理</td><td align="center">清理</td></tr><tr><td align="center">FlushMode.NEVER</td><td align="center">已过时，被MANUAL取代</td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="Session缓存有三大作用"><a href="#Session缓存有三大作用" class="headerlink" title="Session缓存有三大作用:"></a>Session缓存有三大作用:</h4><ul><li>减少数据库访问次数，提高数据访问的效率；</li><li>保证缓存中的对象与数据库中相关的记录同步；</li><li>当缓存中的持久化对象存在循环关联关系时，Session会保证不出现死循环，以及由死循环引起的堆栈溢出异常。</li></ul><h3 id="二-Hibernate对象的生命周期"><a href="#二-Hibernate对象的生命周期" class="headerlink" title="二.Hibernate对象的生命周期"></a>二.Hibernate对象的生命周期</h3><h4 id="实体对象的4种状态"><a href="#实体对象的4种状态" class="headerlink" title="实体对象的4种状态"></a>实体对象的4种状态</h4><ul><li>Transient(临时状态) ： 刚刚被 new 关键字创建，还没有被持久化，不在Session的缓存中。</li><li>Persistent(持久化状态) ： 已经被持久化，并加入到 Session 缓存中。</li><li>Detached(游离状态) ： 已经被持久化，但不再处于 Session 缓存中。</li><li>Removed(删除状态) ： Session 已经计划将其从数据库删除，并且不再处于 Session 缓存中。</li></ul><p><img data-src="5.png" alt="5.png"></p><h4 id="实体对象的生命周期（lifecycle）"><a href="#实体对象的生命周期（lifecycle）" class="headerlink" title="实体对象的生命周期（lifecycle）"></a>实体对象的生命周期（lifecycle）</h4><p><img data-src="6.png" alt="6.png"></p><h3 id="三-Hibernate操作持久化对象"><a href="#三-Hibernate操作持久化对象" class="headerlink" title="三.Hibernate操作持久化对象"></a>三.Hibernate操作持久化对象</h3><h4 id="Session的save-方法"><a href="#Session的save-方法" class="headerlink" title="Session的save()方法"></a>Session的save()方法</h4><p>•1. 把对象加入缓存中，使其变成持久化对象；</p><p>•2. 根据映射文件配置的标识符生成器为对象分配一个<br>OID；</p><p>•3. 计划执行一个 insert，把对象当前属性值组装到<br>insert 语句中；</p><p>•4. 事务提交后（transaction.commit()）永久的将数据保存到数据库。</p><h4 id="Session的update-方法"><a href="#Session的update-方法" class="headerlink" title="Session的update()方法"></a>Session的update()方法</h4><p>•1. 把游离对象重新加入 Session 缓存中，使其变为持久化对象；</p><p>•2. 计划执行一个 update，将对象当前属性组装到 update 语句，执行 update 语句；</p><p>•3. 事务提交后（transaction.commit()）永久的将数据保存到数据库；</p><p>•4. 不管对象属性有没有改变都会执行update （通过设置<class>的select-before-update=true改变）。</class></p><h4 id="Session的saveOrUpdate-方法"><a href="#Session的saveOrUpdate-方法" class="headerlink" title="Session的saveOrUpdate()方法"></a>Session的saveOrUpdate()方法</h4><ul><li>如果参数是临时对象–save()</li><li>如果参数是游离对象–update()</li><li>如果参数是持久化对象–返回</li></ul><p>Hibernate 如何区分临时对象：</p><ul><li>对象的 OID 为 null；</li><li>如果映射文件中设置了 <id> 的 unsaved-value 属性，并且对象的 id 值与 unsaved-value 设置的值相等。</id></li></ul><h4 id="Session的delete-方法"><a href="#Session的delete-方法" class="headerlink" title="Session的delete()方法"></a>Session的delete()方法</h4><p>•1. 检查传入的参数是否是持久化对象，如果是持久化对象将其移出 Session 缓存；</p><p>•2. 计划执行一个 delete，但是并不立即执行；</p><p>•3. 当 Session 清理缓存时才执行 delete，比如执行 Session.flush()。</p><h4 id="Session的load-和get-方法"><a href="#Session的load-和get-方法" class="headerlink" title="Session的load()和get()方法"></a>Session的load()和get()方法</h4><p>load() 与 get() 方法都是根据 OID 加载持久化对象。</p><p>load() 与 get() 方法的不同点：</p><ul><li>如果数据库中不存在与 OID 对应的记录：</li></ul><ol><li>load() 会抛出 ObjectNotFoundException 异常；</li><li>get() 会返回 null。</li></ol><ul><li>默认加载策略：</li></ul><ol><li>load() 使用类的延迟加载策略；</li><li>get() 使用类的立即加载策略。</li></ol>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】多对多关联映射</title>
      <link href="/2020/03/16/hibernate%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/16/hibernate%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在某高校选课系统中，一个学生可以同时选修多门课程，一门课程可以被若干个学生选修，像这样的多对多关联关系，应该如何实现？</p><p><img data-src="1.png" alt="1.png"></p><p><img data-src="2.png" alt="2.png"></p><h3 id="Hibernate多对多关联映射"><a href="#Hibernate多对多关联映射" class="headerlink" title="Hibernate多对多关联映射"></a>Hibernate多对多关联映射</h3><p>Student.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String studentNo;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Course&gt; courses = <span class="keyword">new</span> HashSet&lt;Course&gt;();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Course.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> credit;  <span class="comment">// 学分</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"courses"</span> <span class="attr">table</span>=<span class="string">"studentcourse"</span> <span class="attr">inverse</span>=<span class="string">"false"</span> <span class="attr">cascade</span>=<span class="string">"all"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"student_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"Course"</span> <span class="attr">column</span>=<span class="string">"course_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Course.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"students"</span> <span class="attr">table</span>=<span class="string">"studentcourse"</span> <span class="attr">inverse</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"course_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"Student"</span> <span class="attr">column</span>=<span class="string">"student_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="4.png" alt="4.png"></p><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">addStudent();</span><br><span class="line">delStudent();</span><br><span class="line">query();</span><br><span class="line">addCourse();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setName(<span class="string">"zs"</span>);</span><br><span class="line">Course course = session.get(Course<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Integer</span>(1))</span>;</span><br><span class="line">Course course2 = session.get(Course<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Integer</span>(2))</span>;</span><br><span class="line">student.getCourses().add(course);</span><br><span class="line">student.getCourses().add(course2);</span><br><span class="line"></span><br><span class="line">session.save(student);</span><br><span class="line"></span><br><span class="line">Student student2 = <span class="keyword">new</span> Student();</span><br><span class="line">student2.setName(<span class="string">"ls"</span>);</span><br><span class="line">student2.getCourses().add(course);</span><br><span class="line">student2.getCourses().add(course2);</span><br><span class="line"></span><br><span class="line">session.save(student2);</span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createCourse</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">Course course = <span class="keyword">new</span> Course();</span><br><span class="line">course.setName(<span class="string">"Java"</span>);</span><br><span class="line">session.save(course);</span><br><span class="line">Course course2 = <span class="keyword">new</span> Course();</span><br><span class="line">course2.setName(<span class="string">"H5"</span>);</span><br><span class="line">session.save(course2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">Student student =session.get(Student<span class="class">.<span class="keyword">class</span>, <span class="title">i</span>)</span>;</span><br><span class="line">session.delete(student);</span><br><span class="line">&#125;</span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addCourse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">createCourse(session);</span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">Student student = session.get(Student<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Integer</span>(1))</span>;</span><br><span class="line">Set&lt;Course&gt; courses = student.getCourses();</span><br><span class="line"><span class="keyword">for</span>(Course course:courses)&#123;</span><br><span class="line">System.out.println(course.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Course course = session.get(Course<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Integer</span>(1))</span>;</span><br><span class="line"><span class="keyword">for</span>(Student student2:course.getStudents())&#123;</span><br><span class="line">System.out.println(student2.getName());</span><br><span class="line">&#125;</span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@ManyToMany</span></span><br><span class="line"><span class="meta">@JoinTable</span>(name=<span class="string">"studentcourse"</span>,</span><br><span class="line">joinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"student_id"</span>),</span><br><span class="line">inverseJoinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"course_id"</span>))</span><br><span class="line"><span class="keyword">private</span> Set&lt;Course&gt; courses = <span class="keyword">new</span> HashSet&lt;Course&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Course&gt; <span class="title">getCourses</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> courses;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourses</span><span class="params">(Set&lt;Course&gt; courses)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.courses = courses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"course"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@ManyToMany</span>(mappedBy=<span class="string">"courses"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> students;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudents</span><span class="params">(Set&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.students = students;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="3.png" alt="3.png"></p>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap集合(高级)</title>
      <link href="/2020/03/15/HashMap%E9%9B%86%E5%90%88-%E9%AB%98%E7%BA%A7/"/>
      <url>/2020/03/15/HashMap%E9%9B%86%E5%90%88-%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap集合-高级"><a href="#HashMap集合-高级" class="headerlink" title="HashMap集合(高级)"></a>HashMap集合(高级)</h1><h2 id="1-HashMap集合简介"><a href="#1-HashMap集合简介" class="headerlink" title="1.HashMap集合简介"></a>1.HashMap集合简介</h2><p>​    HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><p>​    JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突<strong>(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)</strong>而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</strong></p><p>补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。</p><p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 <code>treeifyBin</code>方法。</p><p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。 </p><p>小结：</p><p>特点：</p><p>1.存取无序的</p><p>2.键和值位置都可以是null，但是键位置只能是一个null</p><p>3.键位置是唯一的，底层的数据结构控制键的</p><p>4.jdk1.8前数据结构是：链表 + 数组  jdk1.8之后是 ： 链表 + 数组  + 红黑树</p><p>5.阈值(边界值) &gt; 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</p><h2 id="2-HashMap集合底层的数据结构"><a href="#2-HashMap集合底层的数据结构" class="headerlink" title="2.HashMap集合底层的数据结构"></a>2.HashMap集合底层的数据结构</h2><h3 id="2-1数据结构概念"><a href="#2-1数据结构概念" class="headerlink" title="2.1数据结构概念"></a>2.1数据结构概念</h3><p> 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 </p><p>数据结构：就是存储数据的一种方式。ArrayList LinkedList</p><p>在JDK1.8 之前 HashMap 由 <strong>数组+链表</strong> 数据结构组成的。</p><p>在JDK1.8 之后 HashMap 由 <strong>数组+链表 +红黑树</strong>数据结构组成的。</p><h3 id="2-2HashMap底层的数据结构存储数据的过程"><a href="#2-2HashMap底层的数据结构存储数据的过程" class="headerlink" title="2.2HashMap底层的数据结构存储数据的过程"></a>2.2HashMap底层的数据结构存储数据的过程</h3><p>存储过程如下所示：</p><p>使用的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"刘德华"</span>, <span class="number">53</span>);</span><br><span class="line">        map.put(<span class="string">"柳岩"</span>, <span class="number">35</span>);</span><br><span class="line">        map.put(<span class="string">"张学友"</span>, <span class="number">55</span>);</span><br><span class="line">        map.put(<span class="string">"郭富城"</span>, <span class="number">52</span>);</span><br><span class="line">        map.put(<span class="string">"黎明"</span>, <span class="number">51</span>);</span><br><span class="line">        map.put(<span class="string">"林青霞"</span>, <span class="number">55</span>);</span><br><span class="line">        map.put(<span class="string">"刘德华"</span>, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" alt="哈希表存储过程.png"></p><p>说明：</p><p>1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于key的hashCode做hash操作，无符号右移16位然后做异或运算。</span><br><span class="line">还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移16位异或运算效率是最高的。至于底层是如何计算的我们下面看源码时给大家讲解。</span><br></pre></td></tr></table></figure><p>2.面试题：当两个对象的hashCode相等时会怎么样？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">会产生哈希碰撞，若key值内容相同则替换旧的value.不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储。</span><br></pre></td></tr></table></figure><p>3.面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</span><br></pre></td></tr></table></figure><p>4.面试题：如果两个键的hashcode相同，如何存储键值对？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashcode相同，通过equals比较内容是否相同。</span><br><span class="line">相同：则新的value覆盖之前的value</span><br><span class="line">不相同：则将新的键值对添加到哈希表中</span><br></pre></td></tr></table></figure><p>5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p><p>6.通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次查找的效率较低。而<strong>JDK1.8</strong>中，哈希表存储采用数组+链表+红黑树实现，当链表长度(阀值)超过 8 时且当前数组的长度 &gt; 64时，将链表转换为红黑树，这样大大减少了查找时间。jdk8在哈希表中引入红黑树的原因只是为了查找效率更高。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示。</p><p><img data-src="%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="哈希表.png"></p><p> <strong>但是这样的话问题来了，传统hashMap的缺点，1.8为什么引入红黑树？这样结构的话不是更麻烦了吗，为何阈值大于8换成红黑树？</strong></p><p> JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。 当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。</p><p>至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。 下面我们在分析源码的时候会介绍。</p><p><strong>7.总结：</strong></p><p>上述我们大概阐述了HashMap底层存储数据的方式。为了方便大家更好的理解，我们结合一个存储流程图来进一步说明一下：(jdk8存储过程)</p><p><img data-src="1.png" alt="1.png"></p><p>说明：</p><p>1.size表示 HashMap中K-V的实时数量 ， 注意这个不等于数组的长度 。 </p><p>2.threshold( 临界值)  =capacity(容量) * loadFactor( 加载因子 )。这个值是当前已占用数组长度的最大值。size超过这个临界值就重新resize(扩容)，扩容后的 HashMap 容量是之前容量的两倍 。</p><h2 id="3-HashMap继承关系"><a href="#3-HashMap继承关系" class="headerlink" title="3.HashMap继承关系"></a>3.HashMap继承关系</h2><p>HashMap继承关系如下图所示：</p><p><img data-src="1.bmp" alt="1.bmp"></p><p>说明：</p><ul><li>Cloneable 空接口，表示可以克隆。 创建并返回HashMap对象的一个副本。</li><li>Serializable 序列化接口。属于标记性接口。HashMap对象可以被序列化和反序列化。</li><li>AbstractMap 父类提供了Map实现接口。以最大限度地减少实现此接口所需的工作。</li></ul><p>补充：通过上述继承关系我们发现一个很奇怪的现象， 就是HashMap已经继承了AbstractMap而AbstractMap类实现了Map接口，那为什么HashMap还要在实现Map接口呢？同样在ArrayList中LinkedList中都是这种结构。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">据 java 集合框架的创始人Josh Bloch描述，这样的写法是一个失误。在java集合框架中，类似这样的写法很多，最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改，所以就这样存在下来了。</span><br></pre></td></tr></table></figure><h2 id="4-HashMap集合类的成员"><a href="#4-HashMap集合类的成员" class="headerlink" title="4.HashMap集合类的成员"></a>4.HashMap集合类的成员</h2><h3 id="4-1成员变量"><a href="#4-1成员变量" class="headerlink" title="4.1成员变量"></a>4.1成员变量</h3><p>1.序列化版本号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure><p>2.集合的初始化容量( <strong>必须是二的n次幂</strong> )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>问题： <strong>为什么必须是2的n次幂？如果输入值不是2的幂比如10会怎么样？</strong> </p><p>HashMap构造方法还可以指定集合的初始化容量大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap(<span class="keyword">int</span> initialCapacity) 构造一个带指定初始容量和默认加载因子 (<span class="number">0.75</span>) 的空 HashMap。</span><br></pre></td></tr></table></figure><p> 根据上述讲解我们已经知道，当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。 HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。</p><p>这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算(这点上述已经讲解)。所以源码中做了优化,使用 hash&amp;(length-1)，而实际上hash%length等于hash&amp;(length-1)的前提是length是2的n次幂。</p><p>为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；</p><p>举例：</p><p><strong>说明：按位与运算：相同的二进制数位上，都是1的时候，结果为1，否则为零。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例如长度为<span class="number">8</span>时候，<span class="number">3</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">3</span>  <span class="number">2</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">2</span> ，不同位置上，不碰撞；</span><br><span class="line">例如长度length为<span class="number">8</span>时候，<span class="number">8</span>是<span class="number">2</span>的<span class="number">3</span>次幂。二进制是：<span class="number">1000</span></span><br><span class="line">length-<span class="number">1</span> 二进制运算：</span><br><span class="line"><span class="number">1000</span></span><br><span class="line">-   <span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line">     <span class="number">111</span></span><br><span class="line">如下所示：</span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>   &amp;(<span class="number">8</span>    - <span class="number">1</span>)=<span class="number">3</span>  </span><br><span class="line"><span class="number">00000011</span>  <span class="number">3</span> hash</span><br><span class="line">&amp;   <span class="number">00000111</span>  <span class="number">7</span> length-<span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000011</span>-----》<span class="number">3</span> 数组下标</span><br><span class="line"></span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> &amp;  (<span class="number">8</span> -    <span class="number">1</span>) = <span class="number">2</span>  </span><br><span class="line"><span class="number">00000010</span>  <span class="number">2</span> hash</span><br><span class="line">&amp;   <span class="number">00000111</span>  <span class="number">7</span> length-<span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000010</span>-----》<span class="number">2</span>  数组下标</span><br><span class="line">说明：上述计算结果是不同位置上，不碰撞；</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例如长度为<span class="number">9</span>时候，<span class="number">3</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span>  <span class="number">2</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span> ，都在<span class="number">0</span>上，碰撞了；</span><br><span class="line">例如长度length为<span class="number">9</span>时候，<span class="number">9</span>不是<span class="number">2</span>的n次幂。二进制是：<span class="number">00001001</span></span><br><span class="line">length-<span class="number">1</span> 二进制运算：</span><br><span class="line"><span class="number">1001</span></span><br><span class="line">-   <span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">如下所示：</span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>   &amp;(<span class="number">9</span>    - <span class="number">1</span>)=<span class="number">0</span>  </span><br><span class="line"><span class="number">00000011</span>  <span class="number">3</span> hash</span><br><span class="line">&amp;   <span class="number">00001000</span>  <span class="number">8</span> length-<span class="number">1</span> </span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000000</span>-----》<span class="number">0</span>  数组下标</span><br><span class="line"></span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> &amp;  (<span class="number">9</span> -    <span class="number">1</span>) = <span class="number">2</span>  </span><br><span class="line"><span class="number">00000010</span> <span class="number">2</span> hash</span><br><span class="line">&amp;   <span class="number">00001000</span> <span class="number">8</span> length-<span class="number">1</span> </span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000000</span>-----》<span class="number">0</span>  数组下标</span><br><span class="line">说明：上述计算结果都在<span class="number">0</span>上，碰撞了；</span><br></pre></td></tr></table></figure><p><strong>注意： 当然如果不考虑效率直接求余即可（就不需要要求长度必须是2的n次方了）</strong> </p><p>小结：</p><p>​    1.由上面可以看出，当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，可以保证数据的均匀插入，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突。</p><p>​    2.另一方面，一般我们可能会想通过 % 求余来确定位置，这样也可以，只不过性能不如 &amp; 运算。而且当n是2的幂次方时：hash &amp; (length - 1) == hash % length</p><p>​    3.因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突，毕竟hash冲突越大，代表数组中一个链的长度越大，这样的话会降低hashmap的性能</p><p>​    <strong>4.如果创建HashMap对象时，输入的数组长度是10，不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字。</strong></p><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建HashMap集合的对象，指定数组长度是10，不是2的幂</span></span><br><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//initialCapacity=10</span></span><br><span class="line">   <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;<span class="comment">//initialCapacity=10</span></span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//initialCapacity=10</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;<span class="comment">//int cap = 10</span></span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>由此可以看到，当在实例化HashMap实例时，如果给定了initialCapacity(假设是10)，由于HashMap的capacity必须都是2的幂，因此这个方法用于找到大于等于initialCapacity(假设是10)的最小的2的幂（initialCapacity如果就是2的幂，则返回的还是这个数）。 下面分析这个算法： 1)、首先，为什么要对cap做减1操作。int n = cap - 1; 这是为了防止，cap已经是2的幂。如果cap已经是2的幂， 又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。如果不懂，要看完后面的几个无符号右移之后再回来看看。 下面看看这几个无符号右移操作： 2）、如果n这时为0了（经过了cap-1之后），则经过后面的几次无符号右移依然是0，最后返回的capacity是        1（最后有个n+1的操作）。 这里只讨论n不等于0的情况。</p><p>3）、注意：<strong>|（按位或运算）：运算规则：相同的二进制数位上，都是0的时候，结果为0，否则为1。</strong></p><p>​     <strong>第一次右移</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = cap - <span class="number">1</span>;<span class="comment">//cap=10  n=9</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001001</span> <span class="comment">//9</span></span><br><span class="line">|</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span> <span class="comment">//9右移之后变为4</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span> <span class="comment">//按位异或之后是13</span></span><br></pre></td></tr></table></figure><p> 由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span></span><br></pre></td></tr></table></figure><p> <strong>第二次右移</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> n |= n &gt;&gt;&gt; <span class="number">2</span>;<span class="comment">//n通过第一次右移变为了：n=13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span>  <span class="comment">// 13</span></span><br><span class="line">|</span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>  <span class="comment">//13右移之后变为3</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span> <span class="comment">//按位异或之后是15</span></span><br></pre></td></tr></table></figure><p> 注意，这个n已经经过了<code>n |= n &gt;&gt;&gt; 1;</code> 操作。假设此时n为00000000 00000000 00000000 00001101 ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 00001111 &#x2F;&#x2F;按位异或之后是15</span><br></pre></td></tr></table></figure><p> <strong>第三次右移</strong> :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n |&#x3D; n &gt;&gt;&gt; 4;&#x2F;&#x2F;n通过第一、二次右移变为了：n&#x3D;15</span><br><span class="line">00000000 00000000 00000000 00001111  &#x2F;&#x2F; 15</span><br><span class="line">|</span><br><span class="line">    00000000 00000000 00000000 00000000  &#x2F;&#x2F;15右移之后变为0</span><br><span class="line">-------------------------------------------------</span><br><span class="line">00000000 00000000 00000000 00001111 &#x2F;&#x2F;按位异或之后是15</span><br></pre></td></tr></table></figure><p>这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中正常会有8个连续的1。如00001111 1111xxxxxx 。 以此类推 注意，容量最大也就是32bit的正数，因此最后n |= n &gt;&gt;&gt; 16; ，最多也就32个1（但是这已经是负数了。在执行tableSizeFor之前，对initialCapacity做了判断，如果大于MAXIMUM_CAPACITY(2 ^ 30)，则取MAXIMUM_CAPACITY。如果等于MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作。所以这里面的移位操作之后，最大30个1，不会大于等于MAXIMUM_CAPACITY。30个1，加1之后得2 ^ 30） 。 请看下面的一个完整例子：</p><p><img data-src="image-20191115151657917.png" alt="image-20191115151657917.png"></p><p>  注意，得到的这个capacity却被赋值给了threshold。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.threshold &#x3D; tableSizeFor(initialCapacity);&#x2F;&#x2F;initialCapacity&#x3D;10</span><br></pre></td></tr></table></figure><p>3.默认的负载因子，默认值是0.75 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br></pre></td></tr></table></figure><p>4.集合最大容量 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;集合最大容量的上限是：2的30次幂</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br></pre></td></tr></table></figure><p>5.当链表的值超过8则会转红黑树(<strong>1.8新增</strong>) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当桶(bucket)上的结点数大于这个值时会转成红黑树</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br></pre></td></tr></table></figure><p><strong>问题：为什么Map桶中节点个数超过8才转为红黑树？</strong></p><p>8这个阈值定义在HashMap中，针对这个成员变量，在源码的注释中只说明了8是bin（bin就是bucket(桶)）从链表转成树的阈值，但是并没有说明为什么是8： </p><p> 在HashMap中有一段注释说明： 我们继续往下看 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Because TreeNodes are about twice the size of regular nodes, <span class="function">we use them only when bins contain enough nodes to warrant <span class="title">use</span> <span class="params">(see TREEIFY_THRESHOLD)</span>. And when they become too <span class="title">small</span> <span class="params">(due to removal or resizing)</span> they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="function"><span class="params">(http://en.wikipedia.org/wiki/Poisson_distribution)</span> with a parameter of about 0.5 on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k <span class="title">are</span> <span class="params">(exp(<span class="number">-0.5</span>)</span>*<span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span>/<span class="title">factorial</span><span class="params">(k)</span>).</span></span><br><span class="line"><span class="function">The first values are:</span></span><br><span class="line"><span class="function">因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点<span class="params">(参见TREEIFY_THRESHOLD)</span>。当它们变得太小<span class="params">(由于删除或调整大小)</span>时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从泊松分布</span></span><br><span class="line"><span class="function"><span class="params">(http://en.wikipedia.org/wiki/Poisson_distribution)</span>，默认调整阈值为0.75，平均参数约为0.5，尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是<span class="params">(exp(<span class="number">-0.5</span>)</span>*<span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span>/<span class="title">factorial</span><span class="params">(k)</span>)。</span></span><br><span class="line"><span class="function">第一个值是:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">0:    0.60653066</span></span><br><span class="line"><span class="function">1:    0.30326533</span></span><br><span class="line"><span class="function">2:    0.07581633</span></span><br><span class="line"><span class="function">3:    0.01263606</span></span><br><span class="line"><span class="function">4:    0.00157952</span></span><br><span class="line"><span class="function">5:    0.00015795</span></span><br><span class="line"><span class="function">6:    0.00001316</span></span><br><span class="line"><span class="function">7:    0.00000094</span></span><br><span class="line"><span class="function">8:    0.00000006</span></span><br><span class="line"><span class="function">more: less than 1 in ten million</span></span><br></pre></td></tr></table></figure><p>TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点时才会转成TreeNodes，而是否足够多就是由TREEIFY_THRESHOLD的值决定的。当bin中节点数变少时，又会转成普通的bin。并且我们查看源码的时候发现，链表长度达到8就转成红黑树，当长度降到6就转成普通bin。</p><p>这样就解释了为什么不是一开始就将其转换为TreeNodes，而是需要一定节点数才转为TreeNodes，说白了就是权衡，空间和时间的权衡。</p><p> 这段内容还说到：当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是随便决定的，而是根据概率统计决定的。由此可见，发展将近30年的Java每一项改动和优化都是非常严谨和科学的。 </p><p>也就是说：选择8因为符合泊松分布，超过8的时候，概率已经非常小了，所以我们选择8这个数字。</p><p>补充：</p><p>1）.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Poisson分布(泊松分布)，是一种统计与概率学里常见到的离散[概率分布]。</span><br><span class="line">泊松分布的概率函数为：</span><br></pre></td></tr></table></figure><p><img data-src="image-20191115161055901.png" alt="image-20191115161055901.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泊松分布的参数λ是单位时间(或单位面积)内随机事件的平均发生次数。 泊松分布适合于描述单位时间内随机事件发生的次数。</span><br></pre></td></tr></table></figure><p>2）.以下是我在研究这个问题时，在一些资料上面翻看的解释：供大家参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">红黑树的平均查找长度是log(n)，如果长度为8，平均查找长度为log(8)&#x3D;3，链表的平均查找长度为n&#x2F;2，当长度为8时，平均查找长度为8&#x2F;2&#x3D;4，这才有转换成树的必要；链表长度如果是小于等于6，6&#x2F;2&#x3D;3，而log(6)&#x3D;2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</span><br></pre></td></tr></table></figure><p><strong>6.当链表的值小于6则会从红黑树转回链表</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>7.当Map里面的数量超过这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶中结构转化为红黑树对应的数组长度最小的值 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p><strong>8、table用来初始化(必须是二的n次幂)(重点)</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储元素的数组 </span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p><strong>table</strong>在JDK1.8中我们了解到HashMap是由数组加链表加红黑树来组成的结构其中table就是HashMap中的数组，jdk8之前数组类型是Entry&lt;K,V&gt;类型。从jdk1.8之后是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V&gt;。负责存储键值对数据的。</p><p>9、用来存放缓存 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;存放具体元素的集合</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p><strong>10、 HashMap中存放元素的个数(重点)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p><strong>size</strong>为HashMap中K-V的实时数量，不是数组table的长度。</p><p>11、 用来记录HashMap的修改次数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>12、 用来调整大小下一个容量的值计算方式为(容量*负载因子) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 临界值 当实际大小(容量*负载因子)超过临界值时，会进行扩容</span><br><span class="line">int threshold;</span><br></pre></td></tr></table></figure><p><strong>13、 哈希表的加载因子(重点)</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>1.<strong>loadFactor</strong>加载因子，是用来衡量 HashMap 满的程度，<strong>表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率</strong>，计算HashMap的实时加载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。capacity 是桶的数量，也就是 table 的长度length。</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p><p><strong>当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。，所以开发中尽量减少扩容的次数，可以通过创建HashMap集合对象时指定初始容量来尽量避免。</strong></p><p><strong>同时在HashMap的构造器中可以定制loadFactor。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造方法：</span><br><span class="line">HashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor) 构造一个带指定初始容量和加载因子的空 HashMap。</span><br></pre></td></tr></table></figure><p>2.为什么加载因子设置为0.75,初始化临界值是12？</p><p>loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><img data-src="image-20191115173553375.png" alt="image-20191115173553375.png"></p><p>如果希望链表尽可能少些。要提前扩容，有的数组空间有可能一直没有存储数据。加载因子尽可能小一些。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：加载因子是0.4。 那么16*0.4---&gt;6 如果数组中满6个空间就扩容会造成数组利用率太低了。</span><br><span class="line"> 加载因子是0.9。 那么16*0.9----&gt;14 那么这样就会导致链表有点多了。导致查找元素效率低。</span><br></pre></td></tr></table></figure><p>所以既兼顾数组利用率又考虑链表不要太多，经过大量测试0.75是最佳方案。</p><ul><li><strong>threshold</strong>计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。这个值是当前已占用数组长度的最大值。<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的resize(扩容)，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。 扩容后的 HashMap 容量是之前容量的两倍.</li></ul><h3 id="4-2构造方法"><a href="#4-2构造方法" class="headerlink" title="4.2构造方法"></a>4.2构造方法</h3><p> HashMap 中重要的构造方法，它们分别如下： </p><p>1、构造一个空的 <code>HashMap</code> ，默认初始容量（16）和默认负载因子（0.75）。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// 将默认的加载因子0.75赋值给loadFactor，并没有创建数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 构造一个具有指定的初始容量和默认负载因子（0.75） <code>HashMap</code>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>3、 构造一个具有指定的初始容量和负载因子的 <code>HashMap</code>。我们来分析一下。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"><span class="comment"> initialCapacity: 指定的容量</span></span><br><span class="line"><span class="comment"> loadFactor:指定的加载因子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断初始化容量initialCapacity是否小于0</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果小于0，则抛出非法的参数异常IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    <span class="comment">//判断初始化容量initialCapacity是否大于集合的最大容量MAXIMUM_CAPACITY-》2的30次幂</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="comment">//如果超过MAXIMUM_CAPACITY，会将MAXIMUM_CAPACITY赋值给initialCapacity</span></span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//判断负载因子loadFactor是否小于等于0或者是否是一个非数值</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="comment">//如果满足上述其中之一，则抛出非法的参数异常IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">     <span class="comment">//将指定的加载因子赋值给HashMap成员变量的负载因子loadFactor</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    tableSizeFor(initialCapacity) 判断指定的初始化容量是否是2的n次幂，如果不是那么会变为比指定初始化容量大的最小的2的n次幂。这点上述已经讲解过。</span></span><br><span class="line"><span class="comment">    但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边界值了。有些人会觉得这里是一个bug,应该这样书写：</span></span><br><span class="line"><span class="comment">    this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;</span></span><br><span class="line"><span class="comment">    这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。</span></span><br><span class="line"><span class="comment">但是，请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推 迟到了put方法中，在put方法中会对threshold重新计算，put方法的具体实现我们下面会进行讲解</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">最后调用了tableSizeFor，来看一下方法实现：</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">       返回比指定初始化容量大的最小的2的n次幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>对于 this.threshold = tableSizeFor(initialCapacity); 疑问解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tableSizeFor(initialCapacity) 判断指定的初始化容量是否是<span class="number">2</span>的n次幂，如果不是那么会变为比指定初始化容量大的最小的<span class="number">2</span>的n次幂。这点上述已经讲解过。</span><br><span class="line">但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边界值了。有些人会觉得这里是一个bug,应该这样书写：</span><br><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity) * <span class="keyword">this</span>.loadFactor;</span><br><span class="line">这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。</span><br><span class="line">但是，请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推 迟到了put方法中，在put方法中会对threshold重新计算，put方法的具体实现我们下面会进行讲解</span><br></pre></td></tr></table></figure><p>4、包含另一个“Map”的构造函数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个映射关系与指定 Map 相同的新 HashMap。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//负载因子loadFactor变为默认的负载因子0.75</span></span><br><span class="line">         <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">         putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后调用了putMapEntries，来看一下方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取参数集合的长度</span></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断参数集合的长度是否大于0，说明大于0</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>)  <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p> float ft = ((float)s / loadFactor) + 1.0F;这一行代码中为什么要加1.0F ？</p><p> s/loadFactor的结果是小数，加1.0F与(int)ft相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少resize的调用次数。所以 + 1.0F是为了获取更大的容量。 </p><p>例如：原来集合的元素个数是6个，那么6/0.75是8，是2的n次幂，那么新的数组大小就是8了。然后原来数组的数据就会存储到长度是8的新的数组中了，这样会导致在存储元素的时候，容量不够，还得继续扩容，那么性能降低了，而如果+1呢，数组长度直接变为16了，这样可以减少数组的扩容。</p><h3 id="4-3成员方法"><a href="#4-3成员方法" class="headerlink" title="4.3成员方法"></a>4.3成员方法</h3><h4 id="4-3-1增加方法"><a href="#4-3-1增加方法" class="headerlink" title="4.3.1增加方法"></a>4.3.1增加方法</h4><p>put方法是比较复杂的，实现步骤大致如下：</p><p>1）先通过hash值计算出key映射到哪个桶；</p><p>2）如果桶上没有碰撞冲突，则直接插入；</p><p>3）如果出现碰撞冲突了，则需要处理冲突：</p><p>​    a:如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；</p><p>​    b:否则采用传统的链式方法插入。如果链的长度达到临界值，则把链转变为红黑树；</p><p>4）如果桶中存在重复的键，则为该键替换新值value；</p><p>5）如果size大于阈值threshold，则进行扩容；</p><p>具体的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明： </p><p>​    1）HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。 所以我们重点看putVal方法。</p><pre><code>2）我们可以看到在putVal()方法中key在这里执行了一下hash()方法,来看一下Hash方法是如何实现的。 </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）如果key等于null：</span></span><br><span class="line"><span class="comment">    可以看到当key等于null的时候也是有哈希值的，返回的是0.</span></span><br><span class="line"><span class="comment">    2）如果key不等于null：</span></span><br><span class="line"><span class="comment">    首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的hash值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以得知HashMap是支持Key为空的，而HashTable是直接用Key来获取HashCode所以key为空会抛异常。</p><p>{其实上面就已经解释了为什么HashMap的长度<strong>为什么要是2的幂</strong>因为HashMap 使用的方法很巧妙，它通过 hash &amp; (table.length -1)来得到该对象的保存位，前面说过 HashMap 底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当 length 总是2的n次方时，hash &amp; (length-1)运算等价于对 length 取模，也就是hash%length，但是&amp;比%具有更高的效率。比如 n % 32 = n &amp; (32 -1)。}</p><p><strong>解读上述hash方法：</strong></p><p>我们先研究下key的哈希值是如何计算出来的。key的哈希值是通过上述方法计算出来的。</p><p>这个哈希方法首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的    hash值。计算过程如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）如果key等于null：</span></span><br><span class="line"><span class="comment">    可以看到当key等于null的时候也是有哈希值的，返回的是0.</span></span><br><span class="line"><span class="comment">    2）如果key不等于null：</span></span><br><span class="line"><span class="comment">    首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的hash值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在putVal函数中使用到了上述hash函数计算的哈希值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        。。。。。。。。。。。。。。</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//这里的n表示数组长度16</span></span><br><span class="line">       。。。。。。。。。。。。。。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>计算过程如下所示：</p><p>​    说明：</p><p>​        1）key.hashCode()；返回散列值也就是hashcode。假设随便生成的一个值。</p><p>​        2）n表示数组初始化的长度是16</p><p>​        3）&amp;（按位与运算）：运算规则：相同的二进制数位上，都是1的时候，结果为1，否则为零。</p><p>​        4）^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为0，不同为1。</p><p><img data-src="image-20191114193730911.png" alt="image-2019111419370911.png"></p><p>简单来说就是：</p><ul><li><p>高16 bit 不变，低16 bit 和高16 bit 做了一个异或（得到的 hashcode 转化为32位二进制，前16位和后16位低16 bit和高16 bit做了一个异或）</p><p><strong>问题：为什么要这样操作呢？</strong></p><p>如果当n即数组长度很小，假设是16的话，那么n-1即为  —》1111 ，这样的值和hashCode()直接做按位与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如上述：</span><br><span class="line">hashCode()值：     <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1110</span> <span class="number">1010</span></span><br><span class="line">&amp;</span><br><span class="line">n-<span class="number">1</span>即<span class="number">16</span>-<span class="number">1</span>--》<span class="number">15</span>：  。。。。。。。。。。。。。。。。。。。。。。<span class="number">1111</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">  <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span> ----》<span class="number">10</span>作为索引</span><br><span class="line">其实就是将hashCode值作为数组索引，那么如果下个高位hashCode不一致，低位一致的话，就会造成计算的索引还是<span class="number">10</span>,从而造成了哈希冲突了。降低性能。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>(n-1) &amp; hash = -&gt; 得到下标   (n-1)   n表示数组长度16，n-1就是15</p></li><li><p>取余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低。</p></li></ul><p>现在看putVal()方法，看看它到底做了什么。</p><p>主要参数：</p><ul><li>hash key的hash值</li><li>key 原始Key</li><li>value 要存放的值</li><li>onlyIfAbsent 如果true代表不更改现有的值</li><li>evict 如果为false表示table为创建状态</li></ul><p>putVal()方法源代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）transient Node&lt;K,V&gt;[] table; 表示存储Map集合中元素的数组。</span></span><br><span class="line"><span class="comment">    2）(tab = table) == null 表示将空的table赋值给tab,然后判断tab是否等于null，第一次肯定是null</span></span><br><span class="line"><span class="comment">    3）(n = tab.length) == 0 表示将数组的长度0赋值给n,然后判断n是否等于0，n等于0</span></span><br><span class="line"><span class="comment">    由于if判断使用双或，满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化。</span></span><br><span class="line"><span class="comment">    并将初始化好的数组长度赋值给n.</span></span><br><span class="line"><span class="comment">    4）执行完n = (tab = resize()).length，数组tab每个空间都是null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）i = (n - 1) &amp; hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中</span></span><br><span class="line"><span class="comment">    2）p = tab[i = (n - 1) &amp; hash]表示获取计算出的位置的数据赋值给节点p</span></span><br><span class="line"><span class="comment">    3) (p = tab[i = (n - 1) &amp; hash]) == null 判断节点位置是否等于null，如果为null，则执行代码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的节点放入该位置的桶中</span></span><br><span class="line"><span class="comment">        小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//创建一个新的节点存入到桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 执行else说明tab[i]不等于null，表示这个位置已经有值了。</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较桶中第一个元素(数组中的结点)的hash值和key是否相等</span></span><br><span class="line"><span class="comment">        1）p.hash == hash ：p.hash表示原来存在数据的hash值  hash表示后添加数据的hash值 比较两个 hash值是否相等</span></span><br><span class="line"><span class="comment">                 说明：p表示tab[i]，即 newNode(hash, key, value, null)方法返回的Node对象。</span></span><br><span class="line"><span class="comment">                    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) </span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    而在Node类中具有成员变量hash用来记录着之前数据的hash值的</span></span><br><span class="line"><span class="comment">             2）(k = p.key) == key ：p.key获取原来数据的key赋值给k  key 表示后添加数据的key 比较两个key的地址值是否相等</span></span><br><span class="line"><span class="comment">             3）key != null &amp;&amp; key.equals(k)：能够执行到这里说明两个key的地址值不相等，那么先判断后添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                说明：两个元素哈希值相等，并且key的值也相等</span></span><br><span class="line"><span class="comment">                将旧的元素整体对象赋值给e，用e来记录</span></span><br><span class="line"><span class="comment">                */</span> </span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等或者key不相等；判断p是否为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 说明是链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1)如果是链表的话需要遍历到最后节点然后插入</span></span><br><span class="line"><span class="comment">            2)采用循环遍历的方式，判断链表中是否有重复的key</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                1)e = p.next 获取p的下一个元素赋值给e</span></span><br><span class="line"><span class="comment">                2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键</span></span><br><span class="line"><span class="comment">                将该键值对插入链表中</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    1）创建一个新的节点插入到尾部</span></span><br><span class="line"><span class="comment">                     p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                     Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) </span></span><br><span class="line"><span class="comment">                     &#123;</span></span><br><span class="line"><span class="comment">                                return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                         &#125;</span></span><br><span class="line"><span class="comment">                         注意第四个参数next是null，因为当前元素插入到链表末尾了，那么下一个节点肯定是null</span></span><br><span class="line"><span class="comment">                         2）这种添加方式也满足链表数据结构的特点，每次向后添加新的元素</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    1)节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于</span></span><br><span class="line"><span class="comment">                    则将链表转换为红黑树</span></span><br><span class="line"><span class="comment">                    2）int binCount = 0 ：表示for循环的初始化值。从0开始计数。记录着遍历节点的个数。值是0表示第一个节点，1表示第二个节点。。。。7表示第八个节点，加上数组中的的一个元素，元素个数是9</span></span><br><span class="line"><span class="comment">                    TREEIFY_THRESHOLD - 1 --》8 - 1 ---》7</span></span><br><span class="line"><span class="comment">                    如果binCount的值是7(加上数组中的的一个元素，元素个数是9)</span></span><br><span class="line"><span class="comment">                    TREEIFY_THRESHOLD - 1也是7，此时转换红黑树</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//转换为红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                执行到这里说明e = p.next 不是null，不是最后一个元素。继续判断链表中结点的key值与插  入的元素的key值是否相等</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                要添加的元素和链表中的存在的元素的key相等了，则跳出for循环。不用再继续比较了</span></span><br><span class="line"><span class="comment">                直接执行下面的if语句去替换去 if (e != null) </span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                说明新添加的元素和当前节点不相等，继续查找下一个节点。</span></span><br><span class="line"><span class="comment">                用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line"><span class="comment">        也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，并返回旧值</span></span><br><span class="line"><span class="comment">        这里完成了put方法的修改功能</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                <span class="comment">//e.value 表示旧值  value表示新值 </span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改记录次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 判断实际大小是否大于threshold阈值，如果超过则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2将链表转换为红黑树的treeifyBin方法"><a href="#4-3-2将链表转换为红黑树的treeifyBin方法" class="headerlink" title="4.3.2将链表转换为红黑树的treeifyBin方法"></a>4.3.2将链表转换为红黑树的treeifyBin方法</h4><p>节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树，转换红黑树的方法  treeifyBin，整体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">   &#x2F;&#x2F;转换为红黑树 tab表示数组名  hash表示哈希值</span><br><span class="line">   treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure><p>treeifyBin方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">   替换指定哈希表的索引处桶中的所有链接节点，除非表太小，否则将修改大小。</span></span><br><span class="line"><span class="comment">   Node&lt;K,V&gt;[] tab = tab 数组名</span></span><br><span class="line"><span class="comment">   int hash = hash表示哈希值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64),</span></span><br><span class="line"><span class="comment">      就去扩容。而不是将节点变为红黑树。</span></span><br><span class="line"><span class="comment">      目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，那么重新计算哈希值</span></span><br><span class="line"><span class="comment">      ，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          <span class="comment">//扩容方法</span></span><br><span class="line">          resize();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化</span></span><br><span class="line"><span class="comment">          2）e = tab[index = (n - 1) &amp; hash]表示将数组中的元素取出赋值给e,e是哈希表中指定位置桶里的链表节点，从第一个开始</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="comment">//hd：红黑树的头结点   tl :红黑树的尾结点</span></span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="comment">//新创建一个树的节点，内容和当前链表节点e一致</span></span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                  <span class="comment">//将新创键的p节点赋值给红黑树的头结点</span></span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   p.prev = tl：将上一个节点p赋值给现在的p的前一个节点</span></span><br><span class="line"><span class="comment">                   tl.next = p;将现在节点p作为树的尾结点的下一个节点</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              e = e.next 将当前节点的下一个节点赋值给e,如果下一个节点不等于null</span></span><br><span class="line"><span class="comment">              则回到上面继续取出链表中节点转换为红黑树</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树</span></span><br><span class="line"><span class="comment">          而不是链表数据结构了</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>小结：上述操作一共做了如下几件事：</p><p>1.根据哈希表中元素个数确定是扩容还是树形化</p><p>2.如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</p><p>3.然后让桶中的第一个元素指向新创建的树根节点，替换桶的链表内容为树形化内容</p><h4 id="4-3-3扩容方法-resize"><a href="#4-3-3扩容方法-resize" class="headerlink" title="4.3.3扩容方法_resize"></a>4.3.3扩容方法_resize</h4><h5 id="4-3-3-1扩容机制"><a href="#4-3-3-1扩容机制" class="headerlink" title="4.3.3.1扩容机制"></a>4.3.3.1扩容机制</h5><p>想要了解HashMap的扩容机制你要有这两个问题</p><ul><li>1.什么时候才需要扩容</li><li>2.HashMap的扩容是什么</li></ul><p><strong>1.什么时候才需要扩容</strong></p><p>当HashMap中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75=12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。</p><p><strong>补充：</strong></p><p><strong>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。</strong></p><p><strong>2.HashMap的扩容是什么</strong></p><p> 进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 </p><p>HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n-1)&amp;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到”<strong>原位置+旧容量</strong>“这个位置。</p><p> 怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示： </p><p><img data-src="image-20191117110812839.png" alt="image-20191117110812839.png"></p><p> 因此元素在重新计算hash之后，因为n变为2倍，那么n-1的标记范围在高位多1bit(红色)，因此新的index就会发生这样的变化： </p><p><img data-src="image-20191117110934974.png" alt="image-20191117110934974.png"></p><p>说明：5是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以节点要么就在原来的位置，要么就被分配到”<strong>原位置+旧容量</strong>“这个位置。</p><p> 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就可以了，是0的话索引没变，是1的话索引变成“原索引+oldCap(<strong>原位置+旧容量</strong>)”。可以看看下图为16扩充为32的resize示意图： </p><p><img data-src="image-20191117111211630.png" alt="image-20191117111211630.png"></p><p>正是因为这样巧妙的rehash方式，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，在resize的过程中保证了rehash之后每个桶上的节点数一定小于等于原来桶上的节点数，保证了rehash之后不会出现更严重的hash冲突，均匀的把之前的冲突的节点分散到新的桶中了。</p><h5 id="4-3-3-2源码resize方法的解读"><a href="#4-3-3-2源码resize方法的解读" class="headerlink" title="4.3.3.2源码resize方法的解读"></a>4.3.3.2源码resize方法的解读</h5><p>下面是代码的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//得到当前数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//如果当前数组等于null长度返回0，否则返回当前数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//当前阀值点 默认是12(16*0.75)</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果老的数组长度大于0</span></span><br><span class="line">    <span class="comment">//开始计算扩容后的大小</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//修改阈值为int的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        没超过最大值，就扩充为原来的2倍</span></span><br><span class="line"><span class="comment">        1)(newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量</span></span><br><span class="line"><span class="comment">        2）oldCap &gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//老阈值点大于0 直接赋值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 老阈值赋值给新的数组长度</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 直接使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize最大上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的阀值 默认原来是12 乘以2之后变为24</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//newCap是新的数组长度--》32</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//判断旧数组是否等于空</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="comment">//遍历旧的哈希表的每个桶，重新计算桶里元素的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//原来的数据赋值为null 便于GC回收</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//判断数组是否有下一个引用</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//判断是否是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//说明是红黑树来处理冲突的，则调用相关方法把树分开</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 采用链表处理冲突</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//通过上述讲解的原理来计算节点的新位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                     <span class="comment">//这里来判断如果等于true e这个节点在resize之后不需要移动位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-删除方法-remove"><a href="#4-3-4-删除方法-remove" class="headerlink" title="4.3.4 删除方法(remove)"></a>4.3.4 删除方法(remove)</h4><p> 理解了put方法之后，remove方法已经没什么难度了，所以重复的内容就不再做详细介绍了。</p><p> 删除的话就是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于6的时候要转链表。 </p><p> 删除remove方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove方法的具体实现在removeNode方法中，所以我们重点看下removeNode方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> removeNode方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//根据hash找到位置 </span></span><br><span class="line">    <span class="comment">//如果当前key映射到的桶不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">//如果桶上的节点就是要找的key，则将node指向该节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明节点存在下一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//说明是以红黑树来处理的冲突，则获取红黑树要删除的节点</span></span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//判断是否以链表方式处理hash冲突，是的话则通过遍历链表来寻找要删除的节点</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较找到的key的value和要删除的是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="comment">//通过调用红黑树的方法来删除节点</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    <span class="comment">//链表删除</span></span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                <span class="comment">//记录修改次数</span></span><br><span class="line">                ++modCount;</span><br><span class="line">                <span class="comment">//变动的数量</span></span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-5查找元素方法-get"><a href="#4-3-5查找元素方法-get" class="headerlink" title="4.3.5查找元素方法(get)"></a>4.3.5查找元素方法(get)</h4><p> 查找方法，通过元素的Key找到Value。 </p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法主要调用的是getNode方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果哈希表不为空并且key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        判断数组元素是否相等</span></span><br><span class="line"><span class="comment">        根据索引的位置检查第一个元素</span></span><br><span class="line"><span class="comment">        注意：总是检查第一个元素</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果不是第一个元素，判断是否有后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树，是的话调用红黑树中的getTreeNode方法获取节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 不是红黑树的话，那就是链表结构了，通过循环的方法判断链表中是否存在该key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>1.get方法实现的步骤：</p><p>​    1）通过hash值获取该key映射到的桶</p><p>​    2）桶上的key就是要查找的key,则直接找到并返回</p><p>​    3）桶上的key不是要找的key,则查看后续的节点：</p><p>​            a:如果后续节点是红黑树节点，通过调用红黑树的方法根据key获取value</p><p>​            b:如果后续节点是链表节点，则通过循环遍历链表根据key获取value</p><p>2.上述红黑树节点调用的是getTreeNode方法通过树形节点的find方法进行查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">               TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">               <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                   p = pl;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                   p = pr;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                   <span class="keyword">return</span> p;<span class="comment">//找到之后直接返回</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                   p = pr;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                   p = pl;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                         (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                   p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">               <span class="comment">//递归查找</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> q;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   p = pl;</span><br><span class="line">           &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>3.查找红黑树，由于之前添加时已经保证这个树是有序的了，因此查找时基本就是折半查找，效率更高。</p><p>4.这里和插入时一样，如果对比节点的哈希值和要查找的哈希值相等，就会判断key是否相等，相等就直接返回。不相等就从子树中递归查找。</p><p>5.</p><p>​    若为树，则在树中通过key.equals(k)查找，O(logn) </p><p>​    若为链表，则在链表中通过key.equals(k)查找，O(n)。</p><h4 id="4-3-6遍历HashMap集合几种方式"><a href="#4-3-6遍历HashMap集合几种方式" class="headerlink" title="4.3.6遍历HashMap集合几种方式"></a>4.3.6遍历HashMap集合几种方式</h4><p> 1、分别遍历Key和Values </p><p><img data-src="image-20191117160455507.png" alt="image-2019111760455507.png"></p><p>2.使用迭代器Iterator</p><p><img data-src="image-20191117160627369.png" alt="image-20191117160627369.png"></p><p>3、通过get方式（不建议使用）</p><p><img data-src="image-20191117160733756.png" alt="image-20191117160733756.png"></p><p>说明：根据阿里开发手册，不建议使用这种方式，因为迭代两次。keySet获取Iterator一次，还有通过get又迭代一次。降低性能。</p><p>4.jdk8以后使用Map接口中的默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K,? <span class="keyword">super</span> V&gt; action)</span> </span></span><br><span class="line"><span class="function">BiConsumer接口中的方法：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span> 对给定的参数执行此操作。  </span></span><br><span class="line"><span class="function">参数 </span></span><br><span class="line"><span class="function">            t - 第一个输入参数 </span></span><br><span class="line"><span class="function">            u - 第二个输入参数</span></span><br></pre></td></tr></table></figure><p>遍历代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,String&gt; m1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        m1.put(<span class="string">"001"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">        m1.put(<span class="string">"002"</span>, <span class="string">"lisi"</span>);</span><br><span class="line">        m1.forEach((key,value)-&gt;&#123;</span><br><span class="line">            System.out.println(key+<span class="string">"---"</span>+value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-如何设计多个非重复的键值对要存储HashMap的初始化？"><a href="#5-如何设计多个非重复的键值对要存储HashMap的初始化？" class="headerlink" title="5.如何设计多个非重复的键值对要存储HashMap的初始化？"></a>5.如何设计多个非重复的键值对要存储HashMap的初始化？</h2><h3 id="5-1HashMap的初始化问题描述"><a href="#5-1HashMap的初始化问题描述" class="headerlink" title="5.1HashMap的初始化问题描述"></a>5.1HashMap的初始化问题描述</h3><p>​    如果我们确切的知道我们有多少键值对需要存储，那么我们在初始化HashMap的时候就应该指定它的容量，以防止HashMap自动扩容，影响使用效率。</p><p>​    默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(3-&gt;4、7-&gt;8、9-&gt;16) .这点我们在上述已经进行过讲解。</p><p> 《阿里巴巴Java开发手册》中建议我们设置HashMap的初始化容量。 </p><p><img data-src="2.bmp" alt="2.bmp"></p><p> 那么，为什么要这么建议？你有想过没有。 </p><p>当然，以上建议也是有理论支撑的。我们上面介绍过，HashMap的扩容机制，就是当达到扩容条件时会进行扩容。HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。在HashMap中，threshold = loadFactor * capacity。</p><p>所以，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会有可能发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。</p><p>但是设置初始化容量，设置的数值不同也会影响性能，那么当我们已知HashMap中即将存放的KV个数的时候，容量设置成多少为好呢？</p><h3 id="5-2HashMap中容量的初始化"><a href="#5-2HashMap中容量的初始化" class="headerlink" title="5.2HashMap中容量的初始化"></a>5.2HashMap中容量的初始化</h3><p>当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。那么，是不是我们只需要把已知的HashMap中即将存放的元素个数直接传给initialCapacity就可以了呢？</p><p>关于这个值的设置，在《阿里巴巴Java开发手册》有以下建议：</p><p><img data-src="image-20191117165438726.png" alt="image-20191117165438726.png"></p><p>也就是说，如果我们设置的默认值是7，经过Jdk处理之后，会被设置成8，但是，这个HashMap在元素个数达到 8*0.75 = 6的时候就会进行一次扩容，这明显是我们不希望见到的。我们应该尽量减少扩容。原因也已经分析过。</p><p>如果我们通过<strong>initialCapacity/ 0.75F + 1.0F</strong>计算，7/0.75 + 1 = 10 ,10经过Jdk处理之后，会被设置成16，这就大大的减少了扩容的几率。</p><p>当HashMap内部维护的哈希表的容量达到75%时（默认情况下），会触发rehash，而rehash的过程是比较耗费时间的。所以初始化容量要设置成<strong>initialCapacity/0.75 + 1</strong>的话，可以有效的减少冲突也可以减小误差。</p><p>所以，我可以认为，当我们明确知道HashMap中元素的个数的时候，把默认容量设置成<strong>initialCapacity/ 0.75F + 1.0F</strong>是一个在性能上相对好的选择，但是，同时也会牺牲些内存。</p><p>我们想要在代码中创建一个HashMap的时候，如果我们已知这个Map中即将存放的元素个数，给HashMap设置初始容量可以在一定程度上提升效率。</p><p>但是，JDK并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个2的幂。原因也已经分析过。</p><p>但是，为了最大程度的避免扩容带来的性能消耗，我们建议可以把默认容量的数字设置成<strong>initialCapacity/ 0.75F + 1.0F</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算------按位与、按位或、按位异或、取反、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</title>
      <link href="/2020/03/15/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2020/03/15/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>程序中的所有数在计算机内存中都是以二进制的形式储存的，位运算就是直接对整数在内存中的二进制位进行操作。</p><p><strong>1、原码、反码、补码(以byte的1、-1举例)</strong></p><p>示例                    1                      -1                                   </p><p>原码        0000 0001          1000 0001     ——&gt;第一位是符号位，0是正数，1为负数  </p><p>反码        0000 0001          1111 1110       ——&gt;正数反码是其自身，负数则符号位不变，其他位置全部取反</p><p>补码        0000 0001          1111 1111       ——-&gt;正数补码是其自身，负数则为反码+1</p><p>当然也可以从1通过取反，然后+1的方式得到-1的补码</p><p><strong>2、补码：用于将十进制的负整数转换为二进制数。十进制的正整数可以除以2取余，负整数则需要补码。</strong></p><p>  补码的流程：例如-10</p><p>　　10：0000 0000 0000 1010</p><p>​    取反：1111 1111   1111  0101</p><p>​                          +1</p><p>​    -10：1111  1111  1111  0110</p><p><strong>3、整数在内存中以补码存在。</strong></p><h2 id="一、按位与-amp"><a href="#一、按位与-amp" class="headerlink" title="一、按位与(&amp;)"></a><strong>一、按位与(&amp;)</strong></h2><p><strong>定义：如果两个相应的二进制位都为1，则该位的结果值为1，否则为0.</strong></p><p>示例：</p><h3 id="1、10与-10-amp-运算"><a href="#1、10与-10-amp-运算" class="headerlink" title="1、10与-10 &amp;运算"></a>1、10与-10 &amp;运算</h3><p>10：0000 0000 0000 1010     —–&gt;   十进制转二进制</p><p>-10：1111  1111  1111  0110     —–&gt;   -10就是10取反，然后+1(补码)</p><p>结果: 0000 0000 0000 0010     —–&gt;   结果为2</p><h2 id="二、按位或"><a href="#二、按位或" class="headerlink" title="二、按位或(|)"></a><strong>二、按位或(|)</strong></h2><p><strong>定义：如果两个相应的二进制位有一个为1，则该结果为1，否则为0.</strong></p><p>示例：</p><h3 id="1、10与-10-运算"><a href="#1、10与-10-运算" class="headerlink" title="1、10与-10 |运算"></a>1、10与-10 |运算</h3><p> 10：0000 0000 0000 1010</p><p>-10：1111  1111  1111  0110</p><p>结果: 1111  1111 1111   1110  —–&gt;结果-2</p><p>第一位为符号位，1代表是负数，因此是补码形式存在，补码–&gt;十进制。先-1再取反(符号位不变)，。</p><p>1000 0000 0000 0001</p><p>+1</p><p>1000 0000 0000 0010 ——&gt; -2</p><h2 id="三、按位异或"><a href="#三、按位异或" class="headerlink" title="三、按位异或(^)"></a><strong>三、按位异或(^)</strong></h2><p><strong>定义：如果两个相应的二进制位值不同则为1，否则为0</strong></p><p>示例：</p><h3 id="1、10与-10-运算-1"><a href="#1、10与-10-运算-1" class="headerlink" title="1、10与-10 ^运算"></a>1、10与-10 ^运算</h3><p> 10：0000 0000 0000 1010</p><p>-10：1111  1111  1111  0110</p><p>结果: 1111  1111 1111   1100  ——&gt; 结果-4</p><h2 id="四、取反"><a href="#四、取反" class="headerlink" title="四、取反(~)"></a><strong>四、取反(~)</strong></h2><p><strong>定义：用来对一个二进制按位取反。</strong></p><p>示例：</p><h3 id="1、10取反"><a href="#1、10取反" class="headerlink" title="1、10取反"></a>1、10取反</h3><p>10：0000 0000 0000 1010</p><p>结果: 1111  1111 1111  0101 ——&gt; 结果-11</p><h2 id="五、左移-lt-lt"><a href="#五、左移-lt-lt" class="headerlink" title="五、左移(&lt;&lt;)"></a><strong>五、左移(&lt;&lt;)</strong></h2><p><strong>定义：将一个数的各二进制位全部左移N位，右补0</strong></p><p>示例：</p><h3 id="1、10左移-lt-lt-2"><a href="#1、10左移-lt-lt-2" class="headerlink" title="1、10左移&lt;&lt;2"></a>1、10左移&lt;&lt;2</h3><p>10：0000 0000 0000 1010</p><p>结果: 0000 0000 0010 1000——&gt; 结果40</p><h2 id="六、右移-gt-gt"><a href="#六、右移-gt-gt" class="headerlink" title="六、右移(&gt;&gt;)"></a><strong>六、右移(&gt;&gt;)</strong></h2><p><strong>定义：将一个数的各二进制位全部右移N位，移到右边的低位被舍弃，对于无符号数高位补0，负数高位补1.</strong></p><h3 id="1、10右移-gt-gt-2"><a href="#1、10右移-gt-gt-2" class="headerlink" title="1、10右移&gt;&gt;2"></a>1、10右移&gt;&gt;2</h3><p>10：0000 0000 0000 1010</p><p>结果: 0000 0000 0000 0010——&gt; 结果2</p><h3 id="2、-10右移-gt-gt-2"><a href="#2、-10右移-gt-gt-2" class="headerlink" title="2、-10右移&gt;&gt;2"></a>2、-10右移&gt;&gt;2</h3><p>-10：1111  1111  1111  0110</p><p>结果: 1111  1111 1111   1101</p><p>　　　　　 -1</p><p>​          1111  1111 1111   1100</p><p>​          取反，符号位不变</p><p>​           1000 0000 0000 0011</p><p>结果：-3</p><h2 id="七、-gt-gt-gt-无符号右移"><a href="#七、-gt-gt-gt-无符号右移" class="headerlink" title="七、&gt;&gt;&gt;(无符号右移)"></a><strong>七、&gt;&gt;&gt;(无符号右移)</strong></h2><p><strong>定义：将一个数的各二进制位全部右移N位，移到右边的低位被舍弃，对于无符号数高位补0，只是对32位和64位的值有意义。</strong></p><p>示例：</p><h3 id="1、-10-gt-gt-gt-2"><a href="#1、-10-gt-gt-gt-2" class="headerlink" title="1、-10&gt;&gt;&gt;2"></a>1、-10&gt;&gt;&gt;2</h3><p>-10：1111 1111 1111 1111 1111  1111  1111  0110  ——-&gt;由于&gt;&gt;&gt;只对32和64位有意义，所以把-10定义成32位的</p><p>结果: 0011  1111 1111 1111 1111 1111 1111 1101</p><p>　　　　　　-1</p><p>​          0011  1111 1111 1111 1111 1111 1111 1100</p><p>​             取反码(符号位不变，正数反码是其本身)</p><p>​         0011  1111 1111 1111 1111 1111 1111 1100</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap底层实现原理是什么?jdk8做了哪些优化?</title>
      <link href="/2020/03/13/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-jdk8%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/"/>
      <url>/2020/03/13/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-jdk8%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>HashMap 是使用频率最高的类型之一，同时也是面试经常被问到的问题之一，这是因为HashMap<br>的知识点有很多，同时它又属于Java基础知识的一部分，因此在面试中经常被问到。<br>本课时的面试题是，HashMap底层是如何实现的？在JDK1.8中它都做了哪些优化？<br><strong>典型回答</strong><br>在JDK1.7中HashMap是以数组加链表的形式组成的，JDK1.8之后新增了红黑树的组成结构，当链表大于8时，链表结构会转换成红黑树结构，它的组成结构如下图所示：</p><p><img data-src="1.png" alt="1"></p><p>数组中的元素我们称之为哈希桶，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line"> V value;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="keyword">this</span>.hash = hash;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">V oldValue = value;</span><br><span class="line">value = newValue;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"><span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">Objects.equals(value, e.getValue()))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出每个哈希桶中包含了四个字段：hash、key、value、next，其中next 表示链表的下一个节点。<br>JDK 1.8之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。</p><p><strong>考点分析</strong><br>上面大体介绍了HashMap的组成结构，但面试官想要知道的远远不止这些，和HashMap相关的面试题还有以下几个：</p><ul><li>JDK 1.8 HashMap 扩容时做了哪些优化？</li><li>加载因子为什么是0.75？</li><li>当有哈希冲突时，HashMap是如何查找并确认元素的？</li><li>HashMap 源码中有哪些重要的方法？</li><li>HashMap是如何导致死循环的？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-HashMap源码分析"><a href="#1-HashMap源码分析" class="headerlink" title="1.HashMap源码分析"></a>1.HashMap源码分析</h3><p>声明：本系列课程在未做特殊说明的情况下，都是以目前主流的JDK版本1.8为例来进行源码分析的。</p><p>HashMap源码中包含了以下几个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 初始化长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 最大长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的加载因子 (扩容因子)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换红黑树的临界值，当链表长度大于此值时，会把链表结构转换为红黑树结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换链表的临界值，当元素小于此值时，会将红黑树结构转换成链表结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小树容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY =</span><br></pre></td></tr></table></figure><p><strong>什么是加载因子？加载因子为什么是0.75？</strong><br>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是0.5，HashMap<br>的初始化容量是16，那么当HashMap中有16*0.5=8个元素时，HashMap就会进行扩容。</p><p><strong>那加载因子为什么是0.75而不是0.5或者1.0呢？</strong><br>这其实是出于容量和性能之间平衡的结果：</p><ul><li>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</li><li>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</li></ul><p>所以综合了以上情况就取了一个0.5到1.0的平均数0.75作为加载因子。</p><p>HashMap源码中三个重要方法：<strong>查询</strong>、<strong>新增</strong>和<strong>数据扩容</strong>。<br>先来看查询源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 对 key 进行哈希操作</span></span><br><span class="line"><span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"><span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个元素是否是要查询的元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 下一个节点非空判断</span></span><br><span class="line"><span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果第一节点是树结构，则使用 getTreeNode 直接获取相应的数据</span></span><br><span class="line"><span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// 非树结构，循环节点判断</span></span><br><span class="line">                <span class="comment">// hash 相等并且 key 相同，则返回此节点</span></span><br><span class="line"> <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，当哈希冲突时我们需要通过判断key值是否相等，才能确认此元素是不是我们想要的元素。<br>HashMap第二个重要方法：<strong>新增方法</strong>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对 key 进行哈希操作</span></span><br><span class="line"><span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 哈希表为空则创建表  </span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"> <span class="comment">// 根据 key 的哈希值计算出要插入的数组索引 i    </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line"> <span class="comment">// 如果 table[i] 等于 null，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">// 如果 key 已经存在了，直接覆盖 value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"> <span class="comment">// 如果 key 不存在，判断是否为红黑树     </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="comment">// 红黑树直接插入键值对</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 为链表结构，循环准备插入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 下一个元素为空时</span></span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度大于 8 转换为红黑树进行处理</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> <span class="comment">//  key 已经存在直接覆盖 value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过最大容量，扩容</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增方法的执行流程，如下图所示：</p><p><img data-src="2.png" alt="2"></p><p>HashMap 第三个重要的方法是扩容方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 扩容前的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 扩容前的数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 预定义新数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩大容量为当前容量的两倍，但不能超过 MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 当前数组没有数据，使用初始化的值</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 如果初始化的值为 0，则使用默认的初始化容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的容量等于 0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">     Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 开始扩容，将新的容量赋值给 table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 原数据不为空，将原数据复制到新 table 中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据容量循环数组，复制非空元素到新 table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果链表只有一个，则进行直接赋值</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 红黑树相关的操作</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表复制，JDK 1.8 扩容优化部分</span></span><br><span class="line">                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                         <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                             &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将原索引放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="comment">// 将原索引 + oldCap 放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，JDK1.8在扩容时并没有像JDK1.7那样，重新计算每个元素的哈希值，而是通过高位运算（e.hash&amp;oldCap）来确定元素是否需要移动，比如key1的信息如下：</p><ul><li>key1.hash=10 0000 1010</li><li>oldCap=16 00010000</li></ul><p>使用e.hash&amp;oldCap得到的结果高一位为0，当结果为0时表示元素在扩容时位置不会发生任何变化，而key 2信息如下：</p><ul><li>key2.hash=10 0001 0001</li><li>oldCap=1600010000</li></ul><p>这时候得到的结果高一位为1，当结果为1时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置+原数组长度，如下图所示：</p><p><img data-src="3.png" alt="3"></p><p>其中红色的虚线图代表了扩容时元素移动的位置。</p><h3 id="2-HashMap-死循环分析"><a href="#2-HashMap-死循环分析" class="headerlink" title="2.HashMap 死循环分析"></a>2.HashMap 死循环分析</h3><p>以JDK1.7为例，假设HashMap默认大小为2，原本HashMap中有一个元素key（5），我们再使用两个线程：t1添加元素key（3），t2添加元素key（7），当元素key（3）和key（7）都添加到HashMap<br>中之后，线程t1在执行到Entry&lt;K，V&gt;next=e.next；时，交出了CPU的使用权，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程一执行此处</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此时线程t1中的e指向了key（3），而next 指向了key（7）；之后线程t2重新rehash 之后链表的顺序被反转，链表的位置变成了key（5）→key（7）→key（3），其中“→”用来表示下一个元素。<br>当t1重新获得执行权之后，先执行newTalbe[i]=e把key（3）的next 设置为key（7），而下次循环时查询到key（7）的next 元素为key（3），于是就形成了key（3）和key（7）的循环引用，因此就导致了死循环的发生，如下图所示：</p><p><img data-src="4.png" alt="4"></p><p>当然发生死循环的原因是JDK1.7链表插入方式为首部倒序插入，这个问题在JDK1.8得到了改善，变成了尾部正序插入。<br>有人曾经把这个问题反馈给了Sun公司，但Sun公司认为这不是一个问题，因为HashMap本身就是非线程安全的，如果要在多线程下，建议使用ConcurrentHashMap替代，但这个问题在面试中被问到的几率依然很大，所以在这里需要特别说明一下。</p><p><strong>小结</strong></p><p>本课时介绍了HashMap的底层数据结构，在JDK1.7时HashMap是由数组和链表组成的，而JDK<br>1.8则新增了红黑树结构，当链表的长度大于8时会转换为红黑树存储，以提升元素的操作性能。同时还介绍了HashMap的三个重要方法，查询、添加和扩容，以及JDK1.7 resize0在并发环境下导致死循环的原因。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 美团点评2020校招后台开发方向笔试题 </title>
      <link href="/2020/03/12/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%842020%E6%A0%A1%E6%8B%9B%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2020/03/12/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%842020%E6%A0%A1%E6%8B%9B%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-RESTful调用和-RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service-Mesh，如果了解Service-Mesh是用来解决什么问题的？"><a href="#1-RESTful调用和-RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service-Mesh，如果了解Service-Mesh是用来解决什么问题的？" class="headerlink" title="1.RESTful调用和 RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service Mesh，如果了解Service Mesh是用来解决什么问题的？"></a>1.RESTful调用和 RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service Mesh，如果了解Service Mesh是用来解决什么问题的？</h3><p>1、RESTful<strong>是一种软件架构风格</strong>，<strong>用于约束客户端和服务器交互</strong>，满足这些约束条件和原则的应用程序或设计就是 RESTful。比如HTTP协议使用同一个URL地址，通过GET，POST，PUT，DELETE等方式实现查询、提交、删除数据。</p><p>RPC是<strong>远程过程调用</strong>，是用于<strong>解决分布式系统服务间调用的一种方式</strong>。RPC采用客户端与服务端模式，双方通过约定的接口（常见为通过IDL定义或者是代码定义）以类似本地方法调用的方式来进行交互，客户端根据约定传输调用函数+参数给服务端（一般是网络传输TCP/UDP），服务端处理完按照约定将返回值返回给客户端。</p><p><strong>重点为RESTful HTTP的约束风格，RPC调用模型。</strong></p><p>1、可分为两大部分RPC +服务治理<br>RPC部分 = IDL  +客户端/服务端实现层  +协议层 +数据传输层<br>服务治理 =服务管理（注册中心） +服务监控 +服务容灾 +服务鉴权</p><p>2、 Service Mesh为了解决传统微服务框架”胖客户端”方式，引入的如下问题：<br>与业务无关的服务治理逻辑与业务代码强耦合，框架、SDK的升级与业务代码强绑定，多语言的胖客户端支持起来性价比极低。</p><h3 id="2-请描述避免多线程竞争时有哪些手段？"><a href="#2-请描述避免多线程竞争时有哪些手段？" class="headerlink" title="2.请描述避免多线程竞争时有哪些手段？"></a>2.请描述避免多线程竞争时有哪些手段？</h3><p>1) 不可变对象；</p><p>2) 互斥锁；</p><p>3)  ThreadLocal 对象；</p><p>4) CAS；</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p><strong>给出一个布尔表达式的字符串，比如：true or false and false，表达式只包含true，false，and和or，现在要对这个表达式进行布尔求值，计算结果为真时输出true、为假时输出false，不合法的表达时输出error（比如：true true）。表达式求值是注意and 的优先级比 or 要高，比如：true or false and false，等价于 true or (false and false)，计算结果是 true。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">        String str = cal();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine().trim();</span><br><span class="line"><span class="comment">//        String str = "false&amp;nbs***bsp;true and false";</span></span><br><span class="line">        String[] words = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(words));</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(<span class="string">"true"</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(<span class="string">"false"</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(<span class="string">"and"</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() != <span class="number">2</span> &amp;&amp; i != words.length - <span class="number">1</span></span><br><span class="line">                        &amp;&amp; (words[i + <span class="number">1</span>].equals(<span class="string">"true"</span>) || words[i + <span class="number">1</span>].equals(<span class="string">"false"</span>)))&#123;</span><br><span class="line">                    <span class="keyword">int</span> val = words[i + <span class="number">1</span>].equals(<span class="string">"true"</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                    stack.push(stack.pop() &amp; val);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(<span class="string">"or"</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(last == -<span class="number">1</span>)&#123;</span><br><span class="line">                last = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(last == <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> or = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(or != <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">                <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() != <span class="number">2</span>) val = stack.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">                last = last | val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last == <span class="number">1</span> ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>给出两个字符串，分别是模式串P和目标串T，判断模式串和目标串是否匹配，匹配输出 1，不匹配输出 0。模式串中‘？’可以匹配目标串中的任何字符，模式串中的 ’*’可以匹配目标串中的任何长度的串，模式串的其它字符必须和目标串的字符匹配。例如P=a?b，T=acb，则P 和 T 匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String p = sc.next();</span><br><span class="line">        String s = sc.next();</span><br><span class="line">        <span class="comment">// System.out.println(s + " - " + p);</span></span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; p.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((dp[m][n] ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      <categories>
          
          <category> 牛客真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String的特点是什么？它有哪些重要的方法？</title>
      <link href="/2020/03/11/String%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%20%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/11/String%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%20%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>几乎所有的Java面试都是以String开始的，如果第一个问题没有回答好，则会给面试官留下非常不好的第一印象，而糟糕的第一印象则会直接影响到自己的面试结果，就好像刚破壳的小鹅一样，会把第一眼看到的动物当成自己的母亲，即使它第一眼看到的是一只小狗或小猫，也会默认跟随其后，心理学把这种现象叫做<strong>印刻效应</strong>。印刻效应不仅存在于低等动物之中，同样也适用于人类，所以对于String的知识，我们必须深入的掌握才能为自己赢得更多的筹码。</p><p>本课时的问题是：String 是如何实现的？它有哪些重要的方法？</p><h3 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a><strong>典型回答</strong></h3><p>以主流的JDK版本1.8来说，String内部实际存储结构为char数组，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;，<span class="title">CharSequence</span></span>&#123;</span><br><span class="line">    <span class="comment">//用于存储字符串的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value [];</span><br><span class="line">    <span class="comment">//缓存字符串的 hash code </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;<span class="comment">//Default to 0</span></span><br><span class="line">    <span class="comment">//..其他内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 源码中包含下面几个重要的方法。</p><h3 id="1-多构造方法"><a href="#1-多构造方法" class="headerlink" title="1.多构造方法"></a>1.多构造方法</h3><p>String字符串有以下4个重要的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value =original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash =original.hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char[]为参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value=Arrays.copyof(value，value<span class="number">.1</span>ength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StringBuffer为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(buffer)&#123;</span><br><span class="line"><span class="keyword">this</span>.value=Arrays.copyof（buffer.getValue()，buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stringBuilder为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value =Arrays.copyof(builder.getValue()，builder<span class="number">.1</span>ength());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，比较容易被我们忽略的是以StringBuffer和StringBuilder为参数的构造函数，因为这三种数据类型，我们通常都是单独使用的，所以这个小细节我们需要特别留意一下。</p><h3 id="2-equals（）比较两个字符串是否相等"><a href="#2-equals（）比较两个字符串是否相等" class="headerlink" title="2.equals（）比较两个字符串是否相等"></a>2.equals（）比较两个字符串是否相等</h3><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对象引用相同直接返回 true </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==anObject)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断需要对比的值是否为String类型，如果不是则直接返回false </span></span><br><span class="line">    <span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">        String anotherString=(String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span>(n == anotherString.value.length)&#123;</span><br><span class="line">    <span class="comment">//把两个字符串都转换为char数组对比</span></span><br><span class="line">    <span class="keyword">char</span> vl[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环比对两个字符串的每一个字符</span></span><br><span class="line">    <span class="keyword">while</span>（n-- != <span class="number">0</span>）&#123;</span><br><span class="line">    <span class="comment">//如果其中有一个字符不相等就 true false，否则继续对比</span></span><br><span class="line">                <span class="keyword">if</span>(vl[i] != v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 类型重写了Object中的equals(）方法，equals(）方法需要传递一个Object类型的参数值，在比较时会先通过instanceof 判断是否为String 类型，如果不是则会直接返回false，instanceof的使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object oString=<span class="string">"123"</span>;</span><br><span class="line">Object oInt =<span class="number">123</span>;</span><br><span class="line">System.out.println(oString <span class="keyword">instanceof</span> String);<span class="comment">//返回 true</span></span><br><span class="line">System.out.println(oInt <span class="keyword">instanceof</span> String);<span class="comment">//返回false</span></span><br></pre></td></tr></table></figure><p>当判断参数为String类型之后，会循环对比两个字符串中的每一个字符，当所有字符都相等时返回true，否则则返回false。<br>还有一个和equals0比较类似的方法equalslgnoreCase0，它是用于忽略字符串的大小写之后进行字符串对比。</p><h3 id="3-compareTo（）比较两个字符串"><a href="#3-compareTo（）比较两个字符串" class="headerlink" title="3.compareTo（）比较两个字符串"></a>3.compareTo（）比较两个字符串</h3><p>compareTo0方法用于比较两个字符串，返回的结果为int类型的值，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenl=value.length;</span><br><span class="line">    <span class="keyword">int</span> len2=anotherString.value.length;</span><br><span class="line">    <span class="comment">//获取到两个字符串长度最短的那个int值</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">1</span>im=Math.min(<span class="number">1</span>en1，<span class="number">1</span>en2);</span><br><span class="line">    <span class="keyword">char</span> vl[]=value;</span><br><span class="line">    <span class="keyword">char</span> v2[]=anotherString.value;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对比每一个字符</span></span><br><span class="line">    <span class="keyword">while</span>(k &lt; lim)&#123;</span><br><span class="line"><span class="keyword">char</span> cl=vl[k];</span><br><span class="line"><span class="keyword">char</span> c2=v2[k];</span><br><span class="line"><span class="keyword">if</span>（c1 != c2）&#123;</span><br><span class="line"><span class="comment">//有字符不相等就返回差值</span></span><br><span class="line"><span class="keyword">return</span> c1-c2;</span><br><span class="line">        &#125;</span><br><span class="line">k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>en1 - <span class="number">1</span>en2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，compareTo0方法会循环对比所有的字符，当两个字符串中有任意一个字符不相同时，则return char1-char2。比如，两个字符串分别存储的是1和2，返回的值是-1；如果存储的是1和1，则返回的值是0，如果存储的是2和1，则返回的值是1。<br>还有一个和compareTo0 比较类似的方法compareTolgnoreCase0，用于忽略大小写后比较两个字符串。<br>可以看出compareTo0方法和equals0方法都是用于比较两个字符串的，但它们有两点不同：</p><ul><li>equals0可以接收一个Object 类型的参数，而compareTo0只能接收一个String类型的参数；    </li><li>equals0返回值为Boolean，而compareTo0的返回值则为int。</li></ul><p>它们都可以用于两个字符串的比较，当equals0方法返回true时，或者是compareTo0方法返回0时，则表示两个字符串完全相同。</p><h3 id="4-其他重要方法"><a href="#4-其他重要方法" class="headerlink" title="4.其他重要方法"></a>4.其他重要方法</h3><ul><li>indexOf(）：查询字符串首次出现的下标位置</li><li>lastlndexOf()：查询字符串最后出现的下标位置</li><li>contains()：查询字符串中是否包含另一个字符串</li><li>toLowerCase()：把字符串全部转换成小写</li><li>toUpperCase()：把字符串全部转换成大写</li><li>length()：查询字符串的长度</li><li>trim()：去掉字符串首尾空格</li><li>replace()：替换字符串中的某些字符</li><li>split()：把字符串分割并返回字符串数组</li><li>join()：把字符串数组转为字符串</li></ul><p><strong>考点分析</strong></p><p>这道题目考察的重点是，你对Java 源码的理解，这也从侧面反应了你是否热爱和喜欢专研程序，而这正是一个优秀程序员所必备的特质。<br>String 源码属于所有源码中最基础、最简单的一个，对String源码的理解也反应了你的Java基础功底。<br>String问题如果再延伸一下，会问到一些更多的知识细节，这也是大厂一贯使用的面试策略，从一个知识点入手然后扩充更多的知识细节，对于String也不例外，通常还会关联的询问以下问题：</p><ul><li>为什么String 类型要用final修饰？</li><li>==和equals的区别是什么？</li><li>String和StringBuilder、StringBuffer 有什么区别？</li><li>String的intern()方法有什么含义？</li><li>String 类型在 JVM（Java虚拟机）中是如何存储的？编译器对String做了哪些优化？</li></ul><p>接下来我们一起来看这些问题的答案。</p><h4 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a><strong>知识拓展</strong></h4><h5 id="1-和equals的区别"><a href="#1-和equals的区别" class="headerlink" title="1.==和equals的区别"></a>1.==和equals的区别</h5><p>==对于基本数据类型来说，是用于比较“值”是否相等的；而对于引用类型来说，是用于比较引用地址是否相同的。<br>查看源码我们可以知道Object中也有equals0方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Object中的equals0方法其实就是==，而String重写了equals0方法把它修改成比较两个字符串的值是否相等。<br>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对象引用相同直接返回 true </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==anObject)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断需要对比的值是否为String类型，如果不是则直接返回false </span></span><br><span class="line">    <span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">        String anotherString=(String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span>(n == anotherString.value.length)&#123;</span><br><span class="line">    <span class="comment">//把两个字符串都转换为char数组对比</span></span><br><span class="line">    <span class="keyword">char</span> vl[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环比对两个字符串的每一个字符</span></span><br><span class="line">    <span class="keyword">while</span>（n-- != <span class="number">0</span>）&#123;</span><br><span class="line">    <span class="comment">//如果其中有一个字符不相等就 true false，否则继续对比</span></span><br><span class="line">                <span class="keyword">if</span>(vl[i] != v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-final-修饰的好处"><a href="#2-final-修饰的好处" class="headerlink" title="2.final 修饰的好处"></a>2.final 修饰的好处</h5><p>从String类的源码我们可以看出String是被final修饰的不可继承类，源码如下：</p><p>Java 语言之父James Gosling的回答是，他会更倾向于使用final，因为它能够缓存结果，当你在传参时不需要考虑谁会修改它的值；如果是可变类的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上就会有一定的损失。<br>James Gosling 还说迫使String类设计成不可变的另一个原因是安全，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，它的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题，这是迫使String类设计成不可变类的一个重要原因。<br>总结来说，使用final修饰的第一个好处是安全；第二个好处是高效，以JVM中的字符串常量池来举例，如下两个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"java"</span>;</span><br><span class="line">String s2 = <span class="string">"java"</span>;</span><br></pre></td></tr></table></figure><p>只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如下图所示：</p><p><img data-src="1.png" alt="1"></p><p>试想一下如果String是可变的，那当s1的值修改之后，52的值也跟着改变了，这样就和我们预期的结果不相符了，因此也就没有办法实现字符串常量池的功能了。</p><h5 id="3-String-和StringBuilder、StringBuffer的区别"><a href="#3-String-和StringBuilder、StringBuffer的区别" class="headerlink" title="3.String 和StringBuilder、StringBuffer的区别"></a>3.String 和StringBuilder、StringBuffer的区别</h5><p>因为String类型是不可变的，所以在字符串拼接的时候如果使用String的话性能会很低，因此我们就需要使用另一个数据类型 StringBuffer，它提供了append和insert方法可用于字符串的拼接，它使用synchronized来保证线程安全，如下源码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    toStringCache =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    toStringCache =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为它使用了synchronized来保证线程安全，所以性能不是很高，于是在JDK1.5就有了StringBuilder，它同样提供了append和insert的拼接方法，但它没有使用synchronized来修饰，因此在性能上要优于StringBufer，所以在非并发操作的环境下可使用 StringBuilder来进行字符串拼接。</p><h5 id="4-String-和JVM"><a href="#4-String-和JVM" class="headerlink" title="4.String 和JVM"></a>4.String 和JVM</h5><p>String 常见的创建方式有两种，直接赋值的方式”String s1=”Java”；”和“Strings2=new String（”Java”）；”的方式，但两者在JVM的存储区域却截然不同，在JDK1.8中，变量s1会先去字符串常量池中找字符串“Java”，如果有相同的字符则直接返回常量句柄，如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量s2是直接在堆上创建一个变量，如果调用<br>intern方法才会把此字符串保存到常量池中，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String sl =<span class="keyword">new</span> String(<span class="string">"Java"</span>); </span><br><span class="line">String s2=s1.intern();</span><br><span class="line">String s3=<span class="string">"Java"</span>;</span><br><span class="line">System.out.println(s1 ==s2);<span class="comment">//false </span></span><br><span class="line">System.out.println(s2 ==s3);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>它们在 JVM 存储的位置，如下图所示：</p><p><img data-src="2.png" alt="2"></p><p>注：JDK1.7之后把永生代换成的元空间，把字符串常量池从方法区移到了Java堆上。<br>除此之外编译器还会对String字符串做一些优化，例如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Ja"</span> + <span class="string">"va"</span>;</span><br><span class="line">String s2 = <span class="string">"Java"</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure><p>虽然51拼接了多个字符串，但对比的结果却是true，我们使用反编译工具，看到的结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"StringExample.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">lagou</span>.<span class="title">interview</span>.<span class="title">StringExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> com.lagou.interview.StringExample();</span><br><span class="line">Code:</span><br><span class="line">            <span class="number">0</span>:aload_0</span><br><span class="line">            1:invokespecial #1//Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">            <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">       LineNumberTable:</span><br><span class="line">     line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">0: ldc           #2                  // String Java</span><br><span class="line"><span class="number">2</span>: astore_1</span><br><span class="line">       3: ldc           #2                  // String Java</span><br><span class="line"><span class="number">5</span>:astore_2</span><br><span class="line">        6:getstatic     #3 //Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"><span class="number">9</span>: aload_1</span><br><span class="line"> <span class="number">10</span>: aload_2</span><br><span class="line">        <span class="number">11</span>: if_acmpne     <span class="number">18</span></span><br><span class="line">        <span class="number">14</span>: iconst_1</span><br><span class="line">        <span class="number">15</span>: goto          <span class="number">19</span></span><br><span class="line">        <span class="number">18</span>: iconst_0</span><br><span class="line">      19: invokevirtual #4  </span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">        LineNumberTable:</span><br><span class="line">        <span class="number">1</span>ine <span class="number">5</span>:<span class="number">0</span></span><br><span class="line">        <span class="number">1</span>ine <span class="number">6</span>:<span class="number">3</span></span><br><span class="line">        line <span class="number">7</span>:<span class="number">6</span></span><br><span class="line">        <span class="number">1</span>ine <span class="number">8</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从编译代码#2可以看出，代码“Ja”+”va”被直接编译成了“Java”，因此s1==s2的结果才是<br>true，这就是编译器对字符串优化的结果。<br>小结<br>本课时从String 的源码入手，重点讲了String的构造方法、equals0方法和compareTo())方法，其中equals(）重写了Object的equals())方法，把引用对比改成了字符串值对比，也介绍了final修饰String的好处，可以提高效率和增强安全性，同时我们还介绍了String和JVM的一些执行细节。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】一对一关联映射</title>
      <link href="/2020/03/10/hibernate%E4%B8%80%E5%AF%B9%E4%B8%80%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/10/hibernate%E4%B8%80%E5%AF%B9%E4%B8%80%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p><img data-src="1.png" alt="1"></p><h3 id="一-XML方式"><a href="#一-XML方式" class="headerlink" title="一.XML方式"></a>一.XML方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 标识一个类的xml映射,name为类名,table为表名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"Person"</span> <span class="attr">cascade</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Person.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"foreign"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"property"</span>&gt;</span>user<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idNumber"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">constrained</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过&lt;one-to-one&gt; 元素配置。</p><p>•constrained 属性为 true，表明 PERSON 表 ID 为外键，参照主表（USER）。</p><p>•外键表实体类配置文件中 OID 使用 foreign 生成策略。</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">User user  = <span class="keyword">new</span> User();</span><br><span class="line">user.setUserName(<span class="string">"zs"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"ls"</span>);</span><br><span class="line">person.setIdNumber(<span class="string">"2017011776"</span>);</span><br><span class="line">user.setPerson(person);</span><br><span class="line">person.setUser(user);</span><br><span class="line">session.save(user);</span><br><span class="line">session.save(person);</span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-注解方式"><a href="#二-注解方式" class="headerlink" title="二.注解方式"></a>二.注解方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@OneToOne</span>(cascade=CascadeType.ALL)</span><br><span class="line"><span class="meta">@PrimaryKeyJoinColumn</span>(name=<span class="string">"id"</span>)</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator = <span class="string">"foreign"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name = <span class="string">"foreign"</span>, strategy = <span class="string">"foreign"</span>, parameters = &#123;</span><br><span class="line"><span class="meta">@Parameter</span>(name = <span class="string">"property"</span>, value = <span class="string">"user"</span>) &#125;)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="meta">@OneToOne</span>(mappedBy=<span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-唯一外键关联"><a href="#三-唯一外键关联" class="headerlink" title="三.唯一外键关联"></a>三.唯一外键关联</h3><h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"person"</span> <span class="attr">column</span>=<span class="string">"PERSONID"</span> <span class="attr">cascade</span>=<span class="string">"all"</span> <span class="attr">unique</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Person.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Person"</span> <span class="attr">table</span>=<span class="string">"PERSON"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idNumber"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 外键关联方式映射与User的一对一关系   property-ref:外键列对应的属性名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">property-ref</span>=<span class="string">"person"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">User user  = <span class="keyword">new</span> User();</span><br><span class="line">user.setUserName(<span class="string">"zs"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"ls"</span>);</span><br><span class="line">person.setIdNumber(<span class="string">"2017011776"</span>);</span><br><span class="line">user.setPerson(person);</span><br><span class="line">person.setUser(user);</span><br><span class="line">session.save(user);</span><br><span class="line">session.save(person);</span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@OneToOne</span>(cascade=CascadeType.ALL)</span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"PERSONID"</span>)</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userName = userName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.person = person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="meta">@OneToOne</span>(mappedBy=<span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIdNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> idNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdNumber</span><span class="params">(String idNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.idNumber = idNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.user = user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-组合关系映射"><a href="#四-组合关系映射" class="headerlink" title="四.组合关系映射"></a>四.组合关系映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"contact"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"phoneNum"</span>)</span><br><span class="line"><span class="keyword">private</span> String tel;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"><span class="meta">@Embedded</span></span><br><span class="line"><span class="meta">@AttributeOverrides</span>(value=&#123;</span><br><span class="line">    <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"province"</span>, </span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_province"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"city"</span>,</span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_city"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"district"</span>,</span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_district"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"detail"</span>,</span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_detail"</span>))&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Address homeAddress;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTel</span><span class="params">(String tel)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tel = tel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Address <span class="title">getHomeAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> homeAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHomeAddress</span><span class="params">(Address homeAddress)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.homeAddress = homeAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span><span class="comment">//指明为嵌入式类，不需要单独进行映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String province;</span><br><span class="line"><span class="keyword">private</span> String city;</span><br><span class="line"><span class="keyword">private</span> String district;</span><br><span class="line"><span class="keyword">private</span> String detail;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProvince</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> province;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProvince</span><span class="params">(String province)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.province = province;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> city;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span><span class="params">(String city)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.city = city;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDistrict</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> district;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDistrict</span><span class="params">(String district)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.district = district;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> detail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDetail</span><span class="params">(String detail)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.detail = detail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">Contact contact = <span class="keyword">new</span> Contact();</span><br><span class="line">contact.setEmail(<span class="string">"273903932@qq.com"</span>);</span><br><span class="line">contact.setTel(<span class="string">"12312123451"</span>);</span><br><span class="line">Address address = <span class="keyword">new</span> Address();</span><br><span class="line">address.setProvince(<span class="string">"河北省"</span>);</span><br><span class="line">address.setCity(<span class="string">"秦皇岛市"</span>);</span><br><span class="line">address.setDistrict(<span class="string">"昌黎县"</span>);</span><br><span class="line">address.setDetail(<span class="string">"黎昌尚府小区"</span>);</span><br><span class="line">contact.setHomeAddress(address); </span><br><span class="line">session.save(contact);</span><br><span class="line"></span><br><span class="line">tx.commit();</span><br><span class="line"> </span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】单实体映射</title>
      <link href="/2020/03/10/hibernate%E5%8D%95%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/10/hibernate%E5%8D%95%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="Java程序中区分不同对象。"><a href="#Java程序中区分不同对象。" class="headerlink" title="Java程序中区分不同对象。"></a>Java程序中区分不同对象。</h3><p>​    <strong>1.Java语言中通过内存地址区分不同对象；</strong></p><p>​    <strong>2.两种比较引用变量方法；</strong></p><p>​        a. “==” 比较两个变量引用的内存地址是否相同；</p><p>​        b.  equals可以比较两个变量引用的对象的值是否相同。</p><p>​    <strong>3.用户自定义的类也可以覆盖Object的equals方法实现对象按值进行比较。</strong></p><h3 id="Hibernate-自带了很多种标识符生成器："><a href="#Hibernate-自带了很多种标识符生成器：" class="headerlink" title="Hibernate 自带了很多种标识符生成器："></a>Hibernate 自带了很多种标识符生成器：</h3><p><img data-src="1.png" alt="1"></p><p><strong>increment</strong>  采用 Hibernate 数值递增的方式,该机制是 Hibernate 以递增的方式为OID赋值。</p><p>&emsp;&emsp;&emsp;不依赖于底层数据库系统，适合所有数据库;</p><p>&emsp;&emsp;&emsp;适合单独的 Hibernate 应用使用，不适合在集群情况下使用。</p><p><strong>identity</strong> 采用数据库提供的自增长方式,该机制依赖于底层数据库，需要数据库支持自动增长字段。</p><p>&emsp;&emsp;&emsp;例如：MySQL、MSSQL、DB2、Sybase等。</p><p><strong>assigned</strong> 主键由应用逻辑产生；该机制是由外部程序负责生成OID,Hibernate 不负责维护主键生成，与Hibernate和底层数据库都无关。</p><p>&emsp;&emsp;例如：Student类没有定义 ID，而是以学号studentNo 作为业务主键。&emsp;</p><p><strong>sequence</strong> 采用数据库提供的序列方式；</p><p>hilo 通过hi/lo算法   // Hibernate 5.0 以后不支持；</p><p>seqhilo 通过hi/lo算法；</p><p>native 自动选择合适的标识符生成器；</p><p>uuid.hex 通过uuid算法。</p><h3 id="使用注解映射单实体"><a href="#使用注解映射单实体" class="headerlink" title="使用注解映射单实体"></a><strong>使用注解映射单实体</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"employee"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment_generator"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment_generator"</span>, strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"name"</span>) </span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Entity：声明一个实体类。</p><p>@Table(name=”table_name”)：为实体类指定对应的数据库表。</p><p>@Id：声明实体类的OID属性。</p><p>@GeneratedValue(generator=”increment_generator”)：声明OID的生成策略。</p><p>@GenericGenerator(name=”increment_generator”, strategy=”increment”)：使用Hibernate提供的生成策略。</p><p>@Column(name=”columnName”) ：将属性映射到列。</p><p>@Access(AccessType.PROPERTY)：1.通过 getter 和 setter 方法访问实体类的属性；2.需要在 getter 方法上定义字段的属性。</p><p>@Access(AccessType.FIELD)：1.直接访问实体类的属性，可以不定义 getter 和 setter 方法；2.需要在变量上定义字段的属性。</p>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hibernate】搭建框架</title>
      <link href="/2020/03/10/hibernate%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/03/10/hibernate%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="初始框架搭建"><a href="#初始框架搭建" class="headerlink" title="初始框架搭建"></a>初始框架搭建</h1><h3 id="分层构系结构"><a href="#分层构系结构" class="headerlink" title="分层构系结构"></a>分层构系结构</h3><p>指的是将系统的组件分隔到不同的层中，每一层中的组件应保持内聚性；<br>每一层都应与它下面的各层保持松散耦合。</p><h3 id="三层体系结构"><a href="#三层体系结构" class="headerlink" title="三层体系结构"></a><strong>三层体系结构</strong></h3><p><img data-src="1583851295917.png" alt="1583851295917"></p><h3 id="持久化层是怎么来的"><a href="#持久化层是怎么来的" class="headerlink" title="持久化层是怎么来的"></a><strong>持久化层是怎么来的</strong></h3><p>为了把数据访问细节和业务逻辑分开，可以把数据访问作为单独的持久化层。</p><p><img data-src="1583851385990.png" alt="1583851385990"></p><h3 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h3><p><strong>瞬时状态</strong>：保存在内存的程序数据，程序退出后，数据就消失了，称为瞬时状态。</p><p><strong>持久状态</strong>：保存在数据库（磁盘）的程序数据，程序退出后，数据依然存在，称为程序数据的持久状态。</p><p><strong>持久化</strong>：将程序数据在瞬时状态和持久化状态之间转换的机制。</p><h3 id="MVC设计模式与四层结构的对应关系"><a href="#MVC设计模式与四层结构的对应关系" class="headerlink" title="MVC设计模式与四层结构的对应关系"></a>MVC设计模式与四层结构的对应关系</h3><p><img data-src="1583851508296.png" alt="1583851508296"></p><h3 id="持久化层的设计目标："><a href="#持久化层的设计目标：" class="headerlink" title="持久化层的设计目标："></a>持久化层的设计目标：</h3><p>1.代码可重用性高，能够完成对象持久化操作；</p><p>2.如果需要的话，能够支持多种数据库平台；</p><p>3.具有相对独立性，当持久层发生变化时，不会影响上层实现。</p><h3 id="Hibernate是什么？"><a href="#Hibernate是什么？" class="headerlink" title="Hibernate是什么？"></a>Hibernate是什么？</h3><p>1.在分层体系结构中Hibernate位于持久化层，是完成对象持久化的持久化层框架；</p><p>2.Hibernate是连接Java应用程序和关系型数据库的框架，能够建立对象模型和关系数据模型之间的映射，是一种自动ORM框架；</p><p>3.Hibernate是对JDBC API的封装，是JDBC轻量级封装框架。</p><h2 id="第一个Hibernate程序"><a href="#第一个Hibernate程序" class="headerlink" title="第一个Hibernate程序"></a>第一个Hibernate程序</h2><h4 id="1-引入jar包"><a href="#1-引入jar包" class="headerlink" title="1.引入jar包"></a>1.引入jar包</h4><p><img data-src="1583851888229.png" alt="1583851888229"></p><h4 id="2-项目目录结构"><a href="#2-项目目录结构" class="headerlink" title="2.项目目录结构"></a>2.项目目录结构</h4><p><img data-src="1583851908692.png" alt="1583851908692"></p><h4 id="3-hibernate-cfg-xml"><a href="#3-hibernate-cfg-xml" class="headerlink" title="3.hibernate.cfg.xml"></a>3.hibernate.cfg.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span> <span class="meta-string">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/hibernate_demo_db<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/hibernate/entity/Customer.hbm.xml"</span>/&gt;</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;mapping class="top.hiasenna.entity.User" /&gt;</span></span><br><span class="line"><span class="comment">&lt;mapping class="top.hiasenna.entity.Order" /&gt; </span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-编写持久化类"><a href="#4-编写持久化类" class="headerlink" title="4.编写持久化类"></a>4.编写持久化类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Customer [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-创建持久化类的配置文件"><a href="#5-创建持久化类的配置文件" class="headerlink" title="5.创建持久化类的配置文件"></a>5.创建持久化类的配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.hibernate.entity"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 标识一个类的xml映射,name为类名,table为表名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Customer"</span> <span class="attr">table</span>=<span class="string">"customer"</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 主键的设置,generator标识主键生成方式--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 这里配了该类一个属性街道名称 name属性字段,column,数据库对应列 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">column</span>=<span class="string">"name"</span> /&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 这里同上,写法不同而已 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"age"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="标签说明"><a href="#标签说明" class="headerlink" title="标签说明"></a>标签说明</h5><p>1.<strong>&lt;class&gt;</strong>元素用于指定类和表之间的映射</p><p>​        -name属性设定类名(包含路径)；</p><p>​        -table属性设定表名，默认以类名作表名。</p><p>2.<strong>id</strong> 子元素设定持久化类的OID和表的主键的映射关系</p><p>​        -column – 指定表字段的名称；</p><p>​        -generator – 元素指定OID的生成器。</p><p>3.<strong>property</strong>子元素设定类的其他属性和表的字段的映射关系</p><p>​        -name – 对应类的属性名称；</p><p>​        -type – 指定属性的类型；</p><p>​        -column – 指定表字段的名称；</p><p>​        -not-null – 指定属性是否允许为空。</p><p>6.HibernateUtil工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.MetadataSources;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistry;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtil</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">final</span> StandardServiceRegistry registry=<span class="keyword">new</span> StandardServiceRegistryBuilder().configure().build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sessionFactory=<span class="keyword">new</span> MetadataSources(registry).buildMetadata().buildSessionFactory();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">sessionFactory=<span class="keyword">null</span>;</span><br><span class="line">StandardServiceRegistryBuilder.destroy(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SessionFactory <span class="title">getSessionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sessionFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSessionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sessionFactory.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SSH】初始项目搭建流程</title>
      <link href="/2020/03/10/ssh%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/03/10/ssh%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="初始项目搭建流程"><a href="#初始项目搭建流程" class="headerlink" title="初始项目搭建流程"></a>初始项目搭建流程</h1><p>1.创建一个动态web项目</p><p><img data-src="1.png" alt="1"></p><p>接着点击next，勾选自动生成web.xml选项，最后点击finish。</p><p>2.在WEB-INF的lib文件夹中导入必备的jar包，包括spring、struts以及hibernate的jar包：</p><p>spring相关jar包：</p><p><img data-src="2.png" alt="2"></p><p>struts相关jar包：</p><p><img data-src="3.png" alt="3"></p><p>hibernate相关jar包：</p><p><img data-src="4.png" alt="4"></p><p>3.jar导入后，开始搭建框架，完成配置文件</p><p>（1）首先第一步加载数据库配置文件，配置数据源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载数据库配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 包扫描器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.jiangnan.ssh"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置C3P0数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.username&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driverClass&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.url&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.initialPoolSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.maxPoolSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）第二步创建数据库操作对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建数据库的操作对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate5.LocalSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernateProperties"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库方言 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 显示Hibernate持久化操作生成的预编译的SQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将SQL格式化后再输出 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 是否根据需要每次自动创建数据库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hibernate映射文件的目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappingDirectoryLocations"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com/jiangnan/ssh/pojo<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）第三步配置事务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate5.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）第四步配置通知</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> <span class="attr">id</span> =<span class="string">"txadvice"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（5）第五步配置切面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.jiangnan.ssh.service.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（6）最后配置一下web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.jiangnan.ssh.service.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成</p>]]></content>
      
      
      <categories>
          
          <category> spring框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Guava Cache】基于Guava Cache内存缓存实现的token验证</title>
      <link href="/2020/03/10/%E5%9F%BA%E4%BA%8EGuava%20Cache%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E7%9A%84token%E9%AA%8C%E8%AF%81/"/>
      <url>/2020/03/10/%E5%9F%BA%E4%BA%8EGuava%20Cache%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E7%9A%84token%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Guava-Cache内存缓存实现的token验证"><a href="#基于Guava-Cache内存缓存实现的token验证" class="headerlink" title="基于Guava Cache内存缓存实现的token验证"></a>基于Guava Cache内存缓存实现的token验证</h1><h2 id="理解token机制"><a href="#理解token机制" class="headerlink" title="理解token机制"></a>理解token机制</h2><p> 什么是token</p><p>   token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。</p><p>   身份认证概述</p><p>   由于HTTP是一种没有状态的协议，它并不知道是谁访问了我们的应用。这里把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下次这个客户端再发送请求时候，还得再验证一下。<br>通用的解决方法就是，当用户请求登录的时候，如果没有问题，在服务端生成一条记录，在这个记录里可以说明登录的用户是谁，然后把这条记录的id发送给客户端，客户端收到以后把这个id存储在cookie里，下次该用户再次向服务端发送请求的时候，可以带上这个cookie，这样服务端会验证一下cookie里的信息，看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。<br>以上所描述的过程就是利用session，那个id值就是sessionid。我们需要在服务端存储为用户生成的session，这些session会存储在内存，磁盘，或者数据库。</p><p>   基于token机制的身份认证</p><p>   使用token机制的身份验证方法，在服务器端不需要存储用户的登录记录。大概的流程：</p><p>客户端使用用户名和密码请求登录。服务端收到请求，验证用户名和密码。验证成功后，服务端会生成一个token，然后把这个token发送给客户端。客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。客户端每次向服务端发送请求的时候都需要带上服务端发给的token。服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。</p><h3 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h3><p>Guava Cache是单个应用运行时的本地缓存。它不把数据存放到文件或者外部服务器上。简单、强大、及轻量级。它不需要配置文件，使用起来和ConcurrentHashMap一样简单，而且能覆盖绝大多数使用cache的场景需求</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p> 校验答案正确后，在service层来生成一个唯一token，一般可以使用mac地址，或者sessionId来生成token。因为token是可以被截获的，非常容易泄露，如果不进行加密，很容易被恶意拷贝并用来登录。所以一般会对token进行加密处理。</p><p>一般可以在存储的时候把token进行对称加密存储，用到的时候再解密，或者使用请求URL、时间戳、token三者合并，通过算法进行加密处理。两个一块用更安全。这里就简单利用UUID来实现生成唯一token</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String forgetToken = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure><p>然后再把token存到本地Guava Cache内存缓存中，在响应对象中也把这个token封装起来响应给客户端。到时候用户改密，就可以传入该token实现token机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TokenCache.setKey(<span class="string">"Token_"</span>+username,forgetToken);</span><br></pre></td></tr></table></figure><p>Guava Cache实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheLoader;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.LoadingCache;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author Liang Shan</span></span><br><span class="line"><span class="comment"> * @Description token本地缓存，使用guava缓存实现</span></span><br><span class="line"><span class="comment"> * @Date 2018/6/1 17:28</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    创建logback的logger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TokenCache<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//    声明一个静态的内存块,guava里面的本地缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LoadingCache&lt;String, String&gt; localcache =</span><br><span class="line">        <span class="comment">//构建本地缓存，调用链的方式 ,1000是设置缓存的初始化容量，maximumSize是设置缓存最大容量，当超过了最大容量，guava将使用LRU算法（最少使用算法），来移除缓存项</span></span><br><span class="line">        <span class="comment">//expireAfterAccess(12,TimeUnit.HOURS)设置缓存有效期为12个小时</span></span><br><span class="line">        CacheBuilder.newBuilder().initialCapacity(<span class="number">1000</span>).maximumSize(<span class="number">10000</span>).expireAfterAccess(<span class="number">12</span>,TimeUnit.HOURS)</span><br><span class="line">        <span class="comment">//build里面要实现一个匿名抽象类</span></span><br><span class="line">                .build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line"><span class="comment">//                   这个方法是默认的数据加载实现,get的时候，如果key没有对应的值，就调用这个方法进行加载</span></span><br><span class="line"> </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//                        为什么要把return的null值写成字符串，因为到时候用null去.equal的时候，会报空指针异常</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 添加本地缓存</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        localcache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 得到本地缓存</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value= localcache.get(key);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"null"</span>.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"getKey()方法错误"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Guava-Cache的回收策略"><a href="#Guava-Cache的回收策略" class="headerlink" title="Guava Cache的回收策略"></a>Guava Cache的回收策略</h3><h4 id="有两种回收策略："><a href="#有两种回收策略：" class="headerlink" title="有两种回收策略："></a>有两种回收策略：</h4><p>一种是基于容量的回收CacheBuilder.maximumSize(Long)。设置缓存最大容量，当超过最大容量，缓存将尝试回收最近没有使用或总体上很少使用的缓存项。</p><p>第二种定时回收</p><p>expireAfterAccess(long,TimeUnit):缓存项在给定时间内没有被读写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。</p><p>  expireAfterWrite(long,TimeUnit):缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变的陈旧不可用，这种回收是可取的。</p><p>实例中用的是第一种策略，通过设置缓存最大容量，当超过了最大容量，guava将使用LRU算法来减少缓存项</p><h3 id="LRU算法原理"><a href="#LRU算法原理" class="headerlink" title="LRU算法原理"></a>LRU算法原理</h3><p>LRU（Least recently used，最近最少使用的）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高。</p><p>最常见的实现是使用一个链表保存缓存数据：<br>1 新数据插入到链表头部<br>2 每当缓存命中（即缓存数据被访问），则将数据移到链表头部<br>3 当链表满的时候，将链表尾部的数据丢弃</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava Cache </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
