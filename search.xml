<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题总结</title>
      <link href="/2020/08/20/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2020/08/20/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li>byte/8</li><li>char/16</li><li>short/16</li><li>int/32</li><li>float/32</li><li>long/64</li><li>double/64</li><li>boolean/~</li></ul><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank" rel="noopener">Primitive Data Types</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a></li></ul><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱 调用了 Integer.valueOf(2)</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱 调用了 X.intValue()</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html" target="_blank" rel="noopener">Autoboxing and Unboxing</a></li></ul><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> j = low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p><p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</size></p><p><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123" target="_blank" rel="noopener">StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123</a></p><h2 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p><p>在 Java 8 中，String 内部使用 char 数组存储数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h3 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h3><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><p><a href="https://camo.githubusercontent.com/152a310f7698bb23ae201081c5c497b5c1d396d9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313231303030343133323839342e706e67" target="_blank" rel="noopener"><img data-src="https://camo.githubusercontent.com/152a310f7698bb23ae201081c5c497b5c1d396d9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313231303030343133323839342e706e67" alt="img"></a></p><p><strong>3. 安全性</strong></p><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><p><a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/" target="_blank" rel="noopener">Program Creek : Why String is immutable in Java?</a></p><h3 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h3><p><strong>1. 可变性</strong></p><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><strong>2. 线程安全</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><p><a href="https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder" target="_blank" rel="noopener">StackOverflow : String, StringBuffer, and StringBuilder</a></p><h3 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">String s4 = s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">String s6 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><ul><li><a href="https://stackoverflow.com/questions/10578984/what-is-string-interning" target="_blank" rel="noopener">StackOverflow : What is String interning?</a></li><li><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析 String#intern</a></li></ul><h3 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h3><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewStringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 javap -verbose 进行反编译，得到以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Constant pool:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   #2 = Class              #18            // java/lang/String</span><br><span class="line">   #3 = String             #19            // abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  #18 = Utf8               java/lang/String</span><br><span class="line">  #19 = Utf8               abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class java/lang/String</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: ldc           #3                  // String abc</span><br><span class="line">         6: invokespecial #4                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">9</span>: astore_1</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p><p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p><p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getObjectAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">"A"</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        dog.setName(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        dog = <span class="keyword">new</span> Dog(<span class="string">"B"</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@74a14482</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" target="_blank" rel="noopener">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></p><h3 id="float-与-double"><a href="#float-与-double" class="headerlink" title="float 与 double"></a>float 与 double</h3><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p><p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1;</span></span><br></pre></td></tr></table></figure><p>1.1f 字面量才是 float 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;</span></span><br></pre></td></tr></table></figure><p>但是使用 += 或者 ++ 运算符会执行隐式类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;</span><br><span class="line">s1++;</span><br></pre></td></tr></table></figure><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = (<span class="keyword">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting" target="_blank" rel="noopener">StackOverflow : Why don’t Java’s +=, -=, *=, /= compound assignment operators require casting?</a></p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">        System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// long x = 111;</span></span><br><span class="line"><span class="comment">// switch (x) &#123; // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'</span></span><br><span class="line"><span class="comment">//     case 111:</span></span><br><span class="line"><span class="comment">//         System.out.println(111);</span></span><br><span class="line"><span class="comment">//         break;</span></span><br><span class="line"><span class="comment">//     case 222:</span></span><br><span class="line"><span class="comment">//         System.out.println(222);</span></span><br><span class="line"><span class="comment">//         break;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java" target="_blank" rel="noopener">StackOverflow : Why can’t your switch statement data type be long, Java?</a></p><h2 id="四、关键字"><a href="#四、关键字" class="headerlink" title="四、关键字"></a>四、关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><strong>1. 数据</strong></p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable 'x'</span></span><br><span class="line"><span class="keyword">final</span> A y = <span class="keyword">new</span> A();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>2. 方法</strong></p><p>声明方法不能被子类重写。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. 类</strong></p><p>声明类不允许被继承。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>1. 静态变量</strong></p><ul><li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field 'x' cannot be referenced from a static context</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">int</span> x = a.x;</span><br><span class="line">        <span class="keyword">int</span> y = A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = x;</span><br><span class="line">        <span class="comment">// int b = y;  // Non-static field 'y' cannot be referenced from a static context</span></span><br><span class="line">        <span class="comment">// int b = this.y;     // 'A.this' cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p><strong>4. 静态内部类</strong></p><p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context</span></span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        InnerClass innerClass = outerClass.<span class="keyword">new</span> InnerClass();</span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure><p><strong>6. 初始化顺序</strong></p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"静态语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String field = <span class="string">"实例变量"</span>;</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"普通语句块"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后才是构造函数的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h2 id="五、Object-通用方法"><a href="#五、Object-通用方法" class="headerlink" title="五、Object 通用方法"></a>五、Object 通用方法</h2><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; <span class="title">getClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p><strong>1. 等价关系</strong></p><p>两个对象具有等价关系，需要满足以下五个条件：</p><p>Ⅰ 自反性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Ⅱ 对称性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Ⅲ 传递性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure><p>Ⅳ 一致性</p><p>多次调用 equals() 方法结果不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Ⅴ 与 null 的比较</p><p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(<span class="keyword">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure><p><strong>2. 等价与相等</strong></p><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>3. 实现</strong></p><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        EqualExample that = (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p><p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EqualExample e1 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">EqualExample e2 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size());   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p><p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ToStringExample</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ToStringExample example = <span class="keyword">new</span> ToStringExample(<span class="number">123</span>);</span><br><span class="line">System.out.println(example.toString());</span><br><span class="line">ToStringExample@<span class="number">4554617</span>c</span><br></pre></td></tr></table></figure><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p><strong>1. cloneable</strong></p><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'</span></span><br></pre></td></tr></table></figure><p>重写 clone() 得到以下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    CloneExample e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">java.lang.CloneNotSupportedException: CloneExample</span><br></pre></td></tr></table></figure><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 浅拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShallowCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShallowCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ShallowCloneExample e1 = <span class="keyword">new</span> ShallowCloneExample();</span><br><span class="line">ShallowCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><p><strong>3. 深拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用不同对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DeepCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepCloneExample result = (DeepCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DeepCloneExample e1 = <span class="keyword">new</span> DeepCloneExample();</span><br><span class="line">DeepCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>4. clone() 的替代方案</strong></p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneConstructorExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CloneConstructorExample e1 = <span class="keyword">new</span> CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 = <span class="keyword">new</span> CloneConstructorExample(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="六、继承"><a href="#六、继承" class="headerlink" title="六、继承"></a>六、继承</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>可以对类或类中的成员（字段和方法）加上访问修饰符。</p><ul><li>类可见表示其它类可以用这个类创建实例对象。</li><li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li></ul><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p><p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。</p><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class AccessExample &#123;</span><br><span class="line">    public String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = Integer.valueOf(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessWithInnerClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccessWithInnerClassExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerClass.x;  <span class="comment">// 直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p><strong>1. 抽象类</strong></p><p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated</span></span><br><span class="line">AbstractClassExample ac2 = <span class="keyword">new</span> AbstractExtendClassExample();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure><p><strong>2. 接口</strong></p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p><p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p><p>接口的字段默认都是 static 和 final 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;               // Variable 'y' might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> z = <span class="number">0</span>;       <span class="comment">// Modifier 'public' is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier 'private' not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier 'protected' not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier 'private' not allowed here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated</span></span><br><span class="line">InterfaceExample ie2 = <span class="keyword">new</span> InterfaceImplementExample();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure><p><strong>3. 比较</strong></p><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li><li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul><p><strong>4. 使用选择</strong></p><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；</li><li>需要使用多重继承。</li></ul><p>使用抽象类：</p><ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的成员的访问权限，而不是都为 public。</li><li>需要继承非静态和非常量字段。</li></ul><p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html" target="_blank" rel="noopener">Abstract Methods and Classes</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/" target="_blank" rel="noopener">深入理解 abstract class 和 interface</a></li><li><a href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface" target="_blank" rel="noopener">When to Use Abstract Class and Interface</a></li></ul><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。</li><li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">"SuperExtendExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SuperExample e = <span class="keyword">new</span> SuperExtendExample(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure><p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html" target="_blank" rel="noopener">Using the Keyword super</a></p><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><p><strong>1. 重写（Override）</strong></p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>为了满足里式替换原则，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li></ul><p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p><p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p><ul><li>子类方法访问权限为 public，大于父类的 protected。</li><li>子类的返回类型为 ArrayList，是父类返回类型 List 的子类。</li><li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li><li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Integer&gt; <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p><ul><li>this.func(this)</li><li>super.func(this)</li><li>this.func(super)</li><li>super.func(super)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    A</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    B</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    C</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    D</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(A obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A.show(A)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(C obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A.show(C)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(A obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B.show(A)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    D d = <span class="keyword">new</span> D();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 A 中存在 show(A obj)，直接调用</span></span><br><span class="line">    a.show(a); <span class="comment">// A.show(A)</span></span><br><span class="line">    <span class="comment">// 在 A 中不存在 show(B obj)，将 B 转型成其父类 A</span></span><br><span class="line">    a.show(b); <span class="comment">// A.show(A)</span></span><br><span class="line">    <span class="comment">// 在 B 中存在从 A 继承来的 show(C obj)，直接调用</span></span><br><span class="line">    b.show(c); <span class="comment">// A.show(C)</span></span><br><span class="line">    <span class="comment">// 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C</span></span><br><span class="line">    b.show(d); <span class="comment">// A.show(C)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用的还是 B 对象，所以 ba 和 b 的调用结果一样</span></span><br><span class="line">    A ba = <span class="keyword">new</span> B();</span><br><span class="line">    ba.show(c); <span class="comment">// A.show(C)</span></span><br><span class="line">    ba.show(d); <span class="comment">// A.show(C)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 重载（Overload）</strong></p><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p><p>应该注意的是，返回值不同，其它都相同不算是重载。</p><h2 id="七、反射"><a href="#七、反射" class="headerlink" title="七、反射"></a>七、反射</h2><p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li><strong>Constructor</strong> ：可以用 Constructor 的 newInstance() 创建新的对象。</li></ul><p><strong>反射的优点：</strong></p><ul><li><pre><code>**可扩展性**   ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>**类浏览器和可视化开发环境**   ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>**调试器和测试工具**   ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**反射的缺点：**</span><br><span class="line"></span><br><span class="line">尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>**性能开销**   ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>**安全限制**   ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>**内部暴露**   ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- [Trail: The Reflection API](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;reflect&#x2F;index.html)</span><br><span class="line">- [深入解析 Java 反射（1）- 基础](http:&#x2F;&#x2F;www.sczyh30.com&#x2F;posts&#x2F;Java&#x2F;java-reflection-1&#x2F;)</span><br><span class="line"></span><br><span class="line">## 八、异常</span><br><span class="line"></span><br><span class="line">Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： **Error** 和 **Exception**。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</span><br><span class="line"></span><br><span class="line">- **受检异常** ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；</span><br><span class="line">- **非受检异常** ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</span><br><span class="line"></span><br><span class="line">[![img](https:&#x2F;&#x2F;camo.githubusercontent.com&#x2F;106f71b4556e95b4a8508e82d9b6bec8ccb9e964&#x2F;68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50506a77502e706e67)](https:&#x2F;&#x2F;camo.githubusercontent.com&#x2F;106f71b4556e95b4a8508e82d9b6bec8ccb9e964&#x2F;68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50506a77502e706e67)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- [Java 入门之异常处理](https:&#x2F;&#x2F;www.tianmaying.com&#x2F;tutorial&#x2F;Java-Exception)</span><br><span class="line">- [Java 异常的面试问题及答案 -Part 1](http:&#x2F;&#x2F;www.importnew.com&#x2F;7383.html)</span><br><span class="line"></span><br><span class="line">## 九、泛型</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; T stands for &quot;Type&quot;</span><br><span class="line">    private T t;</span><br><span class="line">    public void set(T t) &#123; this.t &#x3D; t; &#125;</span><br><span class="line">    public T get() &#123; return t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><a href="http://www.importnew.com/24029.html" target="_blank" rel="noopener">Java 泛型详解</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1033693" target="_blank" rel="noopener">10 道 Java 泛型面试题</a></p></li></ul><h2 id="十、注解"><a href="#十、注解" class="headerlink" title="十、注解"></a>十、注解</h2><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p><p><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" target="_blank" rel="noopener">注解 Annotation 实现原理与自定义注解例子</a></p><h2 id="十一、特性"><a href="#十一、特性" class="headerlink" title="十一、特性"></a>十一、特性</h2><h3 id="Java-各版本的新特性"><a href="#Java-各版本的新特性" class="headerlink" title="Java 各版本的新特性"></a>Java 各版本的新特性</h3><p><strong>New highlights in Java SE 8</strong></p><ol><li>Lambda Expressions</li><li>Pipelines and Streams</li><li>Date and Time API</li><li>Default Methods</li><li>Type Annotations</li><li>Nashhorn JavaScript Engine</li><li>Concurrent Accumulators</li><li>Parallel operations</li><li>PermGen Error Removed</li></ol><p><strong>New highlights in Java SE 7</strong></p><ol><li>Strings in Switch Statement</li><li>Type Inference for Generic Instance Creation</li><li>Multiple Exception Handling</li><li>Support for Dynamic Languages</li><li>Try with Resources</li><li>Java nio Package</li><li>Binary Literals, Underscore in literals</li><li>Diamond Syntax</li></ol><ul><li><a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17" target="_blank" rel="noopener">Difference between Java 1.8 and Java 1.7?</a></li><li><a href="http://www.importnew.com/19345.html" target="_blank" rel="noopener">Java 8 特性</a></li></ul><h3 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h3><ul><li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li><li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li><li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li><li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li><li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li><li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li><li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li></ul><p><a href="http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php" target="_blank" rel="noopener">What are the main differences between Java and C++?</a></p><h3 id="JRE-or-JDK"><a href="#JRE-or-JDK" class="headerlink" title="JRE or JDK"></a>JRE or JDK</h3><ul><li>JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。</li><li>JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS宽度优先搜索</title>
      <link href="/2020/08/19/BFS%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
      <url>/2020/08/19/BFS%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS使用队列，把每个还没有搜索到的点依次放入队列，然后再弹出队列的头部元素当做当前遍历点。BFS总共有两个模板：</p><p>1.如果不需要确定当前遍历到了哪一层，BFS模板如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> queue 不空：</span><br><span class="line">    cur = queue.pop()</span><br><span class="line">    <span class="keyword">for</span> 节点 in cur的所有相邻节点：</span><br><span class="line">        <span class="keyword">if</span> 该节点有效且未访问过：</span><br><span class="line">            queue.push(该节点)</span><br></pre></td></tr></table></figure><p>2.如果要确定当前遍历到了哪一层，BFS模板如下。<br>这里增加了level表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。size表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">level = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> queue 不空：</span><br><span class="line">    size = queue.size()</span><br><span class="line">    <span class="keyword">while</span> (size --) &#123;</span><br><span class="line">        cur = queue.pop()</span><br><span class="line">        <span class="keyword">for</span> 节点 in cur的所有相邻节点：</span><br><span class="line">            <span class="keyword">if</span> 该节点有效且未被访问过：</span><br><span class="line">                queue.push(该节点)</span><br><span class="line">    &#125;</span><br><span class="line">    level ++;</span><br></pre></td></tr></table></figure><p>上面两个是通用模板，在任何题目中都可以用，是要记住的！</p><p>本题要求二叉树的层次遍历，所以同一层的节点应该放在一起，故使用模板二。</p><p>使用队列保存每层的所有节点，每次把队列里的原先所有节点进行出队列操作，再把每个元素的非空左右子节点进入队列。因此即可得到每层的遍历。</p><p>各语言的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">int</span> count = queue.size();</span><br><span class="line">          List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">              TreeNode node = queue.poll();</span><br><span class="line">              list.add(node.val);</span><br><span class="line">              <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">              <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!list.isEmpty())&#123;</span><br><span class="line">              res.add(list);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试题</title>
      <link href="/2020/08/12/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/12/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis面试题"><a href="#Redis面试题" class="headerlink" title="Redis面试题"></a>Redis面试题</h1><p>本文的面试题如下：<br>Redis 持久化机制<br>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题<br>热点数据和冷数据是什么<br>Memcache与Redis的区别都有哪些？<br>单线程的redis为什么这么快<br>redis的数据类型，以及每种数据类型的使用场景，Redis 内部结构<br>redis的过期策略以及内存淘汰机制【～】<br>Redis 为什么是单线程的，优点<br>如何解决redis的并发竞争key问题<br>Redis 集群方案应该怎么做？都有哪些方案？<br>有没有尝试进行多机redis 的部署？如何保证数据一致的？<br>对于大量的请求怎么样处理<br>Redis 常见性能问题和解决方案？<br>讲解下Redis线程模型<br>为什么Redis的操作是原子性的，怎么保证原子性的？<br>Redis事务<br>Redis实现分布式锁</p><hr><h2 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a>Redis 持久化机制</h2><p>Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。<br>实现：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</p><p><strong>RDB</strong>是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）<br><strong>AOF</strong>：Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。<br>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p><h2 id="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题"><a href="#缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题" class="headerlink" title="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题"></a>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</h2><p><strong>缓存雪崩</strong>我们可以简单的理解为：由于原有缓存失效，新缓存未到期间<br>(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。<br><strong>解决办法</strong>：<br>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。</p><p>二、<strong>缓存穿透</strong><br>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。<br><strong>解决办法;</strong><br>最常见的则是采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<br>另外也有一个更为<strong>简单粗暴的方法</strong>，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。<br>5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？</p><p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。<br>Bitmap： 典型的就是哈希表<br>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p><p><strong>布隆过滤器（推荐）</strong><br>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>Bloom-Filter算法的<strong>核心思想</strong>就是利用多个不同的Hash函数来解决“冲突”。<br>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。<br>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。<br><strong>受提醒补充：缓存穿透与缓存击穿的区别</strong><br><strong>缓存击穿</strong>：指一个key非常热点，大并发集中对这个key进行访问，当这个key在失效的瞬间，仍然持续的大并发访问就穿破缓存，转而直接请求数据库。<br>解决方案;在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p><p>三、<strong>缓存预热</strong><br>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！<br>解决思路：<br>1、直接写个缓存刷新页面，上线时手工操作下；<br>2、数据量不大，可以在项目启动的时候自动进行加载；<br>3、定时刷新缓存；</p><p>四、<strong>缓存更新</strong><br>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<br>（1）定时去清理过期的缓存；<br>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。<br>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。<br>五、<strong>缓存降级</strong><br>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。<br>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。<br>以参考日志级别设置预案：<br>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；<br>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；<br>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；<br>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p><h2 id="热点数据和冷数据是什么"><a href="#热点数据和冷数据是什么" class="headerlink" title="热点数据和冷数据是什么"></a>热点数据和冷数据是什么</h2><p>热点数据，缓存才有价值<br>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存<br>对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。<br>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。<br><strong>数据更新前至少读取两次，</strong>缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。<br>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p><h2 id="Memcache与Redis的区别都有哪些？"><a href="#Memcache与Redis的区别都有哪些？" class="headerlink" title="Memcache与Redis的区别都有哪些？"></a>Memcache与Redis的区别都有哪些？</h2><p>1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，redis可以持久化其数据<br>2)、数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储<br>3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br>4). value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。<br>5）redis的速度比memcached快很多<br>6）Redis支持数据的备份，即master-slave模式的数据备份。</p><h2 id="单线程的redis为什么这么快"><a href="#单线程的redis为什么这么快" class="headerlink" title="单线程的redis为什么这么快"></a>单线程的redis为什么这么快</h2><p>(一)纯内存操作<br>(二)单线程操作，避免了频繁的上下文切换<br>(三)采用了非阻塞I/O多路复用机制</p><h2 id="redis的数据类型，以及每种数据类型的使用场景"><a href="#redis的数据类型，以及每种数据类型的使用场景" class="headerlink" title="redis的数据类型，以及每种数据类型的使用场景"></a>redis的数据类型，以及每种数据类型的使用场景</h2><p>回答：一共五种<br>(一)String<br>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。<br>(二)hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。<br>(三)list<br>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。<br>(四)set<br>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。<br>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。<br>(五)sorted set<br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。</p><h2 id="Redis-内部结构"><a href="#Redis-内部结构" class="headerlink" title="Redis 内部结构"></a>Redis 内部结构</h2><ul><li>dict 本质上是为了解决算法中的查找问题（Searching）是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。 本质上是为了解决算法中的查找问题（Searching）</li><li>sds sds就等同于char * 它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结 束，因此它必然有个长度字段。</li><li>skiplist （跳跃表） 跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现，</li><li>quicklist</li><li>ziplist 压缩表 ziplist是一个编码后的列表，是由一系列特殊编码的连续内存块组成的顺序型数据结构，</li></ul><h2 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h2><p>redis采用的是<strong>定期删除+惰性删除策略</strong>。<br>为什么不用定时删除策略?<br>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.<br><strong>定期删除+惰性删除是如何工作的呢?</strong><br>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。<br>采用定期删除+惰性删除就没其他问题了么?<br>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。<br>在redis.conf中有一行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy volatile-lru</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)<br><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br><strong>allkeys-lru</strong>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰<br><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰<br><strong>no-enviction</strong>（驱逐）：禁止驱逐数据，新写入操作会报错<br>ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p><h2 id="Redis-为什么是单线程的"><a href="#Redis-为什么是单线程的" class="headerlink" title="Redis 为什么是单线程的"></a>Redis 为什么是单线程的</h2><p>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问<br>1）绝大部分请求是纯粹的内存操作（非常快速）2）采用单线程,避免了不必要的上下文切换和竞争条件<br>3）非阻塞IO优点：<br>1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)<br>\2. 支持丰富数据类型，支持string，list，set，sorted set，hash<br>3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行<br>\4. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题</p><p>同时有多个子系统去set一个key。这个时候要注意什么呢？ 不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。<br>(1)如果对这个key操作，不要求顺序： 准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可<br>(2)如果对这个key操作，要求顺序： 分布式锁+时间戳。 假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。<br>(3) 利用队列，将set方法变成串行访问也可以redis遇到高并发，如果保证读写key的一致性<br>对redis的操作都是具有原子性的,是线程安全的操作,你不用考虑并发问题,redis内部已经帮你处理好并发的问题了。</p><h2 id="Redis-集群方案应该怎么做？都有哪些方案？"><a href="#Redis-集群方案应该怎么做？都有哪些方案？" class="headerlink" title="Redis 集群方案应该怎么做？都有哪些方案？"></a>Redis 集群方案应该怎么做？都有哪些方案？</h2><p>1.twemproxy，大概概念是，它类似于一个代理方式， 使用时在本需要连接 redis 的地方改为连接 twemproxy， 它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再返回 twemproxy。<br>缺点： twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</p><p>2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新 hash 节点</p><p>3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p><h2 id="有没有尝试进行多机redis-的部署？如何保证数据一致的？"><a href="#有没有尝试进行多机redis-的部署？如何保证数据一致的？" class="headerlink" title="有没有尝试进行多机redis 的部署？如何保证数据一致的？"></a>有没有尝试进行多机redis 的部署？如何保证数据一致的？</h2><p>主从复制，读写分离<br>一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</p><h2 id="对于大量的请求怎么样处理"><a href="#对于大量的请求怎么样处理" class="headerlink" title="对于大量的请求怎么样处理"></a>对于大量的请求怎么样处理</h2><p>redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求；<br>redis是通过IO多路复用（select，epoll, kqueue，依据不同的平台，采取不同的实现）来处理多个客户端请求的</p><h2 id="Redis-常见性能问题和解决方案？"><a href="#Redis-常见性能问题和解决方案？" class="headerlink" title="Redis 常见性能问题和解决方案？"></a>Redis 常见性能问题和解决方案？</h2><p>(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件<br>(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次<br>(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内<br>(4) 尽量避免在压力很大的主库上增加从库<br>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master &lt;- Slave1 &lt;- Slave2 &lt;-<br>Slave3…</p><h2 id="讲解下Redis线程模型"><a href="#讲解下Redis线程模型" class="headerlink" title="讲解下Redis线程模型"></a>讲解下Redis线程模型</h2><p>文件事件处理器包括分别是<strong>套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器</strong>。使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。<br>I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br><strong>工作原理：</strong><br>1)I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br>尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字.<br><img data-src="https://img-blog.csdnimg.cn/20190429094050254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0J1dHRlcmZseV9yZXN0aW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="为什么Redis的操作是原子性的，怎么保证原子性的？"><a href="#为什么Redis的操作是原子性的，怎么保证原子性的？" class="headerlink" title="为什么Redis的操作是原子性的，怎么保证原子性的？"></a>为什么Redis的操作是原子性的，怎么保证原子性的？</h2><p>对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。<br>Redis的操作之所以是原子性的，是因为Redis是单线程的。<br>Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。<br>多个命令在并发中也是原子性的吗？<br>不一定， 将get和set改成单命令操作，incr 。使用Redis的事务，或者使用Redis+Lua==的方式实现.</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的<br>Redis会将一个事务中的所有命令序列化，然后按顺序执行。<br>1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。<br>2.如果在一个事务中的<strong>命令</strong>出现错误，那么<strong>所有的命令</strong>都不会执行；<br>3.如果在一个事务中出现<strong>运行错误</strong>，那么<strong>正确的命令</strong>会被执行。<br>注：redis的discard只是结束本次事务,正确命令造成的影响仍然存在.</p><p>1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。<br>2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。<br>3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。<br>4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</p><h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。<br>将 key 的值设为 value ，当且仅当 key 不存在。 若给定的 key 已经存在，则 SETNX 不做任何动作<br><img data-src="https://img-blog.csdnimg.cn/20190429094250409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0J1dHRlcmZseV9yZXN0aW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解锁：使用 del key 命令就能释放锁<br>解决死锁：<br>1）通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。<br>2） 使用 setnx key “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis常见面试题</title>
      <link href="/2020/08/12/MyBatis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/12/MyBatis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis常见面试题总结"><a href="#Mybatis常见面试题总结" class="headerlink" title="Mybatis常见面试题总结"></a>Mybatis常见面试题总结</h1><p><strong>1、什么是Mybatis？</strong></p><p>（1）Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</p><p>（2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p><p>（3）通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</p><p><strong>2、Mybaits的优点：</strong></p><p>（1）基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</p><p>（2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p><p>（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p><p>（4）能够与Spring很好的集成；</p><p>（5）提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p><p><strong>3、MyBatis框架的缺点：</strong></p><p>（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p><p>（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><p><strong>4、MyBatis框架适用场合：</strong></p><p>（1）MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</p><p>（2）对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</p><p><strong>5、MyBatis与Hibernate有哪些不同？</strong></p><p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p><p>（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 </p><p>（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。 </p><p><strong>6、#{}和${}的区别是什么？</strong></p><p>#{}是预编译处理，${}是字符串替换。</p><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p><p>Mybatis在处理${}时，就是把${}替换成变量的值。</p><p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><p><strong>7、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</strong></p><p>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectorder”</span> <span class="attr">parametertype</span>=<span class="string">”int”</span> <span class="attr">resultetype</span>=<span class="string">”me.gacl.domain.order”</span>&gt;</span></span><br><span class="line">   select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第2种： 通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。</resultMap></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOrder"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"orderresultmap"</span>&gt;</span></span><br><span class="line">       select * from orders where order_id=#&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">”me.gacl.domain.order”</span> <span class="attr">id</span>=<span class="string">”orderresultmap”</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">!–用id属性来映射主键字段–</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">”id”</span> <span class="attr">column</span>=<span class="string">”order_id”</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">“orderno”</span> <span class="attr">column</span> =<span class="string">”order_no”/</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">”price”</span> <span class="attr">column</span>=<span class="string">”order_price”</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">reslutMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>8、 模糊查询like语句该怎么写?</strong></p><p>第1种：在Java代码中添加sql通配符。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string wildcardname = “%smi%”;</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span></span><br><span class="line"> select * from foo where bar like #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第2种：在sql语句中拼接通配符，会引起sql注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string wildcardname = “smi”;</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span></span><br><span class="line">     select * from foo where bar like "%"$&#123;value&#125;"%"</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>9、通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</strong></p><p>Dao接口即Mapper接口。接口的全限名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。</p><p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MapperStatement对象。</delete></update></insert></select></p><blockquote><p>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面 id 为 findStudentById 的 MapperStatement。</p></blockquote><p>Mapper接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回。</p><p><strong>10、Mybatis是如何进行分页的？分页插件的原理是什么？</strong></p><p>​        Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>​       分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><p><strong>11、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</strong></p><p>第一种是使用<resultMap>标签，逐一定义数据库列名和对象属性名之间的映射关系。</resultMap></p><p>第二种是使用sql列的别名功能，将列的别名书写为对象属性名。</p><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><p><strong>12、如何执行批量插入?</strong></p><p>首先,创建一个简单的insert语句:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">”insertname”</span>&gt;</span></span><br><span class="line">     insert into names (name) values (#&#123;value&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在java代码中像下面这样执行批处理插入:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">list<span class="tag">&lt;<span class="name">string</span>&gt;</span> names = new arraylist();</span><br><span class="line">  names.add(“fred”);</span><br><span class="line">  names.add(“barney”);</span><br><span class="line">  names.add(“betty”);</span><br><span class="line">  names.add(“wilma”);</span><br><span class="line"> </span><br><span class="line">  // 注意这里 executortype.batch</span><br><span class="line">  sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch);</span><br><span class="line">  try &#123;</span><br><span class="line">   namemapper mapper = sqlsession.getmapper(namemapper.class);</span><br><span class="line">   for (string name : names) &#123;</span><br><span class="line">       mapper.insertname(name);</span><br><span class="line">   &#125;</span><br><span class="line">   sqlsession.commit();</span><br><span class="line">  &#125;catch(Exception e)&#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   sqlSession.rollback(); </span><br><span class="line">   throw e; </span><br><span class="line">    &#125;</span><br><span class="line">     finally &#123;</span><br><span class="line">       sqlsession.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>13、如何获取自动生成的(主)键值?</strong></p><p>insert 方法总是返回一个int值 ，这个值代表的是插入的行数。</p><p>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。</p><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">”insertname”</span> <span class="attr">usegeneratedkeys</span>=<span class="string">”true”</span> <span class="attr">keyproperty</span>=<span class="string">”id”</span>&gt;</span></span><br><span class="line">     insert into names (name) values (#&#123;name&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name name = <span class="keyword">new</span> name();</span><br><span class="line">name.setname(“fred”);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> rows = mapper.insertname(name);</span><br><span class="line"><span class="comment">// 完成后,id已经被设置到对象中</span></span><br><span class="line">system.out.println(“rows inserted = ” + rows);</span><br><span class="line">system.out.println(“generated key value = ” + name.getid());</span><br></pre></td></tr></table></figure><p><strong>14、在mapper中如何传递多个参数?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）第一种：</span><br><span class="line"><span class="comment">//DAO层的函数</span></span><br><span class="line"><span class="function">Public <span class="title">UserselectUser</span><span class="params">(String name,String area)</span></span>;  </span><br><span class="line"><span class="comment">//对应的xml,#&#123;0&#125;代表接收的是dao层中的第一个参数，#&#123;1&#125;代表dao层中第二参数，更多参数一致往后加即可。</span></span><br><span class="line">&lt;select id=<span class="string">"selectUser"</span>resultMap=<span class="string">"BaseResultMap"</span>&gt;  </span><br><span class="line">    select *  fromuser_user_t   whereuser_name = #&#123;0&#125; anduser_area=#&#123;1&#125;  </span><br><span class="line">&lt;/select&gt;  </span><br><span class="line"> </span><br><span class="line">（<span class="number">2</span>）第二种： 使用 <span class="meta">@param</span> 注解:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">usermapper</span> </span>&#123;</span><br><span class="line">   <span class="function">user <span class="title">selectuser</span><span class="params">(@param(“username”)</span> string username,@<span class="title">param</span><span class="params">(“hashedpassword”)</span> string hashedpassword)</span>;</span><br><span class="line">&#125;</span><br><span class="line">然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper):</span><br><span class="line">&lt;select id=”selectuser” resulttype=”user”&gt;</span><br><span class="line">         select id, username, hashedpassword</span><br><span class="line">         from some_table</span><br><span class="line">         where username = #&#123;username&#125;</span><br><span class="line">         and hashedpassword = #&#123;hashedpassword&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"> </span><br><span class="line">（<span class="number">3</span>）第三种：多个参数封装成map</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL</span></span><br><span class="line"><span class="comment">//由于我们的参数超过了两个，而方法中只有一个Object参数收集，因此我们使用Map集合来装载我们的参数</span></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">     map.put(<span class="string">"start"</span>, start);</span><br><span class="line">     map.put(<span class="string">"end"</span>, end);</span><br><span class="line">     <span class="keyword">return</span> sqlSession.selectList(<span class="string">"StudentID.pagination"</span>, map);</span><br><span class="line"> &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">     sqlSession.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e; &#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"> MybatisUtil.closeSqlSession();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>15、Mybatis动态sql有什么用？执行原理？有哪些动态sql？</strong></p><p>Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接sql的功能。</p><p>Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。</p><p><strong>16、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</strong></p><p>答：<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。</selectKey></include></sql></selectKey></include></sql></parameterMap></resultMap></p><p><strong>17、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</strong></p><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；</p><p>原因就是namespace+id是作为Map&lt;String, MapperStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><p>但是，在以前的Mybatis版本的namespace是可选的，不过新版本的namespace已经是必须的了。</p><p><strong>18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</strong></p><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><p><strong>19、 一对一、一对多的关联查询 ？</strong> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lcb.mapping.userMapper"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--association  一对一关联查询 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"ClassesResultMap"</span>&gt;</span>  </span><br><span class="line">        select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#&#123;id&#125;  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lcb.user.Classes"</span> <span class="attr">id</span>=<span class="string">"ClassesResultMap"</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 实体类的字段名和数据表的字段名映射 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"c_id"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"c_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.lcb.user.Teacher"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--collection  一对多关联查询 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass2"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"ClassesResultMap2"</span>&gt;</span>  </span><br><span class="line">        select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#&#123;id&#125;  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.lcb.user.Classes"</span> <span class="attr">id</span>=<span class="string">"ClassesResultMap2"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"c_id"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"c_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.lcb.user.Teacher"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span>  </span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"student"</span> <span class="attr">ofType</span>=<span class="string">"com.lcb.user.Student"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"s_id"</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"s_name"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>20、MyBatis实现一对一有几种方式?具体怎么操作的？</strong></p><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；</p><p>嵌套查询是先查一个表，根据这个表里面的结果的 外键id，去再另外一个表里面查询数据,也是通过association配置，但另外一个表的查询通过select属性配置。</p><p><strong>21、MyBatis实现一对多有几种方式,怎么操作的？</strong></p><p>​        有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。</p><p><strong>22、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</strong></p><p>答：Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><p> <strong>23、Mybatis的一级、二级缓存:</strong></p><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p><p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache> ；</cache></p><p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear 掉并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</p><p><strong>24、什么是MyBatis的接口绑定？有哪些实现方式？</strong></p><p>接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p><p>接口绑定有两种实现方式,一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；另外一种就是通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。</p><p><strong>25、使用MyBatis的mapper接口调用时有哪些要求？</strong></p><p>①  Mapper接口方法名和mapper.xml中定义的每个sql的id相同；<br>②  Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；<br>③  Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；<br>④  Mapper.xml文件中的namespace即是mapper接口的类路径。</p><p><strong>26、Mapper编写有哪几种方式？</strong></p><blockquote><p><strong>第一种：接口实现类继承SqlSessionDaoSupport：</strong>使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件。<br>（1）在sqlMapConfig.xml中配置mapper.xml的位置<br><mappers><br>    <mapper resource="mapper.xml文件的地址"><br>    <mapper resource="mapper.xml文件的地址"><br></mapper></mapper></mappers><br>（2）定义mapper接口<br>（3）实现类集成SqlSessionDaoSupport<br>mapper方法中可以this.getSqlSession()进行数据增删改查。<br>（4）spring 配置<br><bean id=" " class="mapper接口的实现"><br>    <property name="sqlSessionFactory" ref="sqlSessionFactory"></property><br></bean></p><p><strong>第二种：使用org.mybatis.spring.mapper.MapperFactoryBean：</strong><br>（1）在sqlMapConfig.xml中配置mapper.xml的位置，如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置<br><mappers><br>    <mapper resource="mapper.xml文件的地址"><br>    <mapper resource="mapper.xml文件的地址"><br></mapper></mapper></mappers><br>（2）定义mapper接口：<br>①mapper.xml中的namespace为mapper接口的地址<br>②mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致<br>③Spring中定义<br><bean id class="org.mybatis.spring.mapper.MapperFactoryBean"><br>    <property name="mapperInterface" value="mapper接口地址"><br>    <property name="sqlSessionFactory" ref="sqlSessionFactory"><br></property></property></bean></p><p><strong>第三种：使用mapper扫描器：</strong><br>（1）mapper.xml文件编写：<br>mapper.xml中的namespace为mapper接口的地址；<br>mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致；<br>如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置。<br>（2）定义mapper接口：<br>注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录<br>（3）配置mapper扫描器：<br><bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"><br>    <property name="basePackage" value="mapper接口包地址"></property><br>    <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"><br></property></bean><br>（4）使用扫描器后从spring容器中获取mapper的实现对象。</p></blockquote><p><strong>27、简述Mybatis的插件运行原理，以及如何编写一个插件。</strong></p><p>答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>编写插件：实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC常见面试题</title>
      <link href="/2020/08/12/SpringMVC%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/12/SpringMVC%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC常见面试题总结"><a href="#SpringMVC常见面试题总结" class="headerlink" title="SpringMVC常见面试题总结"></a>SpringMVC常见面试题总结</h1><p><strong>1、什么是Spring MVC ？简单介绍下你对springMVC的理解?</strong></p><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><p><strong>2、SpringMVC的流程？</strong></p><p>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。</p><p><img data-src="https://img-blog.csdn.net/20180708224853769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><strong>3、Springmvc的优点:</strong></p><p>（1）可以支持各种视图技术,而不仅仅局限于JSP；</p><p>（2）与Spring框架集成（如IoC容器、AOP等）；</p><p>（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。</p><p>（4） 支持各种请求资源的映射策略。</p><p><strong>4、Spring MVC的主要组件？</strong></p><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）</p><p>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p><p>（2）处理器映射器HandlerMapping（不需要程序员开发）</p><p>作用：根据请求的URL来查找Handler</p><p>（3）处理器适配器HandlerAdapter</p><p>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p><p>（4）处理器Handler（需要程序员开发）</p><p>（5）视图解析器 ViewResolver（不需要程序员开发）</p><p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p><p>（6）视图View（需要程序员开发jsp）</p><p>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p><p><strong>5、springMVC和struts2的区别有哪些?</strong></p><p>（1）springmvc的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。</p><p>（2）springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</p><p>（3）Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p><p><strong>6、SpringMVC怎么样设定重定向和转发的？</strong></p><p>（1）转发：在返回值前面加”forward:”，譬如”forward:user.do?name=method4”</p><p>（2）重定向：在返回值前面加”redirect:”，譬如”redirect:<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">http://www.baidu.com&quot;</a></p><p><strong>7、SpringMvc怎么和AJAX相互调用的？</strong></p><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：</p><p>（1）加入Jackson.jar</p><p>（2）在配置文件中配置json的映射</p><p>（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</p><p><strong>8、如何解决POST请求中文乱码问题，GET的又如何处理呢？</strong></p><p>（1）解决post请求乱码问题：</p><p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p><blockquote><filter><p>​    <filter-name>CharacterEncodingFilter</filter-name></p><p>​    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class></p><p>​    <init-param></init-param></p><p>​        <param-name>encoding</param-name></p><p>​        <param-value>utf-8</param-value></p><p>​    </p></filter><filter-mapping><p>​    <filter-name>CharacterEncodingFilter</filter-name></p><p>​    <url-pattern>/*</url-pattern></p></filter-mapping></blockquote><p>（2）get请求中文参数出现乱码解决方法有两个：</p><p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p><blockquote><p>&lt;ConnectorURIEncoding=”utf-8” connectionTimeout=”20000” port=”8080” protocol=”HTTP/1.1” redirectPort=”8443”/&gt;</p></blockquote><p> ②另外一种方法对参数进行重新编码：</p><p>String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),”utf-8”)</p><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p><p><strong>9、Spring MVC的异常处理 ？</strong></p><p>答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p><p><strong>10、SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</strong></p><p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</p><p><strong>11、 SpringMVC常用的注解有哪些？</strong></p><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p><p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p><p><strong>12、SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？</strong></p><p>答：一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。</p><p><strong>13、如果在拦截请求中，我想拦截get方式提交的方法,怎么配置？</strong></p><p>答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。</p><p><strong>14、怎样在方法里面得到Request,或者Session？</strong></p><p>答：直接在方法的形参中声明request,SpringMvc就自动把request对象传入。</p><p><strong>15、如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</strong></p><p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p><p><strong>16、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</strong></p><p>答：直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。</p><p><strong>17、SpringMvc中函数的返回值是什么？</strong></p><p>答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。</p><p><strong>18、SpringMvc用什么对象从后台向前台传递数据的？</strong></p><p>答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p><p><strong>19、怎么样把ModelMap里面的数据放入Session里面？</strong></p><p>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p><p><strong>20、SpringMvc里面拦截器是怎么写的：</strong></p><p>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在SpringMvc的配置文件中配置拦截器即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- 配置SpringMvc的拦截器 --&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myInterceptor"</span> <span class="attr">class</span>=<span class="string">"com.zwp.action.MyHandlerInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 只针对部分请求拦截 --&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/modelMap.do"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.zwp.action.MyHandlerInterceptorAdapter"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>21、注解原理：</strong></p><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring常见面试题</title>
      <link href="/2020/08/12/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/12/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>1、Spring是什么?</strong></p><p>​        Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置。</p><p>主要由以下几个模块组成：</p><p>Spring Core：核心类库，提供IOC服务；</p><p>Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</p><p>Spring AOP：AOP服务；</p><p>Spring DAO：对JDBC的抽象，简化了数据访问异常的处理；</p><p>Spring ORM：对现有的ORM框架的支持；</p><p>Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；</p><p>Spring MVC：提供面向Web应用的Model-View-Controller实现。</p><p><strong>2、Spring 的优点？</strong></p><p>（1）spring属于低侵入式设计，代码的污染极低；</p><p>（2）spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</p><p>（3）Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p><p>（4）spring对于主流的应用框架提供了集成支持。</p><p><strong>3、Spring的AOP理解：</strong></p><p>OOP面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</p><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p><p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><p>​        ①JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,  生成目标类的代理对象。</p><p>​        ②如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p><p>（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p><blockquote><p> InvocationHandler 的 invoke(Object  proxy,Method  method,Object[] args)：proxy是最终生成的代理实例;  method 是被代理目标实例的某个具体方法;  args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p></blockquote><p><strong>4、Spring的IoC理解：</strong></p><p>（1）IOC就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</p><p>（2）最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p><p>（3）Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。</p><blockquote><p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p></blockquote><p><strong>5、BeanFactory和ApplicationContext有什么区别？</strong></p><p>​        BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><p>（1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><p>①继承MessageSource，因此支持国际化。</p><p>②统一的资源文件访问方式。</p><p>③提供在监听器中注册bean的事件。</p><p>④同时加载多个配置文件。</p><p>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p><p>（2）①BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><p>​        ②ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p><p>​        ③相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p><p>（3）BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p><p>（4）BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><p><strong>6、请解释Spring Bean的生命周期？</strong></p><p> 首先说一下Servlet的生命周期：实例化，初始init，接收请求service，销毁destroy；</p><p> Spring上下文中的Bean生命周期也类似，如下：</p><p>（1）实例化Bean：</p><p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p><p>（2）设置对象属性（依赖注入）：</p><p>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><p>（3）处理Aware接口：</p><p>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：</p><p>①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；</p><p>②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。</p><p>③如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文；</p><p>（4）BeanPostProcessor：</p><p>如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p><p>（5）InitializingBean 与 init-method：</p><p>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p><p>（6）如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p><blockquote><p>以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</p></blockquote><p>（7）DisposableBean：</p><p>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p><p>（8）destroy-method：</p><p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p><p><strong>7、 解释Spring支持的几种bean的作用域。</strong></p><p>Spring容器中的bean可以分为5个范围：</p><p>（1）singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。</p><p>（2）prototype：为每一个bean请求提供一个实例。</p><p>（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</p><p>（4）session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</p><p>（5）global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</p><p><strong>8、Spring框架中的单例Beans是线程安全的么？</strong></p><p>​        Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</p><p><strong>9、Spring如何处理线程并发问题？</strong></p><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p><p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p><p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><p><strong>10-1、Spring基于xml注入bean的几种方式：</strong></p><p>（1）Set方法注入；</p><p>（2）构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</p><p>（3）静态工厂注入；</p><p>（4）实例工厂；</p><p>详细内容可以阅读：<a href="https://blog.csdn.net/a745233700/article/details/89307518" target="_blank" rel="noopener">https://blog.csdn.net/a745233700/article/details/89307518</a></p><p><strong>10-2、Spring的自动装配：</strong></p><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p><p>在Spring框架xml配置中共有5种自动装配：</p><p>（1）no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</p><p>（2）byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。 </p><p>（3）byType：通过参数的数据类型进行自动装配。</p><p>（4）constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p><p>（5）autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p><p>基于注解的方式：</p><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</p><p>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p><p>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</p><blockquote><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>注：@Autowired和@Resource之间的区别</p><p>(1) @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p><p>(2) @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p></blockquote><p><strong>11、Spring 框架中都用到了哪些设计模式？</strong></p><p>（1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p><p>（2）单例模式：Bean默认为单例模式。</p><p>（3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p><p>（4）模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p><p>（5）观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p><p><strong>12、Spring事务的实现方式和实现原理：</strong></p><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p><p><strong>（1）Spring事务的种类：</strong></p><p>spring支持编程式事务管理和声明式事务管理两种方式：</p><p>①编程式事务管理使用TransactionTemplate。</p><p>②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><blockquote><p>声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。</p><p>声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式，使业务代码不受污染，只要加上注解就可以获得完全的事务支持。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p></blockquote><p><strong>（2）spring的事务传播行为：</strong></p><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p><blockquote><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘</p><p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p><p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p><p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p></blockquote><p><strong>（3）Spring中的隔离级别：</strong></p><blockquote><p>① ISOLATION_DEFAULT：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。</p><p>② ISOLATION_READ_UNCOMMITTED：读未提交，允许另外一个事务可以看到这个事务未提交的数据。</p><p>③ ISOLATION_READ_COMMITTED：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。</p><p>④ ISOLATION_REPEATABLE_READ：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。</p><p>⑤ ISOLATION_SERIALIZABLE：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。</p></blockquote><p><strong>13、Spring框架中有哪些不同类型的事件？</strong></p><p>Spring 提供了以下5种标准的事件：</p><p>（1）上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</p><p>（2）上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</p><p>（3）上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</p><p>（4）上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</p><p>（5）请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</p><p>如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p><p><strong>14、解释一下Spring AOP里面的几个名词：</strong></p><p>（1）切面（Aspect）：被抽取的公共模块，可能会横切多个对象。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p><p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 </p><p>（3）通知（Advice）：在切面的某个特定的连接点（Join point）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。</p><p>（4）切入点（Pointcut）：切入点是指 我们要对哪些Join point进行拦截的定义。通过切入点表达式，指定拦截的方法，比如指定拦截add<em>、search</em>。</p><p>（5）引入（Introduction）：（也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。</p><p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p><p>（7）织入（Weaving）：指把增强应用到目标对象来创建新的代理对象的过程。Spring是在运行时完成织入。</p><p>切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</p><p><img data-src="https://img-blog.csdn.net/20180708154818891?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><strong>15、Spring通知有哪些类型？</strong></p><p><a href="https://blog.csdn.net/qq_32331073/article/details/80596084" target="_blank" rel="noopener">https://blog.csdn.net/qq_32331073/article/details/80596084</a></p><p>（1）前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</p><p>（2）返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。 </p><p>（3）抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。 </p><p>（4）后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 </p><p>（5）环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。 环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。 </p><blockquote><p>同一个aspect，不同advice的执行顺序：</p><p>①没有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning</p><p>②有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式常见面试题</title>
      <link href="/2020/08/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式常见面试题汇总"><a href="#设计模式常见面试题汇总" class="headerlink" title="设计模式常见面试题汇总"></a>设计模式常见面试题汇总</h2><h4 id="1-说一下设计模式？你都知道哪些？"><a href="#1-说一下设计模式？你都知道哪些？" class="headerlink" title="1.说一下设计模式？你都知道哪些？"></a>1.说一下设计模式？你都知道哪些？</h4><p>答：设计模式总共有 23 种，总体来说可以分为三大类：创建型模式（ Creational Patterns ）、结构型模式（ Structural Patterns ）和行为型模式（ Behavioral Patterns ）。</p><h5 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h5><ul><li><p>工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式 </p></li><li><p>关注于对象的创建，同时隐藏创建逻辑 </p></li></ul><h5 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h5><ul><li>适配器模式、过滤器模式、装饰模式、享元模式、代理模式、外观模式、组合模式、桥接模式 </li><li>关注类和对象之间的组合 </li></ul><h5 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h5><ul><li>责任链模式、命令模式、中介者模式、观察者模式、状态模式、策略模式、模板模式、空对象模式、备忘录模式、迭代器模式、解释器模式、访问者模式 </li><li>关注对象之间的通信   </li></ul><p>下面会对常用的设计模式分别做详细的说明。</p><h4 id="2-什么是单例模式？"><a href="#2-什么是单例模式？" class="headerlink" title="2.什么是单例模式？"></a>2.什么是单例模式？</h4><p>答：单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。</p><p>优点：不会频繁地创建和销毁对象，浪费系统资源。</p><p>使用场景：IO 、数据库连接、Redis 连接等。</p><p>单例模式代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例模式调用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson7</span>\<span class="title">_3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton1 = Singleton.getInstance();</span><br><span class="line">        Singleton singleton2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果：true</p><p>可以看出以上单例模式是在类加载的时候就创建了，这样会影响程序的启动速度，那如何实现单例模式的延迟加载？在使用时再创建？</p><p>单例延迟加载代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例模式-延迟加载版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为非线程安全的，单例模式如何支持多线程？</p><p>使用 synchronized 来保证，单例模式的线程安全代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-什么是简单工厂模式？"><a href="#3-什么是简单工厂模式？" class="headerlink" title="3.什么是简单工厂模式？"></a>3.什么是简单工厂模式？</h4><p>答：简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可。</p><p><strong>优点</strong>：</p><ul><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象；</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量；</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><p><strong>缺点</strong>：</p><ul><li>不易拓展，一旦添加新的产品类型，就不得不修改工厂的创建逻辑；</li><li>产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。</li></ul><p>简单工厂示意图如下：</p><p><img data-src="https://www.cnblogs.com/dailyprogrammer/articles/resources/02F8FF948F8A6033B012F8A6DB595D62" alt="img"></p><p>简单工厂<strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Mocca"</span>:</span><br><span class="line">                result = <span class="string">"摩卡"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Latte"</span>:</span><br><span class="line">                result = <span class="string">"拿铁"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result = <span class="string">"其他"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-什么是抽象工厂模式？"><a href="#4-什么是抽象工厂模式？" class="headerlink" title="4.什么是抽象工厂模式？"></a>4.什么是抽象工厂模式？</h4><p>答：抽象工厂模式是在简单工厂的基础上将未来可能需要修改的代码抽象出来，通过继承的方式让子类去做决定。</p><p>比如，以上面的咖啡工厂为例，某天我的口味突然变了，不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。这个时候就可以使用抽象工厂类了，抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。</p><p>抽象工厂实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 抽象工厂</span></span><br><span class="line">       String result = (<span class="keyword">new</span> CoffeeFactory()).createProduct(<span class="string">"Latte"</span>);</span><br><span class="line">       System.out.println(result); <span class="comment">// output:拿铁</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">createProduct</span><span class="params">(String product)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 啤酒工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeerFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">createProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">       String result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">"Hans"</span>:</span><br><span class="line">               result = <span class="string">"汉斯"</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">"Yanjing"</span>:</span><br><span class="line">               result = <span class="string">"燕京"</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               result = <span class="string">"其他啤酒"</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">/\* \* 咖啡工厂 \*/</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">createProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">       String result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">"Mocca"</span>:</span><br><span class="line">               result = <span class="string">"摩卡"</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">"Latte"</span>:</span><br><span class="line">               result = <span class="string">"拿铁"</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               result = <span class="string">"其他咖啡"</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-什么是观察者模式？"><a href="#5-什么是观察者模式？" class="headerlink" title="5.什么是观察者模式？"></a>5.什么是观察者模式？</h4><p>观察者模式是定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 <strong>优点</strong>：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色；</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合；</li><li>观察者模式支持广播通信；</li><li>观察者模式符合开闭原则（对拓展开放，对修改关闭）的要求。</li></ul><p><strong>缺点</strong>：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间；</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><p>在观察者模式中有如下角色：</p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象；</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知；</li><li>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己；</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><p>观察者模式实现代码如下。</p><h5 id="1）定义观察者（消息接收方）"><a href="#1）定义观察者（消息接收方）" class="headerlink" title="1）定义观察者（消息接收方）"></a>1）定义观察者（消息接收方）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/\* \* 观察者（消息接收方） \*/</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">/\* \* 具体的观察者（消息接收方） \*/</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcrereObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcrereObserver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）定义被观察者（消息发送方）"><a href="#2）定义被观察者（消息发送方）" class="headerlink" title="2）定义被观察者（消息发送方）"></a>2）定义被观察者（消息发送方）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/\* \* 被观察者（消息发布方） \*/</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 增加订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">// 删除订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">// 通知订阅者更新消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">/\* \* 具体被观察者（消息发布方） \*/</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 订阅者列表（存储信息）</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; list = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        list.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        list.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : list) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3）代码调用"><a href="#3）代码调用" class="headerlink" title="3）代码调用"></a>3）代码调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义发布者</span></span><br><span class="line">        ConcreteSubject concreteSubject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        <span class="comment">// 定义订阅者</span></span><br><span class="line">        ConcrereObserver concrereObserver = <span class="keyword">new</span> ConcrereObserver(<span class="string">"老王"</span>);</span><br><span class="line">        ConcrereObserver concrereObserver2 = <span class="keyword">new</span> ConcrereObserver(<span class="string">"Java"</span>);</span><br><span class="line">        <span class="comment">// 添加订阅</span></span><br><span class="line">        concreteSubject.attach(concrereObserver);</span><br><span class="line">        concreteSubject.attach(concrereObserver2);</span><br><span class="line">        <span class="comment">// 发布信息</span></span><br><span class="line">        concreteSubject.notify(<span class="string">"更新了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果如下：</p><blockquote><p>老王：更新了</p><p>Java：更新了</p></blockquote><h4 id="6-什么是装饰器模式？"><a href="#6-什么是装饰器模式？" class="headerlink" title="6.什么是装饰器模式？"></a>6.什么是装饰器模式？</h4><p>答：装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。</p><p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p>装饰器模式的关键：装饰器中使用了被装饰的对象。</p><p>比如，创建一个对象“laowang”，给对象添加不同的装饰，穿上夹克、戴上帽子……，这个执行过程就是装饰者模式，实现代码如下。</p><h5 id="1）定义顶层对象，定义行为"><a href="#1）定义顶层对象，定义行为" class="headerlink" title="1）定义顶层对象，定义行为"></a>1）定义顶层对象，定义行为</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）定义装饰器超类"><a href="#2）定义装饰器超类" class="headerlink" title="2）定义装饰器超类"></a>2）定义装饰器超类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorBase</span> <span class="keyword">implements</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">    IPerson iPerson;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecoratorBase</span><span class="params">(IPerson iPerson)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iPerson = iPerson;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        iPerson.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3）定义具体装饰器"><a href="#3）定义具体装饰器" class="headerlink" title="3）定义具体装饰器"></a>3）定义具体装饰器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jacket</span> <span class="keyword">extends</span> <span class="title">DecoratorBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Jacket</span><span class="params">(IPerson iPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(iPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行已有功能</span></span><br><span class="line">        iPerson.show();</span><br><span class="line">        <span class="comment">// 定义新行为</span></span><br><span class="line">        System.out.println(<span class="string">"穿上夹克"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hat</span> <span class="keyword">extends</span> <span class="title">DecoratorBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hat</span><span class="params">(IPerson iPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(iPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行已有功能</span></span><br><span class="line">        iPerson.show();</span><br><span class="line">        <span class="comment">// 定义新行为</span></span><br><span class="line">        System.out.println(<span class="string">"戴上帽子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4）定义具体对象"><a href="#4）定义具体对象" class="headerlink" title="4）定义具体对象"></a>4）定义具体对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaoWang</span> <span class="keyword">implements</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"什么都没穿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5）装饰器模式调用"><a href="#5）装饰器模式调用" class="headerlink" title="5）装饰器模式调用"></a>5）装饰器模式调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LaoWang laoWang = <span class="keyword">new</span> LaoWang();</span><br><span class="line">        Jacket jacket = <span class="keyword">new</span> Jacket(laoWang);</span><br><span class="line">        Hat hat = <span class="keyword">new</span> Hat(jacket);</span><br><span class="line">        hat.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-什么是模板方法模式？"><a href="#7-什么是模板方法模式？" class="headerlink" title="7.什么是模板方法模式？"></a>7.什么是模板方法模式？</h4><p>答：模板方法模式是指定义一个模板结构，将具体内容延迟到子类去实现。</p><p><strong>优点</strong>：</p><ul><li>提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中；</li><li>实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制并且符合开闭原则。</li></ul><p>以给冰箱中放水果为例，比如，我要放一个香蕉：开冰箱门 → 放香蕉 → 关冰箱门；如果我再要放一个苹果：开冰箱门 → 放苹果 → 关冰箱门。可以看出它们之间的行为模式都是一样的，只是存放的水果品类不同而已，这个时候就非常适用模板方法模式来解决这个问题，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/\* \* 添加模板方法 \*/</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Refrigerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开冰箱门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关冰箱门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Refrigerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"放香蕉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Refrigerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"放苹果"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/\* \* 调用模板方法 \*/</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Refrigerator refrigerator = <span class="keyword">new</span> Banana();</span><br><span class="line">        refrigerator.open();</span><br><span class="line">        refrigerator.put();</span><br><span class="line">        refrigerator.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>开冰箱门</p><p>放香蕉</p><p>关冰箱门</p></blockquote><h4 id="8-什么是代理模式？"><a href="#8-什么是代理模式？" class="headerlink" title="8.什么是代理模式？"></a>8.什么是代理模式？</h4><p>代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p><p><strong>优点</strong>：</p><ul><li>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；</li><li>可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。</li></ul><p><strong>缺点</strong>：</p><ul><li>由于使用了代理模式，因此程序的性能没有直接调用性能高；</li><li>使用代理模式提高了代码的复杂度。</li></ul><p>举一个生活中的例子：比如买飞机票，由于离飞机场太远，直接去飞机场买票不太现实，这个时候我们就可以上携程 App 上购买飞机票，这个时候携程 App 就相当于是飞机票的代理商。</p><p>代理模式实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/\* \* 定义售票接口 \*/</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAirTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">/\* \* 定义飞机场售票 \*/</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirTicket</span> <span class="keyword">implements</span> <span class="title">IAirTicket</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买票"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/\* \* 代理售票平台 \*/</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyAirTicket</span> <span class="keyword">implements</span> <span class="title">IAirTicket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AirTicket airTicket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyAirTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        airTicket = <span class="keyword">new</span> AirTicket();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        airTicket.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/\* \* 代理模式调用 \*/</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IAirTicket airTicket = <span class="keyword">new</span> ProxyAirTicket();</span><br><span class="line">        airTicket.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-什么是策略模式？"><a href="#9-什么是策略模式？" class="headerlink" title="9.什么是策略模式？"></a>9.什么是策略模式？</h4><p>答：策略模式是指定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。</p><p><strong>优点</strong>：遵循了开闭原则，扩展性良好。</p><p><strong>缺点</strong>：随着策略的增加，对外暴露越来越多。</p><p>以生活中的例子来说，比如我们要出去旅游，选择性很多，可以选择骑车、开车、坐飞机、坐火车等，就可以使用策略模式，把每种出行作为一种策略封装起来，后面增加了新的交通方式了，如超级高铁、火箭等，就可以不需要改动原有的类，新增交通方式即可，这样也符合软件开发的开闭原则。 策略模式实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/\* \* 声明旅行 \*/</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITrip</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">going</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">implements</span> <span class="title">ITrip</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">going</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"骑自行车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drive</span> <span class="keyword">implements</span> <span class="title">ITrip</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">going</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/\* \* 定义出行类 \*/</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trip</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITrip trip;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trip</span><span class="params">(ITrip trip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.trip = trip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTrip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.trip.going();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/\* \* 执行方法 \*/</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trip trip = <span class="keyword">new</span> Trip(<span class="keyword">new</span> Bike());</span><br><span class="line">        trip.doTrip();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果：</p><blockquote><p>骑自行车</p></blockquote><h4 id="10-什么是适配器模式？"><a href="#10-什么是适配器模式？" class="headerlink" title="10.什么是适配器模式？"></a>10.什么是适配器模式？</h4><p>答：适配器模式是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。</p><p><strong>优点</strong>：</p><ul><li>可以让两个没有关联的类一起运行，起着中间转换的作用；</li><li>灵活性好，不会破坏原有的系统。</li></ul><p><strong>缺点</strong>：过多地使用适配器，容易使代码结构混乱，如明明看到调用的是 A 接口，内部调用的却是 B 接口的实现。</p><p>以生活中的例子来说，比如有一个充电器是 MicroUSB 接口，而手机充电口却是 TypeC 的，这个时候就需要一个把 MicroUSB 转换成 TypeC 的适配器，如下图所示：</p><p>适配器实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/\* \* 传统的充电线 MicroUSB \*/</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MicroUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">charger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">/\* \* TypeC 充电口 \*/</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITypeC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">charger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeC</span> <span class="keyword">implements</span> <span class="title">ITypeC</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TypeC 充电"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/\* \* 适配器 \*/</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapterMicroUSB</span> <span class="keyword">implements</span> <span class="title">MicroUSB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TypeC typeC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdapterMicroUSB</span><span class="params">(TypeC typeC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeC = typeC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        typeC.charger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/\* \* 测试调用 \*/</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TypeC typeC = <span class="keyword">new</span> TypeC();</span><br><span class="line">        MicroUSB microUSB = <span class="keyword">new</span> AdapterMicroUSB(typeC);</span><br><span class="line">        microUSB.charger();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>TypeC 充电</p></blockquote><h4 id="11-JDK-类库常用的设计模式有哪些？"><a href="#11-JDK-类库常用的设计模式有哪些？" class="headerlink" title="11.JDK 类库常用的设计模式有哪些？"></a>11.JDK 类库常用的设计模式有哪些？</h4><p>答：JDK 常用的设计模式如下：</p><h5 id="1）工厂模式"><a href="#1）工厂模式" class="headerlink" title="1）工厂模式"></a>1）工厂模式</h5><p>java.text.DateFormat 工具类，它用于格式化一个本地日期或者时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style,Locale locale)</span></span>;</span><br></pre></td></tr></table></figure><p>加密类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"DESede"</span>);</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"DESede"</span>);</span><br></pre></td></tr></table></figure><h5 id="2）适配器模式"><a href="#2）适配器模式" class="headerlink" title="2）适配器模式"></a>2）适配器模式</h5><p>把其他类适配为集合类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; arrayList = java.util.Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">List&lt;Integer&gt; arrayList = java.util.Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h5 id="3）代理模式"><a href="#3）代理模式" class="headerlink" title="3）代理模式"></a>3）代理模式</h5><p>如 JDK 本身的动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"The dog is eating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"The cat is eating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">// 取得代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用前"</span>);</span><br><span class="line">        Object result = method.invoke(target, args); <span class="comment">// 方法调用</span></span><br><span class="line">        System.out.println(<span class="string">"调用后"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JDK 动态代理调用</span></span><br><span class="line">    AnimalProxy proxy = <span class="keyword">new</span> AnimalProxy();</span><br><span class="line">    Animal dogProxy = (Animal) proxy.getInstance(<span class="keyword">new</span> Dog());</span><br><span class="line">    dogProxy.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4）单例模式"><a href="#4）单例模式" class="headerlink" title="4）单例模式"></a>4）单例模式</h5><p>全局只允许有一个实例，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime();</span><br></pre></td></tr></table></figure><h5 id="5）装饰器"><a href="#5）装饰器" class="headerlink" title="5）装饰器"></a>5）装饰器</h5><p>为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.BufferedInputStream(InputStream);  </span><br><span class="line">java.io.DataInputStream(InputStream);  </span><br><span class="line">java.io.BufferedOutputStream(OutputStream);  </span><br><span class="line">java.util.zip.ZipOutputStream(OutputStream);  </span><br><span class="line">java.util.Collections.checkedList(List list, Class type) ;</span><br></pre></td></tr></table></figure><h5 id="6）模板方法模式"><a href="#6）模板方法模式" class="headerlink" title="6）模板方法模式"></a>6）模板方法模式</h5><p>定义一个操作中算法的骨架，将一些步骤的执行延迟到其子类中。</p><p>比如，Arrays.sort() 方法，它要求对象实现 Comparable 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Person person = (Person)o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age.compareTo(person.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">SortTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">10</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">5</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="number">15</span>);</span><br><span class="line">        Person[] persons = &#123;p1,p2,p3&#125;;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(persons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-IO-使用了什么设计模式？"><a href="#12-IO-使用了什么设计模式？" class="headerlink" title="12.IO 使用了什么设计模式？"></a>12.IO 使用了什么设计模式？</h4><p>答：IO 使用了适配器模式和装饰器模式。</p><ul><li>适配器模式：由于 InputStream 是字节流不能享受到字符流读取字符那么便捷的功能，借助 InputStreamReader 将其转为 Reader 子类，因而可以拥有便捷操作文本文件方法；</li><li>装饰器模式：将 InputStream 字节流包装为其他流的过程就是装饰器模式，比如，包装为 FileInputStream、ByteArrayInputStream、PipedInputStream 等。</li></ul><h4 id="13-Spring-中都使用了哪些设计模式？"><a href="#13-Spring-中都使用了哪些设计模式？" class="headerlink" title="13.Spring 中都使用了哪些设计模式？"></a>13.Spring 中都使用了哪些设计模式？</h4><p>答：Spring 框架使用的设计模式如下。</p><ul><li>代理模式：在 AOP 中有使用</li><li>单例模式：bean 默认是单例模式</li><li>模板方法模式：jdbcTemplate</li><li>工厂模式：BeanFactory</li><li>观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用，比如，ContextStartedEvent 就是 ApplicationContext 启动后触发的事件</li><li>适配器模式：Spring MVC 中也是用到了适配器模式适配 Controller</li></ul><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM常见面试题</title>
      <link href="/2020/08/11/JVM%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/11/JVM%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>前言：</strong></p><p>　　在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：知名互联网公司校招 Java 开发岗面试知识点解析 ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p><p><strong>(一)JVM 基础知识</strong></p><p><strong>1)Java 是如何实现跨平台的?</strong></p><p>注意：跨平台的是 Java 程序，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</p><p>答：我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。Java 虚拟机(JVM)就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。</p><p>而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。</p><p><strong>2)什么是 JVM ?</strong></p><p>解析：不仅仅是基本概念，还有 JVM 的作用。</p><p>答：JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。</p><p><strong>3)JVM 由哪些部分组成?</strong></p><p>解析：这是对 JVM 体系结构的考察</p><p>答：JVM 的结构基本上由 4 部分组成：</p><p>类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中</p><p>执行引擎，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU</p><p>内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等</p><p>本地方法调用，调用 C 或 C++ 实现的本地方法的代码返回结果</p><p><strong>4)类加载器是有了解吗?</strong></p><p>解析：底层原理的考察，其中涉及到类加载器的概念，功能以及一些底层的实现。</p><p>答：顾名思义，类加载器(class loader)用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序(.java 文件)在经过 Java 编译器编译之后就被转换成 Java 字节代码(.class 文件)。</p><p>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><p><strong>面试官：Java 虚拟机是如何判定两个 Java 类是相同的?</strong></p><p>答：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。</p><p><strong>5)类加载器是如何加载 class 文件的?</strong></p><p>答：下图所示是 ClassLoader 加载一个 class 文件到 JVM 时需要经过的步骤：</p><p>　　第一个阶段是找到 .class 文件并把这个文件包含的字节码加载到内存中</p><p>　　第二阶段又可以分为三个步骤，分别是字节码验证、Class 类数据结构分析及相应的内存分配和最后的符号表的链接</p><p>　　第三个阶段是类中静态属性和初始化赋值，以及静态块的执行等</p><p>面试官：能详细讲讲吗?</p><p>答：</p><p><strong>1.加载</strong></p><p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><p>通过一个类的全限定名来获取其定义的二进制字节流。</p><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p><p>在Java堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</p><p>相对于类加载的其他阶段而言，加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p><strong>2.连接</strong></p><p>验证：确保被加载的类的正确性</p><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><p>文件格式验证：验证字节流是否符合Class文件格式的规范;例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p><p>元数据验证：对字节码描述的信息进行语义分析(注意：对比javac编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求;例如：这个类是否有父类，除了 java.lang.Object之外。</p><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p><p>符号引用验证：确保解析动作能正确执行。</p><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p>准备：为类的静态变量分配内存，并将其初始化为默认值</p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><p>① 这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p><p>② 这里所设置的初始值通常情况下是数据类型默认的零值(如0、0L、null、false等)，而不是被在Java代码中被显式地赋予的值。</p><p>假设一个类变量的定义为： public static int value = 3;</p><p>那么变量value在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的public static指令是在程序编译后，存放于类构造器 ()方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p><p>这里还需要注意如下几点：</p><p>对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</p><p>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过;而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</p><p>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</p><p>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</p><p>③ 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。</p><p>假设上面的类变量 value 被定义为： public static final int value = 3;</p><p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中</p><p>解析：把类中的符号引用转换为直接引用</p><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p><strong>3.初始化</strong></p><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><p>① 声明类变量是指定初始值</p><p>② 使用静态代码块为类变量指定初始值</p><p>JVM初始化步骤</p><p>　　1、假如这个类还没有被加载和连接，则程序先加载并连接该类</p><p>　　2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p><p>　　3、假如类中有初始化语句，则系统依次执行这些初始化语句</p><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><p>创建类的实例，也就是new的方式</p><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p><p>调用类的静态方法</p><p>反射(如 Class.forName(“com.shengsiyuan.Test”))</p><p>初始化某个类的子类，则其父类也会被初始化</p><p>Java虚拟机启动时被标明为启动类的类( JavaTest)，直接使用 java.exe命令来运行某个主类</p><p>结束生命周期</p><p>在如下几种情况下，Java虚拟机将结束生命周期</p><p>执行了 System.exit()方法</p><p>程序正常执行结束</p><p>程序在执行过程中遇到了异常或错误而异常终止</p><p>由于操作系统出现错误而导致Java虚拟机进程终止</p><p>参考文章：jvm系列(一):java类的加载机制 - 纯洁的微笑</p><p><strong>7)双亲委派模型(Parent Delegation Model)?</strong></p><p>解析：类的加载过程采用双亲委派机制，这种机制能更好的保证 Java 平台的安全性</p><p>答：类加载器 ClassLoader 是具有层次结构的，也就是父子关系，其中，Bootstrap 是所有类加载器的父亲，如下图所示：</p><p>该模型要求除了顶层的 Bootstrap class loader 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承(Inheritance)的关系来实现，而是通过组合(Composition)关系来复用父加载器的代码。每个类加载器都有自己的命名空间(由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字(包括类的包名)相同的两个类;在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类)</p><p><strong>面试官：双亲委派模型的工作过程?</strong></p><p>答：</p><p>1.当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</p><p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，</p><p>等下次加载的时候就可以直接返回了。</p><p>2.当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.</p><p>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</p><p><strong>面试官：为什么这样设计呢?</strong></p><p>解析：这是对于使用这种模型来组织累加器的好处</p><p>答：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException.</p><p>参考文章： JVM 的 工作原理，层次结构 以及 GC工作原理</p><p><strong>(二)JVM 内存管理</strong></p><p><strong>1)JVM 内存划分：</strong></p><p>答：</p><p>方法区(线程共享)：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做 Non-Heap(非堆)，目的应该是与 Java 堆区分开来。</p><p>运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</p><p>堆内存(线程共享)：所有线程共享的一块区域，垃圾收集器管理的主要区域。目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代;再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照8:1:1的比例来分配。根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</p><p>程序计数器： Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是 Native 方法，这个计数器值则为空(Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><p>虚拟机栈(栈内存)：Java线程私有，虚拟机展描述的是Java方法执行的内存模型：每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息;每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程;</p><p>本地方法栈 ：和Java虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 native 方法的服务</p><p><strong>2)对象分配规则?</strong></p><p>答：</p><p>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</p><p>大对象直接进入老年代(大对象是指需要大量连续内存空间的对象)。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝(新生代采用复制算法收集内存)。</p><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</p><p>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p><p>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</p><p><strong>3)Java 的内存模型：</strong></p><p>答：</p><p>Java 虚拟机规范中试图定义一种 Java 内存模型(Java Memory Model, JMM)来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><p>Java 内存模型规定了所有的变量都存储在主内存(Main Memory)中。每条线程还有自己的工作内存(Working Memory)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在主内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如上图。</p><p><strong>面试官：两个线程之间是如何通信的呢?</strong></p><p>答：在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。</p><p>例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：</p><p>1.首先，线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去</p><p>2.然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量</p><p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 Java 中典型的消息传递方式就是 wait() 和 notify()。</p><p><strong>5)内存屏障?</strong></p><p>解析：在这之前应该对重排序的问题有所了解，这里我找到一篇很好的文章分享一下：Java内存访问重排序的研究</p><p>答：内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。</p><p><strong>面试官：内存屏障为何重要?</strong></p><p>答：对主存的一次访问一般花费硬件的数百次时钟周期。处理器通过缓存(caching)能够从数量级上降低内存延迟的成本这些缓存为了性能重新排列待定内存操 作的顺序。也就是说，程序的读写操作不一定会按照它要求处理器的顺序执行。当数据是不可变的，同时/或者数据限制在线程范围内，这些优化是无害的。如果把 这些优化与对称多处理(symmetric multi-processing)和共享可变状态(shared mutable state)结合，那么就是一场噩梦。当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据 写入的顺序不一致。适当的放置内存屏障通过强制处理器顺序执行待定的内存操作来避免这个问题。</p><p><strong>5)类似-Xms、-Xmn这些参数的含义：</strong></p><p>答：</p><p>堆内存分配：</p><p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64</p><p>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4</p><p>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制;空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。</p><p>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。</p><p>非堆内存分配：</p><p>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64;</p><p>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。</p><p>-Xmn2G：设置年轻代大小为2G。</p><p>-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。</p><p><strong>6)内存泄漏和内存溢出</strong></p><p>答：</p><p>概念：</p><p>内存溢出指的是内存不够用了。</p><p>内存泄漏是指对象可达，但是没用了。即本该被GC回收的对象并没有被回收</p><p>内存泄露是导致内存溢出的原因之一;内存泄露积累起来将导致内存溢出。</p><p>内存泄漏的原因分析：</p><p>长生命周期的对象引用短生命周期的对象</p><p>没有将无用对象置为null</p><p>小结：本小节涉及到 JVM 虚拟机，包括对内存的管理等知识，相对较深。除了以上问题，面试官会继续问你一些比较深的问题，可能也是为了看看你的极限在哪里吧。比如：内存调优、内存管理，是否遇到过内存泄露的实际案例、是否真正关心过内存等。</p><p><strong>7)简述一下 Java 中创建一个对象的过程?</strong></p><p>解析：回答这个问题首先就要清楚类的生命周期</p><p>答：下图展示的是类的生命周期流向：</p><p>Java中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于new关键字创建的普通Java对象，不包括数组对象的创建。</p><p>大致过程如下：</p><p>1.检测类是否被加载：</p><p>　　当虚拟机执行到new时，会先去常量池中查找这个类的符号引用。如果能找到符号引用，说明此类已经被加载到方法区(方法区存储虚拟机已经加载的类的信息)，可以继续执行;如果找不到符号引用，就会使用类加载器执行类的加载过程，类加载完成后继续执行。</p><p>2.为对象分配内存：</p><p>　　类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。</p><p>　　具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。</p><p>　　对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。</p><p>　　对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。</p><p>分配内存的时候也需要考虑线程安全问题，有两种解决方案：</p><p>　　第一种是采用同步的办法，使用CAS来保证操作的原子性。</p><p>　　另一种是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲(TLAB)，分配内存的时候再TLAB上分配，互不干扰。</p><p>3.为分配的内存空间初始化零值：</p><p>对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。</p><p>4.对对象进行其他设置：</p><p>分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄等信息。</p><p>5.执行 init 方法：</p><p>执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于Java程序来说还需要执行init方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了init方法之后，这个对象才真正能使用。</p><p>到此为止一个对象就产生了，这就是new关键字创建对象的过程。过程如下：</p><p>参考文章：Java创建对象的过程简介</p><p><strong>面试官：对象的内存布局是怎样的?</strong></p><p>答：对象的内存布局包括三个部分：对象头，实例数据和对齐填充。</p><p>对象头：对象头包括两部分信息，第一部分是存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁等等。第二部分是类型指针，即对象指向类元数据的指针。</p><p>实例数据：就是数据啦</p><p>对齐填充：不是必然的存在，就是为了对齐的嘛</p><p>面试官：对象是如何定位访问的?</p><p>答：对象的访问定位有两种：句柄定位和直接指针</p><p>句柄定位：Java 堆会画出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</p><p>直接指针访问：java堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址</p><p>比较：使用直接指针就是速度快，使用句柄reference指向稳定的句柄，对象被移动改变的也只是句柄中实例数据的指针，而reference本身并不需要修改。</p><p>参考文章：JAVA对象创建的过程</p><p><strong>(三)GC 相关</strong></p><p><strong>1)如何判断一个对象是否已经死去?</strong></p><p>答：</p><p>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p><p>可达性分析(Reachability Analysis)：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><p><strong>2)垃圾回收算法有哪些?</strong></p><p>答：</p><p>引用计数：</p><p>　　原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</p><p>标记-清除：</p><p>　　此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p><p>复制算法：</p><p>　　此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</p><p>标记-整理：</p><p>　　此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。</p><p>分代收集算法：</p><p>　　分代收集算法并没有提出新的思想，只是根据对象存活周期的不同将内存划为几块。一般Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。</p><p>　　在新生袋中每次垃圾手机时都会由大批对象死去，只有少量存活，那就用复制算法，只需要付出少量存活对象的复制成本就可以。老年代中对象存活率高、没有额外担保，所以必须使用“标记-清理”或者“标记整理算法。</p><p>参考文章：jvm系列(三):GC算法 垃圾收集器——纯洁的微笑</p><p><strong>3)GC什么时候开始?</strong></p><p>答：GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个Eden区和两个Survivor区。</p><p>对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快;</p><p>Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝;</p><p>发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。</p><p><strong>4)引用的分类?</strong></p><p>答：</p><p>强引用：通过new出来的引用，只要强引用还存在，则不会回收。</p><p>软引用：通过SoftReference类来实现，用来描述一些有用但非必须的对象。在系统将要发生内存溢出异常之前，会把这些对象回收了，如果这次回收还是内存不够的话，才抛出内存溢出异常。</p><p>弱引用：非必须对象，通过WeakReference类来实现，被弱引用引用的对象，只要已发生GC就会把它干掉。</p><p>虚引用：通过PhantomReference类来实现，无法通过徐引用获得对象的实例，唯一作用就是在这个对象被GC时会收到一个系统通知。</p><p>扩展阅读：重新认识java(一) —- 万物皆对象 ，文章中有对这四个引用有详细的描述，还有一些典型的应用，这里就不摘过来啦…</p><p><strong>5)垃圾收集器?</strong></p><p>解析：如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p><p>答：</p><p>1.Serial 收集器</p><p>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收;新生代复制算法、老年代标记-压缩;垃圾收集的过程中会 Stop The World(服务暂停)</p><p>参数控制： -XX:+UseSerialGC 串行收集器</p><p>2.ParNew 收集器</p><p>ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行;新生代复制算法、老年代标记-压缩</p><p>参数控制：</p><p>　　-XX:+UseParNewGC ParNew收集器</p><p>　　-XX:ParallelGCThreads 限制线程数量</p><p>3.Parallel Scavenge收集器</p><p>Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量;也可以通过参数控制GC的时间不大于多少毫秒或者比例;新生代复制算法、老年代标记-压缩</p><p>参数控制： -XX:+UseParallelGC 使用Parallel收集器+ 老年代串行</p><p>4.Parallel Old 收集器</p><p>Parallel Old是Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在 JDK 1.6 中才开始提供</p><p>参数控制： -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行</p><p>5.CMS收集器</p><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p><p>从名字(包含“Mark Sweep”)上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p><p>初始标记(CMS initial mark)</p><p>并发标记(CMS concurrent mark)</p><p>重新标记(CMS remark)</p><p>并发清除(CMS concurrent sweep)</p><p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器(新生代使用ParNew)</p><p>优点: 并发收集、低停顿</p><p>缺点: 产生大量空间碎片、并发阶段会降低吞吐量</p><p>参数控制：</p><p>-XX:+UseConcMarkSweepGC 使用CMS收集器</p><p>-XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理;整理过程是独占的，会引起停顿时间变长</p><p>-XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后，进行一次碎片整理</p><p>-XX:ParallelCMSThreads 设定CMS的线程数量(一般情况约等于可用CPU数量)</p><p>6.G1收集器</p><p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：</p><p>空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p><p>可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java(RTSJ)的垃圾收集器的特征了。</p><p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分(可以不连续)Region的集合。</p><p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p><p>收集步骤：</p><p>　　1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p><p>　　2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p><p>　　3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p><p>　　4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行);G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p><p>　　5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p><p>　　6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p><p>参考文章：jvm系列(三):GC算法 垃圾收集器——纯洁的微笑</p><p><strong>(四)其他 JVM 相关面试题整理</strong></p><p><strong>1)64 位 JVM 中，int 的长度是多数?</strong></p><p>答：Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位或者 4 个字节。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p><p><strong>2)怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位?</strong></p><p>答：Sun有一个Java System属性来确定JVM的位数：32或64：</p><p>sun.arch.data.model=32 // 32 bit JVM</p><p>sun.arch.data.model=64 // 64 bit JVM</p><p>我可以使用以下语句来确定 JVM 是 32 位还是 64 位：</p><p>System.getProperty(“sun.arch.data.model”)</p><p><strong>3)32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数?</strong></p><p>答：理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。</p><p><strong>4)你能保证 GC 执行吗?</strong></p><p>答：不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。</p><p><strong>5)怎么获取 Java 程序使用的内存?堆使用的百分比?</strong></p><p>答：可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。</p><p><strong>6)Java 中堆和栈有什么区别?</strong></p><p>答：JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p><p><strong>7)怎么如何获取堆和栈的dump文件？</strong></p><p>答：Java Dump，Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。</p><p>​     可以使用在服务器上使用jmap命令来获取堆dump，使用jstack命令来获取线程的调用栈dump。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库常见面试题</title>
      <link href="/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="史上最全的数据库面试题"><a href="#史上最全的数据库面试题" class="headerlink" title="史上最全的数据库面试题"></a>史上最全的数据库面试题</h1><h1 id="数据库面试知识点汇总"><a href="#数据库面试知识点汇总" class="headerlink" title="数据库面试知识点汇总"></a>数据库面试知识点汇总</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h4 id="1-主键、外键、超键、候选键"><a href="#1-主键、外键、超键、候选键" class="headerlink" title="1.主键、外键、超键、候选键"></a><strong>1.主键、外键、超键、候选键</strong></h4><blockquote><p><strong>超键</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p><p><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</p><p><strong>主键</strong>：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p><p><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</p></blockquote><h4 id="2-为什么用自增列作为主键"><a href="#2-为什么用自增列作为主键" class="headerlink" title="2.为什么用自增列作为主键"></a><strong>2.为什么用自增列作为主键</strong></h4><blockquote><p>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、</p><p>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、</p><p>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</p><p>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p></blockquote><h4 id="3-触发器的作用？"><a href="#3-触发器的作用？" class="headerlink" title="3.触发器的作用？"></a><strong>3.触发器的作用？</strong></h4><blockquote><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p></blockquote><h4 id="4-什么是存储过程？用什么来调用？"><a href="#4-什么是存储过程？用什么来调用？" class="headerlink" title="4.什么是存储过程？用什么来调用？"></a><strong>4.什么是存储过程？用什么来调用？</strong></h4><blockquote><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>调用：</strong></p><p>1）可以用一个命令对象来调用存储过程。</p><p>2）可以供外部程序调用，比如：java程序。</p></blockquote><h4 id="5-存储过程的优缺点？"><a href="#5-存储过程的优缺点？" class="headerlink" title="5.存储过程的优缺点？"></a><strong>5.存储过程的优缺点？</strong></h4><blockquote><p><strong>优点：</strong></p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，可减少数据库开发人员的工作量。</p><p><strong>缺点：</strong>移植性差</p></blockquote><h4 id="6-存储过程与函数的区别"><a href="#6-存储过程与函数的区别" class="headerlink" title="6.存储过程与函数的区别"></a><strong>6.存储过程与函数的区别</strong></h4><h5 id="1、返回值的区别"><a href="#1、返回值的区别" class="headerlink" title="1、返回值的区别"></a>1、返回值的区别</h5><ul><li>函数有1个返回值,而存储过程是通过参数返回的,可以有多个或者没有</li></ul><h5 id="2-调用的区别-函数可以在查询语句中直接调用-而存储过程必须单独调用"><a href="#2-调用的区别-函数可以在查询语句中直接调用-而存储过程必须单独调用" class="headerlink" title="2. 调用的区别,函数可以在查询语句中直接调用,而存储过程必须单独调用."></a>2. 调用的区别,函数可以在查询语句中直接调用,而存储过程必须单独调用.</h5><ul><li>函数：一般情况下是用来计算并返回一个计算结果；</li><li>存储过程： 一般是用来完成特定的数据操作（比如修改、插入数据库表或执行某些DDL语句等等)</li></ul><h5 id="下图说明他们之间的区别："><a href="#下图说明他们之间的区别：" class="headerlink" title="下图说明他们之间的区别："></a>下图说明他们之间的区别：</h5><table><thead><tr><th align="center">存储过程</th><th align="center">函数</th></tr></thead><tbody><tr><td align="center">用于在数据库中完成特定的操作或者任务(如插入、删除)</td><td align="center">用于特定的数据(如选择)</td></tr><tr><td align="center">程序头部声明用procedure</td><td align="center">程序头部声明用function</td></tr><tr><td align="center">程序头部声明时不需要描述返回类型</td><td align="center">程序头部声明要描述返回类型，而且PL/SQL块中至少要包括一个有效的return语句</td></tr><tr><td align="center">以编译后的形式存放在数据库中</td><td align="center">以编译后的形式存放在数据库中</td></tr><tr><td align="center">可以使用in/out/in out三种模式的参数</td><td align="center">可以使用in/out/in out三种模式的参数</td></tr><tr><td align="center">可以作为一个独立的PL/SQL语句来执行</td><td align="center">不能独立执行，必须作为表达式的一部分调用</td></tr><tr><td align="center">可以通过out/in out返回零个或者多个值</td><td align="center">通过return语句返回一个值，且该值要与申明部分一致，也可以是通过out类型的参数带出的变量</td></tr><tr><td align="center">SQL语句(DML或SELECT)中不可调用存储过程</td><td align="center">SQL语句(DML或SELECT)中可以调用函数</td></tr></tbody></table><h4 id="7-什么叫视图？游标是什么？"><a href="#7-什么叫视图？游标是什么？" class="headerlink" title="7.什么叫视图？游标是什么？"></a><strong>7.什么叫视图？游标是什么？</strong></h4><blockquote><p><strong>视图：</strong></p><p>是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p><strong>游标：</strong></p><p>是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p></blockquote><h4 id="8-视图的优缺点"><a href="#8-视图的优缺点" class="headerlink" title="8.视图的优缺点"></a><strong>8.视图的优缺点</strong></h4><blockquote><p><strong>优点：</strong></p><p>1对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。</p><p>2)用户通过简单的查询可以从复杂查询中得到结果。</p><p>3)维护数据的独立性，试图可从多个表检索数据。</p><p>4)对于相同的数据可产生不同的视图。</p><p><strong>缺点：</strong></p><p>性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据</p></blockquote><h4 id="9-drop、truncate、-delete区别"><a href="#9-drop、truncate、-delete区别" class="headerlink" title="9.drop、truncate、 delete区别"></a><strong>9.drop、truncate、 delete区别</strong></h4><blockquote><p><strong>最基本：</strong></p><ul><li>drop直接删掉表。</li><li>truncate删除表中数据，再插入时自增长id又从1开始。</li><li>delete删除表中数据，可以加where字句。</li></ul><p>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p><p>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p><p>（3） 一般而言，drop &gt; truncate &gt; delete</p><p>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</p><p>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</p><p>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</p><p>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</p><p>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。</p><p>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</p><p>（10） Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p><p>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p><p>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p></blockquote><h4 id="10-什么是临时表，临时表什么时候删除"><a href="#10-什么是临时表，临时表什么时候删除" class="headerlink" title="10.什么是临时表，临时表什么时候删除?"></a><strong>10.什么是临时表，临时表什么时候删除?</strong></h4><blockquote><p><strong>临时表可以手动删除：</strong><br>DROP TEMPORARY TABLE IF EXISTS temp_tb;</p><p><strong>临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，</strong></p><p>如：</p><p>CREATE TEMPORARY TABLE tmp_table (</p><p>NAME VARCHAR (10) NOT NULL,</p><p>time date NOT NULL<br>);</p><p>select * from tmp_table;</p></blockquote><h4 id="11-非关系型数据库和关系型数据库区别，优势比较"><a href="#11-非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="11.非关系型数据库和关系型数据库区别，优势比较?"></a><strong>11.非关系型数据库和关系型数据库区别，优势比较?</strong></h4><blockquote><p><strong>非关系型数据库的优势：</strong></p><ul><li><strong>性能：</strong>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li><li><strong>可扩展性：</strong>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ul><p><strong>关系型数据库的优势：</strong></p><ul><li><strong>复杂查询：</strong>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li><strong>事务支持：</strong>使得对于安全性能很高的数据访问要求得以实现。</li></ul><p><strong>其他：</strong></p><p><strong>1.</strong>对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p><p><strong>2.</strong>NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。</p><p><strong>3.</strong>对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。</p></blockquote><h4 id="12-数据库范式，根据某个场景设计数据表"><a href="#12-数据库范式，根据某个场景设计数据表" class="headerlink" title="12.数据库范式，根据某个场景设计数据表?"></a><strong>12.数据库范式，根据某个场景设计数据表?</strong></h4><blockquote><p><strong>第一范式:</strong>(确保每列保持原子性)所有字段值都是不可分解的原子值。</p><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。<br>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。<br>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p><p><strong>第二范式:</strong>(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。<br>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。</p><p><strong>第三范式:</strong>(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。<br>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p><p><strong>BCNF:</strong>符合3NF，并且，主属性不依赖于主属性。</p><p>若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。<br>通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。<br>BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。<br>还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。<br>一般，一个数据库设计符合3NF或BCNF就可以了。</p><p><strong>第四范式:</strong>要求把同一表内的多对多关系删除。</p><p><strong>第五范式:</strong>从最终结构重新建立原始结构。</p></blockquote><h4 id="13-什么是-内连接、外连接、交叉连接、笛卡尔积等"><a href="#13-什么是-内连接、外连接、交叉连接、笛卡尔积等" class="headerlink" title="13.什么是 内连接、外连接、交叉连接、笛卡尔积等?"></a><strong>13.什么是 内连接、外连接、交叉连接、笛卡尔积等?</strong></h4><blockquote><p><strong>内连接:</strong> 只连接匹配的行</p><p><strong>左外连接:</strong> 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行</p><p><strong>右外连接:</strong> 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行</p><p>例如1：<br>SELECT a.<em>,b.</em> FROM luntan LEFT JOIN usertable as b ON a.username=b.username</p><p>例如2：<br>SELECT a.<em>,b.</em> FROM city as a FULL OUTER JOIN user as b ON a.username=b.username</p><p><strong>全外连接:</strong> 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</p><p><strong>交叉连接:</strong> 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p><p>例如：<br>SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type</p><p><strong>注意：</strong></p><p>很多公司都只是考察是否知道其概念，但是也有很多公司需要不仅仅知道概念，还需要动手写sql,一般都是简单的连接查询，具体关于连接查询的sql练习，参见以下链接：</p><p><a href="https://www.nowcoder.com/ta/sql" target="_blank" rel="noopener">牛客网数据库SQL实战</a></p><p><a href="https://leetcode-cn.com/problemset/database/" target="_blank" rel="noopener">leetcode中文网站数据库练习</a></p><p><a href="http://www.baidu.com/" target="_blank" rel="noopener">我的另一篇文章，常用sql练习50题</a></p></blockquote><h4 id="14-varchar和char的使用场景"><a href="#14-varchar和char的使用场景" class="headerlink" title="14.varchar和char的使用场景?"></a><strong>14.varchar和char的使用场景?</strong></h4><blockquote></blockquote><blockquote><p><strong>1.</strong>char的长度是不可变的，而varchar的长度是可变的。</p><p>定义一个char[10]和varchar[10]。<br>如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。</p><p><strong>2.</strong>char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。<br>char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。<br>varchar是以空间效率为首位。</p><p><strong>3.</strong>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。<br>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</p><p><strong>4.</strong>两者的存储数据都非unicode的字符数据。</p></blockquote><h4 id="15-SQL语言分类"><a href="#15-SQL语言分类" class="headerlink" title="15.SQL语言分类"></a><strong>15.SQL语言分类</strong></h4><blockquote><p><strong>SQL语言共分为四大类：</strong></p><ul><li>数据查询语言DQL</li><li>数据操纵语言DML</li><li>数据定义语言DDL</li><li>数据控制语言DCL。</li></ul><p><strong>1. 数据查询语言DQL</strong></p><p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：</p><p>SELECT<br>FROM<br>WHERE</p><p><strong>2 .数据操纵语言DML</strong></p><p>数据操纵语言DML主要有三种形式：</p><ol><li>插入：INSERT</li><li>更新：UPDATE</li><li>删除：DELETE</li></ol><p><strong>3. 数据定义语言DDL</strong></p><p>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：<br>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER</p><p>表 视图 索引 同义词 簇</p><p>DDL操作是隐性提交的！不能rollback</p><p><strong>4. 数据控制语言DCL</strong></p><p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p><ol><li>GRANT：授权。</li><li>ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚—ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>SQL&gt;ROLLBACK;</li><li>COMMIT [WORK]：提交。</li></ol><p>在数据库的插入、删除和修改操作时，只有当事务在提交到数据<br>库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看<br>到所做的事情，别人只有在最后提交完成后才可以看到。<br>提交数据有三种类型：显式提交、隐式提交及自动提交。下面分<br>别说明这三种类型。</p><p>(1) 显式提交<br>用COMMIT命令直接完成的提交为显式提交。其格式为：<br>SQL&gt;COMMIT；</p><p>(2) 隐式提交<br>用SQL命令间接完成的提交为隐式提交。这些命令是：<br>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p><p>(3) 自动提交<br>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。其格式为：<br>SQL&gt;SET AUTOCOMMIT ON；</p><p>参考文章：<br><a href="https://www.cnblogs.com/study-s/p/5287529.html" target="_blank" rel="noopener">https://www.cnblogs.com/study-s/p/5287529.html</a></p></blockquote><h4 id="16-like-和-的区别"><a href="#16-like-和-的区别" class="headerlink" title="16.like %和-的区别"></a><strong>16.like %和-的区别</strong></h4><blockquote><p><strong>通配符的分类:</strong></p><p><strong>%百分号通配符:</strong>表示任何字符出现任意次数(可以是0次).</p><p><strong>_下划线通配符:</strong>表示只能匹配单个字符,不能多也不能少,就是一个字符.</p><p><strong>like操作符:</strong> LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.</p><p><strong>注意:</strong> 如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,SELECT * FROM products WHERE products.prod_name like ‘1000’;<br>只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果.</p><ul><li>%通配符使用: 匹配以”yves”开头的记录:(包括记录”yves”) SELECT <em>FROM products WHERE products.prod_name like ‘yves%’;匹配包含”yves”的记录(包括记录”yves”) SELECT</em> FROM products WHERE products.prod_name like ‘%yves%’;<br>匹配以”yves”结尾的记录(包括记录”yves”,不包括记录”yves “,也就是yves后面有空格的记录,这里需要注意) SELECT * FROM products WHERE products.prod_name like ‘%yves’;</li><li><em>通配符使用: SELECT FROM products WHERE products.prod_name like ‘_yves’; 匹配结果为: 像”yyves”这样记录.SELECT FROM products WHERE products.prod\</em>name like ‘yves**’; 匹配结果为: 像”yvesHe”这样的记录.(一个下划线只能匹配一个字符,不能多也不能少)</li></ul><p><strong>注意事项:</strong></p><ul><li>注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像YvesHe这样记录是不能被”yves__”这样的匹配条件匹配的.</li><li>注意尾部空格,”%yves”是不能匹配”heyves “这样的记录的.</li><li>注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE products.prod_name like ‘%;是匹配不到products.prod_name为NULL的的记录.</li></ul><p><strong>技巧与建议:</strong></p><p>正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。</p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。</li><li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.</li></ul></blockquote><p>参考博文：<a href="https://blog.csdn.net/u011479200/article/details/78513632" target="_blank" rel="noopener">https://blog.csdn.net/u011479200/article/details/78513632</a></p><h4 id="17-count-、count-1-、count-column-的区别"><a href="#17-count-、count-1-、count-column-的区别" class="headerlink" title="17.count(*)、count(1)、count(column)的区别"></a><strong>17.count(*)、count(1)、count(column)的区别</strong></h4><blockquote><ul><li>count(*)对行的数目进行计算,包含NULL</li><li>count(column)对特定的列的值具有的行数进行计算,不包含NULL值。</li><li>count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的。</li></ul><p><strong>性能问题:</strong></p><p>1.任何情况下SELECT COUNT(*) FROM tablename是最优选择;</p><p>2.尽量减少SELECT COUNT(*) FROM tablename WHERE COL = ‘value’ 这种查询;</p><p>3.杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 = ‘value’ 的出现。</p><ul><li>如果表没有主键,那么count(1)比count(*)快。</li><li>如果有主键,那么count(主键,联合主键)比count(*)快。</li><li>如果表只有一个字段,count(*)最快。</li></ul><p>count(1)跟count(主键)一样,只扫描主键。count(*)跟count(非主键)一样,扫描整个表。明显前者更快一些。</p></blockquote><h4 id="18-最左前缀原则"><a href="#18-最左前缀原则" class="headerlink" title="18.最左前缀原则"></a><strong>18.最左前缀原则</strong></h4><blockquote><p><strong>多列索引：</strong></p><p>ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</p><p>为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。</p><p>注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。</p><p><strong>最左前缀原则：</strong>顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p></blockquote><h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><h4 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1.什么是索引？"></a><strong>1.什么是索引？</strong></h4><blockquote><p><strong>何为索引：</strong></p><p>数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p></blockquote><h4 id="2-索引的作用？它的优点缺点是什么？"><a href="#2-索引的作用？它的优点缺点是什么？" class="headerlink" title="2.索引的作用？它的优点缺点是什么？"></a><strong>2.索引的作用？它的优点缺点是什么？</strong></h4><blockquote><p><strong>索引作用：</strong></p><p>协助快速查询、更新数据库表中数据。</p><p>为表设置索引要付出代价的：</p><ul><li><p>一是增加了数据库的存储空间</p></li><li><p>二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p><h4 id="3-索引的优缺点？"><a href="#3-索引的优缺点？" class="headerlink" title="3.索引的优缺点？"></a><strong>3.索引的优缺点？</strong></h4></li></ul><p><strong>创建索引可以大大提高系统的性能（优点）：</strong></p><p>1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p><strong>增加索引也有许多不利的方面(缺点)：</strong></p><p>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p></blockquote><h4 id="4-哪些列适合建立索引、哪些不适合建索引？"><a href="#4-哪些列适合建立索引、哪些不适合建索引？" class="headerlink" title="4.哪些列适合建立索引、哪些不适合建索引？"></a><strong>4.哪些列适合建立索引、哪些不适合建索引？</strong></h4><blockquote><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p><p><strong>一般来说，应该在这些列上创建索引：</strong></p><p>（1）在经常需要搜索的列上，可以加快搜索的速度；</p><p>（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p><p>（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p><p>（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p><p>（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p><p>（6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><p><strong>对于有些列不应该创建索引：</strong></p><p>（1）对于那些在查询中很少使用或者参考的列不应该创建索引。</p><p>这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>（2）对于那些只有很少数据值的列也不应该增加索引。</p><p>这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>（3）对于那些定义为text, image和bit数据类型的列不应该增加索引。</p><p>这是因为，这些列的数据量要么相当大，要么取值很少。</p><p>(4)当修改性能远远大于检索性能时，不应该创建索引。</p><p>这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p></blockquote><h4 id="5-什么样的字段适合建索引"><a href="#5-什么样的字段适合建索引" class="headerlink" title="5.什么样的字段适合建索引"></a><strong>5.什么样的字段适合建索引</strong></h4><blockquote><p>唯一、不为空、经常被查询的字段</p><h4 id="6-MySQL-B-Tree索引和Hash索引的区别"><a href="#6-MySQL-B-Tree索引和Hash索引的区别" class="headerlink" title="6.MySQL B+Tree索引和Hash索引的区别?"></a><strong>6.MySQL B+Tree索引和Hash索引的区别?</strong></h4><p><strong>Hash索引和B+树索引的特点：</strong></p><ul><li>Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;</li><li>B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;</li></ul><p><strong>为什么不都用Hash索引而使用B+树索引？</strong></p><ol><li>Hash索引仅仅能满足”=”,”IN”和””查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；</li><li>Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；</li><li>Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；</li><li>Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；</li><li>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。</li></ol><p><strong>补充：</strong></p><p>1.MySQL中，只有HEAP/MEMORY引擎才显示支持Hash索引。</p><p>2.常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。<br>B+树索引和哈希索引的明显区别是：</p><p>3.如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</p><p>4.如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；<br>同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</p><p>5.哈希索引也不支持多列联合索引的最左匹配规则；</p><p>6.B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</p><p>7.在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。</p></blockquote><h4 id="7-B树和B-树的区别"><a href="#7-B树和B-树的区别" class="headerlink" title="7.B树和B+树的区别"></a><strong>7.B树和B+树的区别</strong></h4><blockquote><ol><li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。<br><img data-src="https://i.imgur.com/RbzI0R8.jpg" alt="img"></li><li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)<br><img data-src="https://i.imgur.com/9VbnDME.jpg" alt="img"></li></ol></blockquote><h4 id="8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a><strong>8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</strong></h4><blockquote><p><strong>1.B+的磁盘读写代价更低</strong></p><p>B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p><strong>2.B+tree的查询效率更加稳定</strong></p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><h4 id="9-聚集索引和非聚集索引区别"><a href="#9-聚集索引和非聚集索引区别" class="headerlink" title="9.聚集索引和非聚集索引区别?"></a><strong>9.聚集索引和非聚集索引区别?</strong></h4><blockquote><p><strong>聚合索引(clustered index):</strong></p><p>聚集索引<strong>表记录的排列顺序和索引的排列顺序一致，所以查询效率快，</strong>只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。<br>聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。</p><p><strong>非聚合索引(nonclustered index):</strong></p><p>非聚集索引<strong>指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，</strong>两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。<br>非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。</p><p><strong>根本区别：</strong></p><p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p></blockquote><h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><h4 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a><strong>1.什么是事务？</strong></h4><blockquote><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p></blockquote><h4 id="2-事务四大特性（ACID）原子性、一致性、隔离性、持久性"><a href="#2-事务四大特性（ACID）原子性、一致性、隔离性、持久性" class="headerlink" title="2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?"></a><strong>2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?</strong></h4><blockquote><p><strong>原子性（Atomicity）:</strong><br>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p><strong>一致性（Consistency）:</strong><br>事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p><p><strong>隔离性（Isolation）:</strong><br>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p><p><strong>持久性（Durability）:</strong><br>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p></blockquote><h4 id="3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别"><a href="#3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别" class="headerlink" title="3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?"></a><strong>3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?</strong></h4><blockquote><p>从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。<br><strong>事务的并发问题</strong></p><p><strong>1、脏读：</strong>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p><p><strong>2、不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p><strong>3、幻读：</strong>幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。</p><p>例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。<br><strong>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</strong></p><p><strong>事务的隔离级别</strong></p><p><img data-src="https://i.imgur.com/xAeWTSp.png" alt="img"></p><p><strong>读未提交：</strong>另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</p><p><strong>不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p><strong>可重复读：</strong>在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</p><p><strong>串行化：</strong>最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</p></blockquote><p><strong>特别注意：</strong></p><blockquote><p>MySQL默认的事务隔离级别为repeatable-read</p><p>MySQL 支持 4 中事务隔离级别.</p><p>事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</p><p>Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</p><p>SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异</p><p><strong>MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行</strong></p><p><strong>事务隔离级别：</strong>未提交读时，写数据只会锁住相应的行。</p><p><strong>事务隔离级别为：</strong>可重复读时，写数据会锁住整张表。</p><p><strong>事务隔离级别为：</strong>串行化时，读写数据都会锁住整张表。</p><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p></blockquote><h4 id="4-事务传播行为"><a href="#4-事务传播行为" class="headerlink" title="4.事务传播行为"></a><strong>4.事务传播行为</strong></h4><blockquote><p><strong>1.PROPAGATION_REQUIRED：</strong>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p><strong>2.PROPAGATION_SUPPORTS：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><p><strong>3.PROPAGATION_MANDATORY：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p><strong>4.PROPAGATION_REQUIRES_NEW：</strong>创建新事务，无论当前存不存在事务，都创建新事务。</p><p><strong>5.PROPAGATION_NOT_SUPPORTED：</strong>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p><strong>6.PROPAGATION_NEVER：</strong>以非事务方式执行，如果当前存在事务，则抛出异常。</p><p><strong>7.PROPAGATION_NESTED：</strong>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p></blockquote><h4 id="5-嵌套事务"><a href="#5-嵌套事务" class="headerlink" title="5.嵌套事务"></a><strong>5.嵌套事务</strong></h4><blockquote><p><strong>什么是嵌套事务？</strong></p><p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：</p><p><strong>如果子事务回滚，会发生什么？</strong></p><p>父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p><p><strong>如果父事务回滚，会发生什么？</strong></p><p>父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：</p><p><strong>事务的提交，是什么情况？</strong></p><p>是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</p></blockquote><p>参考文章：<a href="https://blog.csdn.net/liangxw1/article/details/51197560" target="_blank" rel="noopener">https://blog.csdn.net/liangxw1/article/details/51197560</a></p><h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><h4 id="1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别"><a href="#1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别" class="headerlink" title="1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?"></a><strong>1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?</strong></h4><blockquote><p><strong>两种存储引擎的大致区别表现在：</strong></p><p>1.<strong>InnoDB支持事务，MyISAM不支持，</strong> <strong>这一点是非常之重要。</strong>事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</p><p>2.MyISAM适合查询以及插入为主的应用。</p><p>3.InnoDB适合频繁修改以及涉及到安全性较高的应用。</p><p>4.InnoDB支持外键，MyISAM不支持。</p><p>5.从MySQL5.5.5以后，InnoDB是默认引擎。</p><p>6.InnoDB不支持FULLTEXT类型的索引。</p><p>7.InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表。</p><p>8.对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</p><p>9.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢。MyISAM则会重建表。</p><p>10.InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’。</p></blockquote><h4 id="2-MySQL存储引擎MyISAM与InnoDB如何选择"><a href="#2-MySQL存储引擎MyISAM与InnoDB如何选择" class="headerlink" title="2.MySQL存储引擎MyISAM与InnoDB如何选择"></a><strong>2.MySQL存储引擎MyISAM与InnoDB如何选择</strong></h4><blockquote><p>MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</p><p>虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。<br>关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用：</p></blockquote><ul><li>1.INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持。</li><li>2.MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。</li></ul><blockquote><p>如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。</p><p>如果你的应用程序对查询性能要求较高，就要使用MyISAM了。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。</p><p>有人说MyISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。</p><p>现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。<br>MEMORY存储引擎</p><p>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。<br>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p><p>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</p><p>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。</p></blockquote><h4 id="3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景"><a href="#3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景" class="headerlink" title="3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?"></a><strong>3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?</strong></h4><blockquote><p><strong>事务处理上方面</strong></p></blockquote><ul><li>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</li><li>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li></ul><blockquote><p><strong>锁级别</strong></p></blockquote><ul><li>MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</li><li>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</li></ul><blockquote><p><strong>关于存储引擎MyISAM和InnoDB的其他参考资料如下：</strong></p><p><a href="http://blog.csdn.net/lc0817/article/details/52757194" target="_blank" rel="noopener">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></p><p><a href="https://www.cnblogs.com/kevingrace/p/5685355.html" target="_blank" rel="noopener">MySQL存储引擎之MyISAM和Innodb总结性梳理</a></p></blockquote><h2 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h2><h4 id="1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?"></a><strong>1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?</strong></h4><ul><li>1.查询中用到的关键词主要包含<strong>六个</strong>，并且他们的顺序依次为 <strong>select–from–where–group by–having–order by</strong></li></ul><blockquote><p><strong>其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序 与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行</strong></p><p><strong>from:</strong>需要从哪个数据表检索数据</p></blockquote><blockquote><p><strong>where:</strong>过滤表中数据的条件</p><p><strong>group by:</strong>如何将上面过滤出的数据分组</p><p><strong>having:</strong>对上面已经分组的数据进行过滤的条件</p><p><strong>select:</strong>查看结果集中的哪个列，或列的计算结果</p><p><strong>order by :</strong>按照什么样的顺序来查看返回的数据</p></blockquote><ul><li>2.<strong>from后面的表关联，是自右向左解析 而where条件的解析顺序是自下而上的。</strong></li></ul><blockquote><p>也就是说，在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边 （用小表去匹配大表）</p><p>其他参考资源：<br><a href="http://www.cnblogs.com/huminxxl/p/3149097.html" target="_blank" rel="noopener">http://www.cnblogs.com/huminxxl/p/3149097.html</a></p></blockquote><h4 id="2-使用explain优化sql和索引"><a href="#2-使用explain优化sql和索引" class="headerlink" title="2.使用explain优化sql和索引?"></a><strong>2.使用explain优化sql和索引?</strong></h4><blockquote><p><strong>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化</strong></p><p><strong>table：</strong>显示这一行的数据是关于哪张表的</p><p><strong>type：</strong>这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</p><p><strong>all:</strong>full table scan ;MySQL将遍历全表以找到匹配的行；</p><p><strong>index:</strong> index scan; index 和 all的区别在于index类型只遍历索引；</p><p><strong>range：</strong>索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询；</p><p><strong>ref：</strong>非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；</p><p><strong>eq_ref：</strong>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；</p><p><strong>const，system：</strong>当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。</p><p><strong>possible_keys：</strong>显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p><p><strong>key：</strong> 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引</p><p><strong>key_len：</strong>使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p><strong>ref：</strong>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><p><strong>rows：</strong>MySQL认为必须检查的用来返回请求数据的行数</p><p><strong>Extra：</strong>关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。</p></blockquote><h4 id="3-MySQL慢查询怎么解决"><a href="#3-MySQL慢查询怎么解决" class="headerlink" title="3.MySQL慢查询怎么解决?"></a><strong>3.MySQL慢查询怎么解决?</strong></h4><blockquote><ul><li>slow_query_log 慢查询开启状态。</li><li>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。</li><li>long_query_time 查询超过多少秒才记录。</li></ul></blockquote><h2 id="六、数据库锁"><a href="#六、数据库锁" class="headerlink" title="六、数据库锁"></a>六、数据库锁</h2><h4 id="1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决"><a href="#1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决" class="headerlink" title="1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?"></a><strong>1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?</strong></h4><blockquote><p><strong>MySQL有三种锁的级别：</strong>页级、表级、行级。</p><ul><li><strong>表级锁：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li><strong>行级锁：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li><strong>页面锁：</strong>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<br><strong>什么情况下会造成死锁?</strong></li></ul><p><strong>什么是死锁？</strong></p><p><strong>死锁:</strong> 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。</p><p>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</p><p><strong>死锁的关键在于：</strong>两个(或以上)的Session加锁的顺序不一致。</p><p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p><p><strong>死锁的解决办法?</strong></p><p>1.查出的线程杀死 kill<br>SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</p><p>2.设置锁的超时时间<br>Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。</p><p>生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值<br>该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：<br>set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。</p><p>3.指定获取锁的顺序</p></blockquote><h4 id="2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁"><a href="#2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁" class="headerlink" title="2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?"></a><strong>2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?</strong></h4><blockquote><p><strong>悲观锁（Pessimistic Lock）:</strong></p><p><strong>悲观锁特点:</strong>先获取锁，再进行业务操作。</p><p>即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的<strong>“一锁二查三更新”即指的是使用悲观锁。</strong>通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p><p><strong>补充：</strong><br>不同的数据库对select for update的实现和支持都是有所区别的，</p><ul><li>oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。</li><li>MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。</li></ul><p><strong>乐观锁（Optimistic Lock）:</strong></p><p><strong>1.</strong>乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。</p><p><strong>2.\</strong>*<em>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。*</em>即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。<br>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。</p><p><strong>3.</strong>一般的做法是<strong>在需要锁的数据上增加一个版本号，或者时间戳</strong>，</p><p><strong>实现方式举例如下：</strong></p><p><strong>乐观锁（给表加一个版本号字段）</strong> 这个并不是乐观锁的定义，给表加版本号，是<strong>数据库实现乐观锁的一种方式</strong>。</p><ol><li>SELECT data AS old_data, version AS old_version FROM …;</li><li>根据获取的数据进行业务操作，得到new_data和new_version</li><li>UPDATE SET data = new_data, version = new_version WHERE version = old_version</li></ol><p>if (updated row &gt; 0) {</p><p>// 乐观锁获取成功，操作完成</p><p>} else {</p><p>// 乐观锁获取失败，回滚并重试</p><p>}</p><p><strong>注意：</strong></p><ul><li>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li><li>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。</li></ul><p><strong>总结：</strong><br>悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select … for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p><ul><li><strong>响应速度：</strong> 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。’</li><li><strong>冲突频率：</strong> 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</li><li><strong>重试代价：</strong> 如果重试代价大，建议采用悲观锁。</li></ul></blockquote><h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h4 id="1-数据库的主从复制"><a href="#1-数据库的主从复制" class="headerlink" title="1.数据库的主从复制"></a><strong>1.数据库的主从复制</strong></h4><blockquote><p><strong>主从复制的几种方式:</strong></p><p><strong>同步复制:</strong></p><p>所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。 这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。</p><p><strong>异步复制:</strong></p><p>如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。</p><p><strong>半同步复制:</strong></p><p>master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。</p></blockquote><h4 id="2-数据库主从复制分析的-7-个问题"><a href="#2-数据库主从复制分析的-7-个问题" class="headerlink" title="2.数据库主从复制分析的 7 个问题?"></a><strong>2.数据库主从复制分析的 7 个问题?</strong></h4><p><strong>问题1：</strong>master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？</p><blockquote><p>假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。</p></blockquote><p><strong>问题2：</strong>主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？</p><blockquote><p><strong>实现数据备份:</strong><br>类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。</p><p><strong>异地容灾:</strong>比如master在北京，地震挂了，那么在上海的slave还可以继续。<br>主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。<br>【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作】</p></blockquote><p><strong>问题3：</strong>主从复制中有master,slave1,slave2,…等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?</p><blockquote><p>我们在应用程序中可以这样，insert/delete/update这些更新数据库的操作，用connection(for master)进行操作，</p><p>select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。</p><p>这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？<br>找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。<br>MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。</p><p>这就是所谓的MySQL READ WRITE SPLITE，MySQL的读写分离。</p></blockquote><p><strong>问题4：</strong>如果MySQL proxy , direct , master他们中的某些挂了怎么办？</p><blockquote><p>总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。</p></blockquote><p><strong>问题5：</strong>当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？</p><blockquote><p>显 然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,…的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。</p></blockquote><p><strong>问题6：</strong>当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。</p><blockquote><p>应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,…这些查询的结果都缓存至mamcache中。</p></blockquote><p><strong>问题7：</strong>随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？</p><blockquote><p>scale on ?更好的服务器？ 没有最好的，只有更好的，太贵了。。。<br>scale out ? 主从复制架构已经满足不了。<br>可以分库【垂直拆分】，分表【水平拆分】。</p></blockquote><h4 id="3-mysql-高并发环境解决方案"><a href="#3-mysql-高并发环境解决方案" class="headerlink" title="3.mysql 高并发环境解决方案?"></a><strong>3.mysql 高并发环境解决方案?</strong></h4><blockquote><p><strong>MySQL 高并发环境解决方案：</strong> 分库 分表 分布式 增加二级缓存。。。。。</p><p><strong>需求分析：</strong>互联网单位 每天大量数据读取，写入，并发性高。</p><p><strong>现有解决方式：</strong>水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。</p><p><strong>集群方案：</strong>解决DB宕机带来的单点DB不能访问问题。</p><p><strong>读写分离策略：</strong>极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。</p></blockquote><h4 id="4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"><a href="#4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）" class="headerlink" title="4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?"></a><strong>4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?</strong></h4><p>转载：<a href="https://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html" target="_blank" rel="noopener">MySQL REDO日志和UNDO日志</a></p><blockquote><p><strong>Undo Log:</strong></p><p>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了Undo Log来实现多版本并发控制(简称：MVCC)。</p><p>事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。<br>原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p><p>之所以能同时保证原子性和持久化，是因为以下<strong>特点：</strong></p><p>更新数据前记录Undo log。<br>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。<br>如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</p><p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。</p><p><strong>Redo Log:</strong></p><p>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。</p></blockquote><h4 id="八、整理时参考的资料"><a href="#八、整理时参考的资料" class="headerlink" title="八、整理时参考的资料"></a><strong>八、整理时参考的资料</strong></h4><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMTY0NDU3Nw==&mid=2651936134&idx=1&sn=5213a59104f6d2a90bc18d878cafe417&chksm=8d0f3ac8ba78b3deb2ea3473906a37dd205b6e64bfbebe86cc00108242bfa4c49a7d1e509eca&mpshare=1&scene=1&srcid=0707k8Bdz85tDHyVotxEQ9of#rd" target="_blank" rel="noopener">java团长 数据库整理</a></p><p><a href="https://my.oschina.net/yanpenglei/blog/1650277" target="_blank" rel="noopener">20个数据库常见面试题讲解 - 鹏磊 - 开源中国”</a></p><p><a href="https://m.2cto.com/database/201710/688377.html" target="_blank" rel="noopener">34个数据库常见面试题讲解</a></p><p><a href="https://kb.cnblogs.com/page/45712/" target="_blank" rel="noopener">漫谈数据库索引<em>知识库</em>博客园</a></p><p><a href="https://blog.csdn.net/u011479200/article/details/78513632" target="_blank" rel="noopener">Mysql| 使用通配符进行模糊查询(like,%,_)</a></p><p><a href="http://blog.csdn.net/lc0817/article/details/52757194" target="_blank" rel="noopener">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></p><p><a href="https://www.cnblogs.com/kevingrace/p/5685355.html" target="_blank" rel="noopener">MySQL存储引擎之MyISAM和Innodb总结性梳理</a></p><p><a href="https://blog.csdn.net/liangxw1/article/details/51197560" target="_blank" rel="noopener">https://blog.csdn.net/liangxw1/article/details/51197560</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程面试题</title>
      <link href="/2020/08/10/%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/10/%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="一、线程基础"><a href="#一、线程基础" class="headerlink" title="一、线程基础"></a><strong>一、线程基础</strong></h3><p>1、什么是线程？什么是进程？他们之间有什么区别？线程的好处和坏处？（坏处从单核CPU上下文切换带来系统损耗来解答）</p><p>2、Java中实现线程有那几种方式？区别是什么？（三种或者四种，根据继承和接口特点区别）</p><p>3、Thread类中的start和run方法的区别？（start方法内部含有native的start0，官方文档解释start0内部调用了run方法）</p><p>4、守护线程和非守护线程的区别？（服务员服务顾客的例子）</p><p>5、为什么wait, notify 和 notifyAll这些方法不在thread类里面？（这些操作都是锁级别操作，每个对象都有锁，所以定义在对象中）</p><p>6、Java中什么是竞态条件？ 举个例子说明。（两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件，导致竞态条件发生的代码区称作临界区。在临界区中使用适当的同步锁就可以避免竞态条件）</p><p>7、Java中如何停止一个线程？（从jdk1.0的stop、suspend、resume被遗弃说起，再到自然停止线程，或者使用volatile+boolean变量手动停止线程）。</p><p>8、sleep和wait的区别？</p><p>（四个：1、sleep是线程中的方法，但是wait是Object中的方法。</p><p>2、sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。</p><p>3、sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。</p><p>4、sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）。）</p><p>9、Java中interrupted 和 isInterruptedd方法的区别？（主要区别是前者会将中断状态清除而后者不会）</p><p>10、如何在两个线程间共享数据？（根据多个线程的代码是否相同判断是否使用同一个Runnable对象）</p><p>11、java的内存模型？（首先说出和内存结构的区别、然后是为什么需要内存模型（从计算机发展的角度来看逐步过渡到原子性、可见性、有序性），最后就是java内存模型如何解决上面三个问题）；</p><p>12、有三个线程T1，T2，T3，怎么确保它们按顺序执行？（多个方法，常见的join极其机制）</p><p>13、Thread类中的yield方法有什么作用？（作用是暂停当前正在执行的线程对象，让其它有相同优先级的线程执行，静态方法，只是可能性，不能保证确定性）</p><p>14、多线程中的忙循环是什么?（忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。）</p><p>线程基础知识主要是线程相关的一些概念和api进行理解。</p><h3 id="二、线程池"><a href="#二、线程池" class="headerlink" title="二、线程池"></a><strong>二、线程池</strong></h3><p>1、为什么要使用线程池？（反过来说，创建销毁线程的代价太高，再正过来说线程池的好处）</p><p>2、线程池有什么用？（提高效率、方便管理）</p><p>3、使用过哪些线程池？有什么使用场景？（newSingleThreadExecutor、newFixedThreadPool、newCachedThreadPool、newScheduledThreadPool，newWorkStealingPool）</p><p>4、线程池的七个参数的作用</p><p>int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler</Runnable></p><p>5、线程池的工作队列（ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue）</p><p>6、线程池的拒绝策略？（三种<strong>AbortPolicy</strong>、<strong>DiscardPolicy</strong>、<strong>DiscardOldestPolicy</strong>）</p><p>7、 execute和submit的区别？（execute适用于不需要关注返回值的场景，只需要将线程丢到线程池中去执行就可以，submit方法适用于需要关注返回值的场景）</p><p>8、如何终止线程池？（shutdownNow：对正在执行的任务停止，shutdown：只是不接受新任务）</p><h3 id="三、锁系列"><a href="#三、锁系列" class="headerlink" title="三、锁系列"></a><strong>三、锁系列</strong></h3><p>1、synchronized的作用、使用、底层原理、常见缺陷？</p><p>（从同步角度看作用，从对象锁和类锁角度看使用，可重入性和不可中断性看性质，从反编译字节码的角度看底层原理包含了监控器monitor，缺点是效率低、不够灵活、不知道是否获得了锁。）</p><p>2、volatile关键字的作用？（保证可见性有序性，不保证原子性，非线程安全，）</p><p>3、什么是活锁、饥饿、无锁、死锁？（死锁是相互占据对方的资源又不释放、活锁是主动释放自己的资源而不使用、饥饿是优先级高的线程一直占据资源，）</p><p>4、什么是CAS?（AtomicInteger底层实现，从A,V,B三个角度看，可以从你妈预期你女朋友A，你现在女朋友V，你妈如果看到A==V，那就让你娶B。）</p><p>5、什么是AQS？（AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的，</p><p><strong>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong>使用了独占式和共享式，底层使用了模板方法模式）</p><p>6、什么是乐观锁，什么是悲观锁？有什么区别？</p><p>（悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p><p>乐观锁是每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。atomic</p><h3 id="四、线程工具类"><a href="#四、线程工具类" class="headerlink" title="四、线程工具类"></a><strong>四、线程工具类</strong></h3><p>1、<strong>ThreadLocal是什么？有什么用？</strong></p><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。ThreadLocal就是一种以<strong>空间换时间</strong>的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p><p>2、<strong>Semaphore有什么作用</strong></p><p>Semaphore就是一个信号量，它的作用是<strong>限制某段代码块的并发数</strong>。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。</p><p>3、CountDownLatch？（类似于计数器的方式，用于等待一个或多个线程执行完操作开始自身代码的执行。）</p><p>4、CyclicBarrier？（CyclicBarrier即同步屏障，它主要功能是让一组线程达到一个屏障（也可以称为同步点）是被阻塞，直到最后一个线程达到屏障是，屏障才被打开，所有被拦截的线程才会继续执行）</p><p>5、Exchanger？（用于线程间的协作工具类，主要用于线程间数据的交换。它提供了一个同步点，在这个同步点，两个线程可以交换彼此的数据）</p><p>6、 CyclicBarrier和CountDownLatch的区别？（二者的区别在于：</p><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，该线程会继续运行。</p><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务。</p><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了）</p><p>线程集合将和java中的类集合一块讨论。如有不完善的地方还请补充。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁常见面试题</title>
      <link href="/2020/08/10/%E9%94%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/10/%E9%94%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>悲观锁和乐观锁并不是某个具体的“锁”而是一种并发编程的基本概念。乐观锁和悲观锁最早出现在数据库的设计当中，后来逐渐被 Java 的并发包所引入。</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观地认为，不加锁的并发操作一定会出问题。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁正好和悲观锁相反，它获取数据的时候，并不担心数据被修改，每次获取数据的时候也不会加锁，只是在更新数据的时候，通过判断现有的数据是否和原数据一致来判断数据是否被其他线程操作，如果没被其他线程修改则进行数据更新，如果被其他线程修改则不进行数据更新。</p><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>根据线程获取锁的抢占机制，锁又可以分为公平锁和非公平锁。</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁是指多个线程按照申请锁的顺序来获取锁。</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。ReentrantLock 提供了公平锁和非公平锁的实现。</p><ul><li>公平锁：new ReentrantLock(true)</li><li>非公平锁：new ReentrantLock(false)</li></ul><p>如果构造函数不传任何参数的时候，默认提供的是非公平锁。</p><h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><p>根据锁能否被多个线程持有，可以把锁分为独占锁和共享锁。</p><h4 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4><p>独占锁是指任何时候都只有一个线程能执行资源操作。</p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>共享锁指定是可以同时被多个线程读取，但只能被一个线程修改。比如 Java 中的 ReentrantReadWriteLock 就是共享锁的实现方式，它允许一个线程进行写操作，允许多个线程读操作。</p><p>ReentrantReadWriteLock 共享锁演示代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyReadWriteLock rwLock = <span class="keyword">new</span> MyReadWriteLock();</span><br><span class="line">        <span class="comment">// 创建读锁 r1 和 r2</span></span><br><span class="line">        Thread r1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rwLock.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"r1"</span>);</span><br><span class="line">        Thread r2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rwLock.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"r2"</span>);</span><br><span class="line">        r1.start();</span><br><span class="line">        r2.start();</span><br><span class="line">        <span class="comment">// 等待同时读取线程执行完成</span></span><br><span class="line">        r1.join();</span><br><span class="line">        r2.join();</span><br><span class="line">        <span class="comment">// 开启写锁的操作</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rwLock.write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"w1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rwLock.write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"w2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReadWriteLock</span> </span>&#123;</span><br><span class="line">        ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.readLock().lock();</span><br><span class="line">                System.out.println(<span class="string">"读操作，进入 | 线程："</span> + Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">"读操作，退出 | 线程："</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.writeLock().lock();</span><br><span class="line">                System.out.println(<span class="string">"写操作，进入 | 线程："</span> + Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">"写操作，退出 | 线程："</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>读操作，进入 | 线程：r1</p><p>读操作，进入 | 线程：r2</p><p>读操作，退出 | 线程：r1</p><p>读操作，退出 | 线程：r2</p><p>写操作，进入 | 线程：w1</p><p>写操作，退出 | 线程：w1</p><p>写操作，进入 | 线程：w2</p><p>写操作，退出 | 线程：w2</p></blockquote><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁指的是该线程获取了该锁之后，可以无限次的进入该锁锁住的代码。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU。</p><h3 id="CAS-与-ABA"><a href="#CAS-与-ABA" class="headerlink" title="CAS 与 ABA"></a>CAS 与 ABA</h3><p>CAS（Compare and Swap）比较并交换，是一种乐观锁的实现，是用非阻塞算法来代替锁定，其中 java.util.concurrent 包下的 AtomicInteger 就是借助 CAS 来实现的。</p><p>但 CAS 也不是没有任何副作用，比如著名的 ABA 问题就是 CAS 引起的。</p><h4 id="ABA-问题描述"><a href="#ABA-问题描述" class="headerlink" title="ABA 问题描述"></a>ABA 问题描述</h4><p>老王去银行取钱，余额有 200 元，老王取 100 元，但因为程序的问题，启动了两个线程，线程一和线程二进行比对扣款，线程一获取原本有 200 元，扣除 100 元，余额等于 100 元，此时阿里给老王转账 100 元，于是启动了线程三抢先在线程二之前执行了转账操作，把 100 元又变成了 200 元，而此时线程二对比自己事先拿到的 200 元和此时经过改动的 200 元值一样，就进行了减法操作，把余额又变成了 100 元。这显然不是我们要的正确结果，我们想要的结果是余额减少了 100 元，又增加了 100 元，余额还是 200 元，而此时余额变成了 100 元，显然有悖常理，这就是著名的 ABA 的问题。</p><p>执行流程如下。</p><ul><li>线程一：取款，获取原值 200 元，与 200 元比对成功，减去 100 元，修改结果为 100 元。</li><li>线程二：取款，获取原值 200 元，阻塞等待修改。</li><li>线程三：转账，获取原值 100 元，与 100 元比对成功，加上 100 元，修改结果为 200 元。</li><li>线程二：取款，恢复执行，原值为 200 元，与 200 元对比成功，减去 100 元，修改结果为 100 元。</li></ul><p>最终的结果是 100 元。</p><h4 id="ABA-问题的解决"><a href="#ABA-问题的解决" class="headerlink" title="ABA 问题的解决"></a>ABA 问题的解决</h4><p>常见解决 ABA 问题的方案加版本号，来区分值是否有变动。以老王取钱的例子为例，如果加上版本号，执行流程如下。</p><ul><li>线程一：取款，获取原值 200_V1，与 200_V1 比对成功，减去 100 元，修改结果为 100_V2。</li><li>线程二：取款，获取原值 200_V1 阻塞等待修改。</li><li>线程三：转账，获取原值 100_V2，与 100_V2 对比成功，加 100 元，修改结果为 200_V3。</li><li>线程二：取款，恢复执行，原值 200_V1 与现值 200_V3 对比不相等，退出修改。</li></ul><p>最终的结果为 200 元，这显然是我们需要的结果。</p><p>在程序中，要怎么解决 ABA 的问题呢？</p><p>在 JDK 1.5 的时候，Java 提供了一个 AtomicStampedReference 原子引用变量，通过添加版本号来解决 ABA 的问题，具体使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"老王"</span>;</span><br><span class="line">String newName = <span class="string">"Java"</span>;</span><br><span class="line">AtomicStampedReference&lt;String&gt; as = <span class="keyword">new</span> AtomicStampedReference&lt;String&gt;(name, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"值："</span> + as.getReference() + <span class="string">" | Stamp："</span> + as.getStamp());</span><br><span class="line">as.compareAndSet(name, newName, as.getStamp(), as.getStamp() + <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"值："</span> + as.getReference() + <span class="string">" | Stamp："</span> + as.getStamp());</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>值：老王 | Stamp：1</p><p>值：Java | Stamp：2</p></blockquote><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="1-synchronized-是哪种锁的实现？为什么？"><a href="#1-synchronized-是哪种锁的实现？为什么？" class="headerlink" title="1. synchronized 是哪种锁的实现？为什么？"></a>1. synchronized 是哪种锁的实现？为什么？</h4><p>答：synchronized 是悲观锁的实现，因为 synchronized 修饰的代码，每次执行时会进行加锁操作，同时只允许一个线程进行操作，所以它是悲观锁的实现。</p><h4 id="2-new-ReentrantLock-创建的是公平锁还是非公平锁？"><a href="#2-new-ReentrantLock-创建的是公平锁还是非公平锁？" class="headerlink" title="2. new ReentrantLock() 创建的是公平锁还是非公平锁？"></a>2. new ReentrantLock() 创建的是公平锁还是非公平锁？</h4><p>答：非公平锁，查看 ReentrantLock 的实现源码可知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-synchronized-使用的是公平锁还是非公平锁？"><a href="#3-synchronized-使用的是公平锁还是非公平锁？" class="headerlink" title="3. synchronized 使用的是公平锁还是非公平锁？"></a>3. synchronized 使用的是公平锁还是非公平锁？</h4><p>答：synchronized 使用的是非公平锁，并且是不可设置的。这是因为非公平锁的吞吐量大于公平锁，并且是主流操作系统线程调度的基本选择，所以这也是 synchronized 使用非公平锁原由。</p><h4 id="4-为什么非公平锁吞吐量大于公平锁？"><a href="#4-为什么非公平锁吞吐量大于公平锁？" class="headerlink" title="4. 为什么非公平锁吞吐量大于公平锁？"></a>4. 为什么非公平锁吞吐量大于公平锁？</h4><p>答：比如 A 占用锁的时候，B 请求获取锁，发现被 A 占用之后，堵塞等待被唤醒，这个时候 C 同时来获取 A 占用的锁，如果是公平锁 C 后来者发现不可用之后一定排在 B 之后等待被唤醒，而非公平锁则可以让 C 先用，在 B 被唤醒之前 C 已经使用完成，从而节省了 C 等待和唤醒之间的性能消耗，这就是非公平锁比公平锁吞吐量大的原因。</p><h4 id="5-volatile-的作用是什么？"><a href="#5-volatile-的作用是什么？" class="headerlink" title="5. volatile 的作用是什么？"></a>5. volatile 的作用是什么？</h4><p>答：volatile 是 Java 虚拟机提供的最轻量级的同步机制。当变量被定义成 volatile 之后，具备两种特性：</p><ul><li>保证此变量对所有线程的可见性，当一条线程修改了这个变量的值，修改的新值对于其他线程是可见的（可以立即得知的）；</li><li>禁止指令重排序优化，普通变量仅仅能保证在该方法执行过程中，得到正确结果，但是不保证程序代码的执行顺序。</li></ul><h4 id="6-volatile-对比-synchronized-有什么区别？"><a href="#6-volatile-对比-synchronized-有什么区别？" class="headerlink" title="6. volatile 对比 synchronized 有什么区别？"></a>6. volatile 对比 synchronized 有什么区别？</h4><p>答：synchronized 既能保证可见性，又能保证原子性，而 volatile 只能保证可见性，无法保证原子性。比如，i++ 如果使用 synchronized 修饰是线程安全的，而 volatile 会有线程安全的问题。</p><h4 id="7-CAS-是如何实现的？"><a href="#7-CAS-是如何实现的？" class="headerlink" title="7. CAS 是如何实现的？"></a>7. CAS 是如何实现的？</h4><p>答：CAS（Compare and Swap）比较并交换，CAS 是通过调用 JNI（Java Native Interface）的代码实现的，比如，在 Windows 系统 CAS 就是借助 C 语言来调用 CPU 底层指令实现的。</p><h4 id="8-CAS-会产生什么问题？应该怎么解决？"><a href="#8-CAS-会产生什么问题？应该怎么解决？" class="headerlink" title="8. CAS 会产生什么问题？应该怎么解决？"></a>8. CAS 会产生什么问题？应该怎么解决？</h4><p>答：CAS 是标准的乐观锁的实现，会产生 ABA 的问题（详见正文）。ABA 通常的解决办法是添加版本号，每次修改操作时版本号加一，这样数据对比的时候就不会出现 ABA 的问题了。</p><h4 id="9-以下说法错误的是？"><a href="#9-以下说法错误的是？" class="headerlink" title="9. 以下说法错误的是？"></a>9. 以下说法错误的是？</h4><p>A：独占锁是指任何时候都只有一个线程能执行资源操作 B：共享锁指定是可以同时被多个线程读取和修改 C：公平锁是指多个线程按照申请锁的顺序来获取锁 D：非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁</p><p>答：B</p><p>题目解析：共享锁指定是可以同时被多个线程读取，但只能被一个线程修改。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了 Java 中各种锁，明白了 Java 程序中比较常用的为非公平锁而非公平锁，原因在于非公平锁的吞吐量要更大，并且发生线程“饥饿”的情况很少，是风险远小于收益的事所以可以广而用之。又重点介绍了 CAS 和著名的 ABA 的问题，以及解决 ABA 的常见手段：添加版本号，可以通过 Java 自身提供的 AtomicStampedReference（原子引用变量）来解决 ABA 的问题，至此我们对 Java 多线程的了解又向前迈了一大步。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题</title>
      <link href="/2020/08/10/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/10/Java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-集合底层的数据结构"><a href="#1-集合底层的数据结构" class="headerlink" title="1.集合底层的数据结构"></a>1.集合底层的数据结构</h3><h5 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h5><ul><li><strong>Arraylist：</strong> Object数组</li><li><strong>Vector：</strong> Object数组</li><li><strong>LinkedList：</strong> 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)</li></ul><h5 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. Set</h5><ul><li><strong>HashSet（无序，唯一）:</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li><strong>LinkedHashSet：</strong> LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的</li><li><strong>TreeSet（有序，唯一）：</strong> 红黑树(自平衡的排序二叉树)</li></ul><h5 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h5><ul><li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li><li><strong>Hashtable：</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><strong>TreeMap：</strong> 红黑树（自平衡的排序二叉树）</li></ul><h5 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h5><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</p><h3 id="2-HashMap、HashTable、-ArrayList、-LinkedList、Vector区别"><a href="#2-HashMap、HashTable、-ArrayList、-LinkedList、Vector区别" class="headerlink" title="2.HashMap、HashTable、 ArrayList、 LinkedList、Vector区别"></a>2.HashMap、HashTable、 ArrayList、 LinkedList、Vector区别</h3><h4 id="HashTable和HashMap区别"><a href="#HashTable和HashMap区别" class="headerlink" title="HashTable和HashMap区别"></a><strong>HashTable和HashMap区别</strong></h4><p>①继承不同。</p><p>public class Hashtable extends Dictionary implements Map</p><p>public class HashMap extends AbstractMap implements Map</p><p>②</p><p>Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p><p>③</p><p>Hashtable中，key和value都不允许出现null值。</p><p>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</p><p>④两个遍历方式的内部实现上不同。</p><p>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</p><p>⑤</p><p>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p><p>⑥</p><p>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p><h4 id="ArrayList、Vector区别"><a href="#ArrayList、Vector区别" class="headerlink" title="ArrayList、Vector区别"></a><strong>ArrayList、Vector</strong>区别</h4><p>①两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，都可以按位置索引号取出某个元素，并且其中的数据是允许重复的，这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。</p><p>②同步性，Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</p><p>③数据增长：ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。</p><h4 id="ArrayList、LinkedList区别"><a href="#ArrayList、LinkedList区别" class="headerlink" title="ArrayList、LinkedList区别"></a><strong>ArrayList、</strong>LinkedList<strong>区别</strong></h4><p>① ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</p><p>② 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p><p>③对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据</p><h3 id="3-红黑树常见面试问题整理"><a href="#3-红黑树常见面试问题整理" class="headerlink" title="3.红黑树常见面试问题整理"></a>3.红黑树常见面试问题整理</h3><h4 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h4><p>红黑树是一种特定类型的二叉树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由RudolfBayer发明的，他称之为”对称二叉B树”，它现代的名字是在LeoJ.Guibas和RobertSedgewick于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的，它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组</p><h4 id="二、性质"><a href="#二、性质" class="headerlink" title="二、性质"></a>二、性质</h4><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：<br>【1】性质1. 节点是红色或黑色。<br>【2】性质2. 根节点是黑色。<br>【3】性质3 每个叶节点是黑色的。<br>【4】性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)<br>【5】性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><h4 id="三、用途和好处"><a href="#三、用途和好处" class="headerlink" title="三、用途和好处"></a>三、用途和好处</h4><p>红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如即时应用(real time application)中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。</p><p>红黑树在函数式编程中也特别有用，在这里它们是最常用的持久数据结构之一，它们用来构造关联数组和集合，在突变之后它们能保持为以前的版本。除了O(log n)的时间之外，红黑树的持久版本对每次插入或删除需要O(log n)的空间。</p><p>红黑树是 2-3-4树的一种等同。换句话说，对于每个 2-3-4 树，都存在至少一个数据元素是同样次序的红黑树。在 2-3-4 树上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得 2-3-4 树成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍 2-3-4 树的原因，尽管 2-3-4 树在实践中不经常使用。</p><h3 id="4-集合常见面试题"><a href="#4-集合常见面试题" class="headerlink" title="4.集合常见面试题"></a>4.集合常见面试题</h3><h4 id="List，Set-Map三者的区别及总结"><a href="#List，Set-Map三者的区别及总结" class="headerlink" title="List，Set,Map三者的区别及总结"></a>List，Set,Map三者的区别及总结</h4><ul><li><p><strong>List：对付顺序的好帮手</strong></p><p>List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</p></li><li><p><strong>Set:注重独一无二的性质</strong></p><p>不允许重复的集合。不会有多个元素引用相同的对象。</p></li><li><p><strong>Map:用Key来搜索的专家</strong></p><p>使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p></li></ul><h4 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h4><p>Arraylist底层使用的是数组（存读数据效率高，插入删除特定位置效率低），LinkedList底层使用的是双向循环链表数据结构（插入，删除效率特别高）。学过数据结构这门课后我们就知道采用链表存储，插入，删除元素时间复杂度不受元素位置的影响，都是近似O（1）而数组为近似O（n），因此当数据特别多，而且经常需要插入删除元素时建议选用LinkedList.一般程序只用Arraylist就够用了，因为一般数据量都不会蛮大，Arraylist是使用最多的集合类。</p><h4 id="ArrayList-与-Vector-区别（为什么要用Arraylist取代Vector呢？）"><a href="#ArrayList-与-Vector-区别（为什么要用Arraylist取代Vector呢？）" class="headerlink" title="ArrayList 与 Vector 区别（为什么要用Arraylist取代Vector呢？）"></a>ArrayList 与 Vector 区别（为什么要用Arraylist取代Vector呢？）</h4><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector，代码要在同步操作上耗费大量的时间。Arraylist不是同步的，所以在不需要同步时建议使用Arraylist。</p><h4 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h4><ol><li>HashMap是非线程安全的，HashTable是线程安全的；HashTable内部的方法基本都经过synchronized修饰。</li><li>因为线程安全的问题，HashMap要比HashTable效率高一点，HashTable基本被淘汰。</li><li>HashMap允许有null值的存在，而在HashTable中put进的键值只要有一个null，直接抛出NullPointerException。</li></ol><p>Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java5或以上的话，请使用ConcurrentHashMap吧</p><h4 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h4><p><img data-src="https://user-gold-cdn.xitu.io/2018/3/2/161e717d734f3b23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="HashSet 和 HashMap 区别"></p><h4 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h4><ol><li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。</li><li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li></ol><h4 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h4><p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。（摘自我的Java启蒙书《Head fist java》第二版）</p><p><strong>hashCode（）与equals（）的相关规定：</strong></p><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与equals的区别</strong></p><ol><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同</li></ol><h4 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h4><ul><li>comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序</li><li>comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p><h3 id="5-ConcurrentHashMap面试题"><a href="#5-ConcurrentHashMap面试题" class="headerlink" title="5.ConcurrentHashMap面试题"></a>5.ConcurrentHashMap面试题</h3><h4 id="1-JDK1-7版本的CurrentHashMap的实现原理"><a href="#1-JDK1-7版本的CurrentHashMap的实现原理" class="headerlink" title="1.JDK1.7版本的CurrentHashMap的实现原理"></a>1.JDK1.7版本的CurrentHashMap的实现原理</h4><p>在JDK1.7中ConcurrentHashMap采用了数组+Segment+分段锁的方式实现。</p><p>1.Segment(分段锁)</p><p>ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表,同时又是一个ReentrantLock（Segment继承了ReentrantLock）。</p><p>2.内部结构</p><p>ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。如下图是ConcurrentHashMap的内部结构图：</p><p><img data-src="https://img2018.cnblogs.com/blog/1415794/201907/1415794-20190706174520770-1254862721.png" alt="img"></p><p>从上面的结构我们可以了解到，ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。</p><p>第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。</p><p>3.该结构的优劣势</p><p>坏处</p><p>这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长</p><p>好处</p><p>写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上）。</p><p>所以，通过这一种结构，ConcurrentHashMap的并发能力可以大大的提高。</p><h4 id="2-JDK1-8版本的CurrentHashMap的实现原理"><a href="#2-JDK1-8版本的CurrentHashMap的实现原理" class="headerlink" title="2.JDK1.8版本的CurrentHashMap的实现原理"></a>2.JDK1.8版本的CurrentHashMap的实现原理</h4><p>JDK8中ConcurrentHashMap参考了JDK8 HashMap的实现，采用了数组+链表+红黑树的实现方式来设计，内部大量采用CAS操作，这里我简要介绍下CAS。</p><p>CAS是compare and swap的缩写，即我们所说的比较交换。cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。</p><p>JDK8中彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。</p><p>Node：保存key，value及key的hash值的数据结构。其中value和next都用volatile修饰，保证并发的可见性。</p><p>Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，不过保证线程安全性。</p><p>在JDK8中ConcurrentHashMap的结构，由于引入了红黑树，使得ConcurrentHashMap的实现非常复杂，我们都知道，红黑树是一种性能非常好的二叉查找树，其查找性能为O（logN），但是其实现过程也非常复杂，而且可读性也非常差，DougLea的思维能力确实不是一般人能比的，早期完全采用链表结构时Map的查找时间复杂度为O（N），JDK8中ConcurrentHashMap在链表的长度大于某个阈值的时候会将链表转换成红黑树进一步提高其查找性能。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。</p><p>1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</p><p>2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。</p><p>3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</p><p>4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。</p><p>5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p><h3 id="6-stringbuffer与stringbuilder区别分析"><a href="#6-stringbuffer与stringbuilder区别分析" class="headerlink" title="6.stringbuffer与stringbuilder区别分析"></a>6.stringbuffer与stringbuilder区别分析</h3><h4 id="它们到底都有什么区别呢！"><a href="#它们到底都有什么区别呢！" class="headerlink" title="它们到底都有什么区别呢！"></a>它们到底都有什么区别呢！</h4><p>三者都是用来对字符串进行操作，String通常用来定义一个变量，而StringBuilder StringBuffer则通常用来对字符串进行拼接等操作。但其实String同样的可以用来拼接字符串，可我们为什么很少使用呢，这样从三者的底层代码说起。</p><p><img data-src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3663061844,3729476112&fm=173&app=25&f=JPEG?w=640&h=100" alt="img"></p><p>String的底层代码为一个用final修饰的char数组，这意味着定义一个String变量以后，该变量的内容是不可变的。</p><p><img data-src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3176837217,228886112&fm=173&app=25&f=JPEG?w=639&h=305&s=C892C51A11D84DCA1AFD31DE020090B1" alt="img"></p><p><img data-src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1058504725,2903224430&fm=173&app=25&f=JPEG?w=638&h=129&s=C094ED3ACDA46C111E599DDE0000C0B1" alt="img"></p><p><img data-src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1411358912,1703876172&fm=173&app=25&f=JPEG?w=640&h=100" alt="img"></p><p>StringBuilder 与StringBuffer都继承自AbstractStringBuilder，该类的char数组并没有用final修饰，内容是可变的，这个是什么意思呢。</p><p>比如：</p><p>String s1= “a”;</p><p>String s2 = new String(“b”) ;</p><p>String s3 = s1+s2;</p><p>如果这样，我们得到“ab”这个字符串，因为String底层未不可变的字符串，所以会创建三个对象，都会占用内存，而这三个对象一直都未失去引用，所以jvm无法垃圾回收，造成内存资源的大量浪费，这在我们开发中是不推崇的，而StringBuilder 与StringBuffer则不存在这样的问题。</p><p><img data-src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2282646292,1468994661&fm=173&app=25&f=JPEG?w=640&h=247&s=4810ED128FD05DC2467D80DE0000D0B3" alt="img"></p><p><img data-src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1487913018,235177156&fm=173&app=25&f=JPEG?w=638&h=154&s=CCC6D51A8864FC0140F448DD020090B0" alt="img"></p><p><img data-src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4153722749,2243141871&fm=173&app=25&f=JPEG?w=640&h=125&s=C890ED1ACF14EC031C40C0DE0200D0B1" alt="img"></p><p>通过底层代码我们可以看到StringBuilder 与StringBuffer在拼接字符串时，通过判断字符串长度是否足够，从而创建一个新的数组用来封装数据，而原来的对象被放弃引用，等待垃圾回收，从而减少内存的浪费，因此在拼接字符串等操作时，我们通常使用StringBuilder 与StringBuffer，但两者在执行效率上又有不同，StringBuilder的执行效率较高，这是为什么呢？</p><p><img data-src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=688262211,3368037231&fm=173&app=25&f=JPEG?w=640&h=166&s=4880CD1A8D204C035445B5DE020080B1" alt="img"></p><p><img data-src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3481353240,327804767&fm=173&app=25&f=JPEG?w=640&h=154&s=E818A51AC1725C310E51B1D80000C0B1" alt="img"></p><p>通过底层源码，可以发现StringBuffer在拼接字符串时，使用了同步锁，安全性提高，而StringBuilder未使用同步锁，故效率提高。</p><h3 id="7-进程和线程的区别？"><a href="#7-进程和线程的区别？" class="headerlink" title="7.进程和线程的区别？"></a>7.进程和线程的区别？</h3><p>​          （1）进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元</p><p>​          （2）同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。</p><p>​          （3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束</p><p>​          （4）线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的</p><p>​          （5）线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源</p><p>​          （6）线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典动态规划：高楼扔鸡蛋</title>
      <link href="/2020/08/09/%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B/"/>
      <url>/2020/08/09/%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="经典动态规划：高楼扔鸡蛋"><a href="#经典动态规划：高楼扔鸡蛋" class="headerlink" title="经典动态规划：高楼扔鸡蛋"></a>经典动态规划：高楼扔鸡蛋</h2><p>今天要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试都经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔杯子，扔破碗什么的。</p><p>具体的问题等会再说，但是这道题的解法技巧很多，光动态规划就好几种效率不同的思路，最后还有一种极其高效数学解法。秉承咱们号一贯的作风，拒绝奇技淫巧，拒绝过于诡异的技巧，因为这些技巧无法举一反三，学了不太划算。</p><p>下面就来用我们一直强调的动态规划通用思路来研究一下这道题。</p><h3 id="一、解析题目"><a href="#一、解析题目" class="headerlink" title="一、解析题目"></a>一、解析题目</h3><p>题目是这样：你面前有一栋从 1 到<code>N</code>共<code>N</code>层的楼，然后给你<code>K</code>个鸡蛋（<code>K</code>至少为 1）。现在确定这栋楼存在楼层<code>0 &lt;= F &lt;= N</code>，在这层楼将鸡蛋扔下去，鸡蛋<strong>恰好没摔碎</strong>（高于<code>F</code>的楼层都会碎，低于<code>F</code>的楼层都不会碎）。现在问你，<strong>最坏</strong>情况下，你<strong>至少</strong>要扔几次鸡蛋，才能<strong>确定</strong>这个楼层<code>F</code>呢？</p><p>PS：F 可以为 0，比如说鸡蛋在 1 层都能摔碎，那么 F = 0。</p><p>也就是让你找摔不碎鸡蛋的最高楼层<code>F</code>，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。</p><p>比方说<strong>现在先不管鸡蛋个数的限制</strong>，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？</p><p>最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……</p><p>以这种策略，<strong>最坏</strong>情况应该就是我试到第 7 层鸡蛋也没碎（<code>F = 7</code>），也就是我扔了 7 次鸡蛋。</p><p>现在你应该理解什么叫做「最坏情况」下了，<strong>鸡蛋破碎一定发生在搜索区间穷尽时</strong>，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。</p><p>现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。</p><p>最好的策略是使用二分查找思路，我先去第<code>(1 + 7) / 2 = 4</code>层扔一下：</p><p>如果碎了说明<code>F</code>小于 4，我就去第<code>(1 + 3) / 2 = 2</code>层试……</p><p>如果没碎说明<code>F</code>大于等于 4，我就去第<code>(5 + 7) / 2 = 6</code>层试……</p><p>以这种策略，<strong>最坏</strong>情况应该是试到第 7 层鸡蛋还没碎（<code>F = 7</code>），或者鸡蛋一直碎到第 1 层（<code>F = 0</code>）。然而无论那种最坏情况，只需要试<code>log7</code>向上取整等于 3 次，比刚才的 7 次要少，这就是所谓的<strong>至少</strong>要扔几次。</p><p>PS：这有点像 Big O 表示法计算算法的复杂度。</p><p>实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，<strong>现在给你了鸡蛋个数的限制K，直接使用二分思路就不行了</strong>。</p><p>比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，但如果碎了你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层<code>F</code>了。这种情况下只能用线性扫描的方法，算法返回结果应该是 7。</p><p>有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？</p><p>很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。</p><p>如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次。</p><p>最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。</p><p>说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？</p><h3 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="二、思路分析"></a>二、思路分析</h3><p>对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。</p><p><strong>「状态」很明显，就是当前拥有的鸡蛋数K和需要测试的楼层数N</strong>。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。</p><p><strong>「选择」其实就是去选择哪层楼扔鸡蛋</strong>。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。</p><p>现在明确了「状态」和「选择」，<strong>动态规划的基本思路就形成了</strong>：肯定是个二维的<code>dp</code>数组或者带有两个状态参数的<code>dp</code>函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新结果 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 当前状态为 (K 个鸡蛋，N 层楼)</span><br><span class="line"># 返回这个状态下的最优结果</span><br><span class="line"><span class="function">def <span class="title">dp</span><span class="params">(K, N)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> res</span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> 1 &lt;</span>= i &lt;= N:</span><br><span class="line">        res = <span class="built_in">min</span>(res, 这次在第 i 层楼扔鸡蛋)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。</p><p>我们在第<code>i</code>层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。<strong>注意，这时候状态转移就来了</strong>：</p><p><strong>如果鸡蛋碎了</strong>，那么鸡蛋的个数<code>K</code>应该减一，搜索的楼层区间应该从<code>[1..N]</code>变为<code>[1..i-1]</code>共<code>i-1</code>层楼；</p><p><strong>如果鸡蛋没碎</strong>，那么鸡蛋的个数<code>K</code>不变，搜索的楼层区间应该从 <code>[1..N]</code>变为<code>[i+1..N]</code>共<code>N-i</code>层楼。</p><p><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdEOJia7Pf28RpZFO1bHqnS8wwh4qJhPCowvn5XwA7DXtic9x9Y5Dic2XIsictw0YETicJFKQNJzayFib26A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>PS：细心的读者可能会问，在第<code>i</code>层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第<code>i</code>层楼呀？不必，因为已经包含了。开头说了 F 是可以等于 0 的，向上递归后，第<code>i</code>层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。</p><p>因为我们要求的是<strong>最坏情况</strong>下扔鸡蛋的次数，所以鸡蛋在第<code>i</code>层楼碎没碎，取决于那种情况的结果<strong>更大</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">dp</span><span class="params">(K, N)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> 1 &lt;</span>= i &lt;= N:</span><br><span class="line">        # 最坏情况下的最少扔鸡蛋次数</span><br><span class="line">        res = <span class="built_in">min</span>(res, </span><br><span class="line">                  <span class="built_in">max</span>( </span><br><span class="line">                        dp(K - <span class="number">1</span>, i - <span class="number">1</span>), # 碎</span><br><span class="line">                        dp(K, N - i)      # 没碎</span><br><span class="line">                     ) + <span class="number">1</span> # 在第 i 楼扔了一次</span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>递归的 base case 很容易理解：当楼层数<code>N</code>等于 0 时，显然不需要扔鸡蛋；当鸡蛋数<code>K</code>为 1 时，显然只能线性扫描所有楼层：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">dp</span><span class="params">(K, N)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> K </span>== <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">    <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">superEggDrop</span><span class="params">(K: <span class="keyword">int</span>, N: <span class="keyword">int</span>)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    memo </span>= dict()</span><br><span class="line">    def dp(K, N) -&gt; int:</span><br><span class="line">        <span class="meta"># base case</span></span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        # 避免重复计算</span><br><span class="line">        <span class="keyword">if</span> (K, N) in memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(K, N)]</span><br><span class="line"></span><br><span class="line">        res = float('INF')</span><br><span class="line">        # 穷举所有可能的选择</span><br><span class="line">        <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">1</span>, N + <span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">            res </span>= <span class="built_in">min</span>(res, </span><br><span class="line">                      <span class="built_in">max</span>(</span><br><span class="line">                            dp(K, N - i), </span><br><span class="line">                            dp(K - <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">                         ) + <span class="number">1</span></span><br><span class="line">                  )</span><br><span class="line">        # 记入备忘录</span><br><span class="line">        memo[(K, N)] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。</p><p>函数本身的复杂度就是忽略递归部分的复杂度，这里<code>dp</code>函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。</p><p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。</p><p>所以算法的总时间复杂度是 O(K*N^2), 空间复杂度为子问题个数，即 O(KN)。</p><h3 id="三、疑难解答"><a href="#三、疑难解答" class="headerlink" title="三、疑难解答"></a>三、疑难解答</h3><p>这个问题很复杂，但是算法代码却十分简洁，这就是动态规划的特性，穷举加备忘录/DP table 优化，真的没啥新意。</p><p>首先，有读者可能不理解代码中为什么用一个 for 循环遍历楼层<code>[1..N]</code>，也许会把这个逻辑和之前探讨的线性扫描混为一谈。其实不是的，<strong>这只是在做一次「选择」</strong>。</p><p>比方说你有 2 个鸡蛋，面对 10 层楼，你得拿一个鸡蛋去某一层楼扔对吧？那选择去哪一层楼扔呢？不知道，那就把这 10 层楼全试一遍。至于鸡蛋碎没碎，下次怎么选择不用你操心，有正确的状态转移，递归会算出每个选择的代价，我们取最优的那个就是最优解。</p><p>其实，这个问题还有更好的解法，比如修改代码中的 for 循环为二分搜索，可以将时间复杂度降为 O(K<em>N</em>logN)；再改进动态规划解法可以进一步降为 O(KN)；使用数学方法解决，时间复杂度达到最优 O(K*logN)，空间复杂度达到 O(1)。</p><p>二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔鸡蛋有关系，实际上没有半毛钱关系。能用二分搜索是因为状态转移方程的函数图像具有单调性，可以快速找到最小值。</p><p>这里就不展开以上解法了，有兴趣的读者可以点击「阅读原文」查看。</p><p>我觉得吧，我们这种解法就够了：<strong>找状态，做选择</strong>，足够清晰易懂，可流程化，可举一反三。掌握这套框架学有余力的话，二分查找的优化应该可以看懂，之后的优化也就随缘吧。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典动态规划:0-1背包问题</title>
      <link href="/2020/08/09/%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/09/%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="经典动态规划：0-1-背包问题"><a href="#经典动态规划：0-1-背包问题" class="headerlink" title="经典动态规划：0-1 背包问题"></a>经典动态规划：0-1 背包问题</h2><p>今天就来说一下背包问题吧，就讨论最常说的 0-1 背包问题，简单描述一下吧：</p><p>给你一个可装载重量为<code>W</code>的背包和<code>N</code>个物品，每个物品有重量和价值两个属性。其中第<code>i</code>个物品的重量为<code>wt[i]</code>，价值为<code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p><p>举个简单的例子，输入如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">3</span>, W = <span class="number">4</span></span><br><span class="line">wt = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">val = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>算法返回 6，选择前两件物品装进背包，总重量 3 小于<code>W</code>，可以获得最大价值 6。</p><p>题目就是这么简单，一个典型的动态规划问题。<strong>这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。</strong>这也许就是 0-1 背包这个名词的来历。</p><p>解决这个问题没有什么排序之类巧妙的方法，只能穷举所有可能，根据我们 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&scene=21#wechat_redirect" target="_blank" rel="noopener">动态规划套路详解</a> 中的套路，直接走流程就行了。</p><h3 id="动规标准套路"><a href="#动规标准套路" class="headerlink" title="动规标准套路"></a>动规标准套路</h3><p>看来我得每篇动态规划文章都得重复一遍套路，历史文章中的动态规划问题都是按照下面的套路来的，今天再来手把手演示一下：</p><p><strong>第一步**</strong>要明确两点，「状态」和「选择」**。</p><p>先说状态，如何才能描述一个问题局面？只要给定几个可选物品和一个背包的容量限制，就形成了一个背包问题，对不对？<strong>所以状态有两个，就是「背包的容量」和「可选择的物品」</strong>。</p><p>再说选择，也很容易想到啊，对于每件物品，你能选择什么？<strong>选择就是「装进背包」或者「不装进背包」嘛</strong>。</p><p>明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2</span>...)</span><br></pre></td></tr></table></figure><p>PS：此框架出自历史文章 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484508&idx=1&sn=42cae6e7c5ccab1f156a83ea65b00b78&chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&scene=21#wechat_redirect" target="_blank" rel="noopener">团灭 LeetCode 股票买卖问题</a>。</p><p><strong>第二步**</strong>要明确<strong>**dp数组的定义</strong>。</p><p><code>dp</code>数组是什么？其实就是描述问题局面的一个数组。换句话说，我们刚才明确问题有什么「状态」，现在需要用<code>dp</code>数组把状态表示出来。</p><p>首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维<code>dp</code>数组，一维表示可选择的物品，一维表示背包的容量。</p><p><strong>dp[i][w]的定义如下：对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是dp[i][w]。</strong></p><p>比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。</p><p>PS：为什么要这么定义？便于状态转移，或者说这就是套路，记下来就行了。建议看一下我们的动态规划系列文章，几种动规套路都被扒得清清楚楚了。</p><p><strong>根据这个定义，我们想求的最终答案就是**</strong>dp[N][W]。base case 就是dp[0][..] = dp[..][0] = 0**，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。</p><p>细化上面的框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[N+<span class="number">1</span>][W+<span class="number">1</span>]</span><br><span class="line">dp[<span class="number">0</span>][..] = <span class="number">0</span></span><br><span class="line">dp[..][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> w in [<span class="number">1.</span>.W]:</span><br><span class="line">        dp[i][w] = <span class="built_in">max</span>(</span><br><span class="line">            把物品 i 装进背包,</span><br><span class="line">            不把物品 i 装进背包</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure><p><strong>第三步</strong> <strong>，根据「选择」，思考状态转移的逻辑</strong>。</p><p>简单说就是，上面伪码中「把物品<code>i</code>装进背包」和「不把物品<code>i</code>装进背包」怎么用代码体现出来呢？</p><p><strong>这一步要结合对</strong> <strong>dp数组的定义和我们的算法逻辑来分析：</strong></p><p>先重申一下刚才我们的<code>dp</code>数组的定义：</p><p><code>dp[i][w]</code>表示：对于前<code>i</code>个物品，当前背包的容量为<code>w</code>时，这种情况下可以装下的最大价值是<code>dp[i][w]</code>。</p><p><strong>如果你没有把这第</strong> <strong>i个物品装入背包</strong>，那么很显然，最大价值<code>dp[i][w]</code>应该等于<code>dp[i-1][w]</code>。你不装嘛，那就继承之前的结果。</p><p><strong>如果你把这第 ** **i个物品装入了背包</strong>，那么<code>dp[i][w]</code>应该等于<code>dp[i-1][w-wt[i-1]] + val[i-1]</code>。</p><p>首先，由于<code>i</code>是从 1 开始的，所以对<code>val</code>和<code>wt</code>的取值是<code>i-1</code>。</p><p>而<code>dp[i-1][w-wt[i-1]]</code>也很好理解：你如果想装第<code>i</code>个物品，你怎么计算这时候的最大价值？<strong>换句话说，在装第</strong> <strong>i个物品的前提下，背包能装的最大价值是多少？</strong></p><p>显然，你应该寻求剩余重量<code>w-wt[i-1]</code>限制下能装的最大价值，加上第<code>i</code>个物品的价值<code>val[i-1]</code>，这就是装第<code>i</code>个物品的前提下，背包可以装的最大价值。</p><p>综上就是两种选择，我们都已经分析完毕，也就是写出来了状态转移方程，可以进一步细化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> w in [<span class="number">1.</span>.W]:</span><br><span class="line">        dp[i][w] = <span class="built_in">max</span>(</span><br><span class="line">            dp[i<span class="number">-1</span>][w],</span><br><span class="line">            dp[i<span class="number">-1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>]</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure><p><strong>最后一步</strong>，<strong>把伪码翻译成代码，处理一些边界情况</strong>。</p><p>我用 C++ 写的代码，把上面的思路完全翻译了一遍，并且处理了<code>w - wt[i-1]</code>可能小于 0 导致数组索引越界的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; wt, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// vector 全填入 0，base case 已初始化</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前背包容量装不下，只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], </span><br><span class="line">                               dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你看这个解法代码，是不是感觉非常简单，就是把我们刚才分析的思路原封不动翻译了一下而已。</p><p>所以说，明确了动态规划的套路，思路就显得行云流水，非常自然就出答案了。</p><p>至此，背包问题就解决了。相比而言，我觉得这是比较简单的动态规划问题，因为状态转移的推导逻辑比较容易想到，基本上你明确了<code>dp</code>数组的定义，就可以理所当然地确定状态转移了。</p><h2 id="经典动态规划：0-1背包问题的变体"><a href="#经典动态规划：0-1背包问题的变体" class="headerlink" title="经典动态规划：0-1背包问题的变体"></a>经典动态规划：0-1背包问题的变体</h2><p>上篇文章 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485064&idx=1&sn=550705eb67f5e71487c8b218382919d6&chksm=9bd7f880aca071962a5a17d0f85d979d6f0c5a5ce32c84b8fee88e36d451f9ccb3bb47b88f78&scene=21#wechat_redirect" target="_blank" rel="noopener">经典动态规划：0-1 背包问题</a> 详解了通用的 0-1 背包问题，今天来看看背包问题的思想能够如何运用到其他算法题目。</p><p>而且，不是经常有读者问，怎么将二维动态规划压缩成一维动态规划吗？这就是状态压缩，很容易的，本文也会提及这种技巧。</p><h3 id="一、问题分析"><a href="#一、问题分析" class="headerlink" title="一、问题分析"></a>一、问题分析</h3><p>先看一下题目：</p><p><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdH4BiajD8HeXJSPSVviccPkjLAJxmP9Kto2Uqwjtv0AOYx9brfPaeSicxYPpjFzKarQygiaKGHYyV7F4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>title</p><p>算法的函数签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一个集合，返回是否能够分割成和相等的两个子集</span></span><br><span class="line"><span class="function">bool <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>;</span><br></pre></td></tr></table></figure><p>对于这个问题，看起来和背包没有任何关系，为什么说它是背包问题呢？</p><p>首先回忆一下背包问题大致的描述是什么：</p><p>给你一个可装载重量为<code>W</code>的背包和<code>N</code>个物品，每个物品有重量和价值两个属性。其中第<code>i</code>个物品的重量为<code>wt[i]</code>，价值为<code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p><p>那么对于这个问题，我们可以先对集合求和，得出<code>sum</code>，把问题转化为背包问题：</p><p><strong>给一个可装载重量为sum/2的背包和N个物品，每个物品的重量为nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满</strong>？</p><p>你看，这就是背包问题的模型，甚至比我们之前的经典背包问题还要简单一些，<strong>下面我们就直接转换成背包问题</strong>，开始套前文讲过的背包问题框架即可。</p><h3 id="二、解法分析"><a href="#二、解法分析" class="headerlink" title="二、解法分析"></a>二、解法分析</h3><p><strong>第一步要明确两点，「状态」和「选择」</strong>。</p><p>这个前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485064&idx=1&sn=550705eb67f5e71487c8b218382919d6&chksm=9bd7f880aca071962a5a17d0f85d979d6f0c5a5ce32c84b8fee88e36d451f9ccb3bb47b88f78&scene=21#wechat_redirect" target="_blank" rel="noopener">经典动态规划：0-1 背包问题</a> 已经详细解释过了，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p><p><strong>第二步要明确dp数组的定义</strong>。</p><p>按照背包问题的套路，可以给出如下定义：</p><p><code>dp[i][j] = x</code>表示，对于前<code>i</code>个物品，当前背包的容量为<code>j</code>时，若<code>x</code>为<code>true</code>，则说明可以恰好将背包装满，若<code>x</code>为<code>false</code>，则说明不能恰好将背包装满。</p><p>比如说，如果<code>dp[4][9] = true</code>，其含义为：对于容量为 9 的背包，若只是用前 4 个物品，可以有一种方法把背包恰好装满。</p><p>或者说对于本题，含义是对于给定的集合中，若只对前 4 个数字进行选择，存在一个子集的和可以恰好凑出 9。</p><p>根据这个定义，我们想求的最终答案就是<code>dp[N][sum/2]</code>，base case 就是<code>dp[..][0] = true</code>和<code>dp[0][..] = false</code>，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。</p><p><strong>第三步，根据「选择」，思考状态转移的逻辑</strong>。</p><p>回想刚才的<code>dp</code>数组含义，可以根据「选择」对<code>dp[i][j]</code>得到以下状态转移：</p><p>如果不把<code>nums[i]</code>算入子集，<strong>或者说你不把这第i个物品装入背包</strong>，那么是否能够恰好装满背包，取决于上一个状态<code>dp[i-1][j]</code>，继承之前的结果。</p><p>如果把<code>nums[i]</code>算入子集，<strong>或者说你把这第i个物品装入了背包</strong>，那么是否能够恰好装满背包，取决于状态<code>dp[i - 1][j-nums[i-1]]</code>。</p><p>首先，由于<code>i</code>是从 1 开始的，而数组索引是从 0 开始的，所以第<code>i</code>个物品的重量应该是<code>nums[i-1]</code>，这一点不要搞混。</p><p><code>dp[i - 1][j-nums[i-1]]</code>也很好理解：你如果装了第<code>i</code>个物品，就要看背包的剩余重量<code>j - nums[i-1]</code>限制下是否能够被恰好装满。</p><p>换句话说，如果<code>j - nums[i-1]</code>的重量可以被恰好装满，那么只要把第<code>i</code>个物品装进去，也可恰好装满<code>j</code>的重量；否则的话，重量<code>j</code>肯定是装不满的。</p><p><strong>最后一步，把伪码翻译成代码，处理一些边界情况</strong>。</p><p>以下是我的 C++ 代码，完全翻译了之前的思路，并处理了一些边界情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="comment">// 和为奇数时，不可能划分成两个和相等的集合</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    sum = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; </span><br><span class="line">        dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(sum + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 背包容量不足，不能装入第 i 个物品</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或不装入背包</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、进行状态压缩"><a href="#三、进行状态压缩" class="headerlink" title="三、进行状态压缩"></a>三、进行状态压缩</h3><p>再进一步，是否可以优化这个代码呢？<strong>注意到dp[i][j]都是通过上一行dp[i-1][..]转移过来的</strong>，之前的数据都不会再使用了。</p><p>所以，我们可以进行状态压缩，将二维<code>dp</code>数组压缩为一维，节约空间复杂度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sum = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = sum; j &gt;= <span class="number">0</span>; j--) </span><br><span class="line">            <span class="keyword">if</span> (j - nums[i] &gt;= <span class="number">0</span>) </span><br><span class="line">                dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是状态压缩，其实这段代码和之前的解法思路完全相同，只在一行<code>dp</code>数组上操作，<code>i</code>每进行一轮迭代，<code>dp[j]</code>其实就相当于<code>dp[i-1][j]</code>，所以只需要一维数组就够用了。</p><p><strong>唯一需要注意的是j应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果</strong>。</p><p>至此，子集切割的问题就完全解决了，时间复杂度 O(n*sum)，空间复杂度 O(sum)。 </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>团灭 LeetCode 股票买卖问题</title>
      <link href="/2020/08/09/%E5%9B%A2%E7%81%AD-LeetCode-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/09/%E5%9B%A2%E7%81%AD-LeetCode-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="团灭-LeetCode-股票买卖问题"><a href="#团灭-LeetCode-股票买卖问题" class="headerlink" title="团灭 LeetCode 股票买卖问题"></a>团灭 LeetCode 股票买卖问题</h1><p>相关推荐：</p><ul><li><a href="https://labuladong.gitbook.io/algo/di-wu-zhang-ji-shu-wen-zhang-xi-lie/zai-xian-lian-xi-ping-tai" target="_blank" rel="noopener">Git/SQL/正则表达式的在线练习平台</a></li><li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-she-ji-zui-chang-di-zeng-zi-xu-lie" target="_blank" rel="noopener">动态规划设计：最长递增子序列</a></li></ul><p>读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：</p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/" target="_blank" rel="noopener">买卖股票的最佳时机</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">买卖股票的最佳时机 III</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">买卖股票的最佳时机 IV</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">买卖股票的最佳时机含手续费</a></p><p>很多读者抱怨 LeetCode 的股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？<strong>所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变</strong>。</p><p>这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。</p><p>先随便抽出一道题，看看别人的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s1=-prices[<span class="number">0</span>],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();++i) &#123;            </span><br><span class="line">        s1 = max(s1, -prices[i]);</span><br><span class="line">        s2 = max(s2, s1+prices[i]);</span><br><span class="line">        s3 = max(s3, s2-prices[i]);</span><br><span class="line">        s4 = max(s4, s3+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">0</span>,s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。</p><p>本文就来告诉你这个框架，然后带着你一道一道秒杀。这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。</p><p>这 6 道题目是有共性的，我就抽出来第 4 道题目，因为这道题是一个最泛化的形式，其他的问题都是这个形式的简化，看下题目：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2Ff2f977954117e3643323d2eac4c3668f502835d1.png?alt=media" alt="img"></p><p>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。</p><p>如果你还不熟悉题目，可以去 LeetCode 查看这些题目的内容，本文为了节省篇幅，就不列举这些题目的具体内容了。下面言归正传，开始解题。</p><p><strong>一、穷举框架</strong></p><p>首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。</p><p>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。</p><p>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2</span>...)</span><br></pre></td></tr></table></figure><p>比如说这个问题，<strong>每天都有三种「选择」</strong>：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。</p><p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。<strong>这个问题的「状态」有三个</strong>，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span> or <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n-<span class="number">1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line">n 为天数，大 K 为最多交易数</span><br><span class="line">此问题共 n × K × <span class="number">2</span> 种状态，全部穷举就能搞定。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">        <span class="keyword">for</span> s in &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">            dp[i][k][s] = max(buy, sell, rest)</span><br></pre></td></tr></table></figure><p>而且我们可以用自然语言描述出每一个状态的含义，比如说 <code>dp[3][2][1]</code> 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 <code>dp[2][3][0]</code> 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p><p>我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p><p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p><p><strong>二、状态转移框架</strong></p><p>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F298b4971971d6e850923f64ab74792b86aa5c668.png?alt=media" alt="img"></p><p>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">              max(   选择 rest  ,             选择 sell      )</span><br><span class="line"></span><br><span class="line">解释：今天我没有持有股票，有两种可能：</span><br><span class="line">要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span><br><span class="line">要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span><br><span class="line"></span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">              max(   选择 rest  ,           选择 buy         )</span><br><span class="line"></span><br><span class="line">解释：今天我持有着股票，有两种可能：</span><br><span class="line">要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span><br><span class="line">要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span><br></pre></td></tr></table></figure><p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。</p><p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。<strong>如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。</strong>不过还差最后一点点，就是定义 base case，即最简单的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 i 是从 <span class="number">0</span> 开始的，所以 i = -<span class="number">1</span> 意味着还没有开始，这时候的利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 k 是从 <span class="number">1</span> 开始的，所以 k = <span class="number">0</span> 意味着根本不允许交易，这时候利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span><br></pre></td></tr></table></figure><p>把上面的状态转移方程总结一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">base <span class="keyword">case</span>：</span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。</p><p><strong>三、秒杀题目</strong></p><p><strong>第一题，k = 1</strong></p><p>直接套状态转移方程，根据 base case，可以做一些化简：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i]) </span><br><span class="line">            = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">解释：k = <span class="number">0</span> 的 base <span class="keyword">case</span>，所以 dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">现在发现 k 都是 <span class="number">1</span>，不会改变，即 k 对状态转移已经没有影响了。</span><br><span class="line">可以进行进一步化简去掉所有 k：</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br></pre></td></tr></table></figure><p>直接写出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = prices.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> == -<span class="number">1</span>) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 解释：</span></span><br><span class="line">        <span class="comment">//   dp[i][0] </span></span><br><span class="line">        <span class="comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span></span><br><span class="line">        <span class="comment">// = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">        <span class="comment">//解释：</span></span><br><span class="line">        <span class="comment">//   dp[i][1] </span></span><br><span class="line">        <span class="comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span></span><br><span class="line">        <span class="comment">// = max(-infinity, 0 - prices[i]) </span></span><br><span class="line">        <span class="comment">// = -prices[i]</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k == 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="comment">// base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span></span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        <span class="comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span></span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p><p><strong>第二题，k = +infinity</strong></p><p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">            = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k][<span class="number">0</span>] - prices[i])</span><br><span class="line"></span><br><span class="line">我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>直接翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_inf</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三题，k = +infinity with cooldown</strong></p><p>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">解释：第 i 天选择 buy 的时候，要从 i-<span class="number">2</span> 的状态转移，而不是 i-<span class="number">1</span> 。</span><br></pre></td></tr></table></figure><p>翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_cool</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp_pre_0 = <span class="number">0</span>; <span class="comment">// 代表 dp[i-2][0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);</span><br><span class="line">        dp_pre_0 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四题，k = +infinity with fee</strong></p><p>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] &#x3D; max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">dp[i][1] &#x3D; max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)</span><br><span class="line">解释：相当于买入股票的价格升高了。</span><br><span class="line">在第一个式子里减也是一样的，相当于卖出股票的价格减小了。</span><br></pre></td></tr></table></figure><p>直接翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_fee</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五题，k = 2</strong></p><p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。</p><p>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始的动态转移方程，没有可化简的地方</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> == -<span class="number">1</span>) &#123; <span class="comment">/* 处理一下 base case*/</span> &#125;</span><br><span class="line">    dp[i][k][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][k][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][k][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>为什么错误？我这不是照着状态转移方程写的吗？</p><p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。比如说第一题，k = 1：</p><p>「代码截图」</p><p>这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max_k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> == -<span class="number">1</span>) &#123; <span class="comment">/*处理 base case */</span> &#125;</span><br><span class="line">        dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 穷举了 n × max_k × 2 个状态，正确。</span></span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。</p><p>这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况全部列举出来也可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">2</span>][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">2</span>][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp_i10 = <span class="number">0</span>, dp_i11 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp_i20 = <span class="number">0</span>, dp_i21 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">        dp_i20 = Math.max(dp_i20, dp_i21 + price);</span><br><span class="line">        dp_i21 = Math.max(dp_i21, dp_i10 - price);</span><br><span class="line">        dp_i10 = Math.max(dp_i10, dp_i11 + price);</span><br><span class="line">        dp_i11 = Math.max(dp_i11, -price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会大惊失色，对你肃然起敬。</p><p><strong>第六题，k = any integer</strong></p><p>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？</p><p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。</p><p>直接把之前的代码重用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_any</span><span class="params">(<span class="keyword">int</span> max_k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (max_k &gt; n / <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> maxProfit_k_inf(prices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> == -<span class="number">1</span>) &#123; <span class="comment">/* 处理 base case */</span> &#125;</span><br><span class="line">            dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);     </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，6 道题目通过一个状态转移方程全部解决。</p><p><strong>四、最后总结</strong></p><p>本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。</p><p>关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？</p><p>具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有，所以给个在看/分享吧，鼓励一下我。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划设计：最长递增子序列</title>
      <link href="/2020/08/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2020/08/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划设计：最长递增子序列"><a href="#动态规划设计：最长递增子序列" class="headerlink" title="动态规划设计：最长递增子序列"></a>动态规划设计：最长递增子序列</h2><h2 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h2><p>很多读者反应，就算看了前文 <a href="http://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247483818&idx=1&sn=6035f861d1b2bfd0178e842f26ac4836&chksm=fb3361e8cc44e8fe331154bfd32bd7b3b4f159bfad5d38d4a6b0b9f0d7e3485b93b828ee72cc&scene=21#wechat_redirect" target="_blank" rel="noopener">动态规划详解</a>，了解了动态规划的套路，也不会写状态转移方程，没有思路，怎么办？本文就借助「最长递增子序列」来讲一种设计动态规划的通用技巧：数学归纳思想。</p><p>最长递增子序列（Longest Increasing Subsequence，简写 LIS）是比较经典的一个问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何写动态规划。</p><p>比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。</p><p>先看一下题目，很容易理解：</p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kgXtfMiaNRfjKJK5DiaHNAiaEaNokicicckI46EhqluRrrWqYzibZfjcow2ppvxG4nibIJTS6JpeibDh7Xjg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来一步一步设计动态规划算法解决这个问题。</p><h3 id="一、动态规划解法"><a href="#一、动态规划解法" class="headerlink" title="一、动态规划解法"></a>一、动态规划解法</h3><p><strong>动态规划的核心设计思想是数学归纳法。</strong></p><p>相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么我们先假设这个结论在 k&lt;n 时成立，然后想办法证明 k=<em>n</em> 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。</p><p>类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 <em>d**p</em>[0…<em>i</em>−1] 都已经被算出来了，然后问自己：怎么通过这些结果算出<em>dp[i] ?</em></p><p>直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 dp[i] 的值到底代表着什么？</p><p><strong>我们的定义是这样的：**</strong>dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。**</p><p>举个例子：</p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kgXtfMiaNRfjKJK5DiaHNAiaEPb6TvHFjI9Q4ZiaDY7uhI14RIJXUGiaIf0dpic0oN7IEaiazPUPK23SIZQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kgXtfMiaNRfjKJK5DiaHNAiaEVoqqLbQqPcQuaH4PNJhsHfpkQUIySgl88W69ePT7AlERVibHHwyib2yQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>算法演进的过程是这样的：<img data-src="https://mmbiz.qpic.cn/mmbiz_gif/b96CibCt70iaZjRayJQVCia5yvdcedgJ5QmIgJLGribw5M569SG75oxjFMqYJSlZED2QxT6l9gyPJJM0KwH18rGLXA/640?tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p><p>根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    res = Math.max(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>读者也许会问，刚才这个过程中每个 dp[i] 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 dp[i] 呢？</p><p>这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：</p><p>我们已经知道了 <em>d**p</em>[0…4] 的所有结果，我们如何通过这些已知结果推出 <em>d**p</em>[5]呢？</p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kgXtfMiaNRfjKJK5DiaHNAiaEC6950mgOcEEBicFQzHFjtzbD4BG1TcKrE7GfTP7ZybTyZIFQCq8JI2Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。</p><p>nums[5] = 3，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</p><p>当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。</p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_gif/b96CibCt70iaZjRayJQVCia5yvdcedgJ5QmIVe4WdmfkT0DmEweibYq7mP7LiapaJBk2xxhgsjapRXA7pdQRUxo801Q/640?tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kgXtfMiaNRfjKJK5DiaHNAiaEARWCyTW78XHOibkxUptWuweLpVjkNiah44RnxbR6cfCiayJBLKlnI2L1A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>这段代码的逻辑就可以算出 dp[5]。到这里，这道算法题我们就基本做完了。读者也许会问，我们刚才只是算了 dp[5] 呀，dp[4], dp[3] 这些怎么算呢？</p><p>类似数学归纳法，你已经可以通过 dp[0…4] 算出 dp[5] 了，那么任意 dp[i] 你肯定都可以算出来：</p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kgXtfMiaNRfjKJK5DiaHNAiaEzRX4QVEaax3Mm5xmeaEqyCTJ7bTNMr2sJVXicEooPpmRgVhdWb9RbtQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>还有一个细节问题，就是 base case。dp 数组应该全部初始化为 1，因为子序列最少也要包含自己，所以长度最小为 1。下面我们看一下完整代码：</p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kgXtfMiaNRfjKJK5DiaHNAiaEckTjx0BjeFdSIXalPct8LfFicaGnZyaRCK0H0HYNF6nAfZHblloRu4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>至此，这道题就解决了，时间复杂度 O(N^2)。总结一下动态规划的设计流程：</p><p>首先明确 dp 数组所存数据的含义。这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。</p><p>然后根据 dp 数组的定义，运用数学归纳法的思想，假设 <em>d**p</em>[0…<em>i</em>−1] 都已知，想办法求出 <em>d**p</em>[<em>i</em>]，一旦这一步完成，整个题目基本就解决了。</p><p>但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。</p><h3 id="二、二分查找解法"><a href="#二、二分查找解法" class="headerlink" title="二、二分查找解法"></a>二、二分查找解法</h3><p>这个解法的时间复杂度会将为 O(NlogN)，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以如果大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。</p><p>根据题目的意思，我都很难想象这个问题竟然能和二分查找扯上关系。其实最长递增子序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting（耐心排序）。</p><p>为了简单起见，后文跳过所有数学证明，通过一个简化的例子来理解一下思路。</p><p>首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。</p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kgXtfMiaNRfjKJK5DiaHNAiaES0lHia2kDKYwlicianraKTDLbPNVEGKmVd2LTbwpWSvbSbUtIazzFHRTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>处理这些扑克牌要遵循以下规则：</p><p>只能把点数小的牌压到点数比它大的牌上。如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去。如果当前牌有多个堆可供选择，则选择最左边的堆放置。</p><p>比如说上述的扑克牌最终会被分成这样 5 堆（我们认为 A 的值是最大的，而不是 1）。</p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kgXtfMiaNRfjKJK5DiaHNAiaENPURgfXOic54wF1QkgedzCBicLuSHeWfDYEVxgB9THLXsBMJk2W5rwVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q），证明略。</p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kgXtfMiaNRfjKJK5DiaHNAiaEsnb1Zu5ZQqSkq3pL2YJntQMQo95MOKyQsyFeDIPwBhaFEJdV1sCibvQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>按照上述规则执行，可以算出最长递增子序列，牌的堆数就是我们想求的最长递增子序列的长度，证明略。</p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kgXtfMiaNRfjKJK5DiaHNAiaEF4TxfZwJ3Ygib450H9mvZ8ibibibaVzhoiafOFqCibyT1pAicicpYXAaqgL2ZQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是有序吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。</p><p>PS：旧文 <a href="http://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247484090&idx=1&sn=5635cf1c4fd8a8570b63c7ae9b4304c2&chksm=fb3362f8cc44ebee0a19a4cfba7f2e13923e05f47e15f2e99a1f42b01aeee83b946aceac3d4c&scene=21#wechat_redirect" target="_blank" rel="noopener">二分查找算法详解</a> 详细介绍了二分查找的细节及变体，这里就完美应用上了。如果没读过强烈建议阅读。</p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kgXtfMiaNRfjKJK5DiaHNAiaE8zEA7icfKhAnXQciaBuic5CEJSQhjL0zs6n7MCTXJ2jooa75NlKQGYsIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>至此，二分查找的解法也讲解完毕。</p><p>这个解法确实很难想到。首先涉及数学证明，谁能想到按照这些规则执行，就能得到最长递增子序列呢？其次还有二分查找的运用，要是对二分查找的细节不清楚，给了思路也很难写对。</p><p>所以，这个方法作为思维拓展好了。但动态规划的设计方法应该完全理解：假设之前的答案已知，利用数学归纳的思想正确进行状态的推演转移，最终得到答案。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划设计：最大子数组</title>
      <link href="/2020/08/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2020/08/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划设计：最大子数组"><a href="#动态规划设计：最大子数组" class="headerlink" title="动态规划设计：最大子数组"></a>动态规划设计：最大子数组</h1><p>相关推荐：</p><ul><li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">动态规划解题套路框架</a></li><li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/tuan-mie-gu-piao-wen-ti" target="_blank" rel="noopener">团灭 LeetCode 股票买卖问题</a></li></ul><p>读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：</p><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53.最大子序和</a></p><p>最大子数组问题和前文讲过的 <a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-she-ji-zui-chang-di-zeng-zi-xu-lie" target="_blank" rel="noopener">经典动态规划：最长递增子序列</a> 的套路非常相似，代表着一类比较特殊的动态规划问题的思路：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F3b5a953a8f720e2eba246bfb521cf4092a1bf2b1.jpg?alt=media" alt="img"></p><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><strong>思路分析</strong></h1><p>其实第一次看到这道题，我首先想到的是<a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/hua-dong-chuang-kou-ji-qiao-jin-jie" target="_blank" rel="noopener">滑动窗口算法</a>，因为我们前文说过嘛，滑动窗口算法就是专门处理子串/子数组问题的，这里不就是子数组问题么？</p><p>但是，稍加分析就发现，<strong>这道题还不能用滑动窗口算法，因为数组中的数字可以是负数</strong>。</p><p>滑动窗口算法无非就是双指针形成的窗口扫描整个数组/子串，但关键是，你得清楚地知道什么时候应该移动右侧指针来扩大窗口，什么时候移动左侧指针来减小窗口。</p><p>而对于这道题目，你想想，当窗口扩大的时候可能遇到负数，窗口中的值也就可能增加也可能减少，这种情况下不知道什么时机去收缩左侧窗口，也就无法求出「最大子数组和」。</p><p>解决这个问题需要动态规划技巧，但是 <code>dp</code> 数组的定义比较特殊。按照我们常规的动态规划思路，一般是这样定义 <code>dp</code> 数组：</p><p><strong>nums[0..i]</strong> <strong>中的「最大的子数组和」为</strong> <strong>dp[i]</strong>。</p><p>如果这样定义的话，整个 <code>nums</code> 数组的「最大子数组和」就是 <code>dp[n-1]</code>。如何找状态转移方程呢？按照数学归纳法，假设我们知道了 <code>dp[i-1]</code>，如何推导出 <code>dp[i]</code> 呢？</p><p>如下图，按照我们刚才对 <code>dp</code> 数组的定义，<code>dp[i] = 5</code> ，也就是等于 <code>nums[0..i]</code> 中的最大子数组和：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2Fac79d04af662535f976b8cd3b944cbebd2fac3a9.jpeg?alt=media" alt="img"></p><p>那么在上图这种情况中，利用数学归纳法，你能用 <code>dp[i]</code> 推出 <code>dp[i+1]</code> 吗？</p><p><strong>实际上是不行的，因为子数组一定是连续的，按照我们当前</strong> <strong>dp</strong> <strong>数组定义，并不能保证</strong> <strong>nums[0..i]</strong> <strong>中的最大子数组与</strong> <strong>nums[i+1]</strong> <strong>是相邻的</strong>，也就没办法从 <code>dp[i]</code> 推导出 <code>dp[i+1]</code>。</p><p>所以说我们这样定义 <code>dp</code> 数组是不正确的，无法得到合适的状态转移方程。对于这类子数组问题，我们就要重新定义 <code>dp</code> 数组的含义：</p><p><strong>以</strong> <strong>nums[i]</strong> <strong>为结尾的「最大子数组和」为</strong> <strong>dp[i]</strong>。</p><p>这种定义之下，想得到整个 <code>nums</code> 数组的「最大子数组和」，不能直接返回 <code>dp[n-1]</code>，而需要遍历整个 <code>dp</code> 数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res = Math.max(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>依然使用数学归纳法来找状态转移关系：假设我们已经算出了 <code>dp[i-1]</code>，如何推导出 <code>dp[i]</code> 呢？</p><p>可以做到，<code>dp[i]</code> 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。</p><p>如何选择？既然要求「最大子数组和」，当然选择结果更大的那个啦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要么自成一派，要么和前面的子数组合并</span></span><br><span class="line">dp[i] = Math.max(nums[i], nums[i] + dp[i - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>综上，我们已经写出了状态转移方程，就可以直接写出解法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// 第一个元素前面没有子数组</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 状态转移方程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(nums[i], nums[i] + dp[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到 nums 的最大子数组</span></span><br><span class="line">    <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上解法时间复杂度是 O(N)，空间复杂度也是 O(N)，较暴力解法已经很优秀了，不过<strong>注意到</strong> <strong>dp[i]</strong> <strong>仅仅和</strong> <strong>dp[i-1]</strong> <strong>的状态有关</strong>，那么我们可以进行「状态压缩」，将空间复杂度降低：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">int</span> dp_0 = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> dp_1 = <span class="number">0</span>, res = dp_0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// dp[i] = max(nums[i], nums[i] + dp[i-1])</span></span><br><span class="line">        dp_1 = Math.max(nums[i], nums[i] + dp_0);</span><br><span class="line">        dp_0 = dp_1;</span><br><span class="line">        <span class="comment">// 顺便计算最大的结果</span></span><br><span class="line">        res = Math.max(res, dp_1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a><strong>最后总结</strong></h1><p>虽然说动态规划推状态转移方程确实比较玄学，但大部分还是有些规律可循的。</p><p>今天这道「最大子数组和」就和「最长递增子序列」非常类似，<code>dp</code> 数组的定义是「以 <code>nums[i]</code> 为结尾的最大子数组和/最长递增子序列为 <code>dp[i]</code>」。因为只有这样定义才能将 <code>dp[i+1]</code> 和 <code>dp[i]</code> 建立起联系，利用数学归纳法写出状态转移方程。</p><p><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu#si-lu-fen-xi" target="_blank" rel="noopener">  </a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划解题框架</title>
      <link href="/2020/08/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/08/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划解题套路框架"><a href="#动态规划解题套路框架" class="headerlink" title="动态规划解题套路框架"></a>动态规划解题套路框架</h1><p>相关推荐：</p><ul><li><a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/bfs-jie-jue-hua-dong-pin-tu" target="_blank" rel="noopener">如何用 BFS 算法秒杀各种智力题</a></li><li><a href="https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/mian-shi-du-zai-wen-de-wei-fu-wu-yi-wen-dai-ni-che-di-gao-dong" target="_blank" rel="noopener">面试都在问的微服务，一文带你彻底搞懂</a></li></ul><p>读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：</p><p><a href="https://leetcode-cn.com/problems/fibonacci-number" target="_blank" rel="noopener">509.斐波那契数</a></p><p><a href="https://leetcode-cn.com/problems/coin-change" target="_blank" rel="noopener">322.零钱兑换</a></p><p>这篇文章是我们号半年前一篇 200 多赞赏的成名之作「动态规划详解」的进阶版。由于账号迁移的原因，旧文无法被搜索到，所以我润色了本文，并添加了更多干货内容，希望本文成为解决动态规划的一部「指导方针」。</p><p>动态规划问题（Dynamic Programming）应该是很多读者头疼的，不过这类问题也是最具有技巧性，最有意思的。本书使用了整整一个章节专门来写这个算法，动态规划的重要性也可见一斑。</p><p>刷题刷多了就会发现，算法技巧就那几个套路，<strong>我们后续的动态规划系列章节，都在使用本文的解题框架思维</strong>，如果你心里有数，就会轻松很多。所以本文放在第一章，来扒一扒动态规划的裤子，形成一套解决这类问题的思维框架，希望能够成为解决动态规划问题的一部指导方针。本文就来讲解该算法的基本套路框架，下面上干货。</p><p><strong>首先，动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离呀等等。</p><p>既然是要求最值，核心问题是什么呢？<strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</p><p>动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！</p><p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p><p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p><p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p><p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p><p>按上面的套路走，最后的结果就可以套这个框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 初始化 base case</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"># 进行状态转移</span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2</span>...)</span><br></pre></td></tr></table></figure><p>下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。</p><h1 id="一、斐波那契数列"><a href="#一、斐波那契数列" class="headerlink" title="一、斐波那契数列"></a><strong>一、斐波那契数列</strong></h1><p>请读者不要嫌弃这个例子简单，<strong>只有简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙</strong>。想要困难的例子，历史文章里有的是。</p><p><strong>1、暴力递归</strong></p><p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fib(int N) &#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F70af23686865b425f7b88f172ac696878985f4c6.jpg?alt=media" alt="img"></p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p><p>这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p><p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><p><strong>2、带备忘录的递归解法</strong></p><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int fib(int N) &#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    // 备忘录全初始化为 <span class="number">0</span></span><br><span class="line">    vector&lt;int&gt; memo(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    // 进行带备忘录的递归</span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int helper(vector&lt;int&gt;&amp; memo, int n) &#123;</span><br><span class="line">    // base case </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    // 已经计算过</span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2Fe6547795e536cbd16b7f5f23da637032cc88e87e.jpg?alt=media" alt="img"></p><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F6d82de2baa7ef942d20da7d9323d86cf55051f67.jpg?alt=media" alt="img"></p><p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><p><strong>3、dp 数组的迭代解法</strong></p><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F65192fe4cbb8d583daf45ceb260b2d333ba77169.jpg?alt=media" alt="img"></p><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F6b54539705dc61842749cf10bfa80e367c912664.png?alt=media" alt="img"></p><p>为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p><h1 id="二、凑零钱问题"><a href="#二、凑零钱问题" class="headerlink" title="二、凑零钱问题"></a><strong>二、凑零钱问题</strong></h1><p>先看下题目：给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// coins 中是可选硬币面值，amount 是目标金额</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span></span>;</span><br></pre></td></tr></table></figure><p>比如说 <code>k = 3</code>，面值分别为 1，2，5，总金额 <code>amount = 11</code>。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</p><p>你认为计算机应该如何解决这个问题？显然，就是把所有肯能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。</p><p><strong>1、暴力递归</strong></p><p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。</p><p>比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p><p>PS：关于最优子结构的问题，后文<a href="https://github.com/labuladong/ebook/tree/f354aec370d0ed934ee8148a7fd40e3eae83089d/动态规划系列/动态规划系列/最优子结构.md" target="_blank" rel="noopener">动态规划答疑篇</a> 还会再举例探讨。</p><p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>？</p><p>1、<strong>确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p><p>2、<strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p><p>3、<strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p><p>4、<strong>明确</strong> <strong>dp</strong> <strong>函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 <code>dp</code> 函数：</p><p><code>dp(n)</code> 的定义：输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 的最少硬币数量。</p><p>搞清楚上面这几个关键点，解法的伪码就可以写出来了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 伪码框架</span><br><span class="line"><span class="function">def <span class="title">coinChange</span><span class="params">(coins: List[<span class="keyword">int</span>], amount: <span class="keyword">int</span>)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">    # 定义：要凑出金额 n，至少要 dp(n) 个硬币</span><br><span class="line">    <span class="function">def <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        # 做选择，选择需要硬币最少的那个结果</span><br><span class="line">        <span class="keyword">for</span> coin in coins:</span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + dp(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    # 题目要求的最终结果是 dp(amount)</span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">coinChange</span><span class="params">(coins: List[<span class="keyword">int</span>], amount: <span class="keyword">int</span>)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    def <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">        <span class="meta"># base case</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> n </span>== <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        # 求最小值，所以初始化为正无穷</span><br><span class="line">        res = float('INF')</span><br><span class="line">        <span class="keyword">for</span> coin in coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            # 子问题无解，跳过</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        return res if res != float('INF') else -1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F5381a5e30482682c1c6f111e882991113b8661f7.png?alt=media" alt="img"></p><p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = {1,2,5}</code> 时画出递归树看看：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F11389aca27fca8bf28578565fcd46e2c4b051e91.jpg?alt=media" alt="img"></p><p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p><p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p><p><strong>2、带备忘录的递归</strong></p><p>类似之前斐波那契数列的例子，只需要稍加修改，就可以通过备忘录消除子问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">coinChange</span><span class="params">(coins: List[<span class="keyword">int</span>], amount: <span class="keyword">int</span>)</span>:</span></span><br><span class="line">    # 备忘录</span><br><span class="line">    memo = dict()</span><br><span class="line">    def dp(n):</span><br><span class="line">        # 查备忘录，避免重复计算</span><br><span class="line">        <span class="keyword">if</span> n in memo: <span class="keyword">return</span> memo[n]</span><br><span class="line">        # base <span class="keyword">case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = float('INF')</span><br><span class="line">        <span class="keyword">for</span> coin in coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        # 记入备忘录</span><br><span class="line">        memo[n] = res if res != float('INF') else -1</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p><p><strong>3、dp 数组的迭代解法</strong></p><p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引：</p><p><strong>dp</strong> <strong>数组的定义：当目标金额为</strong> <strong>i</strong> <strong>时，至少需要</strong> <strong>dp[i]</strong> <strong>枚硬币凑出</strong>。</p><p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F17a588ce985b456232062703d025551175d57895.jpg?alt=media" alt="img"></p><p>PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p><h1 id="三、最后总结"><a href="#三、最后总结" class="headerlink" title="三、最后总结"></a><strong>三、最后总结</strong></h1><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p><p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p><p>之后我们会有一章专门讲解动态规划问题，如果有任何问题都可以随时回来重读本文，希望读者在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树算法套路框架</title>
      <link href="/2020/08/08/%E6%A0%91%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/08/08/%E6%A0%91%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>例题</p><p><a href="https://leetcode-cn.com/problems/same-tree" target="_blank" rel="noopener">100.相同的树</a></p><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst" target="_blank" rel="noopener">450.删除二叉搜索树中的节点</a></p><p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree" target="_blank" rel="noopener">701.二叉搜索树中的插入操作</a></p><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree" target="_blank" rel="noopener">700.二叉搜索树中的搜索</a></p><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank" rel="noopener">98.验证二叉搜索树</a></p><p>二叉树算法的设计的总路线：明确一个节点要做的事情，然后剩下的事抛给框架。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// root 需要做什么？在这做。</span></span><br><span class="line">    <span class="comment">// 其他的不用 root 操心，抛给框架</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举两个简单的例子体会一下这个思路，热热身。</p><p><strong>1. 如何把二叉树所有的节点中的值加一？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plusOne</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    root.val += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    plusOne(root.left);</span><br><span class="line">    plusOne(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 如何判断两棵二叉树是否完全相同？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 都为空的话，显然相同</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 一个为空，一个非空，显然不同</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 两个都非空，但 val 不一样也不行</span></span><br><span class="line">    <span class="keyword">if</span> (root1.val != root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// root1 和 root2 该比的都比完了</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(root1.left, root2.left)</span><br><span class="line">        &amp;&amp; isSameTree(root1.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助框架，上面这两个例子不难理解吧？如果可以理解，那么所有二叉树算法你都能解决。\</p><p>二叉搜索树（Binary Search Tree，简称 BST）是一种很常用的的二叉树。它的定义是：一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右边子树的所有节点的值。</p><p>如下就是一个符合定义的 BST：</p><p><img data-src="1.png" alt="1.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1596851815050.png" alt="1596851815050"></p><p>下面实现 BST 的基础操作：判断 BST 的合法性、增、删、查。其中“删”和“判断合法性”略微复杂。</p><p><strong>零、判断 BST 的合法性</strong></p><p>这里是有坑的哦，我们按照刚才的思路，每个节点自己要做的事不就是比较自己和左右孩子吗？看起来应该这样写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.val &lt;= root.left.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; root.val &gt;= root.right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left)</span><br><span class="line">        &amp;&amp; isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的所有节点，下面这个二叉树显然不是 BST，但是我们的算法会把它判定为 BST。</p><p><img data-src="2.png" alt="2.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1596851973944.png" alt="1596851973944"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root) </span><br><span class="line">        &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一、在 BST 中查找一个数是否存在</strong></p><p>根据我们的指导思想，可以这样写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isInBST(root.left, target)</span><br><span class="line">        || isInBST(root.right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写完全正确，充分证明了你的框架性思维已经养成。现在你可以考虑一点细节问题了：如何充分利用信息，把 BST 这个“左小右大”的特性用上？</p><p>很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 target 和 root.val 的大小比较，就能排除一边。我们把上面的思路稍稍改动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        <span class="keyword">return</span> isInBST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        <span class="keyword">return</span> isInBST(root.left, target);</span><br><span class="line">    <span class="comment">// root 该做的事做完了，顺带把框架也完成了，妙</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，我们对原始框架进行改造，抽象出一套<strong>针对 BST 的遍历框架</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、在 BST 中插入一个数</p><p>对数据结构的操作无非遍历 + 访问，遍历就是“找”，访问就是“改”。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。</p><p>上一个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框架，加上“改”的操作即可。一旦涉及“改”，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到空位置插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="comment">// if (root.val == val)</span></span><br><span class="line">    <span class="comment">//     BST 中一般不会插入已存在元素</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val) </span><br><span class="line">        root.right = insertIntoBST(root.right, val);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) </span><br><span class="line">        root.left = insertIntoBST(root.left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三、在 BST 中删除一个数</strong></p><p>这个问题稍微复杂，不过你有框架指导，难不住你。跟插入操作类似，先“找”再“改”，先把框架写出来再说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 找到啦，进行删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到目标节点了，比方说是节点 A，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。</p><p>情况 1：A 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。</p><p><img data-src="3.png" alt="3.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1596853193684.png" alt="1596853193684"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>情况 2：A 只有一个非空子节点，那么它要让这个孩子接替自己的位置。</p><p><img data-src="4.png" alt="4.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1596853247770.png" alt="1596853247770"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排除了情况 1 之后</span></span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line"><span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br></pre></td></tr></table></figure><p>情况 3：A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。</p><p><img data-src="5.png" alt="5.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1596853382587.png" alt="1596853382587"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">    TreeNode minNode = getMin(root.right);</span><br><span class="line">    <span class="comment">// 把 root 改成 minNode</span></span><br><span class="line">    root.val = minNode.val;</span><br><span class="line">    <span class="comment">// 转而去删除 minNode</span></span><br><span class="line">    root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种情况分析完毕，填入框架，简化一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="comment">// 处理情况 3</span></span><br><span class="line">        TreeNode minNode = getMin(root.right);</span><br><span class="line">        root.val = minNode.val;</span><br><span class="line">        root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">getMin</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作就完成了。注意一下，这个删除操作并不完美，因为我们一般不会通过 root.val = minNode.val 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 root 和 minNode 两个节点。因为具体应用中，val 域可能会很大，修改起来很耗时，而链表操作无非改一改指针，而不会去碰内部数据。</p><p>但这里忽略这个细节，旨在突出 BST 基本操作的共性，以及借助框架逐层细化问题的思维方式。</p><p>四、最后总结</p><p>通过这篇文章，你学会了如下几个技巧：</p><p>1.二叉树算法设计的总路线：把当前节点要做的事做好，其他的交给递归框架，不用当前节点操心。</p><p>2.如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p><p>3.在二叉树框架之上，扩展出一套 BST 遍历框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.掌握了 BST 的基本操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2020/08/05/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2020/08/05/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：</p><p><a href="https://leetcode-cn.com/problems/permutations" target="_blank" rel="noopener">46.全排列</a></p><p><a href="https://leetcode-cn.com/problems/n-queens" target="_blank" rel="noopener">51.N皇后</a></p><p>这篇文章是很久之前的一篇《回溯算法详解》的进阶版，之前那篇不够清楚，就不必看了，看这篇就行。把框架给你讲清楚，你会发现回溯算法问题都是一个套路。</p><p>废话不多说，直接上回溯算法框架。<strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。你只需要思考 3 个问题：</p><p>1、路径：也就是已经做出的选择。</p><p>2、选择列表：也就是你当前可以做的选择。</p><p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p><p>如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。</p><p>代码方面，回溯算法的框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function">def <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> 满足结束条件:</span></span><br><span class="line"><span class="function">        result.<span class="title">add</span><span class="params">(路径)</span></span></span><br><span class="line"><span class="function">        return</span></span><br><span class="line"><span class="function">​</span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> 选择 in 选择列表:</span></span><br><span class="line"><span class="function">        做选择</span></span><br><span class="line"><span class="function">        <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span></span></span><br><span class="line"><span class="function">        撤销选择</span></span><br></pre></td></tr></table></figure><p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong>，特别简单。</p><p>什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！</p><h1 id="一、全排列问题"><a href="#一、全排列问题" class="headerlink" title="一、全排列问题"></a><strong>一、全排列问题</strong></h1><p>我们在高中的时候就做过排列组合的数学题，我们也知道 <code>n</code> 个不重复的数，全排列共有 n! 个。</p><p>PS：<strong>为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字</strong>。</p><p>那么我们当时是怎么穷举全排列的呢？比方说给三个数 <code>[1,2,3]</code>，你肯定不会无规律地乱穷举，一般是这样：</p><p>先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……</p><p>其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2Fb847370747577e500942731dfbc3822c9e445e7b.jpg?alt=media" alt="img"></p><p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。<strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。</p><p><strong>为啥说这是决策树呢，因为你在每个节点上其实都在做决策</strong>。比如说你站在下图的红色节点上：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F2bca8736780b65bbdff30a69fb8e23c7964a1485.jpg?alt=media" alt="img"></p><p>你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。</p><p><strong>现在可以解答开头的几个名词：**</strong>[2]** <strong>就是「路径」，记录你已经做过的选择；**</strong>[1,3]** <strong>就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候</strong>。</p><p>如果明白了这几个名词，<strong>可以把「路径」和「选择」列表作为决策树上每个节点的属性</strong>，比如下图列出了几个节点的属性：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2Fb016864ae8dd85f027f4bc983eb8871baa4e68a7.jpg?alt=media" alt="img"></p><p><strong>我们定义的</strong> <strong>backtrack</strong> <strong>函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列</strong>。</p><p>再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前「学习数据结构的框架思维」写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.childern)</span><br><span class="line">        <span class="comment">// 前序遍历需要的操作</span></span><br><span class="line">        traverse(child);</span><br><span class="line">        <span class="comment">// 后序遍历需要的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F3690d9637ccf0f072e996376d50f5198a22fb36a.jpg?alt=media" alt="img"></p><p><strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行</strong>。</p><p>回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F727ed1ecd086bf28e5c0a22ddd20246839cd34ba.jpg?alt=media" alt="img"></p><p>现在，你是否理解了回溯算法的这段核心框架？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">    # 做选择</span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    # 撤销选择</span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure><p><strong>我们只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径。</p><p>下面，直接看全排列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 路径：记录在 track 中</span></span><br><span class="line"><span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line"><span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F368dee24bab62b1c27fd4a8387cea9619605195f.jpg?alt=media" alt="img"></p><p>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 <code>contains</code> 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。</p><p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。<strong>这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong>。</p><p>明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。</p><h1 id="二、N-皇后问题"><a href="#二、N-皇后问题" class="headerlink" title="二、N 皇后问题"></a><strong>二、N 皇后问题</strong></h1><p>这个问题很经典了，简单解释一下：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。</p><p>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p><p>这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p><p>直接套用框架:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 输入棋盘边长 n，返回所有合法的放置 */</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// '.' 表示空，'Q' 表示皇后，初始化空棋盘。</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">'.'</span>)</span>)</span>;</span><br><span class="line">    backtrack(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">int</span> n = board[row].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span> (!isValid(board, row, col)) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        <span class="comment">// 进入下一行决策</span></span><br><span class="line">        backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分主要代码，其实跟全排列问题差不多，<code>isValid</code> 函数的实现也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 是否可以在 board[row][col] 放置皇后？ */</span></span><br><span class="line"><span class="function">bool <span class="title">isValid</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.size();</span><br><span class="line">    <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; </span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>backtrack</code> 依然像个在决策树上游走的指针，通过 <code>row</code> 和 <code>col</code> 就可以表示函数遍历到的位置，通过 <code>isValid</code> 函数可以将不符合条件的情况剪枝：</p><p><img data-src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2Fa146fd6b92466062b1081fa9d71a1030b49334f5.jpg?alt=media" alt="img"></p><p>如果直接给你这么一大段解法代码，可能是懵逼的。但是现在明白了回溯算法的框架套路，还有啥难理解的呢？无非是改改做选择的方式，排除不合法选择的方式而已，只要框架存于心，你面对的只剩下小问题了。</p><p>当 <code>N = 8</code> 时，就是八皇后问题，数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。</p><p>不过真的不怪高斯。这个问题的复杂度确实非常高，看看我们的决策树，虽然有 <code>isValid</code> 函数剪枝，但是最坏时间复杂度仍然是 O(N^(N+1))，而且无法优化。如果 <code>N = 10</code> 的时候，计算就已经很耗时了。</p><p><strong>有的时候，我们并不想得到所有合法的答案，只想要一个答案，怎么办呢</strong>？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。</p><p>其实特别简单，只要稍微修改一下回溯算法的代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数找到一个答案后就返回 true</span></span><br><span class="line"><span class="function">bool <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> (backtrack(board, row + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">​</span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样修改后，只要找到一个答案，for 循环的后续递归穷举都会被阻断。也许你可以在 N 皇后问题的代码框架上，稍加修改，写一个解数独的算法？</p><h1 id="三、最后总结"><a href="#三、最后总结" class="headerlink" title="三、最后总结"></a><strong>三、最后总结</strong></h1><p>回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">backtrack</span><span class="params">(...)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> 选择 in 选择列表:</span></span><br><span class="line"><span class="function">        做选择</span></span><br><span class="line"><span class="function">        <span class="title">backtrack</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">        撤销选择</span></span><br></pre></td></tr></table></figure><p><strong>写</strong> <strong>backtrack</strong> <strong>函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集</strong>。</p><p>其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？</p><p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表排序</title>
      <link href="/2020/08/05/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/08/05/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>同 leetcode148</p><p>链表排序可按照归并排序进行，即先拆分成单个节点 ，再对节点进行合并并排序</p><h3 id="1-代码"><a href="#1-代码" class="headerlink" title="1.代码"></a>1.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q148</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、找到链表中间节点并断开 &amp; 递归下探</span></span><br><span class="line">        ListNode midNode= middleNode(head);</span><br><span class="line">        ListNode rightHead = midNode.next;</span><br><span class="line">        midNode.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode left = sortList(head);</span><br><span class="line">        ListNode right = sortList(rightHead);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.当前业务操作（合并有序链表）</span></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(left,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  找到链表中间节点（876. 链表的中间结点）</span></span><br><span class="line">    <span class="comment">//这样找到的slow是中间节点左边的那个</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序链表（21. 合并两个有序链表）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur  = newHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) cur.next = l2;</span><br><span class="line">        <span class="keyword">else</span> cur.next = l1;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题2</title>
      <link href="/2020/07/30/%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
      <url>/2020/07/30/%E9%9D%A2%E8%AF%95%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h4 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h4><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1596206668802.png" alt="1596206668802"></p><p>答案C</p><p>A 省略构造函数,编译器会自动生成。</p><p>D 构造函数可以重载</p><p>B 方法是可以和类名同名的，和构造方法唯一的区别就是，构造方法没有返回值。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConStructor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestConStructor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestConStructor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"not constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TestConStructor testConStructor = <span class="keyword">new</span> TestConStructor();</span><br><span class="line">    System.out.println(<span class="string">"main"</span>);</span><br><span class="line">    testConStructor.TestConStructor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Math-float"><a href="#2-Math-float" class="headerlink" title="2.Math.float()"></a>2.Math.float()</h4><p>floor: 求小于参数的最大整数。返回double类型—–n. 地板，地面</p><p>​         例如：Math.floor(-4.2) = -5.0</p><p>-———————————————————-</p><p>ceil:   求大于参数的最小整数。返回double类型—–vt. 装天花板；</p><p>​         例如：Math.ceil(5.6) = 6.0</p><p>-———————————————————-</p><p>round: 对小数进行四舍五入后的结果。返回int类型</p><p>​         例如：Math.round(-4.6) = -5</p><h4 id="3-修饰符"><a href="#3-修饰符" class="headerlink" title="3.修饰符"></a>3.修饰符</h4><p>Java语言提供了很多修饰符，主要分为以下两类：</p><p>1、访问修饰符 </p><p>​    <strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p><p>​    <strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></p><p>​    <strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</p><p>​    <strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</p><p>2、非访问修饰符，包括但不限于：</p><p>​    <strong>static</strong> 修饰符，用来修饰类方法和类变量。</p><p>​    <strong>final</strong> 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p><p>​    <strong>abstract</strong> 修饰符，用来创建抽象类和抽象方法。</p><p>​    <strong>synchronized</strong> 和 <strong>volatile</strong> 修饰符，主要用于线程的编程。</p><h4 id="3-Collection"><a href="#3-Collection" class="headerlink" title="3.Collection"></a>3.Collection</h4><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1596459174484.png" alt="1596459174484"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1596459184837.png" alt="1596459184837"></p><h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1596459290427.png" alt="1596459290427"></p><p>java 中String是 immutable的，也就是不可变，一旦初始化，其引用指向的内容是不可变的。</p><p>也就是说，String str = “aa”；str=“bb”；第二句不是改变“aa”所存储地址的内容，而是另外开辟了一个空间用来存储“bb”；同时由str指向原来的“aa”，现在已经不可达，GC时会自动回收。</p><p>因此String作为参数传进来时候，str= “test ok”; 实际给副本引用str指向了新分配的地址，该地址存储“test ok”。</p><p>因此，原先的str仍然指向“good”</p><h4 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h4><p>Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”</p><p>Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。</p><h4 id="6-构造方法"><a href="#6-构造方法" class="headerlink" title="6.构造方法"></a>6.构造方法</h4><p>java中的构造方法</p><h5 id="构造方法的特点："><a href="#构造方法的特点：" class="headerlink" title="构造方法的特点："></a>构造方法的特点：</h5><p>构造方法的方法名与类名相同</p><p>构造方法没有返回值类型，也不写void</p><p>构造方法可以重载</p><h5 id="什么时候会用到构造方法："><a href="#什么时候会用到构造方法：" class="headerlink" title="什么时候会用到构造方法："></a>什么时候会用到构造方法：</h5><p>在创建对象的时候</p><h5 id="构造方法的作用："><a href="#构造方法的作用：" class="headerlink" title="构造方法的作用："></a>构造方法的作用：</h5><p>创建对象的时候给属性赋初值</p><h5 id="构造方法的分类："><a href="#构造方法的分类：" class="headerlink" title="构造方法的分类："></a>构造方法的分类：</h5><p>显示的构造方法和隐式地构造方法</p><p>显示的构造方法：显示的写出构造方法时，系统不会提供默认的无参构造方法</p><p>隐式地构造方法：系统默认提供的无参构造方法</p><h5 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h5><p>分类：静态代码块和实例代码块</p><p>静态代码块：static修饰的代码块，在类加载时执行，且只执行一次。因为类就加载一次了。</p><p>实例代码块：没有static修饰的代码块，创建对象时执行，每创建一次对象加载一次。</p><p>实例代码块在执行构造方法之前执行。所以优先级高于构造方法。</p><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>静态成员变量或静态代码块&gt;main方法&gt;非静态成员变量或非静态代码块&gt;构造方法</p><h4 id="7-J2EE中常用的名词解释"><a href="#7-J2EE中常用的名词解释" class="headerlink" title="7.J2EE中常用的名词解释"></a>7.J2EE中常用的名词解释</h4><p>1.web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接和容器中的环境变量接接口互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。</p><p>2.Web container：实现J2EE体系结构中Web组件协议的容器。这个协议规定了一个Web组件运行时的环境，包括安全，一致性，生命周期管理，事务，配置和其它的服务。一个提供和JSP和J2EE平台APIs界面相同服务的容器。一个Web container 由Web服务器或者J2EE服务器提供。</p><p>3.EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了J2EE体系结构中EJB组件规范的容器。 这个规范指定了一个Enterprise bean的运行时环境，包括安全，一致性，生命周期，事务， 配置，和其他的服务。</p><p>4.JNDI：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。</p><p>5.JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。</p><p>6.JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。</p><p>7.JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。</p><p>8.RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。RMI-IIOP出现以前，只有RMI和CORBA两种选择来进行分布式程序设计。RMI-IIOP综合了RMI和CORBA的优点，克服了他们的缺点，使得程序员能更方便的编写分布式程序设计，实现分布式计算。首先，RMI-IIOP综合了RMI的简单性和CORBA的多语言性（兼容性），其次RMI-IIOP克服了RMI只能用于Java的缺点和CORBA的复杂性（可以不用掌握IDL）。</p><h4 id="8-访问权限"><a href="#8-访问权限" class="headerlink" title="8.访问权限"></a>8.访问权限</h4><table><thead><tr><th></th><th>private</th><th>default</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一个包中</td><td></td><td>√</td><td>√</td><td>√</td></tr><tr><td>子类中</td><td></td><td></td><td>√</td><td>√</td></tr><tr><td>全局范围内</td><td></td><td></td><td></td><td>√</td></tr></tbody></table><p>（ 1 ）对于外部类而言，它也可以使用访问控制符修饰，但外部类只能有两种访问控制级别： public 和默认。因为外部类没有处于任何类的内部，也就没有其所在类的内部、所在类的子类两个范围，因此 private 和 protected 访问控制符对外部类没有意义。</p><p>（ 2 ）内部类的上一级程序单元是外部类，它具有 4 个作用域：同一个类（ private ）、同一个包（ protected ）和任何位置（ public ）。</p><p>（ 3 ） 因为局部成员的作用域是所在方法，其他程序单元永远不可能访问另一个方法中的局部变量，所以所有的局部成员都不能使用访问控制修饰符修饰。</p><h4 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h4><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1596467840565.png" alt="1596467840565"></p><p>1.java支持单继承，却可以实现多个接口。a对d错<br>2.接口没有构造方法，所以不能实例化，抽象类有构造方法，但是不是用来实例化的，是用来初始化的。c对<br>3.抽象类可以定义普通成员变量而接口不可以，但是抽象类和接口都可以定义静态成员变量，只是接口的静态成员变量要用static final public 来修饰。b错</p><h4 id="10-Integer对象的方法"><a href="#10-Integer对象的方法" class="headerlink" title="10.Integer对象的方法"></a>10.Integer对象的方法</h4><p>Integer.parseInt(“”);是将字符串类型转换为int的基础数据类型</p><p>Integer.valueOf(“”)是将字符串类型数据转换为Integer对象</p><p>Integer.intValue();是将Integer对象中的数据取出，返回一个基础数据类型int</p><h4 id="11Socket编程"><a href="#11Socket编程" class="headerlink" title="11Socket编程"></a>11Socket编程</h4><p>客户端通过socket()方法创建socket对象 服务端通过serverSocket()方法创建TCP对象，通过accept()方法接受客户端请求</p><h4 id="12-内部类"><a href="#12-内部类" class="headerlink" title="12.内部类"></a>12.内部类</h4><h5 id="1-为什么使用内部类"><a href="#1-为什么使用内部类" class="headerlink" title="1.为什么使用内部类?"></a>1.为什么使用内部类?</h5><p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，<br>对于内部类都没有影响<br>1.1.使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:<br>(1)、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独。<br>(2)、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。<br>(3)、创建内部类对象的时刻并不依赖于外围类对象的创建。<br>(4)、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。<br>(5)、内部类提供了更好的封装，除了该外围类，其他类都不能访问。</p><h5 id="2-内部类分类"><a href="#2-内部类分类" class="headerlink" title="2.内部类分类:"></a>2.内部类分类:</h5><h6 id="一-成员内部类"><a href="#一-成员内部类" class="headerlink" title="(一).成员内部类:"></a>(一).成员内部类:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">99</span>;</span><br><span class="line">String name = <span class="string">"Coco"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">String name = <span class="string">"Jayden"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(Outer.<span class="keyword">this</span>.name);</span><br><span class="line">System.out.println(name);</span><br><span class="line">System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">Inner in = o.<span class="keyword">new</span> Inner();</span><br><span class="line">in.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，<br>如 public 、 protected 、 private 等<br>2.Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，<br>如直接访问 Outer 类中的私有属性age<br>3.定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，<br>即：内部类 对象名 = 外部类对象.new 内部类( );<br>4.编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}<br>5.成员内部类中不能存在任何 static 的变量和方法,可以定义常量:<br>(1).因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关,<br>简而言之:在加载静态域时,根本没有外部类,所在在非静态内部类中不能定义静态域或方法,编译不通过;<br>非静态内部类的作用域是实例级别<br>(2).常量是在编译器就确定的,放到所谓的常量池了<br>★★友情提示:<br>1.外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;<br>2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，<br>可以使用 this 关键字,如:Outer.this.name</p><h6 id="二-静态内部类-是-static-修饰的内部类"><a href="#二-静态内部类-是-static-修饰的内部类" class="headerlink" title="(二).静态内部类: 是 static 修饰的内部类,"></a>(二).静态内部类: 是 static 修饰的内部类,</h6><p>1.静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问<br>2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；<br>如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员<br>3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">static</span> String name = <span class="string">"Coco"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">String name = <span class="string">"Jayden"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(Outer.name);</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">i.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="三-方法内部类：其作用域仅限于方法内，方法外部无法访问该内部类"><a href="#三-方法内部类：其作用域仅限于方法内，方法外部无法访问该内部类" class="headerlink" title="(三).方法内部类：其作用域仅限于方法内，方法外部无法访问该内部类"></a>(三).方法内部类：其作用域仅限于方法内，方法外部无法访问该内部类</h6><p>(1).局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的<br>(2).只能访问方法中定义的 final 类型的局部变量,因为:<br>当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在,<br>直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量;<br>==&gt;使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期.<br>局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，<br>自己内部的方法调用的实际是自己的属性而不是外部类方法的参数;<br>防止被篡改数据,而导致内部类得到的值不一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">使用的形参为何要为 final???</span></span><br><span class="line"><span class="comment"> 在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，</span></span><br><span class="line"><span class="comment"> 也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，</span></span><br><span class="line"><span class="comment"> 毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解</span></span><br><span class="line"><span class="comment"> 和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">13</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"访问外部类:"</span> + a);</span><br><span class="line">System.out.println(<span class="string">"访问内部类:"</span> + c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">i.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">o.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3).注意:在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能</strong></p><p><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html" target="_blank" rel="noopener"><strong>http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html</strong></a></p><p><strong>反编译jdk8编译之后的class文件,发现内部类引用外部的局部变量都是 final 修饰的</strong></p><h6 id="四-匿名内部类"><a href="#四-匿名内部类" class="headerlink" title="(四).匿名内部类:"></a>(四).匿名内部类:</h6><p>(1).匿名内部类是直接使用 new 来生成一个对象的引用;</p><p>(2).对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>   num,String str2)</span></span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> InnerClass()&#123;</span><br><span class="line">                  <span class="keyword">int</span> number = num + <span class="number">3</span>;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">                      <span class="keyword">return</span> number;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;;        <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">              OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line">              InnerClass inner = out.getInnerClass(<span class="number">2</span>, <span class="string">"chenssy"</span>);</span><br><span class="line">              System.out.println(inner.getNumber());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="class"><span class="keyword">interface</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题1</title>
      <link href="/2020/07/26/%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
      <url>/2020/07/26/%E9%9D%A2%E8%AF%95%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<p> 1 OOM都有哪些，说出几种？<br> 2 volatile关键字的作用，底层实现？讲一下你对JMM的理解。<br> 3 线程的生命周期？<br> 4 ArrayList的初始长度是多少？扩容机制？<br> 5 谈谈你对JVM虚拟机的了解？垃圾回收过程？你用的哪个版本的JDK，使用的垃圾回收器是什么？垃圾回收算法是什么？介绍一下双亲委派模型</p><p> 6 序列化的原理和作用聊聊你对集合的认识<br> 7 springMVC的内部流程 </p><p> 8 java中的集合类都使用过哪些？CopyonWriteList的原理及使用场景<br> 9 IO模型都有哪些？阻塞与非阻塞IO的区别？同步和异步IO的区别？ </p><p> 10 线程池用过么？谈谈你对ThreadLocal的理解？<br> 11 单一的、固定数的和可变的三种创建线程池的方法，你用哪个多？<br> 12 线程池的拒绝策略都有哪些？如何合理的配置线程池？（考虑CPU密集型和IO密集型） </p><p> 13 有没有使用过redis？redis的基本类型有哪些？redis和memche有什么区别？<br> 14 说一下redis的使用场景吧？你再项目中哪里使用过redis？redis的持久化机制？ </p><p>  15 CAS知道么？底层实现？ 会引发什么问题？如何解决ABA问题？ </p><p>  16 一条sql语句执行时间过长，应该如何优化？从哪些方面进行优化？</p><p>  17 在做分布式集群时候一般会产生什么问题？（分布式幂等性问题，session共享问题，分布式全局生成Id问题）</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础面试题</title>
      <link href="/2020/07/20/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/07/20/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1、List和Set的区别"><a href="#1、List和Set的区别" class="headerlink" title="1、List和Set的区别"></a>1、List和Set的区别</h3><p>Java中的集合共包含三大类，它们分别是Set（集），List（列表）以及Map（映射）。它们都处在java.util中并且都为接口。它们各自都有各自的实现类。Set的实现类主要有HashSet和TreeSet，List的实现类主要有ArrayList</p><p><strong>（1）重复对象</strong></p><p>list方法可以允许重复的对象，而set方法不允许重复对象</p><p><strong>（2）null元素</strong></p><p>list可以插入多个null元素，而set只允许插入一个null元素</p><p><strong>（3）容器是否有序</strong></p><p>list是一个有序的容器，保持了每个元素的插入顺序。即输出顺序就是输入顺序，而set方法是无序容器，无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序</p><p><strong>（4）常用的实现类</strong></p><p>list方法常用的实现类有ArrayList、LinkedList 和 Vector。其中ArrayList 最为流行，它提供了使用索引的随意访问，而LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适，Vector 表示底层数组，线程安全</p><p>Set方法中最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和compareTo() 的定义进行排序的有序容器</p><h3 id="2、List常用的实现类"><a href="#2、List常用的实现类" class="headerlink" title="2、List常用的实现类"></a>2、List常用的实现类</h3><h4 id="1、ArrayList"><a href="#1、ArrayList" class="headerlink" title="1、ArrayList"></a>1、ArrayList</h4><p><strong>非线程安全</strong><br>基于对象数组<br>get(int index)不需要遍历数组，速度快；<br>iterator()方法中调用了get(int index)，所以速度也快<br>set(int index, E e)不需要遍历数组，速度快<br>add方法需要考虑扩容与数组复制问题，速度慢<br>remove(Object o)需要遍历数组，并复制数组元素，速度慢<br>remove(int index)不需要遍历数组，需要复制数组元素，但不常用<br>contain(E)需要遍历数组</p><h4 id="2、LinkedList"><a href="#2、LinkedList" class="headerlink" title="2、LinkedList"></a>2、LinkedList</h4><p><strong>非线程安全</strong><br>基于环形双向链表<br>get(int index)需要遍历链表，速度慢；<br>iterator()方法中调用了get(int index)，所以速度也慢<br>set(int index, E e)方法中调用了get(int index)，所以速度也慢<br>add方法不需要考虑扩容与数组复制问题，只需创建新对象，再将新对象的前后节点的指针指向重新分配一下就好，速度快<br>remove(Object o)需要遍历链表，但不需要复制元素，只需将所要删除的对象的前后节点的指针指向重新分配一下以及将所要删除的对象的三个属性置空即可，速度快<br>remove(int index)需要遍历链表，但不需要复制元素，只需将所要删除的对象的前后节点的指针指向重新分配一下以及将所要删除的对象的三个属性置空即可，但不常用<br>contain(E)需要遍历链表</p><h4 id="3、Vector（线程安全的ArrayList）"><a href="#3、Vector（线程安全的ArrayList）" class="headerlink" title="3、Vector（线程安全的ArrayList）"></a>3、Vector（线程安全的ArrayList）</h4><p>线程安全<br>扩容机制与ArrayList不同</p><h4 id="4、Stack（继承于Vector）"><a href="#4、Stack（继承于Vector）" class="headerlink" title="4、Stack（继承于Vector）"></a>4、Stack（继承于Vector）</h4><p>线程安全<br>效率低下，可采用双端队列Deque或LinkedList来实现，Deque用的较多<br>总结：<br>在查询（get）、遍历（iterator）、修改（set）使用的比较多的情况下，用ArrayList<br>在增加（add）、删除（remove）使用比较多的情况下，用LinkedList<br>在需要线程安全而且对效率要求比较低的情况下，使用Vector，当然，实现ArrayList线程安全的方法也有很多，以后再说<br>在需要使用栈结构的情况下，使用Deque，Stack废弃就行了</p><h3 id="3、ArrayList和LinkedList的区别"><a href="#3、ArrayList和LinkedList的区别" class="headerlink" title="3、ArrayList和LinkedList的区别"></a>3、ArrayList和LinkedList的区别</h3><h4 id="1-Array"><a href="#1-Array" class="headerlink" title="1. Array"></a>1. Array</h4><p><strong>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。</strong></p><p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据, (因为删除数据以后, 需要把后面所有的数据前移)</p><p><strong>缺点:</strong> 数组初始化必须指定初始化的长度, 否则报错</p><p>例如:</p><p>int[] a = new int[4];//推介使用int[] 这种方式初始化</p><p>int c[] = {23,43,56,78};//长度：4，索引范围：[0,3]</p><h4 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h4><p><strong>List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。</strong></p><p><strong>List有两个重要的实现类：ArrayList和LinkedList</strong></p><p>List是一个接口，不可以实例化, 不能写成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> List&lt;Integer&gt;();<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><ul><li>类继承关系</li></ul><p><img data-src="1.png" alt="1.png"></p><p><img data-src="https://img2018.cnblogs.com/blog/838837/201905/838837-20190521092648019-983754481.png" alt="img"></p><h4 id="3-ArrayList"><a href="#3-ArrayList" class="headerlink" title="3. ArrayList"></a>3. ArrayList</h4><p><strong>ArrayList: 可以看作是能够自动增长容量的数组</strong></p><p><strong>ArrayList的toArray方法返回一个数组</strong></p><p><strong>ArrayList的asList方法返回一个列表</strong></p><p>ArrayList底层的实现是Array, 数组扩容实现</p><p>ArrayList扩容的核心方法grow()</p><ul><li><p>新增数据空间判断</p><p>新增数据的时候需要判断当前是否有空闲空间存储</p></li><li><p>扩容需要申请新的连续空间</p></li><li><p>把老的数组复制过去</p></li><li><p>新加的内容</p></li><li><p>回收老的数组空间</p></li></ul><h4 id="4-LinkList"><a href="#4-LinkList" class="headerlink" title="4. LinkList"></a>4. LinkList</h4><p><strong>LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。</strong></p><p>链表不需要连续的空间, 大小不确定</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><ul><li><p>同样查找, 时间复杂度都是O(N), 但是数组要比链表快</p><p>因为数组的连续内存, 会有一部分或者全部数据一起进入到CPU缓存, 而链表还需要在去内存中根据上下游标查找, CPU缓存比内存块太多</p></li><li><p>数据大小固定, 不适合动态存储, 动态添加, 内存为一连续的地址, 可随机访问, 查询速度快</p></li><li><p>链表代销可变, 扩展性强, 只能顺着指针的方向查询, 速度较慢</p></li></ul><h3 id="4、Set常用的实现类"><a href="#4、Set常用的实现类" class="headerlink" title="4、Set常用的实现类"></a>4、Set常用的实现类</h3><p>一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。常用的实现类有HashSet、LinkedHashSet、TreeSet</p><h4 id="HashSet定义及特点"><a href="#HashSet定义及特点" class="headerlink" title="HashSet定义及特点"></a>HashSet定义及特点</h4><p>public class HashSet extends AbstractSet implements Set, Cloneable, Serializable</p><ol><li>实现原理，基于哈希表（HashMap）实现</li><li>不允许重复，最多可以有一个null元素</li><li>不保证顺序恒久不变</li><li>添加元素时把元素作为HashMap的key保存，HashMap的value使用一个固定的Object对象</li><li>排除重复是通过equals方法来检查对象是否相等</li><li>判断两个对象是否相同，先判断两个对象的hashCode是否相同（两个对象的hashCode相等不一定是同一个对象，但如果不同，一定不是同一个对象），若不同，则两个对象不是同一个对象；若相同，还要进行equals判断。equals方法返回true则为同一个对象，返回false则不是同一个对象。</li><li>自定义类存入HashSet时，建议重写类的hashCode和equals方法</li></ol><p>哈希表的存储结构：数组+链表，数组里的每个元素以链表的形式存储<br>如何把对象存储到哈希表中？先计算对象的hashCode值再对数组的长度求余数，来决定对象要存储在数组中的哪个位置。</p><h4 id="TreeSet定义及特点"><a href="#TreeSet定义及特点" class="headerlink" title="TreeSet定义及特点"></a>TreeSet定义及特点</h4><p>public class TreeSet extends AbstractSet implements NavigableSet, Cloneable, Serializable</p><ul><li>基于 TreeMap 的 NavigableSet 实现。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。</li><li>有序的，基于TreeMap(二叉树数据结构)实现，对象需要比较大小，通过对象比较器来实现。对象比较器还可以用来去除重复元素，若自定义的类没有实现比较器（Comparable）接口，将无法添加到TreeSet中。</li></ul><h4 id="LinkedHashSet定义及特点"><a href="#LinkedHashSet定义及特点" class="headerlink" title="LinkedHashSet定义及特点"></a>LinkedHashSet定义及特点</h4><p>public class LinkedHashSet extends HashSet implements Set, Cloneable, Serializable</p><p>具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。此实现与 HashSet 的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，即按照将元素插入到set 中的顺序（插入顺序）进行迭代。注意，插入顺序不 受在 set 中重新插入的 元素的影响。如果在 s.contains(e) 返回 true 后立即调用 s.add(e)，则元素 e 会被重新插入到 set s 中。）</p><p>如何选择Set接口的具体实现？</p><ul><li>如果要排序，选TreeSet</li><li>如果不用排序，也不用保证顺序，选HashSet</li><li>如果不用排序，要保证顺序，选LinkedHashSet</li></ul><h3 id="5、HashSet和LinkedHashSet的区别"><a href="#5、HashSet和LinkedHashSet的区别" class="headerlink" title="5、HashSet和LinkedHashSet的区别"></a>5、HashSet和LinkedHashSet的区别</h3><p>HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。</p><p>TreeSet是采用树结构实现(红黑树算法)。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first(), last(), headSet(), tailSet()等等。</p><p>LinkedHashSet介于HashSet和TreeSet之间。它也是一个hash表，但是同时维护了一个双链表来记录插入的顺序。基本方法的复杂度为O(1)。</p><h3 id="6、int和Integer的区别"><a href="#6、int和Integer的区别" class="headerlink" title="6、int和Integer的区别"></a>6、int和Integer的区别</h3><ol><li>int是基本数据类型，Integer是int包装类。</li><li>Integer变量必须实例化后才能使用，int可以直接使用</li><li>Integer的默认值是null，int默认值是0</li><li>Integer变量实际上是对象的引用，指向new的Integer对象，int是直接存储数据</li></ol><h4 id="深入对比"><a href="#深入对比" class="headerlink" title="深入对比"></a>深入对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(a.equals(b));</span><br></pre></td></tr></table></figure><p>结果前false，后true。<br>因为Integer变量是对Integer对象的引用，new了两个对象，显然内存地址不一样，引用不一样。<br>而Integer重写了equals方法，数值一样就返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">10</span>;</span><br><span class="line">    Integer b = <span class="number">10</span>;</span><br><span class="line">    System.out.println(a == b);</span><br><span class="line">    Integer c = <span class="number">128</span>;</span><br><span class="line">    Integer d = <span class="number">128</span>;</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果前true，后false<br>因为Integer自动装箱时对数值在-128到127的对象放入缓存中，第二次就直接取缓存中的数据而不会new。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    System.out.println(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为true<br>因为Integer类型和int比较时，会自动拆箱，化为基本类型数据比较。</p><h3 id="7、-和equals的区别"><a href="#7、-和equals的区别" class="headerlink" title="7、==和equals的区别"></a>7、==和equals的区别</h3><p><strong>==:</strong>判断两个字符串在内存中首地址是否相同,即判断两者是否是同一个字符串对象</p><p><strong>equles():</strong>如果没有重写equals()方法比较的是对象的地址,因为对Object来说对象没有什么属性可以比较,只能比较最底层的地址.</p><p>而如果重写equals()方法时,该方法的对象因为是Object的子类,所以调用时会调用子类对象里面的方法.所以只有重写equals()方法后,两者比较的才是内容.或者说重写可以使自己定义比较的规则,不想按照地址去比较.</p><h3 id="8、final关键字"><a href="#8、final关键字" class="headerlink" title="8、final关键字"></a>8、final关键字</h3><p>在java的关键字中，static和final是两个我们必须掌握的关键字。不同于其他关键字，他们都有多种用法，而且在一定环境下使用，可以提高程序的运行性能，优化程序的结构。下面我们来了解一下final关键字及其用法。</p><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>在java中，final的含义在不同的场景下有细微的差别，但总体上来说，它指的是“这是不可变的”。下面，我们来讲final的四种主要用法。</p><h4 id="1-修饰数据"><a href="#1-修饰数据" class="headerlink" title="1.修饰数据"></a>1.修饰数据</h4><p>在编写程序时，我们经常需要说明一个数据是不可变的，我们成为常量。在java中，用final关键字修饰的变量，只能进行一次赋值操作，并且在生存期内不可以改变它的值。更重要的是，final会告诉编译器，这个数据是不会修改的，那么编译器就可能会在编译时期就对该数据进行替换甚至执行计算，这样可以对我们的程序起到一点优化。不过在针对基本类型和引用类型时，final关键字的效果存在细微差别。我们来看下面的例子：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> v;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.v = v;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> f2;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         f2 = <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> value1 = <span class="number">1</span>;</span><br><span class="line">         <span class="comment">// value1 = 4;</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">double</span> value2;</span><br><span class="line">         value2 = <span class="number">2.0</span>;</span><br><span class="line">         <span class="keyword">final</span> Value value3 = <span class="keyword">new</span> Value(<span class="number">1</span>);</span><br><span class="line">         value3.v = <span class="number">4</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们先来看一下main方法中的几个final修饰的数据，在给value1赋初始值之后，我们无法再对value1的值进行修改，final关键字起到了常量的作用。从value2我们可以看到，final修饰的变量可以不在声明时赋值，即可以先声明，后赋值。value3时一个引用变量，这里我们可以看到final修饰引用变量时，只是限定了引用变量的引用不可改变，即不能将value3再次引用另一个Value对象，但是引用的对象的值是可以改变的，从内存模型中我们看的更加清晰：</p><p><img data-src="2.png" alt="2.png"></p><p><img data-src="https://img-blog.csdn.net/20180808171104824?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA5Mzg2MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>上图中，final修饰的值用粗线条的边框表示它的值是不可改变的，我们知道引用变量的值实际上是它所引用的对象的地址，也就是说该地址的值是不可改变的，从而说明了为什么引用变量不可以改变引用对象。而实际引用的对象实际上是不受final关键字的影响的，所以它的值是可以改变的。</p><p>另一方面，我们看到了用final修饰成员变量时的细微差别，因为final修饰的数据的值是不可改变的，所以我们必须确保在使用前就已经对成员变量赋值了。因此对于final修饰的成员变量，我们有且只有两个地方可以给它赋值，一个是声明该成员时赋值，另一个是在构造方法中赋值，在这两个地方我们必须给它们赋初始值。</p><p>最后我们需要注意的一点是，同时使用static和final修饰的成员在内存中只占据一段不能改变的存储空间。</p><p>2.修饰方法参数<br>前面我们可以看到，如果变量是我们自己创建的，那么使用final修饰表示我们只会给它赋值一次且不会改变变量的值。那么如果变量是作为参数传入的，我们怎么保证它的值不会改变呢？这就用到了final的第二种用法，即在我们编写方法时，可以在参数前面添加final关键字，它表示在整个方法中，我们不会（实际上是不能）改变参数的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalFunc</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i, <span class="keyword">final</span> Value value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i = 5; 不能改变i的值</span></span><br><span class="line">    <span class="comment">// v = new Value(); 不能改变v的值</span></span><br><span class="line">    value.v = <span class="number">5</span>; <span class="comment">// 可以改变引用对象的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-修饰方法"><a href="#3-修饰方法" class="headerlink" title="3.修饰方法"></a>3.修饰方法</h4><p>第三种方式，即用final关键字修饰方法，它表示该方法不能被覆盖。这种使用方式主要是从设计的角度考虑，即明确告诉其他可能会继承该类的程序员，不希望他们去覆盖这个方法。这种方式我们很容易理解，然而，关于private和final关键字还有一点联系，这就是类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它。</p><h4 id="4-修饰类"><a href="#4-修饰类" class="headerlink" title="4.修饰类"></a>4.修饰类</h4><p>了解了final关键字的其他用法，我们很容易可以想到使用final关键字修饰类的作用，那就是用final修饰的类是无法被继承的。</p><p>上面我们讲解了final的四种用法，然而，对于第三种和第四种用法，我们却甚少使用。这不是没有道理的，从final的设计来讲，这两种用法甚至可以说是鸡肋，因为对于开发人员来讲，如果我们写的类被继承的越多，就说明我们写的类越有价值，越成功。即使是从设计的角度来讲，也没有必要将一个类设计为不可继承的。Java标准库就是一个很好的反例，特别是Java 1.0/1.1中Vector类被如此广泛的运用，如果所有的方法均未被指定为final的话，它可能会更加有用。如此有用的类，我们很容易想到去继承和重写他们，然而，由于final的作用，导致我们对Vector类的扩展受到了一些阻碍，导致了Vector并没有完全发挥它应有的全部价值。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>final关键字是我们经常使用的关键字之一，它的用法有很多，但是并不是每一种用法都值得我们去广泛使用。它的主要用法有以下四种：</p><p>用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；<br>用来修饰方法参数，表示在变量的生存期中它的值不能被改变；<br>修饰方法，表示该方法无法被重写；<br>修饰类，表示该类无法被继承。<br>上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。</p><h3 id="9、接口和抽象类的区别"><a href="#9、接口和抽象类的区别" class="headerlink" title="9、接口和抽象类的区别"></a>9、接口和抽象类的区别</h3><h4 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h4><p>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。<br>接口中的实例变量默认是 final 类型的，而抽象类中则不一定。<br>一个类可以实现多个接口，但最多只能实现一个抽象类。<br>一个类实现接口的话要实现接口的所有方法，而抽象类不一定。<br>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象。从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。<br><code>备注:在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</code></p><h4 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a>抽象类必须要有抽象方法吗？</h4><p>抽象类中不一定包含抽象方法，但是包含抽象方法的类一定要被声明为抽象类。</p><h4 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h4><p>抽象类不能用 final 来修饰。当用 final 修饰一个类时，表明这个类不能被继承。 final 类中的所有成员方法都会被隐式地指定为 final 方法，这明显违背了抽象类存在的意义了。</p><h3 id="10、原子操作，CAS存在的问题，如何解决"><a href="#10、原子操作，CAS存在的问题，如何解决" class="headerlink" title="10、原子操作，CAS存在的问题，如何解决"></a>10、原子操作，CAS存在的问题，如何解决</h3><h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h4><p>CAS,compare and swap的缩写，中文翻译成<strong>比较并交换</strong>。</p><p>我们都知道，在java语言之前，并发就已经广泛存在并在服务器领域得到了大量的应用。所以硬件厂商老早就在芯片中加入了大量直至并发操作的原语，从而在硬件层面提升效率。在intel的CPU中，使用cmpxchg指令。</p><p>在Java发展初期，java语言是不能够利用硬件提供的这些便利来提升系统的性能的。而随着java不断的发展,Java本地方法(JNI)的出现，使得java程序越过JVM直接调用本地方法提供了一种便捷的方式，因而java在并发的手段上也多了起来。而在Doug Lea提供的cucurenct包中，CAS理论是它实现整个java包的基石。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”</p><p>通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。</p><p>类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。</p><h4 id="CAS的目的"><a href="#CAS的目的" class="headerlink" title="CAS的目的"></a>CAS的目的</h4><p>利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。</p><h3 id="11、-和–操作是否为原子操作，为什么"><a href="#11、-和–操作是否为原子操作，为什么" class="headerlink" title="11、++和–操作是否为原子操作，为什么"></a>11、++和–操作是否为原子操作，为什么</h3><p>不是原子操作。理由：</p><p><strong>1.i++分为三个阶段：</strong></p><p>内存到寄存器<br>寄存器自增<br>写回内存<br>这三个阶段中间都可以被中断分离开.</p><p> <strong>2.++i首先要看编译器是怎么编译的</strong>，</p><p>某些编译器比如VC在非优化版本中会编译为以下汇编代码：</p><p>__asm<br>{<br>        moveax,  dword ptr[i]<br>        inc eax<br>        mov dwordptr[i], eax<br>}<br>这种情况下，必定不是原子操作，不加锁互斥是不行的。<br>假设加了优化参数，那么是否一定会编译为“inc dword ptr[i]”呢？答案是否定的，这要看编译器心情，如果++i的结果还要被使用的话，那么一定不会被编译为“inc dword ptr[i]”的形式。<br>那么假设如果编译成了“inc dword ptr[i]”，这是原子操作，是否就不需要加锁了呢？如果在单核机器上，不加锁不会有问题，但到了多核机器上，这个不加锁同样会带来严重后果，两个CPU可以同时执行inc指令，但是两个执行以后，却可能出现只自加了一次。<br>真正可以确保不“额外”加锁的汇编指令是“lock inc dword ptr[i]”，lock前缀可以暂时锁住总线，这时候其他CPU是无法访问相应数据的。但是目前没有任何一个编译器会将++int编译为这种形式。</p><h3 id="12、Java的异常处理机制，Error和Exception的区别"><a href="#12、Java的异常处理机制，Error和Exception的区别" class="headerlink" title="12、Java的异常处理机制，Error和Exception的区别"></a>12、Java的异常处理机制，Error和Exception的区别</h3><h4 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h4><p>异常的英文单词是exception，字面翻译就是“意外、例外”的意思，也就是非正常情况。事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用空的引用、数组下标越界、内存溢出错误等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果。因此，如何对运行期间出现的错误进行处理和补救呢？<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java</a>提供了异常机制来进行处理，通过异常机制来处理程序运行期间出现的错误。通过异常机制，我们可以更好地提升程序的健壮性。</p><h4 id="unchecked-exception（非检查异常）"><a href="#unchecked-exception（非检查异常）" class="headerlink" title="unchecked exception（非检查异常）"></a>unchecked exception（非检查异常）</h4><p>也称运行时异常（RuntimeException），比如常见的NullPointerException、IndexOutOfBoundsException。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。</p><h4 id="checked-exception（检查异常，编译异常）"><a href="#checked-exception（检查异常，编译异常）" class="headerlink" title="checked exception（检查异常，编译异常）"></a>checked exception（检查异常，编译异常）</h4><p>也称非运行时异常（运行时异常以外的异常就是非运行时异常），java编译器强制程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</p><h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><p>有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><h4 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h4><p>是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p><h4 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h4><p>是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。<br>可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。<br>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><h4 id="应该catch什么"><a href="#应该catch什么" class="headerlink" title="应该catch什么"></a>应该catch什么</h4><p>其实只要是Throwable和其子类都是可以throw和catch的，那么如果在需要统一处理异常的地方，我们应该catch (Throwable th) 还是 catch (Exception)呢？<br>这两种处理的区别在于，catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception极其子类，捕捉的范围更小。先不考虑有其他的类继承了Throwable的情况下，第一种catch相当于比第二种catch多捕捉了把Error和其子类。<br>那么究竟Error是否需要捕捉呢？JDK中Error类的的注释（如下）里提到过，Error是一种严重的问题，应用程序不应该捕捉它。<br>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. The ThreadDeath error, though a “normal” condition, is also a subclass of Error because most applications should not try to catch it.<br>A method is not required to declare in its throws clause any subclasses of Error that might be thrown during the execution of the method but not caught, since these errors are abnormal conditions that should never occur.<br><a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java </a>Lanuage Spec 7 中也提到：Error继承自Throwable而不是继承自Exception，是为了方便程序可以使用 “catch (Exception)“来捕捉异常而不会把Error也捕捉在内，因为Exception发生后可以进行一些恢复工作的，但是Error发生后一般是不可恢复的。<br>The class Error is a separate subclass ofThrowable, distinct from Exception in the class<br>hierarchy, to allow programs to use the idiom “} catch (Exception e) { ” (§11.2.3)<br>to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible.<br>已经不难看出，Java本身设计思路就是希望大家catch Exception就足够了，如果有Error发生，catch了也不会有什么作用。</p><h4 id="Error可以catch吗？-可以catch了后做些其他处理吗？"><a href="#Error可以catch吗？-可以catch了后做些其他处理吗？" class="headerlink" title="Error可以catch吗？ 可以catch了后做些其他处理吗？"></a>Error可以catch吗？ 可以catch了后做些其他处理吗？</h4><p>Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。</p><h3 id="13、IOException需要捕获吗？"><a href="#13、IOException需要捕获吗？" class="headerlink" title="13、IOException需要捕获吗？"></a>13、IOException需要捕获吗？</h3><p>如果你不想捕捉，就需要把异常往上一级继续抛出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">//方法声明的时候带有异常抛出</span></span><br><span class="line">         System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"test"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; <span class="comment">//方法声明的时候不带异常抛出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"2"</span>);</span><br><span class="line">            test(); <span class="comment">//那么调用带有异常抛出的方法的时候，就必须捕捉异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> satatic <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        test(); <span class="comment">//如果不想捕捉异常，那么就在方法声明的时候继续向上级抛出异常</span></span><br><span class="line">         test2();<span class="comment">//这样，方法异常的时候，程序就中止，由上级继续处理异常，直到JVM级别为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14、synchronized和Lock的区别"><a href="#14、synchronized和Lock的区别" class="headerlink" title="14、synchronized和Lock的区别"></a>14、synchronized和Lock的区别</h3><p>两者区别：</p><p>1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</p><p>2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</p><p>3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</p><p>4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</p><p>5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</p><p>6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</p><h3 id="15、线程池：创建、核心参数、拒绝策略"><a href="#15、线程池：创建、核心参数、拒绝策略" class="headerlink" title="15、线程池：创建、核心参数、拒绝策略"></a>15、线程池：创建、核心参数、拒绝策略</h3><h3 id="16、Spring依赖注入的方式"><a href="#16、Spring依赖注入的方式" class="headerlink" title="16、Spring依赖注入的方式"></a>16、Spring依赖注入的方式</h3><ul><li><strong>set方法注入</strong></li><li><strong>构造器注入</strong></li><li><strong>静态工厂注入</strong></li><li><strong>实例工厂注入</strong></li></ul><h4 id="1-set方法注入"><a href="#1-set方法注入" class="headerlink" title="1.set方法注入"></a>1.set方法注入</h4><ul><li> 在演示前，我们需要准备几个类，我使用下面两个类来进行注入的演示，这两个类分别是<code>User</code>和<code>Car</code>类：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只包含基本数据类型的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> speed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">int</span> speed, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.speed = speed;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpeed</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Car&#123;"</span> +</span><br><span class="line">                <span class="string">"speed="</span> + speed +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 除了上面两个基本数据类型的属性，User还依赖Car</span></span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age, Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", car="</span> + car +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    有了上面两个类，我们就可以演示<code>set</code>注入了。需要注意一点，如果我们需要使用<code>set</code>注入，那么必须要为属性提供<code>set</code>方法，<code>Spring</code>容器就是通过调用<code>bean</code>的<code>set</code>方法为属性注入值的。而在<code>xml</code>文件中，使用<code>set</code>注入的方式就是通过<code>property</code>标签，如下所示：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义car这个bean，id为myCar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCar"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.Car"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        为car的属性注入值，因为speed和price都是基本数据类型，所以使用value为属性设置值；</span></span><br><span class="line"><span class="comment">        注意，这里的name为speed和price，不是因为属性名就是speed和price，</span></span><br><span class="line"><span class="comment">        而是set方法分别为setSpeed和setPrice，名称是通过将set删除，然后将第一个字母变小写得出；</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"speed"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"99999.9"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义user这个bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"aaa"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- car是引用类型，所以这里使用ref为其注入值，注入的就是上面定义的myCar </span></span><br><span class="line"><span class="comment">         基本数据类型或Java包装类型使用value，</span></span><br><span class="line"><span class="comment">         而引用类型使用ref，引用另外一个bean的id </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"myCar"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>    通过上面的配置，就可以为<code>Car</code>和<code>User</code>这两个类型的<code>bean</code>注入值了。需要注意的是，<strong>property的name属性，填写的不是属性的名称，而是set方法去除set，然后将第一个字符小写后的结果。对于基本数据类型，或者是Java的包装类型（比如String），使用value注入值，而对于引用类型，则使用ref，传入其他bean的id。</strong>接下来我们就可以测试效果了：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context =</span><br><span class="line">        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">// 获取user这个bean</span></span><br><span class="line">    User user = context.getBean(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 输出产看结果</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    由于<code>user</code>包含<code>car</code>的引用，所以我们直接输出<code>user</code>，也能够看到<code>car</code>的情况，输入结果如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User&#123;name&#x3D;&#39;aaa&#39;, age&#x3D;123, car&#x3D;Car&#123;speed&#x3D;100, price&#x3D;99999.9&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-构造器注入"><a href="#2-构造器注入" class="headerlink" title="2.构造器注入"></a>2.构造器注入</h4><p>    下面我们来说第二种方式——构造器注入。听名字就可以知道，这种注入值的方式，就是通过调用<code>bean</code>所属类的带参构造器为<code>bean</code>的属性注入值。这也就意味着，<strong>我们如果需要使用构造器注入，就得为类提供包含参数的构造方法</strong>。构造器注入，实际上有多种匹配属性值的方式，下面我们就来一一列举。我们这里依然使用<code>2.2</code>中定义的<code>Car</code>和<code>User</code>这两个类，测试方法以及类的定义都不需要变，需要改变的仅仅是<code>xml</code>配置文件。</p><p>  <strong>（一）匹配构造器的参数名称</strong></p><p>    我们需要通过<code>constructor-arg</code>标签为构造器传入参数值，但是每个<code>constructor-arg</code>标签对应哪一个参数值呢？这就有多种方式指定了。第一种就是直接匹配参数名，配置如下：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCar"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.Car"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过constructor-arg的name属性，指定构造器参数的名称，为参数赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"speed"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"99999.9"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"aaa"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">         和之前一样，基本数据类型或Java包装类型使用value，</span></span><br><span class="line"><span class="comment">         而引用类型使用ref，引用另外一个bean的id </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"myCar"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>    这样就完成了，测试代码和之前一样，运行结果也一样，我这里就不贴出来了。有人看完之后，可能会觉得这里的配置和<code>set</code>注入时的配置几乎一样，除了一个使用<code>property</code>，一个使用<code>constructor-arg</code>。确实，写法上一样，但是表示的含义却完全不同。<strong>property的name属性，是通过set方法的名称得来；而constructor-arg的name，则是构造器参数的名称</strong>。</p><p>  <strong>（二）匹配构造器的参数下标</strong></p><p>    上面是通过构造器参数的名称，匹配需要传入的值，那种方式最为直观，而<code>Spring</code>还提供另外两种方式匹配参数，这里就来说说通过参数在参数列表中的下标进行匹配的方式。下面的配置，请结合<code>2.2</code>节中<code>User</code>和<code>Car</code>的构造方法一起阅读，配置方式如下：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.Car"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 下标编号从0开始，构造器的第一个参数是speed，为它赋值100 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构造器的第二个参数是price，为它赋值99999.9 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"99999.9"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 与上面car的配置同理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"aaa"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span> <span class="attr">ref</span>=<span class="string">"car"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>    上面就是通过参数的下标为构造器的参数赋值，需要注意的是，<strong>参实的下标从0开始</strong>。使用上面的方式配置，若赋值的类型与参数的类型不一致，将会在容器初始化<code>bean</code>的时候抛出异常。如果<code>bean</code>存在多个参数数量一样的构造器，<code>Spring</code>容器会自动找到类型匹配的那个进行调用。比如说，<code>Car</code>有如下两个构造器，<code>Spring</code>容器将会调用第二个，因为上面的配置中，<code>index = 1</code>对应的<code>value</code>是<code>double</code>类型，与第二个构造器匹配，而第一个不匹配：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将使用匹配这个构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">int</span> speed, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    还存在另外一种特殊情况，那就是多个构造器都满足<code>bean</code>的配置，此时选择哪一个？假设当前<code>car</code>的配置是这样的：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.Car"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 两个下标的value值都是整数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"999"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>    假设<code>Car</code>还是有上面两个构造器，两个构造器都是一个<code>int</code>类型一个<code>double</code>类型的参数，只是位置不同。而配置中，指定的两个值都是<code>int</code>类型。但是，<code>int</code>类型也可以使用<code>double</code>类型存储，所以上面两个构造器都是匹配的，此时调用哪一个呢？结论就是调用第二个。自己去尝试就会发现，<strong>若存在多个构造器匹配bean的定义，Spring容器总是使用最后一个满足条件的构造器</strong>。</p><p>  <strong>（三）匹配构造器的参数类型</strong></p><p>    下面说最后一种匹配方式——匹配构造器的参数类型。直接看配置文件吧：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.Car"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用type属性匹配类型，car的构造器包含两个参数，一个是int类型，一个是double类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"double"</span> <span class="attr">value</span>=<span class="string">"99999.9"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对于引用类型，需要使用限定类名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"aaa"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"cn.tewuyiang.pojo.Car"</span> <span class="attr">ref</span>=<span class="string">"car"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>    上面应该不难理解，直接通过匹配构造器的参数类型，从而选择一个能够完全匹配的构造器，调用这个构造器完成<code>bean</code>的创建和属性注入。需要注意的是，上面的配置中，类型并不需要按构造器中声明的顺序编写，<code>Spring</code>也能进行匹配。这也就意味着可能出现多个能够匹配的构造器，和上一个例子中一样。比如说，<code>Car</code>还是有下面两个构造器：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出一句话，看是否调用这个构造器</span></span><br><span class="line">    System.out.println(<span class="number">111</span>);</span><br><span class="line">    <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将使用匹配这个构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">int</span> speed, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出一句话，看是否调用这个构造器</span></span><br><span class="line">    System.out.println(<span class="number">222</span>);</span><br><span class="line">    <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    上面两个构造器都是一个<code>int</code>，一个<code>double</code>类型的参数，都符合xml文件中，<code>car</code>这个<code>bean</code>的配置。通过测试发现，<strong>Spring容器使用的永远都是最后一个符合条件的构造器</strong>，这和上面通过下标匹配是一致的。<strong>需要说明的一点是，这三种使用构造器注入的方式，可以混用</strong>。</p><h4 id="3-静态工厂注入"><a href="#3-静态工厂注入" class="headerlink" title="3.静态工厂注入"></a>3.静态工厂注入</h4><p>    静态工厂注入就是我们编写一个静态的工厂方法，这个工厂方法会返回一个我们需要的值，然后在配置文件中，我们指定使用这个工厂方法创建<code>bean</code>。首先我们需要一个静态工厂，如下所示：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态工厂，返回一个Car的实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car(<span class="number">12345</span>, <span class="number">5.4321</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    下面我们需要在<code>xml</code>中配置car这个bean，并指定它由工厂方法进行创建。配置如下：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">注意，这里的配置并不是创建一个SimpleFactory对象，取名为myCar，</span></span><br><span class="line"><span class="comment">    这一句配置的意思是，调用SimpleFactory的getCar方法，创建一个car实例对象，</span></span><br><span class="line"><span class="comment">    将这个car对象取名为myCar。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.factory.SimpleFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getCar"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name和age使用set注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"aaa"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将上面配置的car，注入到user的car属性中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"car"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>    以上就配置成功了，测试方法以及执行效果如下，注意看<code>car</code>的属性值，就是我们在静态工厂中配置的那样，这说明，<code>Spring</code>容器确实是使用我们定义的静态工厂方法，创建了<code>car</code>这个<code>bean</code>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context =</span><br><span class="line">        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">// 获取静态工厂创建的car</span></span><br><span class="line">    Car car = (Car) context.getBean(<span class="string">"car"</span>);</span><br><span class="line">    <span class="comment">// 获取user</span></span><br><span class="line">    User user = context.getBean(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(car);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    输出如下所示：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car&#123;speed&#x3D;12345, price&#x3D;5.4321&#125;</span><br><span class="line">User&#123;name&#x3D;&#39;aaa&#39;, age&#x3D;123, car&#x3D;Car&#123;speed&#x3D;12345, price&#x3D;5.4321&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-实例工厂注入"><a href="#4-实例工厂注入" class="headerlink" title="4.实例工厂注入"></a>4.实例工厂注入</h4><p>    实例工厂与静态工厂类似，不同的是，静态工厂调用工厂方法不需要先创建工厂类的对象，因为静态方法可以直接通过类调用，所以在上面的配置文件中，并没有声明工厂类的<code>bean</code>。但是，实例工厂，需要有一个实例对象，才能调用它的工厂方法。我们先看看实例工厂的定义：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例工厂方法，返回一个Car的实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car(<span class="number">12345</span>, <span class="number">5.4321</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例工厂方法，返回一个String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"tewuyiang"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例工厂方法，返回一个int，在Spring容器中会被包装成Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">128</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    在上面的工厂类中，共定义了三个工厂方法，分别用来返回<code>user</code>所需的<code>car</code>，<code>name</code>以及<code>age</code>，而配置文件如下：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明实例工厂bean，Spring容器需要先创建一个SimpleFactory对象，才能调用工厂方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.factory.SimpleFactory"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    通过实例工厂的工厂方法，创建三个bean，通过factory-bean指定工厂对象，</span></span><br><span class="line"><span class="comment">    通过factory-method指定需要调用的工厂方法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"getName"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"age"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"getAge"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"getCar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将上面通过实例工厂方法创建的bean，注入到user中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">ref</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">ref</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"car"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>    我们尝试从<code>Spring</code>容器中取出<code>name</code>，<code>age</code>，<code>car</code>以及<code>user</code>，看看它们的值，测试代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context =</span><br><span class="line">        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">// 获取静态工厂创建的car，name和age这三个bean</span></span><br><span class="line">    Car car = (Car) context.getBean(<span class="string">"car"</span>);</span><br><span class="line">    String name = (String) context.getBean(<span class="string">"name"</span>);</span><br><span class="line">    Integer age = (Integer) context.getBean(<span class="string">"age"</span>);</span><br><span class="line">    <span class="comment">// 获取user这个bean</span></span><br><span class="line">    User user = context.getBean(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(car);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    以下就是输出结果，可以看到，我们通过工厂创建的<code>bean</code>，都在<code>Spring</code>容器中能够获取到：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car&#123;speed&#x3D;12345, price&#x3D;5.4321&#125;</span><br><span class="line">tewuyiang</span><br><span class="line">128</span><br><span class="line">User&#123;name&#x3D;&#39;tewuyiang&#39;, age&#x3D;128, car&#x3D;Car&#123;speed&#x3D;12345, price&#x3D;5.4321&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="17、当前bean有没有都行，应该采用什么方式注入"><a href="#17、当前bean有没有都行，应该采用什么方式注入" class="headerlink" title="17、当前bean有没有都行，应该采用什么方式注入"></a>17、当前bean有没有都行，应该采用什么方式注入</h3><h3 id="18、Redis的数据类型，常用的Redis命令"><a href="#18、Redis的数据类型，常用的Redis命令" class="headerlink" title="18、Redis的数据类型，常用的Redis命令"></a>18、Redis的数据类型，常用的Redis命令</h3><h4 id="Redis支持的五种数据类型"><a href="#Redis支持的五种数据类型" class="headerlink" title="Redis支持的五种数据类型"></a>Redis支持的五种数据类型</h4><ul><li>字符串 (string)</li><li>字符串列表 (list)</li><li>散列 (hash)</li><li>字符串集合 (set)</li><li>有序字符串集合 (sorted-set)</li></ul><h4 id="key（键）"><a href="#key（键）" class="headerlink" title="key（键）"></a>key（键）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">keys * 获取所有的key</span><br><span class="line">select 0 选择第一个库</span><br><span class="line">move myString 1 将当前的数据库key移动到某个数据库,目标库有，则不能移动</span><br><span class="line">flush db      清除指定库</span><br><span class="line">randomkey     随机key</span><br><span class="line">type key      类型</span><br><span class="line">set key1 value1 设置key</span><br><span class="line">get key1    获取key</span><br><span class="line">mset key1 value1 key2 value2 key3 value3</span><br><span class="line">mget key1 key2 key3</span><br><span class="line">del key1   删除key</span><br><span class="line">exists key      判断是否存在key</span><br><span class="line">expire key 10   10过期</span><br><span class="line">pexpire key 1000 毫秒</span><br><span class="line">persist key     删除过期时间</span><br></pre></td></tr></table></figure><h4 id="string-（字符串）"><a href="#string-（字符串）" class="headerlink" title="string （字符串）"></a>string （字符串）</h4><ul><li>String类型是以二进制进行操作，最多容量数据的长度是512M</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">set name cxx</span><br><span class="line">get name</span><br><span class="line">getrange name 0 -1        字符串分段</span><br><span class="line">getset name new_cxx       设置值，返回旧值</span><br><span class="line">mset key1 key2            批量设置</span><br><span class="line">mget key1 key2            批量获取</span><br><span class="line">setnx key value           不存在就插入（not exists）</span><br><span class="line">setex key time value      过期时间（expire）</span><br><span class="line">setrange key index value  从index开始替换value</span><br><span class="line">incr age        递增</span><br><span class="line">incrby age 10   递增</span><br><span class="line">decr age        递减</span><br><span class="line">decrby age 10   递减</span><br><span class="line">incrbyfloat     增减浮点数</span><br><span class="line">append          追加</span><br><span class="line">strlen          长度</span><br><span class="line">getbit&#x2F;setbit&#x2F;bitcount&#x2F;bitop    位操作</span><br></pre></td></tr></table></figure><h4 id="hash（散列）"><a href="#hash（散列）" class="headerlink" title="hash（散列）"></a>hash（散列）</h4><ul><li>每一个Hash可以储存(2^32-1)个：4294967295个键值对</li><li>String Key和String Value的map容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hset myhash name cxx</span><br><span class="line">hget myhash name</span><br><span class="line">hmset myhash name cxx age 25 note &quot;i am notes&quot;</span><br><span class="line">hmget myhash name age note   </span><br><span class="line">hgetall myhash               获取所有的</span><br><span class="line">hexists myhash name          是否存在</span><br><span class="line">hsetnx myhash score 100      设置不存在的</span><br><span class="line">hincrby myhash id 1          递增</span><br><span class="line">hdel myhash name             删除</span><br><span class="line">hkeys myhash                 只取key</span><br><span class="line">hvals myhash                 只取value</span><br><span class="line">hlen myhash                  长度</span><br></pre></td></tr></table></figure><h4 id="list（字符串列表）"><a href="#list（字符串列表）" class="headerlink" title="list（字符串列表）"></a>list（字符串列表）</h4><ul><li>经常用于消息队列的服务，多个程序之间的交互</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lpush mylist a b c  左插入</span><br><span class="line">rpush mylist x y z  右插入</span><br><span class="line">lrange mylist 0 -1  数据集合</span><br><span class="line">lpop mylist  弹出元素</span><br><span class="line">rpop mylist  弹出元素</span><br><span class="line">llen mylist  长度</span><br><span class="line">lrem mylist count value  删除</span><br><span class="line">lindex mylist 2          指定索引的值</span><br><span class="line">lset mylist 2 n          索引设值</span><br><span class="line">ltrim mylist 0 4         删除key</span><br><span class="line">linsert mylist before a  插入</span><br><span class="line">linsert mylist after a   插入</span><br><span class="line">rpoplpush list list2     转移列表的数据</span><br></pre></td></tr></table></figure><h4 id="set（字符串集合）"><a href="#set（字符串集合）" class="headerlink" title="set（字符串集合）"></a>set（字符串集合）</h4><ul><li><p>Set集合中不允许出现重复的元素</p></li><li><p>使用场景：</p><p>1、跟踪一些唯一性数据：访问某博客的IP信息（将访问者的IP存入redis中）</p><p>2、用于维护数据对象之间的关联关系（所有购买某一电子设备的用户的ID）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sadd myset redis </span><br><span class="line">smembers myset       数据集合</span><br><span class="line">srem myset set1         删除</span><br><span class="line">sismember myset set1 判断元素是否在集合中</span><br><span class="line">scard key_name       个数</span><br><span class="line">sdiff | sinter | sunion myset1 myset2 操作：集合间运算：差集 | 交集 | 并集</span><br><span class="line">srandmember          随机获取集合中的元素</span><br><span class="line">spop                 从集合中弹出一个元素</span><br></pre></td></tr></table></figure><h4 id="sorted-set（有序字符串集合）"><a href="#sorted-set（有序字符串集合）" class="headerlink" title="sorted-set（有序字符串集合）"></a>sorted-set（有序字符串集合）</h4><ul><li>与set类似，但每个成员都有一个关联的score属性，用于排序。成员不可以重复，score可以重复</li><li>sorted-set中的每一个成员都有一个分数与之关联，redis通过这个分数来为集合中的成员进行排序（成员必须唯一，但是分数可以重复）</li><li>Sorted-Set : 字符串集合，不允许元素重复。存储元素时需要关联存储一个对应的分数，分数用于排序。元素不可重复但分数可重复。成员在集合中的位置是有序的。</li><li>使用场景：游戏排名、微博热点话题、构建索引数据等等</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">zadd zset 1 one</span><br><span class="line">zadd zset 2 two</span><br><span class="line">zadd zset 3 three</span><br><span class="line">zincrby zset 1 one              增长分数</span><br><span class="line">zscore zset two                 获取分数</span><br><span class="line">zrange zset 0 -1 withscores     范围值</span><br><span class="line">zrangebyscore zset 10 25 withscores 指定范围的值</span><br><span class="line">zrangebyscore zset 10 25 withscores limit 1 2 分页</span><br><span class="line">Zrevrangebyscore zset 10 25 withscores  指定范围的值</span><br><span class="line">zcard zset  元素数量</span><br><span class="line">Zcount zset 获得指定分数范围内的元素个数</span><br><span class="line">Zrem zset one two        删除一个或多个元素</span><br><span class="line">Zremrangebyrank zset 0 1  按照排名范围删除元素</span><br><span class="line">Zremrangebyscore zset 0 1 按照分数范围删除元素</span><br><span class="line">Zrank zset 0 -1    分数最小的元素排名为0</span><br><span class="line">Zrevrank zset 0 -1  分数最大的元素排名为0</span><br><span class="line">Zinterstore</span><br><span class="line">zunionstore rank:last_week 7 rank:20150323 rank:20150324 rank:20150325  weights 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure><h3 id="19、MyBatis中-和-的区别"><a href="#19、MyBatis中-和-的区别" class="headerlink" title="19、MyBatis中 # 和 $ 的区别"></a>19、MyBatis中 # 和 $ 的区别</h3><p><strong>先给大家介绍下MyBatis中#{}和${}的区别，具体介绍如下：</strong></p><p>\1. #将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by “111”, 如果传入的值是id，则解析成的sql为order by “id”.</p><p>\2. $将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id, 如果传入的值是id，则解析成的sql为order by id.</p><p>\3. #方式能够很大程度防止sql注入。　</p><p>4.$方式无法防止Sql注入。</p><p>5.$方式一般用于传入数据库对象，例如传入表名.</p><p>6.一般能用#的就别用$.</p><p>MyBatis排序时使用order by 动态参数时需要注意，用$而不是#</p><p><strong>字符串替换</strong></p><p>默认情况下，使用#{}格式的语法会导致MyBatis创建预处理语句属性并以它为背景设置安全的值（比如?）。这样做很安全，很迅速也是首选做法，有时你只是想直接在SQL语句中插入一个不改变的字符串。比如，像ORDER BY，你可以这样来使用：<br>ORDER BY ${columnName}</p><p>这里MyBatis不会修改或转义字符串。</p><p>重要：接受从用户输出的内容并提供给语句中不变的字符串，这样做是不安全的。这会导致潜在的SQL注入攻击，因此你不应该允许用户输入这些字段，或者通常自行转义并检查。</p><p><strong>mybatis本身的说明：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;String Substitution&#96;&#96;By &#96;&#96;default&#96;&#96;, using the #&#123;&#125; syntax will cause MyBatis to generate PreparedStatement properties and set the values safely against the PreparedStatement parameters (e.g. ?). While &#96;&#96;this&#96; &#96;is safer, faster and almost always preferred, sometimes you just want to directly inject a string unmodified into the SQL Statement. For example, &#96;&#96;for&#96; &#96;ORDER BY, you might use something like &#96;&#96;this&#96;&#96;:&#96;&#96;ORDER BY $&#123;columnName&#125;&#96;&#96;Here MyBatis won&#39;t modify or escape the string.&#96;&#96;NOTE It&#39;s not safe to accept input from a user and supply it to a statement unmodified in &#96;&#96;this&#96; &#96;way. This leads to potential SQL Injection attacks and therefore you should either disallow user input in these fields, or always perform your own escapes and checks.&#96;</span><br></pre></td></tr></table></figure><p><strong>从上文可以看出：</strong></p><p>\1. 使用#{}格式的语法在mybatis中使用Preparement语句来安全的设置值，执行sql类似下面的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;PreparedStatement ps &#x3D; conn.prepareStatement(sql);&#96;&#96;ps.setInt(&#96;&#96;1&#96;&#96;,id);&#96;</span><br></pre></td></tr></table></figure><p>这样做的好处是：更安全，更迅速，通常也是首选做法。</p><p>\2. 不过有时你只是想直接在 SQL 语句中插入一个不改变的字符串。比如，像 ORDER BY，你可以这样来使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;ORDER BY $&#123;columnName&#125;&#96;</span><br></pre></td></tr></table></figure><p>此时MyBatis 不会修改或转义字符串。</p><p>这种方式类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;Statement st &#x3D; conn.createStatement();&#96;&#96;ResultSet rs &#x3D; st.executeQuery(sql);&#96;</span><br></pre></td></tr></table></figure><p><strong>这种方式的缺点是：</strong></p><p>以这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。</p><h3 id="20、Mysql联合索引的最左匹配原则"><a href="#20、Mysql联合索引的最左匹配原则" class="headerlink" title="20、Mysql联合索引的最左匹配原则"></a>20、Mysql联合索引的最左匹配原则</h3><blockquote><h2 id="创建联合索引时列的选择原则"><a href="#创建联合索引时列的选择原则" class="headerlink" title="创建联合索引时列的选择原则"></a>创建联合索引时列的选择原则</h2><ol><li>经常用的列优先（最左匹配原则）</li><li>离散度高的列优先（离散度高原则）</li><li>宽度小的列优先（最少空间原则） </li></ol><p>在Mysql建立多列索引（联合索引）有最左前缀的原则，即最左优先。<br>如果我们建立了一个2列的联合索引(col1,col2),实际上已经建立了两个联合索引(col1)、(col1,col2）;<br>如果有一个3列索引(col1,col2,col3)，实际上已经建立了三个联合索引(col1)、(col1,col2)、(col1,col2,col3)。</p></blockquote><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>1、b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。</p><p>2、比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）</p><h2 id="mysql里创建联合索引的意义"><a href="#mysql里创建联合索引的意义" class="headerlink" title="mysql里创建联合索引的意义"></a>mysql里创建联合索引的意义</h2><h3 id="一个顶三个"><a href="#一个顶三个" class="headerlink" title="一个顶三个"></a>一个顶三个</h3><p>建了一个(a,b,c)的复合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，这可是不小的开销！</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>同样的有复合索引（a,b,c），如果有如下的sql: select a,b,c from table where a=1 and b = 1。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一</p><h3 id="索引列越多，通过索引筛选出的数据越少"><a href="#索引列越多，通过索引筛选出的数据越少" class="headerlink" title="索引列越多，通过索引筛选出的数据越少"></a>索引列越多，通过索引筛选出的数据越少</h3><p>有1000W条数据的表，有如下sql:select * from table where a = 1 and b =2 and c = 3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W<em>10%=100w 条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是复合索引，通过索引筛选出1000w</em> 10% <em>10%</em> 10%=1w，然后再排序、分页，哪个更高效，一眼便知</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划笔记</title>
      <link href="/2020/07/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/07/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PriorityQueue优先级队列详解</title>
      <link href="/2020/07/02/PriorityQueue%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/07/02/PriorityQueue%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="源码分析（基于jdk1-8）"><a href="#源码分析（基于jdk1-8）" class="headerlink" title="源码分析（基于jdk1.8）"></a><strong>源码分析（基于jdk1.8）</strong></h2><p>源码分析一般的顺序都是先类属性、构造方法、普通方法。</p><h3 id="1、属性"><a href="#1、属性" class="headerlink" title="1、属性"></a><strong>1、属性</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//维护一个队列，因为基于二叉堆来实现优先队列，queue[i]的子节点为queue[2*i+1]或queue[2*i+2]</span></span><br><span class="line">   <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"><span class="comment">//优先级队列中的元素个数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//比较器：用于降序或者是比较自定义的对象，比如可以根据age</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"><span class="comment">//优先级队列的结构：被修改的次数</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a><strong>2、构造方法</strong></h3><h5 id="（1）默认构造方法：PriorityQueue"><a href="#（1）默认构造方法：PriorityQueue" class="headerlink" title="（1）默认构造方法：PriorityQueue()"></a>（1）默认构造方法：PriorityQueue()</h5><p>使用默认的初始容量（11）创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> PriorityQueue&#125; with the default initial</span></span><br><span class="line"><span class="comment">    * capacity (11) that orders its elements according to their</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@linkplain</span> Comparable natural ordering&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="（2）包含集合元素：PriorityQueue-Collection-c"><a href="#（2）包含集合元素：PriorityQueue-Collection-c" class="headerlink" title="（2）包含集合元素：PriorityQueue(Collection c)"></a>（2）包含集合元素：PriorityQueue(Collection c)</h5><p>创建包含指定 collection 中元素的 PriorityQueue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> PriorityQueue&#125; containing the elements in the</span></span><br><span class="line"><span class="comment">    * specified collection.  If the specified collection is an instance of</span></span><br><span class="line"><span class="comment">    * a &#123;<span class="doctag">@link</span> SortedSet&#125; or is another &#123;<span class="doctag">@code</span> PriorityQueue&#125;, this</span></span><br><span class="line"><span class="comment">    * priority queue will be ordered according to the same ordering.</span></span><br><span class="line"><span class="comment">    * Otherwise, this priority queue will be ordered according to the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@linkplain</span> Comparable natural ordering&#125; of its elements.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  c the collection whose elements are to be placed</span></span><br><span class="line"><span class="comment">    *         into this priority queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ClassCastException if elements of the specified collection</span></span><br><span class="line"><span class="comment">    *         cannot be compared to one another according to the priority</span></span><br><span class="line"><span class="comment">    *         queue's ordering</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment">    *         of its elements are null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">           SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">           <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">           initElementsFromCollection(ss);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">           PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class="line">           <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">           initFromPriorityQueue(pq);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">           initFromCollection(c);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="（3）指定初始容量：PriorityQueue-int-initialCapacity"><a href="#（3）指定初始容量：PriorityQueue-int-initialCapacity" class="headerlink" title="（3）指定初始容量：PriorityQueue(int initialCapacity)"></a>（3）指定初始容量：PriorityQueue(int initialCapacity)</h5><p>使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> PriorityQueue&#125; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity that orders its elements according to their</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@linkplain</span> Comparable natural ordering&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity the initial capacity for this priority queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> initialCapacity&#125; is less</span></span><br><span class="line"><span class="comment">    *         than 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="（4）指定初始容量和比较器：PriorityQueue-int-initialCapacity-Comparator-comparator"><a href="#（4）指定初始容量和比较器：PriorityQueue-int-initialCapacity-Comparator-comparator" class="headerlink" title="（4）指定初始容量和比较器：PriorityQueue(int initialCapacity, Comparator comparator)"></a>（4）指定初始容量和比较器：PriorityQueue(int initialCapacity, Comparator comparator)</h5><p>使用指定的初始容量创建一个 PriorityQueue，并根据指定的比较器对元素进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> PriorityQueue&#125; with the specified initial capacity</span></span><br><span class="line"><span class="comment">    * that orders its elements according to the specified comparator.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity for this priority queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  comparator the comparator that will be used to order this</span></span><br><span class="line"><span class="comment">    *         priority queue.  If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable</span></span><br><span class="line"><span class="comment">    *         natural ordering&#125; of the elements will be used.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> initialCapacity&#125; is</span></span><br><span class="line"><span class="comment">    *         less than 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">       <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="（5）包含优先级元素：PriorityQueue-PriorityQueue-c"><a href="#（5）包含优先级元素：PriorityQueue-PriorityQueue-c" class="headerlink" title="（5）包含优先级元素：PriorityQueue(PriorityQueue c)"></a>（5）包含优先级元素：PriorityQueue(PriorityQueue c)</h5><p>创建包含指定优先级队列元素的 PriorityQueue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> PriorityQueue&#125; containing the elements in the</span></span><br><span class="line"><span class="comment">    * specified priority queue.  This priority queue will be</span></span><br><span class="line"><span class="comment">    * ordered according to the same ordering as the given priority</span></span><br><span class="line"><span class="comment">    * queue.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  c the priority queue whose elements are to be placed</span></span><br><span class="line"><span class="comment">    *         into this priority queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ClassCastException if elements of &#123;<span class="doctag">@code</span> c&#125; cannot be</span></span><br><span class="line"><span class="comment">    *         compared to one another according to &#123;<span class="doctag">@code</span> c&#125;'s</span></span><br><span class="line"><span class="comment">    *         ordering</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if the specified priority queue or any</span></span><br><span class="line"><span class="comment">    *         of its elements are null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">       initFromPriorityQueue(c);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>（6）包含set元素：PriorityQueue(SortedSet c)</p><p>创建包含指定有序 set 元素的 PriorityQueue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> PriorityQueue&#125; containing the elements in the</span></span><br><span class="line"><span class="comment">    * specified sorted set.   This priority queue will be ordered</span></span><br><span class="line"><span class="comment">    * according to the same ordering as the given sorted set.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  c the sorted set whose elements are to be placed</span></span><br><span class="line"><span class="comment">    *         into this priority queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ClassCastException if elements of the specified sorted</span></span><br><span class="line"><span class="comment">    *         set cannot be compared to one another according to the</span></span><br><span class="line"><span class="comment">    *         sorted set's ordering</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if the specified sorted set or any</span></span><br><span class="line"><span class="comment">    *         of its elements are null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(SortedSet&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">       initElementsFromCollection(c);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3、普通方法"><a href="#3、普通方法" class="headerlink" title="3、普通方法"></a><strong>3、普通方法</strong></h3><p>PriorityQueue中常用的方法很多。</p><h5 id="（1）add：插入一个元素，不成功会抛出异常"><a href="#（1）add：插入一个元素，不成功会抛出异常" class="headerlink" title="（1）add：插入一个元素，不成功会抛出异常"></a><strong>（1）add：插入一个元素，不成功会抛出异常</strong></h5><p>public boolean add(E e) { return offer(e);}</p><p>我们看到add方法其实是通过调用offer方法实现的。我们直接看offer方法</p><h5 id="（2）offer：插入一个元素，不能被立即执行的情况下会返回一个特殊的值（true-或者-false）"><a href="#（2）offer：插入一个元素，不能被立即执行的情况下会返回一个特殊的值（true-或者-false）" class="headerlink" title="（2）offer：插入一个元素，不能被立即执行的情况下会返回一个特殊的值（true 或者 false）"></a><strong>（2）offer：插入一个元素，不能被立即执行的情况下会返回一个特殊的值（true 或者 false）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">int</span> i = size;</span><br><span class="line">       <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">           grow(i + <span class="number">1</span>);</span><br><span class="line">       size = i + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">           queue[<span class="number">0</span>] = e;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           siftUp(i, e);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>注意，优先级队列插入的元素不能为空，这一点在文章一开始提到过。</strong>步骤是这样的：</p><p>首先把modCount数量加1，如果容量不够把当前队列的尺寸加1，最后在i的位置上使用siftUp方法把e添加进来。此时真正插入的操作又落到了siftUp方法身上，我们接着看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">           siftUpUsingComparator(k, x);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           siftUpComparable(k, x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里先判断是否使用了自己的比较器。我们直接来看自己的比较器不为空，如何插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">          Object e = queue[parent];</span><br><span class="line">          <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          queue[k] = e;</span><br><span class="line">          k = parent;</span><br><span class="line">      &#125;</span><br><span class="line">      queue[k] = x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里就是真正的插入操作了。一个正常的数据插入过程。没什么特别的。</p><h5 id="（3）remove：删除一个元素，如果不成功会返回false。"><a href="#（3）remove：删除一个元素，如果不成功会返回false。" class="headerlink" title="（3）remove：删除一个元素，如果不成功会返回false。"></a><strong>（3）remove：删除一个元素，如果不成功会返回false。</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">       <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           removeAt(i);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里会发现真正实现删除操作的是removeAt方法。我们跟进去看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">int</span> s = --size;</span><br><span class="line">       <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">           queue[i] = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           E moved = (E) queue[s];</span><br><span class="line">           queue[s] = <span class="keyword">null</span>;</span><br><span class="line">           siftDown(i, moved);</span><br><span class="line">           <span class="keyword">if</span> (queue[i] == moved) &#123;</span><br><span class="line">               siftUp(i, moved);</span><br><span class="line">               <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                   <span class="keyword">return</span> moved;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个删除操作主要是两部分，if里面判断删除的是否是最后一个，否则的话就是用siftDown方法进行“向下沉”删除。不成功那就使用“向上浮”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">           siftDownUsingComparator(k, x);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           siftDownComparable(k, x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>删除的时候同样需要进行判断比较器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">           <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">           Object c = queue[child];</span><br><span class="line">           <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">               comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">               c = queue[child = right];</span><br><span class="line">           <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           queue[k] = c;</span><br><span class="line">           k = child;</span><br><span class="line">       &#125;</span><br><span class="line">       queue[k] = x;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>OK。删除操作就是这么多。基本思路是向上浮还是向下沉。</p><h5 id="（4）poll：删除一个元素，并返回删除的元素"><a href="#（4）poll：删除一个元素，并返回删除的元素" class="headerlink" title="（4）poll：删除一个元素，并返回删除的元素"></a><strong>（4）poll：删除一个元素，并返回删除的元素</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        modCount++;</span><br><span class="line">        E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">        E x = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            siftDown(<span class="number">0</span>, x);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>又回到了siftDown删除操作，就不赘述了。</p><h5 id="（5）peek：查询队顶元素"><a href="#（5）peek：查询队顶元素" class="headerlink" title="（5）peek：查询队顶元素"></a><strong>（5）peek：查询队顶元素</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="（6）indexOf-Object-o-：查询对象o的索引"><a href="#（6）indexOf-Object-o-：查询对象o的索引" class="headerlink" title="（6）indexOf(Object o)：查询对象o的索引"></a><strong>（6）indexOf(Object o)：查询对象o的索引</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(queue[i]))</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="（7）contain-Object-o-：判断是否容纳了元素"><a href="#（7）contain-Object-o-：判断是否容纳了元素" class="headerlink" title="（7）contain(Object o)：判断是否容纳了元素"></a><strong>（7）contain(Object o)：判断是否容纳了元素</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="优先级队列使用"><a href="#优先级队列使用" class="headerlink" title="优先级队列使用"></a><strong>优先级队列使用</strong></h2><p>上面已经介绍了原理和源码。而且给出了一个实际力扣案例。但是那属于算法，其实在真正工作领域也有不少的应用场景。</p><h5 id="1、股票交易"><a href="#1、股票交易" class="headerlink" title="1、股票交易"></a><strong>1、股票交易</strong></h5><p>我们的股票屏幕上总是给出最好或者是表现最差的那些股票。就可以基于优先级队列。方法其实是和找出前K个最大最小的元素方法类似。可以类比到股票中。</p><p>这只是给出了一个案例，你可以把股票交易的这样的使用场景类比到其他的场景中去。</p><h5 id="2、会员项目"><a href="#2、会员项目" class="headerlink" title="2、会员项目"></a><strong>2、会员项目</strong></h5><p>会员的优先级总是比普通会员高，因此我们就可以使用优先级队列保存会员的优先级。</p><p>这里只给出俩。其他的各位同僚自己体会吧，我自己曾经使用优先级队列来保存无人机的各种状态信息。所以也可以保存各种状态信息。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka服务注册与发现</title>
      <link href="/2020/06/07/Eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
      <url>/2020/06/07/Eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Eureka"><a href="#什么是Eureka" class="headerlink" title="什么是Eureka"></a>什么是Eureka</h2><ul><li>NextFlix在设计Eureka时，遵循的就是AP原则</li><li>Eureka是NextFlix的一个子模块，也是核心模块之一。Eureka是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册。</li></ul><h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><ul><li>Eureka的基本架构<ul><li>SpringCloud封装了NextFlix公司开发的Eureka模块来实现服务注册和发现（对比Zookeeper）</li><li>Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心</li><li>而系统中的其他微服务，使用Eureka的客户端连接到EurekaServer并维持心跳连接，这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，SpringCloud的一些其他模块(比如Zuul)就可以通过EurekaServer来发现系统中的其它微服务，并执行相关逻辑</li><li></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse快捷键</title>
      <link href="/2020/05/22/Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2020/05/22/Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Eclipse-常用快捷键"><a href="#Eclipse-常用快捷键" class="headerlink" title="Eclipse 常用快捷键"></a>Eclipse 常用快捷键</h2><p>Eclipse的编辑功能非常强大，掌握了Eclipse快捷键功能，能够大大提高开发效率。Eclipse中有如下一些和编辑相关的快捷键。<br>\1. 【ALT+/】<br>此快捷键为用户编辑的好帮手，能为用户提供内容的辅助，不要为记不全方法和属性名称犯愁，当记不全类、方法和属性的名字时，多体验一下【ALT+/】快捷键带来的好处吧。<br>\2. 【Ctrl+O】<br>显示类中方法和属性的大纲，能快速定位类的方法和属性，在查找Bug时非常有用。<br>\3. 【Ctrl+/】<br>快速添加注释，能为光标所在行或所选定行快速添加注释或取消注释，在调试的时候可能总会需要注释一些东西或取消注释，现在好了，不需要每行进行重复的注释。<br>\4. 【Ctrl+D】<br>删除当前行，这也是笔者的最爱之一，不用为删除一行而按那么多次的删除键。<br>\5. 【Ctrl+M】<br>窗口最大化和还原，用户在窗口中进行操作时，总会觉得当前窗口小（尤其在编写代码时），现在好了，试试【Ctrl+M】快捷键。<br>查看和定位快捷键<br>在程序中，迅速定位代码的位置，快速找到Bug的所在，是非常不容易的事，Eclipse提供了强大的查找功能，可以利用如下的快捷键帮助完成查找定位的工作。<br>\1. 【Ctrl+K】、【Ctrl++Shift+K】<br>快速向下和向上查找选定的内容，从此不再需要用鼠标单击查找对话框了。<br>\2. 【Ctrl+Shift+T】<br>查找工作空间（Workspace）构建路径中的可找到Java类文件，不要为找不到类而痛苦，而且可以使用“*”、“？”等通配符。<br>\3. 【Ctrl+Shift+R】<br>和【Ctrl+Shift+T】对应，查找工作空间（Workspace）中的所有文件（包括Java文件），也可以使用通配符。<br>\4. 【Ctrl+Shift+G】<br>查找类、方法和属性的引用。这是一个非常实用的快捷键，例如要修改引用某个方法的代码，可以通过【Ctrl+Shift+G】快捷键迅速定位所有引用此方法的位置。<br>\5. 【Ctrl+Shift+O】<br>快速生成import，当从网上拷贝一段程序后，不知道如何import进所调用的类，试试【Ctrl+Shift+O】快捷键，一定会有惊喜。<br>\6. 【Ctrl+Shift+F】<br>格式化代码，书写格式规范的代码是每一个程序员的必修之课，当看见某段代码极不顺眼时，选定后按【Ctrl+Shift+F】快捷键可以格式化这段代码，如果不选定代码则默认格式化当前文件（Java文件）。<br>\7. 【ALT+Shift+W】<br>查找当前文件所在项目中的路径，可以快速定位浏览器视图的位置，如果想查找某个文件所在的包时，此快捷键非常有用（特别在比较大的项目中）。<br>\8. 【Ctrl+L】<br>定位到当前编辑器的某一行，对非Java文件也有效。<br>\9. 【Alt+←】、【Alt+→】<br>后退历史记录和前进历史记录，在跟踪代码时非常有用，用户可能查找了几个有关联的地方，但可能记不清楚了，可以通过这两个快捷键定位查找的顺序。<br>\10. 【F3】<br>快速定位光标位置的某个类、方法和属性。<br>\11. 【F4】<br>显示类的继承关系，并打开类继承视图。</p><h2 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h2><p>Eclipse中有如下一些和运行调试相关的快捷键。<br>\1. 【Ctrl+Shift+B】：在当前行设置断点或取消设置的断点。<br>\2. 【F11】：调试最后一次执行的程序。<br>\3. 【Ctrl+F11】：运行最后一次执行的程序。<br>\4. 【F5】：跟踪到方法中，当程序执行到某方法时，可以按【F5】键跟踪到方法中。<br>\5. 【F6】：单步执行程序。<br>\6. 【F7】：执行完方法，返回到调用此方法的后一条语句。<br>\7. 【F8】：继续执行，到下一个断点或程序结束。</p><h2 id="常用编辑器快捷键"><a href="#常用编辑器快捷键" class="headerlink" title="常用编辑器快捷键"></a>常用编辑器快捷键</h2><p>通常文本编辑器都提供了一些和编辑相关的快捷键，在Eclipse中也可以通过这些快捷键进行文本编辑。<br>\1. 【Ctrl+C】：复制。<br>\2. 【Ctrl+X】：剪切。<br>\3. 【Ctrl+V】：粘贴。<br>\4. 【Ctrl+S】：保存文件。<br>\5. 【Ctrl+Z】：撤销。<br>\6. 【Ctrl+Y】：重复。<br>\7. 【Ctrl+F】：查找。</p><h2 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h2><p>Eclipse中还有很多快捷键，无法一一列举，用户可以通过帮助文档找到它们的使用方式，另外还有几个常用的快捷键如下。<br>\1. 【Ctrl+F6】：切换到下一个编辑器。<br>\2. 【Ctrl+Shift+F6】：切换到上一个编辑器。<br>\3. 【Ctrl+F7】：切换到下一个视图。<br>\4. 【Ctrl+Shift+F7】：切换到上一个视图。<br>\5. 【Ctrl+F8】：切换到下一个透视图。<br>\6. 【Ctrl+Shift+F8】：切换到上一个透视图。</p><p>Eclipse中快捷键比较多，可以通过帮助文档找到所有快捷键的使用，但要掌握所有快捷键的使用是不可能的，也没有必要，如果花点时间熟悉本节列举的快捷键，必将会事半功倍</p><ol><li>edit-&gt;content Assist - &gt; add Alt+/ 代码关联</li><li>Window -&gt; Next Editor -&gt; add Ctrl+Tab 切换窗口</li><li>Run/Debug Toggle Line Breakpoint -&gt; add Ctrl+` 在调试的时候 增删断点</li><li>Source-&gt; Surround with try/catch Block -&gt; Ctrl+Shift+v 增加try catch 框框</li><li>Source -&gt; Generate Getters and Setters -&gt; Ctrl+Shift+. 增加get set 方法</li></ol><p>———–有用的快捷键———–<br>Alt+/ 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替)<br>Ctrl+1:光标停在某变量上，按Ctrl+1键，可以提供快速重构方案。选中若干行，按Ctrl+1键可将此段代码放入for、while、if、do或try等代码块中。<br>双击左括号（小括号、中括号、大括号），将选择括号内的所有内容。<br>Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性<br>———–Ctrl系列———–<br>Ctrl+K:将光标停留在变量上，按Ctrl+K键可以查找到下一个同样的变量<br>Ctrl+Shift+K:和Ctrl+K查找的方向相反<br>Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示)<br>Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作)<br>Ctrl+Q 定位到最后编辑的地方<br>Ctrl+L 定位在某行 (对于程序超过100的人就有福音了)<br>Ctrl+M 最大化当前的Edit或View (再按则反之)<br>Ctrl+/ 注释当前行,再按则取消注释<br>Ctrl+T 快速显示当前类的继承结构<br>Ctrl+Shift-T: 打开类型（Open type）。如果你不是有意磨洋工，还是忘记通过源码树（source tree）打开的方式吧。<br>Ctrl+O:在代码中打开类似大纲视图的小窗口<br>Ctrl+鼠标停留:可以显示类和方法的源码<br>Ctrl+H:打开搜索窗口<br>Ctrl+/(小键盘) 折叠当前类中的所有代码<br>Ctrl+×(小键盘) 展开当前类中的所有代码<br>———–Ctrl+Shift 系列———–<br>Ctrl+Shift+F 格式化当前代码<br>Ctrl+Shift+X 把当前选中的文本全部变味小写<br>Ctrl+Shift+Y 把当前选中的文本全部变为小写<br>Ctrl+Shift+O:快速地导入import<br>Ctrl+Shift+R:打开资源 open Resource<br>———–F快捷键 系列———–<br>F3:打开声明该引用的文件<br>F4:打开类型层次结构<br>F5:单步跳入<br>F6:单步跳过<br>F7:单步跳出<br>F8:继续，如果后面没有断点，程序将运行完<br>———–行编辑用———–<br>Ctrl+D: 删除当前行<br>Ctrl+Alt+↓ 复制当前行到下一行(复制增加)<br>Ctrl+Alt+↑ 复制当前行到上一行(复制增加)<br>Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了)<br>Alt+↑ 当前行和上面一行交互位置(同上)<br>Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后)<br>Ctrl+Shift+Enter 在当前行插入空行(原理同上条)<br>———–不常用的———–<br>Alt+← 前一个编辑的页面<br>Alt+→ 下一个编辑的页面(当然是针对上面那条来说了)<br>Ctrl+Shift+S:保存全部<br>Ctrl+W 关闭当前Editer<br>Ctrl+Shift+F4 关闭所有打开的Editer<br>Ctrl+Shift+G: 在workspace中搜索引用<br>Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)<br>———–不明白———–<br>Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了)<br>Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查)</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用代码</title>
      <link href="/2020/05/22/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/"/>
      <url>/2020/05/22/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="JDBC操作"><a href="#JDBC操作" class="headerlink" title="JDBC操作"></a>JDBC操作</h3><h4 id="1-执行sql语句获得-并获得数据（返回类型DataTable）"><a href="#1-执行sql语句获得-并获得数据（返回类型DataTable）" class="headerlink" title="1.执行sql语句获得 并获得数据（返回类型DataTable）"></a>1.执行sql语句获得 并获得数据（返回类型DataTable）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataTable dt = <span class="keyword">this</span>.genericDao.getDataIntoDataTable(sql,<span class="keyword">new</span> Object[] &#123;&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 公司 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Netflix学习</title>
      <link href="/2020/05/17/SpringCloud-Netflix%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/05/17/SpringCloud-Netflix%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringCloud简介："><a href="#SpringCloud简介：" class="headerlink" title="SpringCloud简介："></a>SpringCloud简介：</h2><p>Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性简化了分布式系统的开发，比如服务发现、服务网关、服务路由、链路追踪等。Spring Cloud 并不重复造轮子，而是将市面上开发得比较好的模块集成进去，进行封装，从而减少了各模块的开发成本。换句话说：Spring Cloud 提供了构建分布式系统所需的“全家桶”。</p><h2 id="Spring-Cloud-优缺点"><a href="#Spring-Cloud-优缺点" class="headerlink" title="Spring Cloud 优缺点"></a>Spring Cloud 优缺点</h2><h3 id="其主要优点有："><a href="#其主要优点有：" class="headerlink" title="其主要优点有："></a>其主要优点有：</h3><p>集大成者，Spring Cloud 包含了微服务架构的方方面面。<br>约定优于配置，基于注解，没有配置文件。<br>轻量级组件，Spring Cloud 整合的组件大多比较轻量级，且都是各自领域的佼佼者。<br>开发简便，Spring Cloud 对各个组件进行了大量的封装，从而简化了开发。<br>开发灵活，Spring Cloud 的组件都是解耦的，开发人员可以灵活按需选择组件。</p><h3 id="接下来，我们看下它的缺点："><a href="#接下来，我们看下它的缺点：" class="headerlink" title="接下来，我们看下它的缺点："></a>接下来，我们看下它的缺点：</h3><p>项目结构复杂，每一个组件或者每一个服务都需要创建一个项目。<br>部署门槛高，项目部署需要配合 Docker 等容器技术进行集群部署，而要想深入了解 Docker，学习成本高。<br>Spring Cloud 的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习 Spring Cloud 是一个不错的选择。</p><h2 id="微服务的四个核心问题："><a href="#微服务的四个核心问题：" class="headerlink" title="微服务的四个核心问题："></a>微服务的四个核心问题：</h2><p>1.服务很多，客户端之间该怎么进行访问？</p><p>2.这么多服务，服务之间如何通信？</p><p>3.这么多服务，如何治理？</p><p>4.服务挂了怎么办？</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>Spring Cloud  是一个生态，解决上面四个问题。</p><ol><li><p>SpringCloud NetFlix  一站式解决方案</p><p>api网关，zuul组件</p><p>Frign —HttpClient——Http通信方式，同步，阻塞</p><p>服务注册发现：Eureka</p><p>熔断机制：Hystrix</p></li></ol><ol start="2"><li><p>Apache Dubbo Zookeeper  半自动，需要整合别人的</p><p>API：没有，找第三方组件 ，或者自己实现</p><p>Dubbo ：RPC通信组件</p><p>Zookeeper </p><p>没有熔断机制，借助Hystrix</p><p>所以说，Dubbo这个方案并不完善。只专注于RPC</p></li><li><p>SpringCloud Alibaba 最新的一站式解决方案</p><p>更简单，和第一个类似，界面不一样了，简化了</p></li></ol><p>新概念：服务网格 Server Mesh </p><p>  istio</p><p>万变不离其宗</p><p>1.API  解决路由问题</p><p>2.Http RPC 解决通信问题</p><p>3.注册和发现  解决高可用问题</p><p>4.熔断机制 解决服务降级的问题  防止服务雪崩</p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><p>1.什么是微服务？</p><p>2.微服务之间是如何独立通讯的？</p><p>3.SpringCloud 和 Dubbo之间有哪些区别？</p><p>4.SpringBoot和SpringCloud，请你谈谈对他们的理解</p><p>5.什么是服务熔断？什么是服务降级</p><p>6.微服务的优缺点分别是什么？说下你在项目开发中遇到的问题</p><p>7.你所知道的微服务技术栈有哪些？</p><p>8.eureka 和 zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</p><h2 id="微服务优缺点"><a href="#微服务优缺点" class="headerlink" title="微服务优缺点"></a>微服务优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>单一职责原则 苹果手机</li><li>每个服务足够内聚，足够小，代码容易理解没这样能聚焦一个指定的业务功能或业务需求</li><li>开发简单，开发效率提高 一个服务可能就是专一的只干一件事；</li><li>微服务能够被小团队单独开发，这个小团队是2-5人的开发人员组成</li><li>微服务是松耦合的，是具有功能意义的服务，无论是在开发或者部署阶段都是独立的</li><li>微服务能使用不同的语言开发</li><li>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins,Hudson,bamboo</li><li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作结果，无需通过合作才能体现价值</li><li>微服务允许你利用融合最新技术</li><li><strong>微服务知识业务逻辑的代码 不会和html css 或 其它界面混合</strong></li><li><strong>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一数据库</strong></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>开发人员要处理分布式系统的复杂性</li><li>多服务运维难度，随着服务的增加，运维的压力也增大</li><li>系统部署依赖</li><li>服务间通信成本</li><li>数据一致性</li><li>系统集成测试</li><li>性能监控 </li></ul><h2 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h2><table><thead><tr><th>微服务条目</th><th>落地技术</th></tr></thead><tbody><tr><td>服务开发</td><td>SpringBoot，Spring，SpringMVC</td></tr><tr><td>服务配置与管理</td><td>NetFlix公司的Archaius、阿里的Diamond等</td></tr><tr><td>服务注册与实现</td><td>Eureka、Consul、Zookeeper</td></tr><tr><td>服务调用</td><td>Rest、RPC、gRPC</td></tr><tr><td>服务熔断器</td><td>Hystrix、Envoy</td></tr><tr><td>负载均衡</td><td>Ribbon、Nginx等</td></tr><tr><td>服务接口调用(客户端调用服务的简化工具)</td><td>Feign</td></tr><tr><td>消息队列</td><td>Kafka、RabbitMQ、ActiveMQ等</td></tr><tr><td>服务配置中心管理</td><td>SpringCloudConfig、Chef等</td></tr><tr><td>服务路由(API网关)</td><td>Zuul等</td></tr><tr><td>服务监控</td><td>Zabbix、Nagios、Metrics、Specatator</td></tr><tr><td>全链路追踪</td><td>Zipkin、Brave、Dapper</td></tr><tr><td>服务部署</td><td>Docker、OpenStack、Kubernetes</td></tr><tr><td>数据流操作开发包</td><td>SpringCloud Stream(封装Redis Rabbit Kafka等发送接收消息)</td></tr><tr><td>事件消息总线</td><td>SpringCloud Bus</td></tr></tbody></table><h2 id="SpringBoot-和-SpringCloud-的关系"><a href="#SpringBoot-和-SpringCloud-的关系" class="headerlink" title="SpringBoot 和 SpringCloud 的关系"></a>SpringBoot 和 SpringCloud 的关系</h2><ul><li>SpringBoot 专注于快速方便地开发单个个体微服务</li><li>SpringCloud是专注全局的微服务协调整理治理框架，它将SpringBoot 开发的一个个单体微服务整合并管理起来，为各个微服务之间提供：配置管理，服务发现，断路器，路由，微代理，事件总线，全局锁，决策竞选，分布式回话等等集成服务</li><li>SpringBoot可以离开SpringCloud独立使用，开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系</li><li>SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的微服务治理框架</li></ul><h2 id="传统网站架构图"><a href="#传统网站架构图" class="headerlink" title="传统网站架构图"></a>传统网站架构图</h2><p><img data-src="1.png" alt="1.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger笔记</title>
      <link href="/2020/05/16/Swagger%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/16/Swagger%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>学习目标：</strong></p><ul><li>了解Swagger的概念及作用</li><li>掌握在项目中集成Swagger自动生成API文档</li></ul><h2 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h2><p><strong>前后端分离</strong></p><ul><li>前端 -&gt; 前端控制层、视图层</li><li>后端 -&gt; 后端控制层、服务层、数据访问层</li><li>前后端通过API进行交互</li><li>前后端相对独立且松耦合</li></ul><p><strong>产生的问题</strong></p><ul><li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li></ul><p><strong>解决方案</strong></p><ul><li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li></ul><p><strong>Swagger</strong></p><ul><li>号称世界上最流行的API框架</li><li>Restful Api 文档在线自动生成器 =&gt; <strong>API 文档 与API 定义同步更新</strong></li><li>直接运行，在线测试API</li><li>支持多种语言 （如：Java，PHP等）</li><li>官网：<a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></li></ul><h2 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h2><p><strong>SpringBoot集成Swagger</strong> =&gt; <strong>springfox</strong>，两个jar包</p><ul><li><strong>Springfox-swagger2</strong></li><li>swagger-springmvc</li></ul><p><strong>使用Swagger</strong></p><p>要求：jdk 1.8 + 否则swagger2无法运行</p><p>步骤：</p><p>1、新建一个SpringBoot-web项目</p><p>2、添加Maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、编写HelloController，测试确保运行成功！</p><p>4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2<span class="comment">// 开启Swagger2的自动配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、访问测试 ：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p><h2 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h2><p>1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//配置docket以配置Swagger具体参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、可以通过apiInfo()属性配置文档信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置文档信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Contact contact = <span class="keyword">new</span> Contact(<span class="string">"联系人名字"</span>, <span class="string">"http://xxx.xxx.com/联系人访问链接"</span>, <span class="string">"联系人邮箱"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">           <span class="string">"Swagger学习"</span>, <span class="comment">// 标题</span></span><br><span class="line">           <span class="string">"学习演示如何配置Swagger"</span>, <span class="comment">// 描述</span></span><br><span class="line">           <span class="string">"v1.0"</span>, <span class="comment">// 版本</span></span><br><span class="line">           <span class="string">"http://terms.service.url/组织链接"</span>, <span class="comment">// 组织链接</span></span><br><span class="line">           contact, <span class="comment">// 联系人信息</span></span><br><span class="line">           <span class="string">"Apach 2.0 许可"</span>, <span class="comment">// 许可</span></span><br><span class="line">           <span class="string">"许可链接"</span>, <span class="comment">// 许可连接</span></span><br><span class="line">           <span class="keyword">new</span> ArrayList&lt;&gt;()<span class="comment">// 扩展</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Docket 实例关联上 apiInfo()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、重启项目，访问测试 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a>  看下效果；</p><h2 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h2><p>1、构建Docket时通过select()方法配置怎么扫描接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.kuang.swagger.controller"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p><p>3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">any() <span class="comment">// 扫描所有，项目中的所有接口都会被扫描到</span></span><br><span class="line">none() <span class="comment">// 不扫描接口</span></span><br><span class="line"><span class="comment">// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span></span><br><span class="line">withMethodAnnotation(<span class="keyword">final</span> Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line"><span class="comment">// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span></span><br><span class="line">withClassAnnotation(<span class="keyword">final</span> Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line">basePackage(<span class="keyword">final</span> String basePackage) <span class="comment">// 根据包路径扫描接口</span></span><br></pre></td></tr></table></figure><p>4、除此之外，我们还可以配置接口扫描过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.kuang.swagger.controller"</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">"/kuang/**"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、这里的可选值还有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">any() <span class="comment">// 任何请求都扫描</span></span><br><span class="line">none() <span class="comment">// 任何请求都不扫描</span></span><br><span class="line">regex(<span class="keyword">final</span> String pathRegex) <span class="comment">// 通过正则表达式控制</span></span><br><span class="line">ant(<span class="keyword">final</span> String antPattern) <span class="comment">// 通过ant()控制</span></span><br></pre></td></tr></table></figure><h2 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h2><p>1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(<span class="keyword">false</span>) <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.kuang.swagger.controller"</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">"/kuang/**"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 设置要显示swagger的环境</span></span><br><span class="line">   Profiles of = Profiles.of(<span class="string">"dev"</span>, <span class="string">"test"</span>);</span><br><span class="line">   <span class="comment">// 判断当前是否处于该环境</span></span><br><span class="line">   <span class="comment">// 通过 enable() 接收此参数判断是否要显示</span></span><br><span class="line">   <span class="keyword">boolean</span> b = environment.acceptsProfiles(of);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(b) <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.kuang.swagger.controller"</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">"/kuang/**"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、可以在项目中增加一个dev的配置文件查看效果！</p><h2 id="配置API分组"><a href="#配置API分组" class="headerlink" title="配置API分组"></a>配置API分组</h2><p>1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">      .groupName(<span class="string">"hello"</span>) <span class="comment">// 配置分组</span></span><br><span class="line">       <span class="comment">// 省略配置....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、重启项目查看分组</p><p>3、如何配置多个分组？配置多个分组只需要配置多个docket即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">"group1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">"group2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket3</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">"group3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、重启项目查看即可</p><h2 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h2><p>1、新建一个实体类.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span>(<span class="string">"用户实体"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="meta">@ApiModelProperty</span>(<span class="string">"用户名"</span>)</span><br><span class="line">   <span class="keyword">public</span> String username;</span><br><span class="line">   <span class="meta">@ApiModelProperty</span>(<span class="string">"密码"</span>)</span><br><span class="line">   <span class="keyword">public</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、重启查看测试</p><p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p><p>@ApiModel为类添加注释</p><p>@ApiModelProperty为类属性添加注释</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>Swagger的所有注解定义在io.swagger.annotations包下</p><p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p><table><thead><tr><th>Swagger注解</th><th>简单说明</th></tr></thead><tbody><tr><td>@Api(tags = “xxx模块说明”)</td><td>作用在模块类上</td></tr><tr><td>@ApiOperation(“xxx接口说明”)</td><td>作用在接口方法上</td></tr><tr><td>@ApiModel(“xxxPOJO说明”)</td><td>作用在模型类上：如VO、BO</td></tr><tr><td>@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td><td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td></tr><tr><td>@ApiParam(“xxx参数说明”)</td><td>作用在参数、方法和字段上，类似@ApiModelProperty</td></tr></tbody></table><p>我们也可以给请求的接口配置一些注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(<span class="string">"狂神的接口"</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/kuang"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">kuang</span><span class="params">(@ApiParam(<span class="string">"这个名字会被返回"</span>)</span>String username)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p><p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p><p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api</span>：用在请求的类上，表示对类的说明</span><br><span class="line">    tags=<span class="string">"说明该类的作用，可以在UI界面上看到的注解"</span></span><br><span class="line">    value=<span class="string">"该参数没什么意义，在UI界面上也看到，所以不需要配置"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@ApiOperation</span>：用在请求的方法上，说明方法的用途、作用</span><br><span class="line">    value=<span class="string">"说明方法的用途、作用"</span></span><br><span class="line">    notes=<span class="string">"方法的备注说明"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@ApiImplicitParams</span>：用在请求的方法上，表示一组参数说明</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>：用在<span class="meta">@ApiImplicitParams</span>注解中，指定一个请求参数的各个方面</span><br><span class="line">        name：参数名</span><br><span class="line">        value：参数的汉字说明、解释</span><br><span class="line">        required：参数是否必须传</span><br><span class="line">        paramType：参数放在哪个地方</span><br><span class="line">            · header --&gt; 请求参数的获取：<span class="meta">@RequestHeader</span></span><br><span class="line">            · query --&gt; 请求参数的获取：<span class="meta">@RequestParam</span></span><br><span class="line">            · path（用于restful接口）--&gt; 请求参数的获取：<span class="meta">@PathVariable</span></span><br><span class="line">            · body（不常用）</span><br><span class="line">            · form（不常用）    </span><br><span class="line">        dataType：参数类型，默认String，其它值dataType=<span class="string">"Integer"</span>       </span><br><span class="line">        defaultValue：参数的默认值</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@ApiResponses</span>：用在请求的方法上，表示一组响应</span><br><span class="line">    <span class="meta">@ApiResponse</span>：用在<span class="meta">@ApiResponses</span>中，一般用于表达一个错误的响应信息</span><br><span class="line">        code：数字，例如<span class="number">400</span></span><br><span class="line">        message：信息，例如<span class="string">"请求参数没填好"</span></span><br><span class="line">        response：抛出异常的类</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@ApiModel</span>：用于响应类上，表示一个返回响应数据的信息</span><br><span class="line">            （这种一般用在post创建的时候，使用<span class="meta">@RequestBody</span>这样的场景，</span><br><span class="line">            请求参数无法使用<span class="meta">@ApiImplicitParam</span>注解进行描述的时候）</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>：用在属性上，描述响应类的属性</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记</title>
      <link href="/2020/05/15/Redis%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/15/Redis%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装和使用"><a href="#1-安装和使用" class="headerlink" title="1.安装和使用"></a>1.安装和使用</h1><h2 id="1-1-安装Redis"><a href="#1-1-安装Redis" class="headerlink" title="1.1 安装Redis"></a>1.1 安装Redis</h2><p><strong>下载地址：</strong><a href="https://github.com/MSOpenTech/redis/releases。" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases。</a></p><p>从redis.io下载最新版redis-X.Y.Z.tar.gz后解压，然后进入redis-X.Y.Z文件夹后直接make即可，安装非常简单。</p><p>make成功后会在src文件夹下产生一些二进制可执行文件，包括redis-server、redis-cli等等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -executable</span></span><br><span class="line">./redis-benchmark //用于进行redis性能测试的工具</span><br><span class="line">./redis-check-dump //用于修复出问题的dump.rdb文件</span><br><span class="line">./redis-cli //redis的客户端</span><br><span class="line">./redis-server //redis的服务端</span><br><span class="line">./redis-check-aof //用于修复出问题的AOF文件</span><br><span class="line">./redis-sentinel //用于集群管理</span><br></pre></td></tr></table></figure><h2 id="1-2-启动Redis"><a href="#1-2-启动Redis" class="headerlink" title="1.2 启动Redis"></a>1.2 启动Redis</h2><p>启动redis非常简单，直接./redis-server就可以启动服务端了，还可以用下面的方法指定要加载的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../redis.conf</span><br></pre></td></tr></table></figure><p>默认情况下，redis-server会以非daemon的方式来运行，且<strong>默认服务端口为6379</strong>。</p><h2 id="1-3-使用Redis客户端"><a href="#1-3-使用Redis客户端" class="headerlink" title="1.3 使用Redis客户端"></a>1.3 使用Redis客户端</h2><p>例子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这样来启动redis客户端了</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./redis-cli</span></span><br><span class="line">//用set指令来设置key、value</span><br><span class="line">127.0.0.1:6379&gt; set name "roc" </span><br><span class="line">OK</span><br><span class="line">//来获取name的值</span><br><span class="line">127.0.0.1:6379&gt; get name </span><br><span class="line">"roc"</span><br><span class="line">//通过客户端来关闭redis服务端</span><br><span class="line">127.0.0.1:6379&gt; shutdown </span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h1 id="2-Redis数据结构"><a href="#2-Redis数据结构" class="headerlink" title="2.Redis数据结构"></a>2.Redis数据结构</h1><p>redis是一种高级的key:value存储系统，其中value支持五种数据类型：</p><p>1.字符串（strings）<br>2.字符串列表（lists）<br>3.字符串集合（sets）<br>4.有序字符串集合（sorted sets）<br>5.哈希（hashes）</p><p><strong>而关于key，有几个点要提醒大家：</strong></p><p>1.key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；<br>2.key也不要太短，太短的话，key的可读性会降低；<br>3.在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd。</p><h2 id="2-1-Redis数据结构-–-strings"><a href="#2-1-Redis数据结构-–-strings" class="headerlink" title="2.1 Redis数据结构 – strings"></a>2.1 Redis数据结构 – strings</h2><p>有人说，如果只使用redis中的字符串类型，且不使用redis的持久化功能，那么，redis就和memcache非常非常的像了。这说明strings类型是一个很基础的数据类型，也是任何存储系统都必备的数据类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set mystr "hello world!" //设置字符串类型</span><br><span class="line">get mystr //读取字符串类型</span><br></pre></td></tr></table></figure><p>字符串类型的用法就是这么简单，因为是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储。</p><p>另外，我们还可以通过字符串类型进行数值操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set mynum "2"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get mynum</span><br><span class="line">"2"</span><br><span class="line">127.0.0.1:6379&gt; incr mynum</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get mynum</span><br><span class="line">"3"</span><br></pre></td></tr></table></figure><p>在遇到数值操作时，redis会将字符串类型转换成数值。</p><p>由于INCR等指令本身就具有原子操作的特性，所以我们完全可以利用redis的<strong>INCR</strong>、<strong>INCRBY</strong>、<strong>DECR</strong>、<strong>DECRBY</strong>等指令来实现原子计数的效果，假如，在某种场景下有3个客户端同时读取了mynum的值（值为2），然后对其同时进行了加1的操作，那么，最后mynum的值一定是5。不少网站都利用redis的这个特性来实现业务上的统计计数需求。</p><h2 id="2-2-Redis数据结构-–-lists"><a href="#2-2-Redis数据结构-–-lists" class="headerlink" title="2.2  Redis数据结构 – lists"></a>2.2  Redis数据结构 – lists</h2><p>redis的另一个重要的数据结构叫做lists，翻译成中文叫做“列表”。</p><p>首先要明确一点，redis中的lists在底层实现上并不是数组，而是<strong>链表</strong>，也就是说对于一个具有上百万个元素的lists来说，在头部和尾部插入一个新元素，其时间复杂度是常数级别的，比如用LPUSH在10个元素的lists头部插入新元素，和在上千万元素的lists头部插入新元素的速度应该是相同的。</p><p>虽然lists有这样的优势，但同样有其弊端，那就是，<strong>链表型lists的元素定位会比较慢，而数组型lists的元素定位就会快得多</strong>。</p><p>lists的常用操作包括LPUSH、RPUSH、LRANGE等。我们可以用LPUSH在lists的左侧插入一个新元素，用RPUSH在lists的右侧插入一个新元素，用LRANGE命令从lists中指定一个范围来提取元素。我们来看几个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//新建一个list叫做mylist，并在列表头部插入元素"1"</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist "1" </span><br><span class="line">//返回当前mylist中的元素个数</span><br><span class="line">(integer) 1 </span><br><span class="line">//在mylist右侧插入元素"2"</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist "2" </span><br><span class="line">(integer) 2</span><br><span class="line">//在mylist左侧插入元素"0"</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist "0" </span><br><span class="line">(integer) 3</span><br><span class="line">//列出mylist中从编号0到编号1的元素</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 1 </span><br><span class="line">1) "0"</span><br><span class="line">2) "1"</span><br><span class="line">//列出mylist中从编号0到倒数第一个元素</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1 </span><br><span class="line">1) "0"</span><br><span class="line">2) "1"</span><br><span class="line">3) "2"</span><br></pre></td></tr></table></figure><p>lists的应用相当广泛，随便举几个例子：</p><p>1.我们可以利用lists来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样还需要通过ORDER BY来进行排序。<br>2.利用LRANGE还可以很方便的实现分页的功能。<br>3.在博客系统中，每片博文的评论也可以存入一个单独的list中。</p><h2 id="2-3-Redis数据结构-–-集合"><a href="#2-3-Redis数据结构-–-集合" class="headerlink" title="2.3 Redis数据结构 – 集合"></a>2.3 Redis数据结构 – 集合</h2><p>redis的集合，是一种<strong>无序的集合</strong>，集合中的元素没有先后顺序。</p><p>集合相关的操作也很丰富，如添加新元素、删除已有元素、取交集、取并集、取差集等。我们来看例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//向集合myset中加入一个新元素"one"</span><br><span class="line">127.0.0.1:6379&gt; sadd myset "one" </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset "two"</span><br><span class="line">(integer) 1</span><br><span class="line">//列出集合myset中的所有元素</span><br><span class="line">127.0.0.1:6379&gt; smembers myset </span><br><span class="line">1) "one"</span><br><span class="line">2) "two"</span><br><span class="line">//判断元素1是否在集合myset中，返回1表示存在</span><br><span class="line">127.0.0.1:6379&gt; sismember myset "one" </span><br><span class="line">(integer) 1</span><br><span class="line">//判断元素3是否在集合myset中，返回0表示不存在</span><br><span class="line">127.0.0.1:6379&gt; sismember myset "three" </span><br><span class="line">(integer) 0</span><br><span class="line">//新建一个新的集合yourset</span><br><span class="line">127.0.0.1:6379&gt; sadd yourset "1" </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd yourset "2"</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers yourset</span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">//对两个集合求并集</span><br><span class="line">127.0.0.1:6379&gt; sunion myset yourset </span><br><span class="line">1) "1"</span><br><span class="line">2) "one"</span><br><span class="line">3) "2"</span><br><span class="line">4) "two"</span><br></pre></td></tr></table></figure><p>对于集合的使用，也有一些常见的方式，比如，QQ有一个社交功能叫做“好友标签”，大家可以给你的好友贴标签，比如“大美女”、“土豪”、“欧巴”等等，这时就可以使用redis的集合来实现，把每一个用户的标签都存储在一个集合之中。</p><h2 id="2-4-Redis数据结构-–-有序集合"><a href="#2-4-Redis数据结构-–-有序集合" class="headerlink" title="2.4 Redis数据结构 – 有序集合"></a>2.4 Redis数据结构 – 有序集合</h2><p>redis不但提供了无需集合（sets），还很体贴的提供了有序集合（sorted sets）。有序集合中的每个元素都关联一个序号（score），这便是排序的依据。</p><p>很多时候，我们都将redis中的有序集合叫做zsets，这是因为在redis中，有序集合相关的操作指令都是以z开头的，比如zrange、zadd、zrevrange、zrangebyscore等等</p><p>老规矩，我们来看几个生动的例子：<br>//新增一个有序集合myzset，并加入一个元素baidu.com，给它赋予的序号是1：</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的过期策略和内存淘汰机制有什么区别?</title>
      <link href="/2020/05/14/Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/05/14/Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>Redis 和 MySQL 是面试绕不过的两座大山，他们一个是关系型数据库的代表（MySQL），一个是键值数据库以及缓存中间件的一哥。尤其 Redis 几乎是所有互联网公司都在用的技术，比如国内的 BATJ、新浪、360、小米等公司；国外的微软、Twitter、Stack Overflow、GitHub、暴雪等公司。我从业了十几年，就职过 4、5 家公司，有的公司用 MySQL、有的用 SQL Server、甚至还有的用 Oracle 和 DB2，但缓存无一例外使用的都是 Redis，从某种程度上来讲 Redis 是普及率最高的技术，没有之一。</p><p>我们本课时的面试题是，Redis 是如何处理过期数据的？当内存不够用时 Redis 又是如何处理的？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>我们在新增 Redis 缓存时可以设置缓存的过期时间，该时间保证了数据在规定的时间内失效，可以借助这个特性来实现很多功能。比如，存储一定天数的用户（登录）会话信息，这样在一定范围内用户不用重复登录了，但为了安全性，需要在一定时间之后重新验证用户的信息。因此，我们可以使用 Redis 设置过期时间来存储用户的会话信息。</p><p>对于已经过期的数据，Redis 将使用两种策略来删除这些过期键，它们分别是<strong>惰性删除</strong>和<strong>定期删除</strong>。</p><p><strong>惰性删除</strong>是指 Redis 服务器不主动删除过期的键值，而是当访问键值时，再检查当前的键值是否过期，如果过期则执行删除并返回 null 给客户端；如果没过期则正常返回值信息给客户端。</p><p>它的优点是不会浪费太多的系统资源，只是在每次访问时才检查键值是否过期。缺点是删除过期键不及时，造成了一定的空间浪费。</p><p>惰性删除的源码位于 src/db.c 文件的 expireIfNeeded 方法中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断键是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != NULL) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 删除过期键 */</span></span><br><span class="line">    <span class="comment">// 增加过期键个数</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">// 传播键过期的消息</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">    <span class="comment">// server.lazyfree_lazy_expire 为 1 表示异步删除，否则则为同步删除</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断键是否过期</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    mstime_t when = getExpire(db,key);</span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    mstime_t now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键的过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == NULL) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    serverAssertWithInfo(NULL,key,dictFind(db-&gt;dict,key-&gt;ptr) != NULL);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>惰性删除的执行流程如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p>除了惰性删除之外，Redis 还提供了定期删除功能以弥补惰性删除的不足。</p><p>定期删除是指 Redis 服务器每隔一段时间会检查一下数据库，看看是否有过期键可以被清除。</p><p>默认情况下 Redis 定期检查的频率是每秒扫描 10 次，用于定期清除过期键。当然此值还可以通过配置文件进行设置，在 redis.conf 中修改配置“hz”即可，默认的值为“hz 10”。</p><blockquote><p>小贴士：定期删除的扫描并不是遍历所有的键值对，这样的话比较费时且太消耗系统资源。Redis 服务器采用的是随机抽取形式，每次从过期字典中，取出 20 个键进行过期检测，过期字典中存储的是所有设置了过期时间的键值对。如果这批随机检查的数据中有 25% 的比例过期，那么会再抽取 20 个随机键值进行检测和删除，并且会循环执行这个流程，直到抽取的这批数据中过期键值小于 25%，此次检测才算完成。</p></blockquote><p>定期删除的源码在 expire.c 文件的 activeExpireCycle 方法中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeExpireCycle</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> unsigned <span class="keyword">int</span> current_db = <span class="number">0</span>; <span class="comment">/* 上次定期删除遍历到的数据库ID */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timelimit_exit = <span class="number">0</span>;      </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> last_fast_cycle = <span class="number">0</span>; <span class="comment">/* 上次执行定期删除的时间点 */</span></span><br><span class="line">    <span class="keyword">int</span> j, iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dbs_per_call = CRON_DBS_PER_CALL; <span class="comment">// 需要遍历数据库的数量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime(), timelimit, elapsed;</span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// ACTIVE_EXPIRE_CYCLE_FAST_DURATION 快速定期删除的执行时长</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line">    <span class="comment">// 慢速定期删除的执行时长</span></span><br><span class="line">    timelimit = <span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;</span><br><span class="line">    timelimit_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; <span class="comment">/* 删除操作花费的时间 */</span></span><br><span class="line">    <span class="keyword">long</span> total_sampled = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> total_expired = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call &amp;&amp; timelimit_exit == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> expired;</span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line">        current_db++;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// .......</span></span><br><span class="line">            expired = <span class="number">0</span>;</span><br><span class="line">            ttl_sum = <span class="number">0</span>;</span><br><span class="line">            ttl_samples = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 每个数据库中检查的键的数量</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line">            <span class="comment">// 从数据库中随机选取 num 个键进行检查</span></span><br><span class="line">            <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == NULL) <span class="keyword">break</span>;</span><br><span class="line">                ttl = dictGetSignedInteger</span><br><span class="line">                <span class="comment">// 过期检查，并对过期键进行删除</span></span><br><span class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ttl_sum += ttl;</span><br><span class="line">                    ttl_samples++;</span><br><span class="line">                &#125;</span><br><span class="line">                total_sampled++;</span><br><span class="line">            &#125;</span><br><span class="line">            total_expired += expired;</span><br><span class="line">            <span class="keyword">if</span> (ttl_samples) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line">                <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl/<span class="number">50</span>)*<span class="number">49</span> + (avg_ttl/<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* check once every 16 iterations. */</span></span><br><span class="line">                elapsed = ustime()-start;</span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt; timelimit) &#123;</span><br><span class="line">                    timelimit_exit = <span class="number">1</span>;</span><br><span class="line">                    server.stat_expired_time_cap_reached_count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 判断过期键删除数量是否超过 25% */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定期删除的执行流程，如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><blockquote><p>小贴士：Redis 服务器为了保证过期删除策略不会导致线程卡死，会给过期扫描增加了最大执行时间为 25ms。</p></blockquote><p>以上是 Redis 服务器对待过期键的处理方案，当 Redis 的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，这和过期策略是完全不同的两个概念，经常有人把二者搞混，这两者一个是在正常情况下清除过期键，一个是在非正常情况下为了保证 Redis 顺利运行的保护策略。</p><p>当 Redis 内存不够用时，Redis 服务器会根据服务器设置的淘汰策略，删除一些不常用的数据，以保证 Redis 服务器的顺利运行。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>本课时的面试题并非 Redis 的入门级面试题，需要面试者对 Redis 有一定的了解才能对答如流，并且 Redis 的过期淘汰策略和内存淘汰策略的概念比较类似，都是用于淘汰数据的。因此很多人会把二者当成一回事，但其实并不是，这个面试者特别注意一下，和此知识点相关的面试题还有以下这些：</p><ul><li>Redis 内存淘汰策略有哪些？</li><li>Redis 有哪些内存淘汰算法？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="Redis-内存淘汰策略"><a href="#Redis-内存淘汰策略" class="headerlink" title="Redis 内存淘汰策略"></a>Redis 内存淘汰策略</h3><p>我们可以使用 config get maxmemory-policy 命令，来查看当前 Redis 的内存淘汰策略，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config get maxmemory-policy</span><br><span class="line"><span class="number">1</span>) <span class="string">"maxmemory-policy"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"noeviction"</span></span><br></pre></td></tr></table></figure><p>从上面的结果可以看出，当前 Redis 服务器设置的是“noeviction”类型的内存淘汰策略，那么这表示什么含义呢？Redis 又有几种内存淘汰策略呢？</p><p>在 4.0 版本之前 Redis 的内存淘汰策略有以下 6 种。</p><ul><li>noeviction：不淘汰任何数据，当内存不足时，执行缓存新增操作会报错，它是 Redis 默认内存淘汰策略。</li><li>allkeys-lru：淘汰整个键值中最久未使用的键值。</li><li>allkeys-random：随机淘汰任意键值。</li><li>volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值。</li><li>volatile-random：随机淘汰设置了过期时间的任意键值。</li><li>volatile-ttl：优先淘汰更早过期的键值。</li></ul><p>可以看出我们上面示例使用的是 Redis 默认的内存淘汰策略“noeviction”。</p><p>而在 Redis 4.0 版本中又新增了 2 种淘汰策略：</p><ul><li><p>volatile-lfu，淘汰所有设置了过期时间的键值中最少使用的键值；</p></li><li><p>allkeys-lfu，淘汰整个键值中最少使用的键值。</p></li></ul><blockquote><p>小贴士：从以上内存淘汰策略中可以看出，allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰数据。</p></blockquote><p>这个内存淘汰策略我们可以通过配置文件来修改，redis.conf 对应的配置项是“maxmemory-policy noeviction”，只需要把它修改成我们需要设置的类型即可。</p><p>需要注意的是，如果使用修改 redis.conf 的方式，当设置完成之后需要重启 Redis 服务器才能生效。</p><p>还有另一种简单的修改内存淘汰策略的方式，我们可以使用命令行工具输入“config set maxmemory-policy noeviction”来修改内存淘汰的策略，这种修改方式的好处是执行成功之后就会生效，无需重启 Redis 服务器。但它的坏处是不能持久化内存淘汰策略，每次重启 Redis 服务器之后设置的内存淘汰策略就会丢失。</p><h3 id="Redis-内存淘汰算法"><a href="#Redis-内存淘汰算法" class="headerlink" title="Redis 内存淘汰算法"></a>Redis 内存淘汰算法</h3><p>内存淘汰算法主要包含两种：LRU 淘汰算法和 LFU 淘汰算法。</p><p><strong>LRU</strong>（ Least Recently Used，最近最少使用）<strong>淘汰算法</strong>：是一种常用的页面置换算法，也就是说最久没有使用的缓存将会被淘汰。</p><p>LRU 是基于链表结构实现的，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要进行内存淘汰时，只需要删除链表尾部的元素即可。</p><p>Redis 使用的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是给现有的数据结构添加一个额外的字段，用于记录此键值的最后一次访问时间。Redis 内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值 (此值可配置) ，然后淘汰最久没有使用的数据。</p><p><strong>LFU</strong>（Least Frequently Used，最不常用的）<strong>淘汰算法</strong>：最不常用的算法是根据总访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p><p>LFU 相对来说比 LRU 更“智能”，因为它解决了使用频率很低的缓存，只是最近被访问了一次就不会被删除的问题。如果是使用 LRU 类似这种情况数据是不会被删除的，而使用 LFU 的话，这个数据就会被删除。</p><p>Redis 内存淘汰策略使用了 LFU 和近 LRU 的淘汰算法，具体使用哪种淘汰算法，要看服务器是如何设置内存淘汰策略的，也就是要看“maxmemory-policy”的值是如何设置的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们讲了 Redis 的过期删除策略：惰性删除 + 定期删除；还讲了 Redis 的内存淘汰策略，它和过期策略是完全不同的两个概念，内存淘汰策略是当内存不够用时才会触发的一种机制，它在 Redis 4.0 之后提供了 8 种内存淘汰策略，这些淘汰策略主要使用了近 LRU 淘汰算法和 LFU 淘汰算法。</p><p>00:00 Java 源码剖析 34 讲</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系型数据和文档型数据库有什么区别？</title>
      <link href="/2020/05/14/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%92%8C%E6%96%87%E6%A1%A3%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2020/05/14/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%92%8C%E6%96%87%E6%A1%A3%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>关系数据库（Relational Database）是建立在关系模型基础上的数据库，借助于几何代数等数学概念和方法来处理数据库中的数据。所谓关系模型是一对一、一对多或者多对多等关系，常见的关系型数据库有 Oracle、SQL Server、DB2、MySQL 等。</p><p>而文档型数据库是一种非关系型数据库，非关系型数据库（Not Only SQL，NoSQL）正好与关系型数据库相反，它不是建立在“关系模型”上的数据库。文档型数据库的典型代表是 MongoDB。</p><p>我们本课时的面试题是，关系型数据库和文档型数据库有什么区别？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>关系型数据库属于早期的传统型数据库，它有着标准化的数据模型，以及事务和持久化的支持、例如，关系型数据库都会支持的 <strong>ACID</strong> 特性，也就是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），具体含义如下。</p><ul><li>原子性（Atomicity）：是指一个事务中的所有操作，要么全部完成、要么全部不完成，不会存在中间的状态。也就是说事务在正常的情况下会执行完成；异常的情况下，比如在执行的过程中如果出现问题，会回滚成最初的状态，而非中间状态。</li><li>一致性（Consistency）：是指事务从开始执行到结束执行之间的中间状态不会被其他事务看到。</li><li>隔离性（Isolation）：是指数据库允许多个事务同时对数据进行读写或修改的能力，并且整个过程对各个事务来说是相互隔离的。</li><li>持久性（Durability）：是指每次事务提交之后都不会丢失。</li></ul><p>关系型数据库一般遵循三范式设计思想，具体内容如下。</p><p><strong>第一范式（The First Normal Form，1NF）</strong>：要求对属性的原子性，也就是说要求数据库中的字段需要具备原子性，不能再被拆分。</p><p>比如，用户表中有字段：用户 ID、用户名、电话；而其中电话又可以分为：家庭电话和移动电话等。因此，此表不符合第一范式，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p><strong>第二范式（The Second Normal Form，2NF）</strong>：例如订单详情表有这些字段：订单 ID、产品 ID、产品名称、产品单价、折扣。其中，订单 ID 和产品 ID 为联合主键，但这个表中的产品名称和产品单价两个字段只依赖产品 ID，和订单 ID 就没有任何关系了，因此这个表也不符合第二范式。</p><p>我们可以把原来的订单表拆分为订单表和产品表，其中订单表包含：订单 ID、产品 ID、折扣等字段；而产品表包含：产品 ID、产品名称、产品单价等字段。这样就消除了产品名称和产品单价多次重复出现的情况了，从而避免了冗余数据的产生。</p><p><img data-src="2.png" alt="2.png"></p><p><strong>第三范式（The Third Normal Form，3NF）</strong>：想要满足第三范式必须先满足第二范式，第三范式要求所有的非主键字段必须直接依赖主键，且不存在传递依赖的情况。</p><p>例如，有一个学生表中包含了：学生 ID、姓名、所在学院 ID、学院电话、学院地址等字段。这个表的所有字段（除去主键字段）都完全依赖唯一的主键字段（学生 ID），所以符合第二范式。但它存在一个问题，学院电话、学院地址依赖非主键字段学院 ID，而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合第三范式。</p><p>我们可以把学生表分为两张表，一张是学生表包含了：学生 ID、姓名、所在学院 ID 等字段；另一张为学院表包含了：学院 ID、学院电话、学院地址等字段，这样就满足第三范式的要求了。</p><p><img data-src="3.png" alt="3.png"></p><p>可以看出，使用三范式可以避免数据的冗余，而且在更新表操作时，只需要更新单张表就可以了。</p><p>但随着互联网应用的快速发展，我们需要应对日益复杂且快速迭代的数据库，以应对互联网快速发展的趋势，于是诞生了以 MongoDB 为代表的文档型数据库。它提供了更高效的读/写性能以及可自动容灾的数据库集群，还有灵活的数据库结构，从而给系统的数据库存储带来了更多可能 性。</p><p>当然 MongoDB 的诞生并不是为了替代关系型数据库，而是为系统的快速开发提供一种可能性，它和关系型数据库是一种互补的关系，可供开发者在不同的业务场景下选择相对应的数据库类型。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>本课时的面试题考察的是面试者对数据库整体概念的理解与区分，这个问题看似简单，但包含着众多小的知识点，面试者需要真正的理解关系型数据库和非关系型数据库以及文档型数据库之间的区别才能灵活应对。与之相关的面试题还有：</p><ul><li>非关系型数据库和文档型数据库有什么区别？</li><li>MongoDB 支持事务吗？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="非关系型数据库-VS-文档型数据库"><a href="#非关系型数据库-VS-文档型数据库" class="headerlink" title="非关系型数据库 VS 文档型数据库"></a>非关系型数据库 VS 文档型数据库</h3><p>非关系型数据和文档型数据库属于包含关系，非关系型数据包含了文档型数据库，文档型数据库属于非关系型数据。</p><p>非关系型数据通常包含 3 种数据库类型：文档型数据库、键值型数据库和全文搜索型数据库，下面分别来看每种类型的具体用途。</p><h4 id="1-文档型数据库"><a href="#1-文档型数据库" class="headerlink" title="1.文档型数据库"></a>1.文档型数据库</h4><p>文档型数据库以 MongoDB 和 Apache CouchDB 为代表，文档型数据库通常以 JSON 或者 XML 为格式进行数据存储。</p><p>以 MongoDB 为例，它是由 C++ 编写的一种面向文档的数据库管理系统，在 2007 年 10 月 由 10gen 团队所开发，并在 2009 年 2 月首度推出。MongoDB 是以二进制 JSON 格式存储数据的，MongoDB 对 JSON 做了一些优化，它支持了更多的数据类型，这种二进制存储的 JSON 我们也可以称之为 <strong>BSON（Binary JSON）。</strong></p><p>BSON 具备三个特点：轻量、可遍历以及高效，它的缺点是空间利用率不是很理想。MongoDB 使用 BSON 进行存储的另一个重要原因是 BSON 具备可遍历性。</p><p>MongoDB 存储结构示例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"_id":ObjectId(“57ce2d4cce8685a6fd9df3a3"),"name":"老王","email":['java@qq.com','java@163.com']&#125;</span><br></pre></td></tr></table></figure><p>其中，“_id”为 MongoDB 默认的主键字段，它会为我们生成一起全局唯一的 id 值，并且这个值在做数据分片时非常有用。</p><p>文档型数据库的使用场景如下。</p><ul><li><strong>敏捷开发</strong>，因为 MongoDB 拥有比关系型数据库更快的开发速度，因此很多敏捷开发组织，包括纽约时报等都采用了 MongoDB 数据库。使用它可以有效地避免在增加和修改数据库带来的沟通成本，以及维护和创建数据库模型成本，使用 MongoDB 只需要在程序层面严格把关就行，程序提交的数据结构可以直接更新到数据库中，并不需要繁杂的设计数据库模型再生成修改语句等过程。</li><li><strong>日志系统</strong>，使用 MongoDB 数据库非常适合存储日志，日志对应到数据库中就是很多个文件，而 MongoDB 更擅长存储和查询文档，它提供了更简单的存储和更方便的查询功能。</li><li><strong>社交系统</strong>，使用 MongoDB 可以很方便的存储用户的位置信息，可以方便的实现查询附近的人以及附近的地点等功能。</li></ul><h4 id="2-键值型数据库"><a href="#2-键值型数据库" class="headerlink" title="2.键值型数据库"></a>2.键值型数据库</h4><p>键值数据库也就是 <strong>Key-Value 数据库</strong>，它的典型代表数据库是 <strong>Redis 和 Memcached</strong>，而它们通常被当做非持久化的内存型数据库缓存来使用。当然 Redis 数据库是具备可持久化得能力的，但是开启持久化会降低系统的运行效率，因此在使用时需要根据实际的情况，选择开启或者关闭持久化的功能。</p><p>键值型数据库以极高的性能著称，且除了 Key-Value 字符串类型之外，还包含一些其他的数据类型。以 Redis 为例，它提供了字符串类型（String）、列表类型（List）、哈希表类型（Hash）、集合类型（Set）、有序集合类型（ZSet）等五种最常用的基础数据类型，还有管道类型（Pipeline）、地理位置类型（GEO）、基数统计类型（HyperLogLog）和流类型（Stream），并且还提供了消息队列的功能。</p><p>此数据库的优点是性能比较高，缺点是对事务的支持不是很好。</p><h4 id="3-全文搜索型数据库"><a href="#3-全文搜索型数据库" class="headerlink" title="3.全文搜索型数据库"></a>3.全文搜索型数据库</h4><p>传统的关系型数据库主要是依赖索引来实现快速查询功能的，而在全文搜索的业务下，索引很难满足查询的需求。因为全文搜索需要支持模糊匹配的，当数据量比较大的情况下，传递的关系型数据库的查询效率是非常低的；另一个原因是全文搜索需要支持多条件随意组合排序，如果要通过索引来实现的话，则需要创建大量的索引，而传统型数据库也很难实现，因此需要专门全文搜索引擎和相关的数据库才能实现此功能。</p><p>全文搜索型数据库以 ElasticSearch 和 Solr 为代表，它们的出现解决了关系型数据库全文搜索功能较弱的问题。</p><h5 id="MongoDB-事务"><a href="#MongoDB-事务" class="headerlink" title="MongoDB 事务"></a>MongoDB 事务</h5><p>MongoDB 在 4.0 之前是不支持事务的，不支持的原因也很简单，因为文档型数据库和传统的关系型数据库不一样，不需要满足三范式。文档型数据库之所以性能比较高的另一个主要原因，就是使用文档型数据库不用进行多表关联性查询，因为文档型数据库会把相关的信息存放到一张表中。因此，无需关联多表查询的 MongoDB，在这种情况下的查询性能是比较高的。</p><p>把所有相关的数据都放入一个表中，这也是 MongoDB 之前很长一段时间内不支持事务的原因，它可以保证单表操作的原子性，一条记录要么成功插入，要么插入失败，不会存在插入了一半的数据。因此，在这种设计思路下，MongoDB 官方认为“事务功能”的实现没有那么紧迫。</p><p>但在 MongoDB 4.0 之中正式添加了事务的功能，并且在 MongoDB 4.2 中实现了分布式事务的功能，至此 MongoDB 开启了支持事务之旅。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们首先讲了关系型数据库的 ACID 特性以及设计时需要遵循的三范式设计思想；然后介绍了以 MongoDB 为代表的文档型数据库与关系型数据库的不同；最后还讲了 MongoDB 的事务功能，以及文档性数据库与非关系型数据库的关系，希望本课时的内容对你有帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 的优化方案有哪些</title>
      <link href="/2020/05/07/MySQL-%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
      <url>/2020/05/07/MySQL-%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<p><strong>性能优化（Optimize）</strong>指的是在保证系统正确性的前提下，能够更快速响应请求的一种手段。而且有些性能问题，比如慢查询等，如果积累到一定的程度或者是遇到急速上升的并发请求之后，会导致严重的后果，轻则造成服务繁忙，重则导致应用不可用。它对我们来说就像一颗即将被引爆的定时炸弹一样，时刻威胁着我们。因此在上线项目之前需要严格的把关，以确保 MySQL 能够以最优的状态进行运行。同时，在实际工作中还有面试中关于 MySQL 优化的知识点，都是面试官考察的重点内容。</p><p>我们本课时的面试题是，MySQL 的优化方案有哪些？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>MySQL 数据库常见的优化手段分为三个层面：<strong>SQL 和索引优化、数据库结构优化、系统硬件优化等</strong>，然而每个大的方向中又包含多个小的优化点，下面我们具体来看看。</p><h3 id="1-SQL-和索引优化"><a href="#1-SQL-和索引优化" class="headerlink" title="1.SQL 和索引优化"></a>1.SQL 和索引优化</h3><p>此优化方案指的是通过优化 SQL 语句以及索引来提高 MySQL 数据库的运行效率，具体内容如下。</p><h4 id="①-使用正确的索引"><a href="#①-使用正确的索引" class="headerlink" title="① 使用正确的索引"></a>① 使用正确的索引</h4><p>索引是数据库中最重要的概念之一，也是提高数据库性能最有效的手段之一，它的诞生本身就是为了提高数据查询效率的，就像字典的目录一样，通过目录可以很快找到相关的内容，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p><img data-src="2.png" alt="2.png"></p><p>假如我们没有添加索引，那么在查询时就会触发全表扫描，因此查询的数据就会很多，并且查询效率会很低，为了提高查询的性能，我们就需要给最常使用的查询字段上，添加相应的索引，这样才能提高查询的性能。</p><blockquote><p>小贴士：我们应该尽可能的使用主键查询，而非其他索引查询，因为主键查询不会触发回表查询，因此节省了一部分时间，变相的提高了查询的性能。</p></blockquote><p>在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，在 MySQL 5.0 之后的版本中引入了索引合并，简单来说就是把多条件查询，比如 or 或 and 查询的结果集进行合并交集或并集的功能，因此就不会导致索引失效的问题了。</p><p>避免在 where 查询条件中使用 != 或者 &lt;&gt; 操作符，因为这些操作符会导致查询引擎放弃索引而进行全表扫描。</p><p>适当使用前缀索引，MySQL 是支持前缀索引的，也就是说我们可以定义字符串的一部分来作为索引。我们知道索引越长占用的磁盘空间就越大，那么在相同数据页中能放下的索引值也就越少，这就意味着搜索索引需要的查询时间也就越长，进而查询的效率就会降低，所以我们可以适当的选择使用前缀索引，以减少空间的占用和提高查询效率。比如，邮箱的后缀都是固定的“@xxx.com”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引。</p><h4 id="②-查询具体的字段而非全部字段"><a href="#②-查询具体的字段而非全部字段" class="headerlink" title="② 查询具体的字段而非全部字段"></a>② 查询具体的字段而非全部字段</h4><p>要尽量避免使用 select *，而是查询需要的字段，这样可以提升速度，以及减少网络传输的带宽压力。</p><h4 id="③-优化子查询"><a href="#③-优化子查询" class="headerlink" title="③ 优化子查询"></a>③ 优化子查询</h4><p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，但 Join 语句并不会创建临时表，因此性能会更高。</p><h4 id="④-注意查询结果集"><a href="#④-注意查询结果集" class="headerlink" title="④ 注意查询结果集"></a>④ 注意查询结果集</h4><p>我们要尽量使用小表驱动大表的方式进行查询，也就是如果 B 表的数据小于 A 表的数据，那执行的顺序就是先查 B 表再查 A 表，具体查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B);</span><br></pre></td></tr></table></figure><h4 id="⑤-不要在列上进行运算操作"><a href="#⑤-不要在列上进行运算操作" class="headerlink" title="⑤ 不要在列上进行运算操作"></a>⑤ 不要在列上进行运算操作</h4><p>不要在列字段上进行算术运算或其他表达式运算，否则可能会导致查询引擎无法正确使用索引，从而影响了查询的效率。</p><h4 id="⑥-适当增加冗余字段"><a href="#⑥-适当增加冗余字段" class="headerlink" title="⑥ 适当增加冗余字段"></a>⑥ 适当增加冗余字段</h4><p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是<strong>以空间换时间的优化策略</strong>。</p><h3 id="2-数据库结构优化"><a href="#2-数据库结构优化" class="headerlink" title="2.数据库结构优化"></a>2.数据库结构优化</h3><h4 id="①-最小数据长度"><a href="#①-最小数据长度" class="headerlink" title="① 最小数据长度"></a>① 最小数据长度</h4><p>一般说来数据库的表越小，那么它的查询速度就越快，因此为了提高表的效率，应该将表的字段设置的尽可能小，比如身份证号，可以设置为 char(18) 就不要设置为 varchar(18)。</p><h4 id="②-使用最简单数据类型"><a href="#②-使用最简单数据类型" class="headerlink" title="② 使用最简单数据类型"></a>② 使用最简单数据类型</h4><p>能使用 int 类型就不要使用 varchar 类型，因为 int 类型比 varchar 类型的查询效率更高。</p><h4 id="③-尽量少定义-text-类型"><a href="#③-尽量少定义-text-类型" class="headerlink" title="③ 尽量少定义 text 类型"></a>③ 尽量少定义 text 类型</h4><p>text 类型的查询效率很低，如果必须要使用 text 定义字段，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率。</p><h4 id="④-适当分表、分库策略"><a href="#④-适当分表、分库策略" class="headerlink" title="④ 适当分表、分库策略"></a>④ 适当分表、分库策略</h4><p>分表和分库方案也是我们经常说的垂直分隔（分表）和水平分隔（分库）。</p><p><strong>分表</strong>是指当一张表中的字段更多时，可以尝试将一张大表拆分为多张子表，把使用比较高频的主信息放入主表中，其他的放入子表，这样我们大部分查询只需要查询字段更少的主表就可以完成了，从而有效的提高了查询的效率。</p><p><strong>分库</strong>是指将一个数据库分为多个数据库。比如我们把一个数据库拆分为了多个数据库，一个主数据库用于写入和修改数据，其他的用于同步主数据并提供给客户端查询，这样就把一个库的读和写的压力，分摊给了多个库，从而提高了数据库整体的运行效率。</p><h3 id="3-硬件优化"><a href="#3-硬件优化" class="headerlink" title="3.硬件优化"></a>3.硬件优化</h3><p>MySQL 对硬件的要求主要体现在三个方面：磁盘、网络和内存。</p><h4 id="①-磁盘"><a href="#①-磁盘" class="headerlink" title="① 磁盘"></a>① 磁盘</h4><p>磁盘应该尽量使用有高性能读写能力的磁盘，比如固态硬盘，这样就可以减少 I/O 运行的时间，从而提高了 MySQL 整体的运行效率。</p><p>磁盘也可以尽量使用多个小磁盘而不是一个大磁盘，因为磁盘的转速是固定的，有多个小磁盘就相当于拥有多个并行运行的磁盘一样。</p><h4 id="②-网络"><a href="#②-网络" class="headerlink" title="② 网络"></a>② 网络</h4><p>保证网络带宽的通畅（低延迟）以及够大的网络带宽是 MySQL 正常运行的基本条件，如果条件允许的话也可以设置多个网卡，以提高网络高峰期 MySQL 服务器的运行效率。</p><h4 id="③-内存"><a href="#③-内存" class="headerlink" title="③ 内存"></a>③ 内存</h4><p>MySQL 服务器的内存越大，那么存储和缓存的信息也就越多，而内存的性能是非常高的，从而提高了整个 MySQL 的运行效率。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>MySQL 性能优化的方案很多，因此它可以全面考察的一个程序员的经验是否丰富。当然这个问题的回答也是可深可浅，不同的岗位对此问题的答案要求也是不同的，这个问题也可以引申出更多的面试问题，比如：</p><ul><li>联合索引需要注意什么问题？</li><li>如何排查慢查询？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="正确使用联合索引"><a href="#正确使用联合索引" class="headerlink" title="正确使用联合索引"></a>正确使用联合索引</h3><p>使用了 B+ 树的 MySQL 数据库引擎，比如 InnoDB 引擎，在每次查询复合字段时是从左往右匹配数据的，因此在创建联合索引的时候需要注意索引创建的顺序。例如，我们创建了一个联合索引是 idx(name,age,sex)，那么当我们使用，姓名+年龄+性别、姓名+年龄、年龄+性别等这种从左往右顺序查询的条件时，就会触发联合索引进行查询；然而如果使用年龄+姓名这种非从左边往右边匹配的组合查询条件，就不能使用此联合索引进行查询了。</p><p>当然，当我们已经有了（name,age）这个联合索引之后，一般情况下就不需要在 name 字段单独创建索引了，这样就可以少维护一个索引。</p><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p><strong>慢查询</strong>通常的排查手段是先使用慢查询日志功能，查询出比较慢的 SQL 语句，然后再通过 explain 来查询 SQL 语句的执行计划，最后分析并定位出问题的根源，再进行处理。</p><p>慢查询日志指的是在 MySQL 中可以通过配置来开启慢查询日志的记录功能，超过 long_query_time 值的 SQL 将会被记录在日志中。我们可以通过设置“slow_query_log=1”来开启慢查询，它的开启方式有两种：</p><ul><li>通过 MySQL 命令行的模式进行开启，只需要执行“set global slow_query_log=1”即可，然而这种配置模式再重启 MySQL 服务之后就会失效；</li><li>另一种方式可通过修改 MySQL 配置文件的方式进行开启，我们需要配置 my.cnf 中的“slow_query_log=1”即可，并且可以通过设置“slow_query_log_file=/tmp/mysql_slow.log”来配置慢查询日志的存储目录，但这种方式配置完成之后需要重启 MySQL 服务器才可生效。</li></ul><p>需要注意的是，在开启慢日志功能之后，会对 MySQL 的性能造成一定的影响，因此在生产环境中要慎用此功能。</p><p>explain 执行计划的使用示例 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> person <span class="keyword">where</span> uname = <span class="string">'Java'</span>;</span><br></pre></td></tr></table></figure><p>它的执行结果如下图所示：</p><p><img data-src="3.png" alt="3.png"></p><p>摘要说明如下表所示：</p><p><img data-src="4.png" alt="4.png"></p><p>以上字段中最重要的就是 type 字段，它的所有值如下所示：</p><p><img data-src="5.png" alt="5.png"></p><p>当 type 为 all 时，则表示全表扫描，因此效率会比较低，此时需要查看一下为什么会造成此种原因，是没有创建索引还是索引创建的有问题？以此来优化整个 MySQL 运行的速度。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们从三个维度讲了 MySQL 的优化手段：SQL 和索引优化、数据库结构优化以及系统硬件优化等；同时深入到每个维度中，详细地介绍了 MySQL 具体的优化细节；最后我们讲了联合索引的最左匹配原则，以及慢查询的具体解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的运行机制是什么它有哪些引擎</title>
      <link href="/2020/05/07/MySQL%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E6%93%8E/"/>
      <url>/2020/05/07/MySQL%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>数据库是 Java 程序员面试必问的知识点之一，它和 Java 的核心面试点共同组成了一个完整的技术面试。而数据库一般泛指的就是 MySQL，因为 MySQL 几乎占据了数据库的半壁江山，即使有些公司没有使用 MySQL 数据库，如果你对 MySQL 足够精通的话，也是会被他们录取的。因为数据库的核心与原理基本是相通的，所以有了 MySQL 的基础之后，再去熟悉其他数据库也是非常快的，那么接下来的几个课时就让我们好好的学习一下 MySQL。</p><p>我们本课时的面试题是，MySQL 是如何运行的？说一下它有哪些引擎？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>MySQL 的执行流程是这样的，首先客户端先要发送用户信息去服务器端进行授权认证。如果使用的是命令行工具，通常需要输入如下信息：</p><blockquote><p>mysql -h 主机名(IP) -u 用户名 -P 端口 -p</p></blockquote><p>其中：</p><ul><li>h 表示要连接的数据库服务器的主机名或者 IP 信息；</li><li>u 表示数据库的用户名称；</li><li>P 表示数据库服务器的端口号，</li><li>小写的 -p 表示需要输入数据库的密码。</li></ul><p>具体使用示例，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p><strong>当输入正确密码之后可以连接到数据库了</strong>，如果密码输入错误，则会提示“Access denied for user ‘xxx’@’xxx’ (using password: YES)”密码错误信息，如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><p><strong>当连接服务器端成功之后就可以正常的执行 SQL 命令了</strong>，MySQL 服务器拿到 SQL 命令之后，<strong>会使用 MySQL 的分析器解析 SQL 指令，同时会根据语法分析器验证 SQL 指令</strong>，查询 SQL 指令是否满足 MySQL 的语法规则。如果不支持此语法，则会提示“SQL syntax”语法错误信息。</p><p><strong>当分析器验证并解析 SQL 命令之后，会进入优化器阶段，执行生成计划，并设置相应的索引；当上面的这些步骤都执行完之后，就进入了执行器阶段，并开始正式执行 SQL 命令。</strong>同样在执行命令之前，它会先对你的执行命令进行权限查询，看看是否有操作某个表的权限，如果有相应的权限，执行器就去调用 MySQL 数据库引擎提供的接口，<strong>执行相应的命令；如果是非查询操作会记录对应的操作日志，再命令执行完成之后返回结果给客户端，这就是整个 MySQL 操作的完整流程</strong>。</p><p>需要注意的是，如果执行的是 select 语句并且是 MySQL 8.0 之前的版本的话，则会去 MySQL 的查询缓存中查看之前是否有执行过这条 SQL；如果缓存中可以查到，则会直接返回查询结果，这样查询性能就会提升很高。</p><p>整个 SQL 的执行流程，如下图所示：</p><p><img data-src="3.png" alt="3.png"></p><p>我们可以使用 SHOW ENGINES 命令来查看 MySQL 数据库使用的存储引擎，如下图所示：</p><p><img data-src="4.png" alt="4.png"></p><p>常用的数据库引擎有 InnoDB、MyISAM、MEMORY 等，其中 InnoDB 支持事务功能，而 MyISAM 不支持事务，但 MyISAM 拥有较高的插入和查询的速度。而 MEMORY 是内存型的数据库引擎，它会将表中的数据存储到内存中，因为它是内存级的数据引擎，因此具备最快速的查询效率，但它的缺点是，重启数据库之后，所有数据都会丢失，因为这些数据是存放在内存中的。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>此面试题考察的是面试者对 MySQL 基础知识的掌握程度，以及对于 MySQL 引擎的了解程度，这些都是属于 MySQL 最核心的原理之一，也是面试中常见的面试问题，它一般作为数据库面试题的开始题目，和此面试题相关的面试点还有以下几个：</p><ul><li>查询缓存在什么问题？</li><li>如何选择数据库的引擎？</li><li>InnoDB 自增索引的持久化问题。</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-查询缓存的利弊"><a href="#1-查询缓存的利弊" class="headerlink" title="1.查询缓存的利弊"></a>1.查询缓存的利弊</h3><p>MySQL 8.0 之前可以正常的使用查询缓存的功能，可通过“SHOW GLOBAL VARIABLES LIKE ‘query_cache_type’”命令查询数据库是否开启了查询缓存的功能，它的结果值有以下三项：</p><ul><li>OFF，关闭了查询缓存功能；</li><li>ON，开启了查询缓存功能；</li><li>DEMAND，在 sql 语句中指定 sql_cache 关键字才会有查询缓存，也就是说必须使用 sql_cache 才可以把该 select 语句的查询结果缓存起来，比如“select sql_cache name from token where tid=1010”语句。</li></ul><p>开启和关闭查询缓存可以通过修改 MySQL 的配置文件 my.cnf 进行修改，它的配置项如下：</p><blockquote><p>query_cache_type = ON</p></blockquote><p>注意：配置被更改之后需要重启 MySQL 服务才能生效。</p><p>查询缓存的功能要根据实际的情况进行使用，建议设置为<strong>按需缓存（DEMAND）模式</strong>，因为查询缓存的功能并不是那么好用。比如我们设置了 query_cache_type = ON，当我们好不容易缓存了很多查询语句之后，任何一条对此表的更新操作都会把和这个表关联的所有查询缓存全部清空，那么在更新频率相对较高的业务中，查询缓存功能完全是一个鸡肋。因此，在 MySQL 8.0 的版本中已经完全移除了此功能，也就是说在 MySQL 8.0 之后就完全没有查询缓存这个概念和功能了。</p><h3 id="2-如何选择数据库引擎"><a href="#2-如何选择数据库引擎" class="headerlink" title="2.如何选择数据库引擎"></a>2.如何选择数据库引擎</h3><p>选择数据库引擎要从实际的业务情况入手，比如是否需要支持事务？是否需要支持外键？是否需要支持持久化？以及是否支持地理位置存储以及索引等方面进行综合考量。</p><p>我们最常用的数据库引擎是 InnoDB，它是 MySQL 5.5.5 之后的默认引擎，其优点是支持事务，且支持 4 种隔离级别。</p><ul><li><p>读未提交：也就是一个事务还没有提交时，它做的变更就能被其他事务看到。</p></li><li><p>读已提交：指的是一个事务只有提交了之后，其他事务才能看得到它的变更。</p></li><li><p>可重复读：此方式为默认的隔离级别，它是指一个事务在执行过程中（从开始到结束）看到的数据都是一致的，在这个过程中未提交的变更对其他事务也是不可见的。</p></li><li><p>串行化：是指对同一行记录的读、写都会添加读锁和写锁，后面访问的事务必须等前一个事务执行完成之后才能继续执行，所以这种事务的执行效率很低。</p></li></ul><p>InnoDB 还支持外键、崩溃后的快速恢复、支持全文检索（需要 5.6.4+ 版本）、集群索引，以及地理位置类型的存储和索引等功能。</p><p>MyISAM 引擎是 MySQL 原生的引擎，但它并不支持事务功能，这也是后来被 InnoDB 替代为默认引擎的主要原因。MyISAM 有独立的索引文件，因此在读取数据方面的性能很高，它也支持全文索引、地理位置存储和索引等功能，但不支持外键。</p><p>InnoDB 和 MyISAM 都支持持久化，但 MEMORY 引擎是将数据直接存储在内存中了，因此在重启服务之后数据就会丢失，但它带来的优点是执行速度很快，可以作为临时表来使用。</p><p>我们可以根据实际的情况设置相关的数据库引擎，还可以针对不同的表设置不同的数据引擎，只需要在创建表的时候指定 engine=引擎名称即可，SQL 代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">   uname <span class="built_in">varchar</span>(<span class="number">60</span>),</span><br><span class="line">   age <span class="built_in">int</span></span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">Memory</span>;</span><br></pre></td></tr></table></figure><h3 id="3-InnoDB-自增主键"><a href="#3-InnoDB-自增主键" class="headerlink" title="3.InnoDB 自增主键"></a>3.InnoDB 自增主键</h3><p>在面试的过程中我们经常看到这样一道面试题：</p><blockquote><p>在一个自增表里面一共有 5 条数据，id 从 1 到 5，删除了最后两条数据，也就是 id 为 4 和 5 的数据，之后重启的 MySQL 服务器，又新增了一条数据，请问新增的数据 id 为几？</p></blockquote><p>我们通常的答案是如果表为 MyISAM 引擎，那么 id 就是 6，如果是 InnoDB 那么 id 就是 4。</p><p>但是这个情况在高版本的 InnoDB 中，也就是 MySQL 8.0 之后就不准确了，它的 id 就不是 4 了，而是 6 了。因为在 MySQL 8.0 之后 InnoDB 会把索引持久化到日志中，重启服务之后自增索引是不会丢失的，因此答案是 6，这个需要面试者注意一下。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们讲了 MySQL 数据库运行流程的几个阶段，先从连接器授权，再到分析器进行语法分析。如果是 MySQL 8.0 之前的 select 语句可能会先查询缓存，如果有缓存则会直接返回结果给客户端，否则会从分析器进入优化器生成 SQL 的执行计划，然后交给执行器调用操作引擎执行相关的 SQL，再把结果返回给客户端。我们还讲了最常见的三种数据库引擎 InnoDB、MyISAM、MEMORY，以及它们的利弊分析。最后讲了 InnoDB 在高版本（8.0）之后可以持久化自增主键的小特性，希望可以帮助到你。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ有什么作用,你都用过哪些MQ中间件</title>
      <link href="/2020/05/07/MQ%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8-%E4%BD%A0%E9%83%BD%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BMQ%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2020/05/07/MQ%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8-%E4%BD%A0%E9%83%BD%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BMQ%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在第 10 课时中讲过“手写消息队列”，当时粗略的讲了 Java API 中使用 Queue 实现自定义消息队列，以及使用 Delayed 实现延迟队列的示例；同时还讲了 RabbitMQ 中的一些基础概念。本课时我们将会更加深入的讲解 MQ（Message Queue，消息队列）中间件，以及这些热门中间件的具体使用。</p><p>我们本课时的面试题是，MQ 常见的使用场景有哪些？你都用过哪些 MQ 中间件？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>在介绍 MQ 的使用场景之前，先来回忆一下 MQ 的作用。MQ 可以用来实现削峰填谷，也就是使用它可以解决短时间内爆发式的请求任务，在不使用 MQ 的情况下会导致服务处理不过来，出现应用程序假死的情况，而使用了 MQ 之后可以把这些请求先暂存到消息队列中，然后进行排队执行，那么就不会出现应用程序假死的情况了，所以它的<strong>第一个应用就是商品秒杀以及产品抢购等使用场景</strong>，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><h3 id="使用-MQ-实现消息通讯"><a href="#使用-MQ-实现消息通讯" class="headerlink" title="使用 MQ 实现消息通讯"></a>使用 MQ 实现消息通讯</h3><p>使用 MQ 可以作为消息通讯的实现手段，利用它可以实现点对点的通讯或者多对多的聊天室功能。</p><p>点对点的消息通讯如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><p>多对多的消息通讯如下图所示：</p><p><img data-src="3.png" alt="3.png"></p><h3 id="使用-MQ-实现日志系统"><a href="#使用-MQ-实现日志系统" class="headerlink" title="使用 MQ 实现日志系统"></a>使用 MQ 实现日志系统</h3><p>可使用 MQ 实现对日志的采集和转发，比如有多个日志写入到程序中，然后把日志添加到 MQ，紧接着由日志处理系统订阅 MQ，最后 MQ 将消息接收并转发给日志处理系统，这样就完成了日志的分析和保存功能，如下图所示：</p><p><img data-src="4.png" alt="4.png"></p><p>常用的 MQ 中间件有 RabbitMQ、Kafka 和 Redis 等，其中 Redis 属于轻量级的消息队列，而 RabbitMQ、Kafka 属于比较成熟且比较稳定和高效的 MQ 中间件。</p><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>MQ 属于中高级或优秀的程序员必备的技能，对于 MQ 中间件掌握的数量则是你技术广度和编程经验的直接体现信息之一。值得庆幸的是，关于 MQ 中间件的实现原理和使用方式都比较类似，因此如果开发者掌握一项 MQ 中间件再去熟悉其他 MQ 中间件时，会非常的容易。</p><p>MQ 相关的面试题还有这些：</p><ul><li>MQ 的特点是什么？引入 MQ 中间件会带来哪些问题？</li><li>常见的 MQ 中间件的优缺点分析。</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="MQ-的特点及注意事项"><a href="#MQ-的特点及注意事项" class="headerlink" title="MQ 的特点及注意事项"></a>MQ 的特点及注意事项</h3><p>MQ 具有以下 5 个特点。</p><ul><li><p><strong>先进先出：</strong>消息队列的顺序一般在入列时就基本确定了，最先到达消息队列的信息，一般情况下也会先转发给订阅的消费者，我们把这种实现了先进先出的数据结构称之为队列。</p></li><li><p><strong>发布、订阅工作模式</strong>：生产者也就是消息的创建者，负责创建和推送数据到消息服务器；消费者也就是消息的接收方，用于处理数据和确认消息的消费；消息队列也是 MQ 服务器中最重要的组成元素之一，它负责消息的存储，这三者是 MQ 中的三个重要角色。而它们之间的消息传递与转发都是通过发布以及订阅的工作模式来进行的，即生产者把消息推送到消息队列，消费者订阅到相关的消息后进行消费，在消息非阻塞的情况下，此模式基本可以实现同步操作的效果。并且此种工作模式会把请求的压力转移给 MQ 服务器，以减少了应用服务器本身的并发压力。</p></li><li><p><strong>持久化</strong>：持久化是把消息从内存存储到磁盘的过程，并且在服务器重启或者发生宕机的情况下，重新启动服务器之后是保证数据不会丢失的一种手段，也是目前主流 MQ 中间件都会提供的重要功能。</p></li><li><p><strong>分布式：</strong>MQ 的一个主要特性就是要应对大流量、大数据的高并发环境，一个单体的 MQ 服务器是很难应对这种高并发的压力的，所以 MQ 服务器都会支持分布式应用的部署，以分摊和降低高并发对 MQ 系统的冲击。</p></li><li><p><strong>消息确认：</strong>消息消费确认是程序稳定性和安全性的一个重要考核指标，假如消费者在拿到消息之后突然宕机了，那么 MQ 服务器会误认为此消息已经被消费者消费了，从而造成消息丢失的问题，而目前市面上的主流 </p><p>MQ 都实现了消息确认的功能，保证了消息不会丢失，从而保证了系统的稳定性。</p></li></ul><h4 id="引入-MQ-系统会带来的问题"><a href="#引入-MQ-系统会带来的问题" class="headerlink" title="引入 MQ 系统会带来的问题"></a>引入 MQ 系统会带来的问题</h4><p>任何系统的引入都是有两面性的，MQ 也不例外，在引入 MQ 之后，可能会带来以下两个问题。</p><ul><li>增加了系统的运行风险：引入 MQ 系统，则意味着新增了一套系统，并且其他的业务系统会对 MQ 系统进行深度依赖，系统部署的越多则意味着发生故障的可能性就越大，如果 MQ 系统挂掉的话可能会导致整个业务系统瘫痪。</li><li>增加了系统的复杂度：引入 MQ 系统后，需要考虑消息丢失、消息重复消费、消息的顺序消费等问题，同时还需要引入新的客户端来处理 MQ 的业务，增加了编程的运维门槛，增加了系统的复杂性。</li></ul><p>使用 MQ 需要注意的问题，不要过度依赖 MQ，比如发送短信验证码或邮件等功能，这种低频但有可能比较耗时的功能可以使用多线程异步处理即可，不用任何的功能都依赖 MQ 中间件来完成，但像秒杀抢购可能会导致超卖（也就是把货卖多了，库存变成负数了）等短时间内高并发的请求，此时建议使用 MQ 中间件。</p><h3 id="常用的-MQ-中间件"><a href="#常用的-MQ-中间件" class="headerlink" title="常用的 MQ 中间件"></a>常用的 MQ 中间件</h3><p>常用的 MQ 中间件有 Redis、RabbitMQ、Kafka，下来我们分别来看看各自的作用。</p><h4 id="Redis-轻量级的消息中间件"><a href="#Redis-轻量级的消息中间件" class="headerlink" title="Redis 轻量级的消息中间件"></a>Redis 轻量级的消息中间件</h4><p>Redis 是一个高效的内存性数据库中间件，但使用 Redis 也可以实现消息队列的功能。</p><p>早期的 Redis（Redis 5.0 之前）是不支持消息确认的，那时候我们可以通过 List 数据类型的 lpush 和 rpop 方法来实现队列消息的存入和读取功能，或者使用 Redis 提供的发布订阅（pub/sub）功能来实现消息队列，但这种模式不支持持久化，List 虽然支持持久化但不能设置复杂的路由规则来匹配多个消息，并且他们二者都不支持消息消费确认。</p><p>于是在 Redis 5.0 之后提供了新的数据类型 Stream 解决了消息确认的问题，但它同样不能提供复杂的路由匹配规则，因此在业务不复杂的场景下可以尝试性的使用 Redis 提供的消息队列。</p><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>在第 10 课时中，我们对 RabbitMQ 有过初步的讲解，它是一个实现了标准的高级消息队列协议（AMQP，Advanced Message Queuing Protocol）的老牌开源消息中间件，最初起源于金融系统，后来被普遍应用在了其他分布式系统中，它支持集群部署，和多种客户端调用。</p><p>之前主要介绍了 RabbitMQ 的基础功能，本课时我们重点来看 RabbitMQ 集群相关的内容。</p><p>RabbitMQ 集群是由多个节点组成，但默认情况下每个节点并不是存储所有队列的完整拷贝，这是出于存储空间和性能的考虑，因为如果存储了队列的完整拷贝，那么就会有很多冗余的重复数据，并且在新增节点的情况下，不但没有新增存储空间，反而需要更大的空间来存储旧的数据；同样的道理，如果每个节点都保存了所有队列的完整信息，那么非查询操作的性能就会很慢，就会需要更多的网络带宽和磁盘负载来存储这些数据。</p><p>为了能兼顾性能和稳定性，RabbitMQ 集群的节点分为两种类型，即磁盘节点和内存节点，对于磁盘节点来说显然它的优势就是稳定，可以把相关数据保存下来，若 RabbitMQ 因为意外情况宕机，重启之后保证了数据不丢失；而内存节点的优势是快，因为是在内存中进行数据交换和操作，因此性能比磁盘节点要高出很多倍。</p><p>如果是单个 RabbitMQ 那么就必须要求是磁盘节点，否则当 RabbitMQ 服务器重启之后所有的数据都会丢失，这样显然是不能接受的。在 RabbitMQ 的集群中，至少需要一个磁盘节点，这样至少能保证集群数据的相对可靠性。</p><blockquote><p>小贴士：对于 RabbitMQ 集群来说，我们启动集群节点的顺序应该是先启动磁盘节点再启动内存节点，而关闭的顺序正好和启动的顺序相反，不然可能会导致 RabbitMQ 集群启动失败或者是数据丢失等异常问题。</p></blockquote><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>Kafka 是 LinkedIn 公司开发的基于 ZooKeeper 的多分区、多副本的分布式消息系统，它于 2010 年贡献给了 Apache 基金会，并且成为了 Apache 的顶级开源项目。其中 ZooKeeper 的作用是用来为 Kafka 提供集群元数据管理以及节点的选举和发现等功能。</p><p>与 RabbitMQ 比较类似，一个典型的 Kafka 是由多个 Broker、多个生产者和消费者，以及 ZooKeeper 集群组成的，其中 Broker 可以理解为一个代理，Kafka 集群中的一台服务器称之为一个 Broker，其组成框架图如下所示：</p><p><img data-src="5.png" alt="5.png"></p><h3 id="Kafka-VS-RabbitMQ"><a href="#Kafka-VS-RabbitMQ" class="headerlink" title="Kafka VS RabbitMQ"></a>Kafka VS RabbitMQ</h3><p>Kafka（2.0.0）和 RabbitMQ（3.6.10）的区别主要体现在以下几点：</p><ul><li>Kafka 支持消息回溯，它可以根据 Offset（消息偏移量）、TimeStamp（时间戳）等维度进行消息回溯，而 RabbitMQ 并不支持消息回溯；</li><li>Kafka 的消息消费是基于拉取数据的模式，也就是消费者主动向服务器端发送拉取消息请求，而 RabbitMQ 支持拉取数据模式和主动推送数据的模式，也就说 RabbitMQ 服务器会主动把消息推送给订阅的消费者；</li><li>在相同配置下，Kafka 的吞吐量通常会比 RabbitMQ 高一到两个级别，比如在单机模式下，RabbitMQ 的吞吐量大概是万级别的处理能力，而 Kafka 则可以到达十万甚至是百万的吞吐级别；</li><li>Kafka 从 0.11 版本就开始支持幂等性了，当然所谓的幂等性指的是对单个生产者在单分区上的单会话的幂等操作，但对于全局幂等性则还需要结合业务来处理，比如，消费者在消费完一条消息之后没有来得及确认就发生异常了，等到恢复之后又得重新消费原来消费过的消息，类似这种情况，是无法在消息中间件层面来保证的，这个时候则需要引入更多的外部资源来保证全局幂等性，比如唯一的订单号、消费之前先做去重判断等；而 RabbitMQ 是没有幂等性功能支持的；</li><li>RabbitMQ 支持多租户的功能，也就是常说的 Virtual Host（vhost），每一个 vhost 相当于一个独立的小型 RabbitMQ 服务器，它们拥有自己独立的交换器、消息队列及绑定关系等，并且拥有自己独立权限，而且多个 vhost 之间是绝对隔离的，但 Kafka 并不支持多租户的功能。</li></ul><p>Kafka 和 RabbitMQ 都支持分布式集群部署，并且都支持数据持久化和消息消费确认等 MQ 的核心功能，对于 MQ 的选型要结合自己团队本身的情况，从性能、稳定性及二次开发的难易程度等维度来进行综合的考量并选择。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们讲了 MQ 的常见使用场景，以及常见的 MQ 中间件（Redis、RabbitMQ、Kafka）及其优缺点分析；同时还了解了 MQ 的五大特点：先进先出、发布和订阅的模式、持久化、分布式和消息确认等；接着讲了 MQ 引入对系统可能带来的风险；最后讲了 MQ 在使用时需要注意的问题。希望本课时对你整体了解 MQ 系统有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简谈你对synchronized关键字的理解</title>
      <link href="/2020/05/05/%E7%AE%80%E8%B0%88%E4%BD%A0%E5%AF%B9synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/05/05/%E7%AE%80%E8%B0%88%E4%BD%A0%E5%AF%B9synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="面试官：sychronized关键字有哪些特性？"><a href="#面试官：sychronized关键字有哪些特性？" class="headerlink" title="面试官：sychronized关键字有哪些特性？"></a><strong>面试官：sychronized关键字有哪些特性？</strong></h2><p>应聘者：</p><ul><li>可以用来修饰方法;</li><li>可以用来修饰代码块;</li><li>可以用来修饰静态方法;</li><li>可以保证线程安全;</li><li>支持锁的重入;</li><li>sychronized使用不当导致死锁;</li></ul><p>了解sychronized之前,我们先来看一下几个常见的概念:内置锁、互斥锁、对象锁和类锁。</p><h2 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a><strong>内置锁</strong></h2><p>在Java中每一个对象都可以作为同步的锁，那么这些锁就被称为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><strong>互斥锁</strong></h2><p>内置锁同时也是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，直到线程B抛出异常或者正常执行完毕释放这个锁；如果B线程不释放这个锁，那么A线程将永远等待下去。</p><h2 id="对象锁和类锁"><a href="#对象锁和类锁" class="headerlink" title="对象锁和类锁"></a><strong>对象锁和类锁</strong></h2><p>对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的。</p><ul><li>对象锁是用于对象实例方法；</li><li>类锁是用于类的静态方法或者一个类的class对象上的</li></ul><p>一个对象无论有多少个同步方法区，它们共用一把锁，某一时刻某个线程已经进入到某个synchronzed方法，那么在该方法没有执行完毕前，其他线程无法访问该对象的任何synchronzied 方法的，但可以访问非synchronzied方法。</p><p>如果synchronized方法是static的，那么当线程访问该方法时，它锁的并不是synchronized方法所在的对象，而是synchronized方法所在对象的对应的Class对象，</p><p>因为java中无论一个类有多少个对象，这些对象会对应唯一一个Class对象，因此当线程分别访问同一个类的两个对象的static，synchronized方法时，他们的执行也是按顺序来的，也就是说一个线程先执行，一个线程后执行。</p><p>synchronized的用法：修饰方法和修饰代码块，下面分别分析这两种用法在对象锁和类锁上的效果。</p><h2 id="对象锁的synchronized修饰方法和代码块"><a href="#对象锁的synchronized修饰方法和代码块" class="headerlink" title="对象锁的synchronized修饰方法和代码块"></a><strong>对象锁的synchronized修饰方法和代码块</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TestSynchronized myt2 = <span class="keyword">new</span> TestSynchronized();</span><br><span class="line">    Thread test1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myt2.test1();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"test1"</span>);</span><br><span class="line">    Thread test2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myt2.test2();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"test2"</span>);</span><br><span class="line">    test1.start();</span><br><span class="line">    test2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test2 : <span class="number">4</span></span><br><span class="line">test2 : <span class="number">3</span></span><br><span class="line">test2 : <span class="number">2</span></span><br><span class="line">test2 : <span class="number">1</span></span><br><span class="line">test2 : <span class="number">0</span></span><br><span class="line">test1 : <span class="number">4</span></span><br><span class="line">test1 : <span class="number">3</span></span><br><span class="line">test1 : <span class="number">2</span></span><br><span class="line">test1 : <span class="number">1</span></span><br><span class="line">test1 : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上述的代码，第一个方法用了同步代码块的方式进行同步，传入的对象实例是this，表明是当前对象；第二个方法是修饰方法的方式进行同步</p><p>。因为第一个同步代码块传入的this，所以两个同步代码所需要获得的对象锁都是同一个对象锁，下面main方法时分别开启两个线程，分别调用test1和test2方法，那么两个线程都需要获得该对象锁，另一个线程必须等待。</p><p>上面也给出了运行的结果可以看到：直到test2线程执行完毕，释放掉锁，test1线程才开始执行。这里test2方法先抢到CPU资源，故它先执行，它获得了锁，它执行完毕后，test1才开始执行。</p><p>如果我们把test2方法的synchronized关键字去掉，执行结果会如何呢？　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test1 : <span class="number">4</span></span><br><span class="line">test2 : <span class="number">4</span></span><br><span class="line">test2 : <span class="number">3</span></span><br><span class="line">test2 : <span class="number">2</span></span><br><span class="line">test2 : <span class="number">1</span></span><br><span class="line">test2 : <span class="number">0</span></span><br><span class="line">test1 : <span class="number">3</span></span><br><span class="line">test1 : <span class="number">2</span></span><br><span class="line">test1 : <span class="number">1</span></span><br><span class="line">test1 : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们可以看到，结果输出是交替着进行输出的，这是因为，某个线程得到了对象锁，但是另一个线程还是可以访问没有进行同步的方法或者代码。进行了同步的方法（加锁方法）和没有进行同步的方法（普通方法）是互不影响的，一个线程进入了同步方法，得到了对象锁，其他线程还是可以访问那些没有同步的方法（普通方法）。</p><h2 id="类锁的修饰（静态）方法和代码块"><a href="#类锁的修饰（静态）方法和代码块" class="headerlink" title="类锁的修饰（静态）方法和代码块　　"></a><strong>类锁的修饰（静态）方法和代码块</strong>　　</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (TestSynchronized<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TestSynchronized myt2 = <span class="keyword">new</span> TestSynchronized();</span><br><span class="line">    Thread test1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myt2.test1();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"test1"</span>);</span><br><span class="line">    Thread test2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestSynchronized.test2();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"test2"</span>);</span><br><span class="line">    test1.start();</span><br><span class="line">    test2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test1 : <span class="number">4</span></span><br><span class="line">test1 : <span class="number">3</span></span><br><span class="line">test1 : <span class="number">2</span></span><br><span class="line">test1 : <span class="number">1</span></span><br><span class="line">test1 : <span class="number">0</span></span><br><span class="line">test2 : <span class="number">4</span></span><br><span class="line">test2 : <span class="number">3</span></span><br><span class="line">test2 : <span class="number">2</span></span><br><span class="line">test2 : <span class="number">1</span></span><br><span class="line">test2 : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>类锁修饰方法和代码块的效果和对象锁是一样的，因为类锁只是一个抽象出来的概念，只是为了区别静态方法的特点，因为静态方法是所有对象实例共用的，所以对应着synchronized修饰的静态方法的锁也是唯一的，所以抽象出来个类锁。其实这里重点在下面这块代码，synchronized同时修饰静态和非静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TestSynchronized myt2 = <span class="keyword">new</span> TestSynchronized();</span><br><span class="line">    Thread test1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myt2.test1();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"test1"</span>);</span><br><span class="line">    Thread test2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestSynchronized.test2();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"test2"</span>);</span><br><span class="line">    test1.start();</span><br><span class="line">    test2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test1 : <span class="number">4</span></span><br><span class="line">test2 : <span class="number">4</span></span><br><span class="line">test1 : <span class="number">3</span></span><br><span class="line">test2 : <span class="number">3</span></span><br><span class="line">test2 : <span class="number">2</span></span><br><span class="line">test1 : <span class="number">2</span></span><br><span class="line">test2 : <span class="number">1</span></span><br><span class="line">test1 : <span class="number">1</span></span><br><span class="line">test1 : <span class="number">0</span></span><br><span class="line">test2 : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上面代码synchronized同时修饰静态方法和实例方法，但是运行结果是交替进行的，这证明了类锁和对象锁是两个不一样的锁，控制着不同的区域，它们是互不干扰的。同样，线程获得对象锁的同时，也可以获得该类锁，即同时获得两个锁，这是允许的。</p><h2 id="synchronized是如何保证线程安全的"><a href="#synchronized是如何保证线程安全的" class="headerlink" title="synchronized是如何保证线程安全的"></a><strong>synchronized是如何保证线程安全的</strong></h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p>我们通过一个案例，演示线程的安全问题：</p><p>我们来模拟一下火车站卖票过程，总共有100张票，总共有三个窗口卖票。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建票对象</span></span><br><span class="line">    Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">    <span class="comment">// 创建3个窗口</span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口2"</span>);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口3"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 模拟票</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 共100票</span></span><br><span class="line">  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟卖票</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 模拟选坐的操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖票:"</span></span><br><span class="line">            + ticket--);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果发现：上面程序出现了问题</p><ul><li>票出现了重复的票</li><li>错误的票 0、-1</li></ul><p>其实，线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p><p>那么出现了上述问题，我们应该如何解决呢？</p><h2 id="线程同步（线程安全处理Synchronized）"><a href="#线程同步（线程安全处理Synchronized）" class="headerlink" title="线程同步（线程安全处理Synchronized）"></a><strong>线程同步（线程安全处理Synchronized）</strong></h2><p>java中提供了线程同步机制，它能够解决上述的线程安全问题。</p><p>线程同步的方式有两种：</p><ul><li>方式1：同步代码块</li><li>方式2：同步方法</li></ul><p><strong>同步代码块</strong></p><p>同步代码块: 在代码块声明上 加上synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (锁对象) &#123;</span><br><span class="line">  可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。</p><p>使用同步代码块，对火车站卖票案例中Ticket类进行如下代码修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建票对象</span></span><br><span class="line">    Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">    <span class="comment">// 创建3个窗口</span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口2"</span>);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口3"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 模拟票</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 共100票</span></span><br><span class="line">  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">  Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟卖票</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 同步代码块</span></span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 模拟选坐的操作</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()</span><br><span class="line">              + <span class="string">"正在卖票:"</span> + ticket--);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用了同步代码块后，上述的线程的安全问题，解决了。</p><p><strong>同步方法</strong></p><p>同步方法：在方法声明上加上synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法中的锁对象是 this</p><p>使用同步方法，对火车站卖票案例中Ticket类进行如下代码修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建票对象</span></span><br><span class="line">    Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">    <span class="comment">// 创建3个窗口</span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口2"</span>);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口3"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 模拟票</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 共100票</span></span><br><span class="line">  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">  Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟卖票</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 同步方法</span></span><br><span class="line">      method();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 同步方法,锁对象this</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 模拟选坐的操作</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖票:"</span></span><br><span class="line">          + ticket--);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized支持锁的重入吗？"><a href="#synchronized支持锁的重入吗？" class="headerlink" title="synchronized支持锁的重入吗？　　"></a><strong>synchronized支持锁的重入吗？</strong>　　</h2><p>我们先来看下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"a"</span>);</span><br><span class="line">    b();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"b"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReentrantLockDemo d = <span class="keyword">new</span> ReentrantLockDemo();</span><br><span class="line">        d.a();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码，我们分析一下，两个方法，方法a和方法b都被synchronized关键字修饰，锁对象是当前对象实例，按照上文我们对synchronized的了解，如果调用方法a,在方法a还没有执行完之前，我们是不能执行方法b的，方法a必须先释放锁，方法b才能执行，方法b处于等待状态，那样不就形成死锁了吗？那么事实真的如分析一致吗？</p><p>运行结果发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><p>代码很快就执行完了，实验结果与分析不一致，这就引入了另外一个概念：重入锁。在 java 内部，同一线程在调用自己类中其他 synchronized 方法/块或调用父类的 synchronized 方法/块都不会阻碍该线程的执行。就是说同一线程对同一个对象锁是可重入的，而且同一个线程可以获取同一把锁多次，也就是可以多次重入。在JDK1.5后对synchronized关键字做了相关优化。</p><h2 id="synchronized死锁问题"><a href="#synchronized死锁问题" class="headerlink" title="synchronized死锁问题"></a><strong>synchronized死锁问题</strong></h2><p>同步锁使用的弊端：当线程任务中出现了多个同步(多个锁)时，如果同步中嵌套了其他的同步。这时容易引发一种现象：程序出现无限等待，这种现象我们称为死锁。这种情况能避免就避免掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronzied(A锁)&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(B锁)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进行下死锁情况的代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">  Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">  Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">        System.out.println(<span class="string">"a"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">        System.out.println(<span class="string">"b"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DeadLock d = <span class="keyword">new</span> DeadLock();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        d.a();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        d.b();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码，我们分析一下，两个方法，我们假设两个线程T1,T2，T1运行到方法a了，拿到了obj1这把锁，此时T2运行到方法b了，拿到了obj2这把锁，T1要往下执行，就必须等待T2释放了obj2这把锁，线程T2要往下面执行，就必须等待T1释放了持有的obj1这把锁，他们两个互相等待，就形成了死锁。</p><p>为了演示的更明白，需要让两个方法执行过程中睡眠10ms，要不然很难看到现象，因为计算机执行速度贼快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">  Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">  Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">        System.out.println(<span class="string">"a"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">        System.out.println(<span class="string">"b"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DeadLock d = <span class="keyword">new</span> DeadLock();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        d.a();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        d.b();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感兴趣的童鞋，下去可以试一下，程序执行不完，永远处于等待状态。</p><p><strong>总结</strong></p><ul><li>sychronized是隐式锁，是JVM底层支持的关键字，由JVM来维护；</li><li>单体应用下，多线程并发操作时，使用sychronized关键字可以保证线程安全;</li><li>sychronized可以用来修饰方法和代码块，此时锁是当前对象实例，修饰静态方法时，锁是对象的class字节码文件;</li><li>一个线程进入了sychronized修饰的同步方法，得到了对象锁，其他线程还是可以访问那些没有同步的方法（普通方法）;</li><li>sychronized支持锁的重入;</li></ul><p>以上就是本文的全部内容，希望对大家的学习有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2020/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>所谓单例，就是整个程序有且仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。在Java，一般常用在工具类的实现或创建对象需要消耗资源。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>类构造器私有</li><li>持有自己类型的属性</li><li>对外提供获取实例的静态方法</li></ul><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a><strong>懒汉模式</strong></h3><p>线程不安全，延迟初始化，严格意义上不是不是单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a><strong>饿汉模式</strong></h3><p>线程安全，比较常用，但容易产生垃圾，因为一开始就初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重锁模式"><a href="#双重锁模式" class="headerlink" title="双重锁模式"></a><strong>双重锁模式</strong></h3><p>线程安全，延迟初始化。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。由于<code>singleton=new Singleton()</code>对象的创建在JVM中可能会进行重排序，在多线程访问下存在风险，使用<code>volatile</code>修饰<code>signleton</code>实例变量有效，解决该问题。</p><h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a><strong>静态内部类单例模式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Inner.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。</p><h3 id="枚举单例模式"><a href="#枚举单例模式" class="headerlink" title="枚举单例模式"></a><strong>枚举单例模式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。实际上</p><ul><li>枚举类隐藏了私有的构造器。</li><li>枚举类的域 是相应类型的一个实例对象<br>那么枚举类型日常用例是这样子的：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton  &#123;</span><br><span class="line">    INSTANCE </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//doSomething 该实例支持的行为</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//可以省略此方法，通过Singleton.INSTANCE进行操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton get <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举单例模式在《Effective Java》中推荐的单例模式之一。但枚举实例在日常开发是很少使用的，就是很简单以导致可读性较差。</p><p>在以上所有的单例模式中，推荐静态内部类单例模式。主要是非常直观，即保证线程安全又保证唯一性。<br>众所周知，单例模式是创建型模式，都会新建一个实例。那么一个重要的问题就是反序列化。当实例被写入到文件到反序列化成实例时，我们需要重写<code>readResolve</code>方法，以让实例唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap详解</title>
      <link href="/2020/04/28/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/04/28/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Map 这样的 <code>Key Value</code> 在软件开发中是非常经典的结构，常用于在内存中存放数据。</p><p>本篇主要想讨论 ConcurrentHashMap 这样一个并发容器，在正式开始之前我觉得有必要谈谈 HashMap，没有它就不会有后面的 ConcurrentHashMap。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>众所周知 HashMap 底层是基于 <code>数组 + 链表</code> 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p><h3 id="Base-1-7"><a href="#Base-1-7" class="headerlink" title="Base 1.7"></a>Base 1.7</h3><p>1.7 中的数据结构图：</p><p><img data-src="1.png" alt="1.png"></p><p>先来看看 1.7 中的实现。</p><p><img data-src="2.png" alt="2.png"></p><p>这是 HashMap 中比较核心的几个成员变量；看看分别是什么意思？</p><ol><li>初始化桶大小，因为底层是数组，所以这是数组默认的大小。</li><li>桶最大值。</li><li>默认的负载因子（0.75）</li><li><code>table</code> 真正存放数据的数组。</li><li><code>Map</code> 存放数量的大小。</li><li>桶大小，可在初始化时显式指定。</li><li>负载因子，可在初始化时显式指定。</li></ol><p>重点解释下负载因子：</p><p>由于给定的 HashMap 的容量大小是固定的，比如默认初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 <code>16 * 0.75 = 12</code> 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><p>因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗。</p><p>根据代码可以看到其实真正存放数据的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Entry&lt;K,V&gt;[] table &#x3D; (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p>这个数组，那么它又是如何定义的呢？</p><p><img data-src="3.png" alt="3.png"></p><p>Entry 是 HashMap 中的一个内部类，从他的成员变量很容易看出：</p><ul><li>key 就是写入时的键。</li><li>value 自然就是值。</li><li>开始的时候就提到 HashMap 是由数组和链表组成，所以这个 next 就是用于实现链表结构。</li><li>hash 存放的是当前 key 的 hashcode。</li></ul><p>知晓了基本结构，那来看看其中重要的写入、获取函数：</p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前数组是否需要初始化。</li><li>如果 key 为空，则 put 一个空值进去。</li><li>根据 key 计算出 hashcode。</li><li>根据计算出的 hashcode 定位出所在桶。</li><li>如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。</li><li>如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当调用 addEntry 写入 Entry 时需要判断是否需要扩容。</p><p>如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位。</p><p>而在 <code>createEntry</code> 中会将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表。</p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><p>再来看看 get 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。</li><li>判断该位置是否为链表。</li><li>不是链表就根据 <code>key、key 的 hashcode</code> 是否相等来返回值。</li><li>为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。</li><li>啥都没取到就直接返回 null 。</li></ul><h3 id="Base-1-8"><a href="#Base-1-8" class="headerlink" title="Base 1.8"></a>Base 1.8</h3><p>不知道 1.7 的实现大家看出需要优化的点没有？</p><p>其实一个很明显的地方就是：</p><blockquote><p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。</p></blockquote><p>因此 1.8 中重点优化了这个查询效率。</p><p>1.8 HashMap 结构图：</p><p><img data-src="4.png" alt="4.png"></p><p>先来看看几个核心的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span>    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 4     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> 5     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> 6     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> 7     */</span></span><br><span class="line"> <span class="number">8</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"> <span class="number">9</span></span><br><span class="line"><span class="number">10</span>    <span class="comment">/**</span></span><br><span class="line"><span class="comment">11     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">12     */</span></span><br><span class="line"><span class="number">13</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span>    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span>    <span class="comment">/**</span></span><br><span class="line"><span class="comment">20     * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">21     * for keySet() and values().</span></span><br><span class="line"><span class="comment">22     */</span></span><br><span class="line"><span class="number">23</span>    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span>    <span class="comment">/**</span></span><br><span class="line"><span class="comment">26     * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">27     */</span></span><br><span class="line"><span class="number">28</span>    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>和 1.7 大体上都差不多，还是有几个重要的区别：</p><ul><li><code>TREEIFY_THRESHOLD</code> 用于判断是否需要将链表转换为红黑树的阈值。</li><li>HashEntry 修改为 Node。</li></ul><p>Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 <code>key value hashcode next</code> 等数据。</p><p>再来看看核心方法。</p><h4 id="put-方法-1"><a href="#put-方法-1" class="headerlink" title="put 方法"></a>put 方法</h4><p>  <img data-src="5.png" alt="5.png"></p><p>看似要比 1.7 的复杂，我们一步步拆解：</p><ol><li>判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。</li><li>根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。</li><li>如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 <code>key、key 的 hashcode</code> 与写入的 key 是否相等，相等就赋值给 <code>e</code>,在第 8 步的时候会统一进行赋值及返回。</li><li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</li><li>如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。</li><li>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</li><li>如果在遍历过程中找到 key 相同时直接退出遍历。</li><li>如果 <code>e != null</code> 就相当于存在相同的 key,那就需要将值覆盖。</li><li>最后判断是否需要进行扩容。</li></ol><h4 id="get-方法-1"><a href="#get-方法-1" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>        Node&lt;K,V&gt; e;</span><br><span class="line"> <span class="number">3</span>        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line"> <span class="number">4</span>    &#125;</span><br><span class="line"> <span class="number">5</span></span><br><span class="line"> <span class="number">6</span>    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line"> <span class="number">7</span>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"> <span class="number">8</span>        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line"> <span class="number">9</span>            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">10</span>            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line"><span class="number">11</span>                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">12</span>                <span class="keyword">return</span> first;</span><br><span class="line"><span class="number">13</span>            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">14</span>                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">15</span>                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"><span class="number">16</span>                <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">17</span>                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">18</span>                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">19</span>                        <span class="keyword">return</span> e;</span><br><span class="line"><span class="number">20</span>                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="number">21</span>            &#125;</span><br><span class="line"><span class="number">22</span>        &#125;</span><br><span class="line"><span class="number">23</span>        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">24</span>    &#125;</span><br></pre></td></tr></table></figure><p>get 方法看起来就要简单许多了。</p><ul><li>首先将 key hash 之后取得所定位的桶。</li><li>如果桶为空则直接返回 null 。</li><li>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。</li><li>如果第一个不匹配，则判断它的下一个是红黑树还是链表。</li><li>红黑树就按照树的查找方式返回值。</li><li>不然就按照链表的方式遍历匹配返回值。</li></ul><p>从这两个核心方法（get/put）可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 <code>O(logn)</code>。</p><p>但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">final</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="number">2</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="number">3</span>    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="number">4</span>        <span class="meta">@Override</span></span><br><span class="line"><span class="number">5</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">6</span>            map.put(UUID.randomUUID().toString(), <span class="string">""</span>);</span><br><span class="line"><span class="number">7</span>        &#125;</span><br><span class="line"><span class="number">8</span>    &#125;).start();</span><br><span class="line"><span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure><p>但是为什么呢？简单分析下。</p><p>看过上文的还记得在 HashMap 扩容的时候会调用 <code>resize()</code> 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</p><p>如下图：</p><p><img data-src="6.png" alt="6.png"></p><p><img data-src="7.png" alt="7.png"></p><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line"> <span class="number">2</span>        <span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line"> <span class="number">3</span>            Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line"> <span class="number">4</span>            System.out.println(<span class="string">"key="</span> + next.getKey() + <span class="string">" value="</span> + next.getValue());</span><br><span class="line"> <span class="number">5</span>        &#125;</span><br><span class="line"> <span class="number">6</span></span><br><span class="line"> <span class="number">7</span> Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"> <span class="number">8</span>        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"> <span class="number">9</span>            String key = iterator.next();</span><br><span class="line"><span class="number">10</span>            System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + map.get(key));</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span>        &#125;</span><br></pre></td></tr></table></figure><p><code>强烈建议</code>使用第一种 EntrySet 进行遍历。</p><p>第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。</p><blockquote><p>简单总结下 HashMap：无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至出现死循环导致系统不可用</p></blockquote><p>因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 <code>java.util.concurrent</code> 包下，专门用于解决并发问题。</p><blockquote><p>坚持看到这里的朋友算是已经把 ConcurrentHashMap 的基础已经打牢了，下面正式开始分析。</p></blockquote><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap 同样也分为 1.7 、1.8 版，两者在实现上略有不同。</p><h3 id="Base-1-7-1"><a href="#Base-1-7-1" class="headerlink" title="Base 1.7"></a>Base 1.7</h3><p>先来看看 1.7 的实现，下面是他的结构图：</p><p><img data-src="8.png" alt="8.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4MQ?x-oss-process=image/format,png" alt="img"></p><p>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。</p><p>它的核心成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看其中 HashEntry 的组成：</p><p><img data-src="9.png" alt="9.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4Mg?x-oss-process=image/format,png" alt="img"></p><p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</p><p>原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p><p>下面也来看看核心的 <code>put get</code> 方法。</p><p>put 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。</p><p>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</p><p><img data-src="10.png" alt="10.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4Mw?x-oss-process=image/format,png" alt="img"></p><ol><li>尝试自旋获取锁。</li><li>如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li></ol><p><img data-src="11.png" alt="11.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4NA?x-oss-process=image/format,png" alt="img"></p><p>再结合图看看 put 的流程。</p><ol><li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li><li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li><li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li><li>最后会解除在 1 中所获取当前 Segment 的锁。</li></ol><p>get 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 逻辑比较简单：</p><p>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p><p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p><p>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</p><h3 id="Base-1-8-1"><a href="#Base-1-8-1" class="headerlink" title="Base 1.8"></a>Base 1.8</h3><p>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题。</p><blockquote><p>那就是查询遍历链表效率太低。</p></blockquote><p>因此 1.8 做了一些数据结构上的调整。</p><p>首先来看下底层的组成结构：</p><p><img data-src="12.png" alt="12.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4NQ?x-oss-process=image/format,png" alt="img"></p><p>看起来是不是和 1.8 HashMap 结构类似？</p><p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p><p><img data-src="13.png" alt="13.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4Ng?x-oss-process=image/format,png" alt="img"></p><p>也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。</p><p>其中的 <code>val next</code> 都用了 volatile 修饰，保证了可见性。</p><p>put 方法</p><p>重点来看看 put 函数：</p><p><img data-src="14.png" alt="14.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4Nw?x-oss-process=image/format,png" alt="img"></p><ul><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li><code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ul><p>get 方法</p><p><img data-src="15.png" alt="15.png"></p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTcyNjg4OA?x-oss-process=image/format,png" alt="img"></p><ul><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值。</li></ul><blockquote><p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code>），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完了整个 HashMap 和 ConcurrentHashMap 在 1.7 和 1.8 中不同的实现方式相信大家对他们的理解应该会更加到位。</p><p>其实这块也是面试的重点内容，通常的套路是：</p><ol><li>谈谈你理解的 HashMap，讲讲其中的 get put 过程。</li><li>1.8 做了什么优化？</li><li>是线程安全的嘛？</li><li>不安全会导致哪些问题？</li><li>如何解决？有没有线程安全的并发容器？</li><li>ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-多路查找树</title>
      <link href="/2020/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/2020/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot有哪些优点它和Spring有什么区别</title>
      <link href="/2020/04/26/SpringBoot%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%AE%83%E5%92%8CSpring%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/04/26/SpringBoot%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%AE%83%E5%92%8CSpring%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>Spring 和 Spring Boot 的区别很多新手容易搞混，从这道简单的面试题也可以很轻易试探出你的 Java 基础功底，如果连这个问题都答不上来的话，通常就没有什么下文了，因为这已经是用人单位对面试者的最低要求了，所以本课时我们就来看一下二者的区别，以及 Spring Boot 的特性。</p><p>我们本课时的面试题是，Spring 和 Spring Boot 有什么区别？Spring Boot 的优点有哪些？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>作为 Java 开发人员对 Spring 框架都很熟悉，Spring 为 Java 程序提供了全面的基础架构支持，包含了很多非常实用的功能，如 Spring JDBC、Spring AOP、Spring ORM、Spring Test 等，这些模块的出现，大大的缩短了应用程序的开发时间，同时提高了应用开发的效率。</p><p>Spring Boot 本质上是 Spring 框架的延伸和扩展，它的诞生是为了简化 Spring 框架初始搭建以及开发的过程，使用它可以不再依赖 Spring 应用程序中的 XML 配置，为更快、更高效的开发 Spring 提供更加有力的支持。Spring Boot 具体的特性如下。</p><h3 id="Spring-Boot-特性一：更快速的构建能力"><a href="#Spring-Boot-特性一：更快速的构建能力" class="headerlink" title="Spring Boot 特性一：更快速的构建能力"></a>Spring Boot 特性一：更快速的构建能力</h3><p>Spring Boot 提供了更多的 Starters 用于快速构建业务框架，Starters 可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找依赖包。</p><p>例如在 Spring 中如果要创建 Web 应用程序的最小依赖项为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而 Spring Boot 只需要一个依赖项就可以来启动和运行 Web 应用程序，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们添加了 Starter 模块支持之后，在项目的构建期，它就会把所有其他依赖项将自动添加到项目中。</p><p>这样的例子还有很多，比如测试库，如果是 Spring 项目我们通常要添加 Spring Test、JUnit、Hamcrest 和 Mockito 库；而如果是 Spring Boot 项目的话，只需要添加 spring-boot-starter-test 即可，它会自动帮我们把其他的依赖项添加到项目中。</p><p>常见的 Starters 有以下几个：</p><ul><li>spring-boot-starter-test</li><li>spring-boot-starter-web</li><li>spring-boot-starter-data-jpa</li><li>spring-boot-starter-thymeleaf</li></ul><h3 id="Spring-Boot-特性二：起步依赖"><a href="#Spring-Boot-特性二：起步依赖" class="headerlink" title="Spring Boot 特性二：起步依赖"></a>Spring Boot 特性二：起步依赖</h3><p>Spring Boot 提供了起步依赖，也就是在创建 Spring Boot 时可以直接勾选依赖模块，这样在项目初始化时就会把相关依赖直接添加到项目中，大大缩短了查询并添加依赖的时间，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><h3 id="Spring-Boot-特性三：内嵌容器支持"><a href="#Spring-Boot-特性三：内嵌容器支持" class="headerlink" title="Spring Boot 特性三：内嵌容器支持"></a>Spring Boot 特性三：内嵌容器支持</h3><p>Spring Boot 内嵌了 Tomcat、Jetty、Undertow 三种容器，其默认嵌入的容器是 Tomcat，这个在我们启动 Spring Boot 项目的时候，在控制台上就能看到，具体信息如下：</p><p>o.s.b.w.embedded.tomcat.TomcatWebServer :Tomcat started on port(s): 8080 (http) with context path ‘’</p><p>可以看出 Spring Boot 默认使用的是 Tomcat 容器启动的。</p><p>我们可以通过修改 pom.xml 来移除内嵌的 Tomcat 更换为其他的容器，比如更换为 Jetty 容器，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 移处 Tomcat --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 移处 jetty 容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们添加完成之后，再重新生成 pom.xml 文件，然后再启动 Spring Boot 项目容器信息就变了，如下所示：</p><p>o.e.jetty.server.AbstractConnector: Started ServerConnector@53f9009d{HTTP/1.1, (http/1.1)}{0.0.0.0:8080}<br>o.s.b.web.embedded.jetty.JettyWebServer</p><p>可以看出 Spring Boot 使用了我们指定的 Jetty 容器启动了。</p><h3 id="Spring-Boot-特性四：Actuator-监控"><a href="#Spring-Boot-特性四：Actuator-监控" class="headerlink" title="Spring Boot 特性四：Actuator 监控"></a>Spring Boot 特性四：Actuator 监控</h3><p>Spring Boot 自带了 Actuator 监控功能，主要用于提供对应用程序监控，以及控制的能力，比如监控应用程序的运行状况，或者内存、线程池、Http 请求统计等，同时还提供了关闭应用程序等功能。</p><p>Actuator 提供了 19 个接口，接口请求地址和代表含义如下表所示：</p><table><thead><tr><th>访问路径</th><th>描述</th></tr></thead><tbody><tr><td>/auditevents</td><td>显示应用暴露的审计事件（比如认证进入）</td></tr><tr><td>/beans</td><td>显示应用程序中所有 Spring Bean 的完整列表</td></tr><tr><td>/caches</td><td>公开可用的缓存</td></tr><tr><td>/conditions</td><td>显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因</td></tr><tr><td>/configprops</td><td>获取全部环境属性</td></tr><tr><td>/env</td><td>获取全部环境属性</td></tr><tr><td>/flyway</td><td>提供一份 Flyway 数据库迁移信息</td></tr><tr><td>/health</td><td>显示应用程序运行状况信息</td></tr><tr><td>/httptrace</td><td>显示 HTTP 跟踪信息（默认情况下，最近 100 个 HTTP 请求-响应交换）</td></tr><tr><td>/info</td><td>获取应用程序的定制信息，这些信息由 info 开头的属性提供</td></tr><tr><td>/integrationgraph</td><td>显示 Spring Integration 图，需要依赖于 spring-integration-core</td></tr><tr><td>/loggers</td><td>显示和修改应用程序的配置</td></tr><tr><td>/liquibase</td><td>显示已应用的所有 Liquibase 数据库迁移</td></tr><tr><td>/metrics/{name}</td><td>报告指定名称的应用程序度量值</td></tr><tr><td>/mappings</td><td>显示所有 @RequestMapping 路径的列表</td></tr><tr><td>/scheduledtasks</td><td>显示应用程序中的计划任务</td></tr><tr><td>/sessions</td><td>允许从 Spring Session 支持的会话存储中检索和删除用户会话，需要使用 Spring Session 基于 Servlet 的 Web 应用程序</td></tr><tr><td>/shutdown</td><td>使应用程序正常关闭，默认禁用</td></tr><tr><td>/threaddump</td><td>获取线程活动的快照</td></tr></tbody></table><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>很多人都知道 Spring Boot 是基于 Spring 的，使用它可以更加快速高效的构建 Spring，然而当面试官问到 Spring Boot 是如何高效构建 Spring 时，可能大部分人回答不上来了，上面讲解的 Spring Boot 四大特性基本涵盖了此问题的答案。如果面试官继续追问更深的细节的话，可能会问到关于 Spring Boot 执行的源码细节，比如 Spring Boot 的启动流程是怎么样的？</p><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="Spring-Boot-启动源码分析"><a href="#Spring-Boot-启动源码分析" class="headerlink" title="Spring Boot 启动源码分析"></a>Spring Boot 启动源码分析</h3><p>我们知道 Spring Boot 程序的入口是 SpringApplication.run(Application.class, args) 方法，那么就从 run() 方法开始分析吧，它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建并启动计时监控类</span></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="comment">// 2.声明应用上下文对象和异常报告集合</span></span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">// 3.设置系统属性 headless 的值</span></span><br><span class="line">    <span class="keyword">this</span>.configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 4.创建所有 Spring 运行监听器并发布应用启动事件</span></span><br><span class="line">    SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    Collection exceptionReporters;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 5.处理 args 参数</span></span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">// 6.准备环境</span></span><br><span class="line">        ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">// 7.创建 Banner 的打印类</span></span><br><span class="line">        Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</span><br><span class="line">        <span class="comment">// 8.创建应用上下文</span></span><br><span class="line">        context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">        <span class="comment">// 9.实例化异常报告器</span></span><br><span class="line">        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        <span class="comment">// 10.准备应用上下文</span></span><br><span class="line">        <span class="keyword">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">// 11.刷新应用上下文</span></span><br><span class="line">        <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">        <span class="comment">// 12.应用上下文刷新之后的事件的处理</span></span><br><span class="line">        <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">// 13.停止计时监控类</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="comment">// 14.输出日志记录执行主类名、时间信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 15.发布应用上下文启动完成事件</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">// 16.执行所有 Runner 运行器</span></span><br><span class="line">        <span class="keyword">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var10);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 17.发布应用上下文就绪事件</span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">        <span class="comment">// 18.返回应用上下文对象</span></span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出 Spring Boot 的启动总共分为以下 18 个步骤。</p><h3 id="Spring-Boot-的启动流程"><a href="#Spring-Boot-的启动流程" class="headerlink" title="Spring Boot 的启动流程"></a>Spring Boot 的启动流程</h3><h4 id="1-创建并启动计时监控类"><a href="#1-创建并启动计时监控类" class="headerlink" title="1.创建并启动计时监控类"></a>1.创建并启动计时监控类</h4><p>此计时器是为了监控并记录 Spring Boot 应用启动的时间的，它会记录当前任务的名称，然后开启计时器。</p><h4 id="2-声明应用上下文对象和异常报告集合"><a href="#2-声明应用上下文对象和异常报告集合" class="headerlink" title="2.声明应用上下文对象和异常报告集合"></a>2.声明应用上下文对象和异常报告集合</h4><p>此过程声明了应用上下文对象和一个异常报告的 ArrayList 集合。</p><h4 id="3-设置系统属性-headless-的值"><a href="#3-设置系统属性-headless-的值" class="headerlink" title="3.设置系统属性 headless 的值"></a>3.设置系统属性 headless 的值</h4><p>设置 Java.awt.headless = true，其中 awt（Abstract Window Toolkit）的含义是抽象窗口工具集。设置为 true 表示运行一个 headless 服务器，可以用它来作一些简单的图像处理。</p><h4 id="4-创建所有-Spring-运行监听器并发布应用启动事件"><a href="#4-创建所有-Spring-运行监听器并发布应用启动事件" class="headerlink" title="4.创建所有 Spring 运行监听器并发布应用启动事件"></a>4.创建所有 Spring 运行监听器并发布应用启动事件</h4><p>此过程用于获取配置的监听器名称并实例化所有的类。</p><h4 id="5-初始化默认应用的参数类"><a href="#5-初始化默认应用的参数类" class="headerlink" title="5.初始化默认应用的参数类"></a>5.初始化默认应用的参数类</h4><p>也就是说声明并创建一个应用参数对象。</p><h4 id="6-准备环境"><a href="#6-准备环境" class="headerlink" title="6.准备环境"></a>6.准备环境</h4><p>创建配置并且绑定环境（通过 property sources 和 profiles 等配置文件）。</p><h4 id="7-创建-Banner-的打印类"><a href="#7-创建-Banner-的打印类" class="headerlink" title="7.创建 Banner 的打印类"></a>7.创建 Banner 的打印类</h4><p>Spring Boot 启动时会打印 Banner 图片，如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><p>此 banner 信息是在 SpringBootBanner 类中定义的，我们可以通过实现 Banner 接口来自定义 banner 信息，然后通过代码 setBanner() 方法设置 Spring Boot 项目使用自己自定义 Banner 信息，或者是在 resources 下添加一个 banner.txt，把 banner 信息添加到此文件中，就可以实现自定义 banner 的功能了。</p><h4 id="8-创建应用上下文"><a href="#8-创建应用上下文" class="headerlink" title="8.创建应用上下文"></a>8.创建应用上下文</h4><p>根据不同的应用类型来创建不同的 ApplicationContext 上下文对象。</p><h4 id="9-实例化异常报告器"><a href="#9-实例化异常报告器" class="headerlink" title="9.实例化异常报告器"></a>9.实例化异常报告器</h4><p>它调用的是 getSpringFactoriesInstances() 方法来获取配置异常类的名称，并实例化所有的异常处理类。</p><h4 id="10-准备应用上下文"><a href="#10-准备应用上下文" class="headerlink" title="10.准备应用上下文"></a>10.准备应用上下文</h4><p>此方法的主要作用是把上面已经创建好的对象，传递给 prepareContext 来准备上下文，例如将环境变量 environment 对象绑定到上下文中、配置 bean 生成器以及资源加载器、记录启动日志等操作。</p><h4 id="11-刷新应用上下文"><a href="#11-刷新应用上下文" class="headerlink" title="11.刷新应用上下文"></a>11.刷新应用上下文</h4><p>此方法用于解析配置文件，加载 bean 对象，并且启动内置的 web 容器等操作。</p><h4 id="12-应用上下文刷新之后的事件处理"><a href="#12-应用上下文刷新之后的事件处理" class="headerlink" title="12.应用上下文刷新之后的事件处理"></a>12.应用上下文刷新之后的事件处理</h4><p>这个方法的源码是空的，可以做一些自定义的后置处理操作。</p><h4 id="13-停止计时监控类"><a href="#13-停止计时监控类" class="headerlink" title="13.停止计时监控类"></a>13.停止计时监控类</h4><p>停止此过程第一步中的程序计时器，并统计任务的执行信息。</p><h4 id="14-输出日志信息"><a href="#14-输出日志信息" class="headerlink" title="14.输出日志信息"></a>14.输出日志信息</h4><p>把相关的记录信息，如类名、时间等信息进行控制台输出。</p><h4 id="15-发布应用上下文启动完成事件"><a href="#15-发布应用上下文启动完成事件" class="headerlink" title="15.发布应用上下文启动完成事件"></a>15.发布应用上下文启动完成事件</h4><p>触发所有 SpringApplicationRunListener 监听器的 started 事件方法。</p><h4 id="16-执行所有-Runner-运行器"><a href="#16-执行所有-Runner-运行器" class="headerlink" title="16.执行所有 Runner 运行器"></a>16.执行所有 Runner 运行器</h4><p>执行所有的 ApplicationRunner 和 CommandLineRunner 运行器。</p><h4 id="17-发布应用上下文就绪事件"><a href="#17-发布应用上下文就绪事件" class="headerlink" title="17.发布应用上下文就绪事件"></a>17.发布应用上下文就绪事件</h4><p>触发所有的 SpringApplicationRunListener 监听器的 running 事件。</p><h4 id="18-返回应用上下文对象"><a href="#18-返回应用上下文对象" class="headerlink" title="18.返回应用上下文对象"></a>18.返回应用上下文对象</h4><p>到此为止 Spring Boot 的启动程序就结束了，我们就可以正常来使用 Spring Boot 框架了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本课时首先讲了 Spring 和 Spring Boot 的区别，Spring Boot 本质上是 Spring 的延伸，它是基于 Spring 的，它为快速构建和开发 Spring 提供了有力的支撑；接着介绍了 Spring Boot 的四大特性：更快速的构建能力、起步依赖、内嵌容器支持、Actuator 监控支持等，最后 还介绍了 Spring Boot 启动的 18 个步骤。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试真题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis使用了哪些设计模式在源码中是如何体现的</title>
      <link href="/2020/04/26/MyBatis%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%BA%90%E7%A0%81%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%E7%9A%84/"/>
      <url>/2020/04/26/MyBatis%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%BA%90%E7%A0%81%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>MyBatis 的前身是 IBatis，IBatis 是由 Internet 和 Abatis 组合而成，其目的是想当做互联网的篱笆墙，围绕着数据库提供持久化服务的一个框架，2010 年正式改名为 MyBatis。它是一款优秀的持久层框架，支持自定义 SQL、存储过程及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作，还可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><p>关于 MyBatis 的介绍与使用，官方已经提供了比较详尽的中文参考文档，可点击这里查看，而本课时则以面试的角度出发，聊一聊不一样的知识点，它也是 MyBatis 比较热门的面试题之一，MyBatis 使用了哪些设计模式？在源码中是如何体现的？</p><p><strong>注意：本课时使用的 MyBatis 源码为 3.5.5。</strong></p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h3><p>工厂模式想必都比较熟悉，它是 Java 中最常用的设计模式之一。工厂模式就是提供一个工厂类，当有客户端需要调用的时候，只调用这个工厂类就可以得到自己想要的结果，从而无需关注某类的具体实现过程。这就好比你去餐馆吃饭，可以直接点菜，而不用考虑厨师是怎么做的。</p><p>工厂模式在 MyBatis 中的典型代表是 SqlSessionFactory。</p><p>SqlSession 是 MyBatis 中的重要 Java 接口，可以通过该接口来执行 SQL 命令、获取映射器示例和管理事务，而 SqlSessionFactory 正是用来产生 SqlSession 对象的，所以它在 MyBatis 中是比较核心的接口之一。</p><p>工厂模式应用解析：SqlSessionFactory 是一个接口类，它的子类 DefaultSqlSessionFactorys 有一个 openSession(ExecutorType execType) 的方法，其中使用了工厂模式，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">        <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        closeTransaction(tx); </span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从该方法我们可以看出它会 configuration.newExecutor(tx, execType) 读取对应的环境配置，而此方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 newExecutor() 方法为标准的工厂模式，它会根据传递 ExecutorType 值生成相应的对象然后进行返回。</p><h3 id="2-建造者模式（Builder）"><a href="#2-建造者模式（Builder）" class="headerlink" title="2.建造者模式（Builder）"></a>2.建造者模式（Builder）</h3><p>建造者模式指的是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。也就是说建造者模式是通过多个模块一步步实现了对象的构建，相同的构建过程可以创建不同的产品。</p><p>例如，组装电脑，最终的产品就是一台主机，然而不同的人对它的要求是不同的，比如设计人员需要显卡配置高的；而影片爱好者则需要硬盘足够大的（能把视频都保存起来），但对于显卡却没有太大的要求，我们的装机人员根据每个人不同的要求，组装相应电脑的过程就是<strong>建造者模式</strong>。</p><p>建造者模式在 MyBatis 中的典型代表是 SqlSessionFactoryBuilder。</p><p>普通的对象都是通过 new 关键字直接创建的，但是如果创建对象需要的构造参数很多，且不能保证每个参数都是正确的或者不能一次性得到构建所需的所有参数，那么就需要将构建逻辑从对象本身抽离出来，让对象只关注功能，把构建交给构建类，这样可以简化对象的构建，也可以达到分步构建对象的目的，而 SqlSessionFactoryBuilder 的构建过程正是如此。</p><p>在 SqlSessionFactoryBuilder 中构建 SqlSessionFactory 对象的过程是这样的，首先需要通过 XMLConfigBuilder 对象读取并解析 XML 的配置文件，然后再将读取到的配置信息存入到 Configuration 类中，然后再通过 build 方法生成我们需要的 DefaultSqlSessionFactory 对象，实现源码如下（在 SqlSessionFactoryBuilder 类中）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">        <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlSessionFactoryBuilder 类相当于一个建造工厂，先读取文件或者配置信息、再解析配置、然后通过反射生成对象，最后再把结果存入缓存，这样就一步步构建造出一个 SqlSessionFactory 对象。</p><h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，此模式保证某个类在运行期间，只有一个实例对外提供服务，而这个类被称为<strong>单例类</strong>。</p><p>单例模式也比较好理解，比如一个人一生当中只能有一个真实的身份证号，每个收费站的窗口都只能一辆车子一辆车子的经过，类似的场景都是属于<strong>单例模式</strong>。</p><p>单例模式在 MyBatis 中的典型代表是 ErrorContext。</p><p>ErrorContext 是线程级别的的单例，每个线程中有一个此对象的单例，用于记录该线程的执行环境的错误信息。</p><p>ErrorContext 的实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.lineSeparator();</span><br><span class="line">  <span class="comment">// 每个线程存储的容器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ErrorContext&gt; LOCAL = ThreadLocal.withInitial(ErrorContext::<span class="keyword">new</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorContext <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LOCAL.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 忽略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 ErrorContext 使用 private 修饰的 ThreadLocal 来保证每个线程拥有一个 ErrorContext 对象，在调用 instance() 方法时再从 ThreadLocal 中获取此单例对象。</p><h3 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="4.适配器模式"></a>4.适配器模式</h3><p>适配器模式是指将一个不兼容的接口转换成另一个可以兼容的接口，这样就可以使那些不兼容的类可以一起工作。</p><p>例如，最早之前我们用的耳机都是圆形的，而现在大多数的耳机和电源都统一成了方形的 typec 接口，那之前的圆形耳机就不能使用了，只能买一个适配器把圆形接口转化成方形的，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p>而这个转换头就相当于程序中的适配器模式，适配器模式在 MyBatis 中的典型代表是 Log。</p><p>MyBatis 中的日志模块适配了以下多种日志类型：</p><ul><li>SLF4J</li><li>Apache Commons Logging</li><li>Log4j 2</li><li>Log4j</li><li>JDK logging</li></ul><p>首先 MyBatis 定义了一个 Log 的接口，用于统一和规范接口的行为，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 MyBatis 定义了多个适配接口，例如 Log4j2 实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4j2Impl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Log log;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Log4j2Impl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">    Logger logger = LogManager.getLogger(clazz);</span><br><span class="line">    <span class="keyword">if</span> (logger <span class="keyword">instanceof</span> AbstractLogger) &#123;</span><br><span class="line">      log = <span class="keyword">new</span> Log4j2AbstractLoggerImpl((AbstractLogger) logger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log = <span class="keyword">new</span> Log4j2LoggerImpl(logger);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">    log.error(s, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.error(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.debug(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.trace(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.warn(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当你项目中添加了 Log4j2 时，MyBatis 就可以直接使用它打印 MyBatis 的日志信息了。Log 的所有子类如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><h3 id="5-代理模式"><a href="#5-代理模式" class="headerlink" title="5.代理模式"></a>5.代理模式</h3><p>代理模式指的是给某一个对象提供一个代理对象，并由代理对象控制原对象的调用。</p><p>代理模式在生活中也比较常见，比如我们常见的超市、小卖店其实都是一个个“代理”，他们的最上游是一个个生产厂家，他们这些代理负责把厂家生产出来的产品卖出去。</p><p>代理模式在 MyBatis 中的典型代表是 MapperProxyFactory。</p><p>MapperProxyFactory 的 newInstance() 方法就是生成一个具体的代理来实现功能的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethodInvoker&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethodInvoker&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建代理类</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-模板方法模式"><a href="#6-模板方法模式" class="headerlink" title="6.模板方法模式"></a>6.模板方法模式</h3><p>模板方法模式是最常用的设计模式之一，它是指定义一个操作算法的骨架，而将一些步骤的实现延迟到子类中去实现，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。此模式是基于继承的思想实现代码复用的。</p><p>例如，我们喝茶的一般步骤都是这样的：</p><ul><li>把热水烧开</li><li>把茶叶放入壶中</li><li>等待一分钟左右</li><li>把茶倒入杯子中</li><li>喝茶</li></ul><p>整个过程都是固定的，唯一变的就是泡入茶叶种类的不同，比如今天喝的是绿茶，明天可能喝的是红茶，那么我们就可以把流程定义为一个模板，而把茶叶的种类延伸到子类中去实现，这就是模板方法的实现思路。</p><p>模板方法在 MyBatis 中的典型代表是 BaseExecutor。</p><p>在 MyBatis 中 BaseExecutor 实现了大部分 SQL 执行的逻辑，然后再把几个方法交给子类来实现，它的继承关系如下图所示：</p><p><img data-src="3.png" alt="3.png"></p><p>比如 doUpdate() 就是交给子类自己去实现的，它在 BaseExecutor 中的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>在 SimpleExecutor 中的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(configuration, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 忽略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 SimpleExecutor 每次使用完 Statement 对象之后，都会把它关闭掉，而 ReuseExecutor 中的实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Statement&gt; statementMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReuseExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(configuration, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    Statement stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 忽略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，ReuseExecutor 每次使用完 Statement 对象之后不会把它关闭掉。</p><h3 id="7-装饰器模式"><a href="#7-装饰器模式" class="headerlink" title="7.装饰器模式"></a>7.装饰器模式</h3><p>装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构，这种类型的设计模式属于结构型模式，它是作为现有类的一个包装。</p><p>装饰器模式在生活中很常见，比如装修房子，我们在不改变房子结构的同时，给房子添加了很多的点缀；比如安装了天然气报警器，增加了热水器等附加的功能都属于装饰器模式。</p><p>装饰器模式在 MyBatis 中的典型代表是 Cache。</p><p>Cache 除了有数据存储和缓存的基本功能外（由 PerpetualCache 永久缓存实现），还有其他附加的 Cache 类，比如先进先出的 FifoCache、最近最少使用的 LruCache、防止多线程并发访问的 SynchronizedCache 等众多附加功能的缓存类，Cache 所有实现子类如下图所示：</p><p><img data-src="4.png" alt="4.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本课时我们重点讲了 MyBatis 源码中的几个主要设计模式，即工厂模式、建造者模式、单例模式、适配器模式、代理模式、模板方法模式等，希望本课时的内容能起到抛砖引玉的作用，对你理解设计模式和 MyBatis 提供一些帮助，如果想要阅读全部的 MyBatis 源码可以访问：<a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试真题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说自己是怎么使用synchronized关键字在项目中用到了吗</title>
      <link href="/2020/04/26/%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%90%97/"/>
      <url>/2020/04/26/%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%90%97/</url>
      
        <content type="html"><![CDATA[<p><img data-src="1.png" alt="1.png"></p><h3 id="synchronized关键字最主要的三种使用方式的总结"><a href="#synchronized关键字最主要的三种使用方式的总结" class="headerlink" title="synchronized关键字最主要的三种使用方式的总结"></a>synchronized关键字最主要的三种使用方式的总结</h3><ul><li><strong>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</strong></li><li><strong>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</strong> 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</strong> 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</li></ul><p>下面我已一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题整理</title>
      <link href="/2020/04/26/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2020/04/26/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="JAVA基础部分"><a href="#JAVA基础部分" class="headerlink" title="JAVA基础部分"></a><strong>JAVA基础</strong>部分</h2><h3 id="1-Java中的String，StringBuilder，StringBuffer三者的区别"><a href="#1-Java中的String，StringBuilder，StringBuffer三者的区别" class="headerlink" title="1.Java中的String，StringBuilder，StringBuffer三者的区别"></a>1.<strong>Java中的String，StringBuilder，StringBuffer三者的区别</strong></h3><p>执行速度：StringBuilder &gt; StringBuffer &gt; String<br>String：适用于少量的字符串操作的情况<br>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p><h3 id="2-Hashtable和HashMap的区别："><a href="#2-Hashtable和HashMap的区别：" class="headerlink" title="2.Hashtable和HashMap的区别："></a><strong>2.Hashtable和HashMap的区别：</strong></h3><p>a) 继承不同。 </p><p>public class Hashtable extends Dictionary implements Map </p><p>public class HashMap extends AbstractMap implements Map<br>b) Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。<br>c) Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。<strong>因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断。</strong><br>d) 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。<br>e) 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。<br>f) Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。<strong>HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</strong><br>注： HashSet子类依靠hashCode()和equal()方法来区分重复元素。 HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。</p><h3 id="3-乐观锁和悲观锁"><a href="#3-乐观锁和悲观锁" class="headerlink" title="3.乐观锁和悲观锁"></a>3.乐观锁和悲观锁</h3><p><strong>悲观锁</strong><br>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<strong>synchronized</strong>和<strong>ReentrantLock</strong>等独占锁就是悲观锁思想的实现。<br><strong>乐观锁</strong><br>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。<br><strong>两种锁的使用场景</strong><br>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，<strong>像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量</strong>。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p><h3 id="4-java的8种基本数据类型"><a href="#4-java的8种基本数据类型" class="headerlink" title="4.java的8种基本数据类型"></a>4.java的8种基本数据类型</h3><p>四种整数类型(byte、short、int、long)、两种浮点数类型(float、double)、一种字符类型(char)、一种布尔类型(boolean)<br>类型转换： char–&gt; 自动转换：byte–&gt;short–&gt;int–&gt;long–&gt;float–&gt;double 强制转换：①会损失精度，产生误差，小数点以后的数字全部舍弃。②容易超过取值范围。</p><h3 id="5-synchronized和Lock有什么区别？"><a href="#5-synchronized和Lock有什么区别？" class="headerlink" title="5.synchronized和Lock有什么区别？"></a>5.<strong>synchronized和Lock有什么区别？</strong></h3><p>①:synchronized是JVM层面实现的，java提供的关键字，Lock是API层面的锁。</p><p>②: synchronized不需要手动释放锁，底层会自动释放，</p><p>​        Lock则需要手动释放锁，否则有可能导致死锁</p><p> ③:synchronized等待不可中断，除非抛出异常或者执行完成</p><p>​      Lock可以中断，通过interrupt()可中断</p><p> ④: synchronized是非公平锁</p><p>​       Lock是默认公平锁，当传入false时是非公平锁</p><p>  ⑤:synchronized不可绑定多个条件</p><p>​        Lock可实现分组唤醒需要唤醒的锁</p><h3 id="6-请说明一下JAVA中反射的实现过程和作用分别是什么？"><a href="#6-请说明一下JAVA中反射的实现过程和作用分别是什么？" class="headerlink" title="6.请说明一下JAVA中反射的实现过程和作用分别是什么？"></a>6.请说明一下JAVA中反射的实现过程和作用分别是什么？</h3><p>JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。反射的实现主要借助以下四个类：Class：类的对象，Constructor：类的构造方法，Field：类中的属性对象，Method：类中的方法对象。</p><p>作用：反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，只要给定类的名字，那么就可以通过反射机制来获取类的所有信息。</p><h3 id="7-请你介绍一下map的分类和常见的情况"><a href="#7-请你介绍一下map的分类和常见的情况" class="headerlink" title="7.请你介绍一下map的分类和常见的情况"></a>7.请你介绍一下map的分类和常见的情况</h3><p>java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap.</p><p><strong>Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。</strong></p><p>Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 <strong>HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;</strong>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</p><p>Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:<strong>它不允许记录的键或者值为空;它支持线程的同步</strong>，<strong>即任一时刻只有一个线程能写Hashtable</strong>,因此也导致了 <strong>Hashtable在写入时会比较慢</strong>。</p><p><strong>LinkedHashMap 是HashMap的一个子类</strong>，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</p><p><strong>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</strong></p><p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p><h3 id="8-说说-synchronized-关键字和-volatile-关键字的区别？"><a href="#8-说说-synchronized-关键字和-volatile-关键字的区别？" class="headerlink" title="8.说说 synchronized 关键字和 volatile 关键字的区别？"></a>8.说说 synchronized 关键字和 volatile 关键字的区别？</h3><p>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</p><p>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</p><p>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p><p>volatile关键字是线程同步的轻量级实现。所以volatile性能肯定比synchronized关键字要好。但是volatile关 键字只能用于变量而synchronized关键字可以修饰方法以及代码块。</p><p>synchronized关键字在JavaSE1.6之后进 行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行 效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</p><p>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞 volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</p><p>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访 问资源的同步性。 </p><h3 id="9-hashCode-与-equals-？为什么重写equals时必须重写hashCode方法？"><a href="#9-hashCode-与-equals-？为什么重写equals时必须重写hashCode方法？" class="headerlink" title="9.hashCode 与 equals ？为什么重写equals时必须重写hashCode方法？"></a>9.hashCode 与 equals ？为什么重写equals时必须重写hashCode方法？</h3><h4 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h4><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个int整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。<strong>hashCode() 在散列表中才有用，在其它情况下没用</strong>。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><h4 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h4><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h3 id="10-面向对象的特征有哪些方面"><a href="#10-面向对象的特征有哪些方面" class="headerlink" title="10.面向对象的特征有哪些方面"></a>10.面向对象的特征有哪些方面</h3><p>有四大基本特征:<strong>封装、抽象、继承、多态</strong></p><p>​      面向对象的<strong>封装</strong>性，即将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。</p><p>张三这个人，他的姓名等属性，要有自己提供的获取或改变的方法来操作。private name setName getName</p><p>​      <strong>抽象</strong>就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。 <strong>就是把现实生活中的对象，抽象为类。</strong></p><p>在定义和实现一个类的时候，<strong>可以在一个已经存在的类的基础之上来进行</strong>，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是<strong>继承</strong>。遗产继承</p><p><strong>多态</strong>是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>Object obj = new xxx();</p><p>UserDao userDao = new UserDaoJdbcImpl();</p><p>UserDao userDao = new UserDaoHibernateImpl();</p><p>靠的是<strong>父类或接口定义的引用变量可以指向子类或具体实现类的实例对象</strong>，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。  </p><p><strong>原则：回答比较抽象问题的时候，要举例说明</strong></p><h3 id="11-有了基本数据类型，为什么还需要包装类型？"><a href="#11-有了基本数据类型，为什么还需要包装类型？" class="headerlink" title="11.有了基本数据类型，为什么还需要包装类型？"></a>11.有了基本数据类型，为什么还需要包装类型？</h3><p>基本数据类型，java中提供了8中基本的数据类型。boolean int float等</p><p>包装类型：每一个基本的数据类型都会一一对应一个包装类型。</p><p>boolean —–&gt;Boolean</p><p>Int ——–&gt;Integer</p><h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><p><strong>装箱</strong>：<strong>把基本的数据类型转换成对应的包装类型.</strong></p><p>Integer .valueOf(1)</p><p>Integer i = 1;自动装箱，实际上在编译时会调用Integer .valueOf方法来装箱</p><p><strong>拆箱</strong>：<strong>就是把包装类型转换为基本数据类型.基本数据类型 名称 = 对应的包装类型。</strong></p><p>Integer i = 1;</p><p>int j = i;//自动拆箱//int j = i=intValue();手动拆箱</p><p>自动拆箱：实际上会在编译调用intValue</p><p>为什么：</p><p><strong>Java是一个面向对象的语言，而基本的数据类型，不具备面向对象的特性。</strong></p><p>null Integer—&gt;null int—-&gt;0 用Integer和int分别表示Person这个类的ID</p><p>Max 最大值</p><p>min 最小值</p><p>缓存值:对象缓存,Integer i=1; integer j= 1;i ==j  常量池</p><h3 id="12-说一下”-”和equals方法究竟有什么区别？"><a href="#12-说一下”-”和equals方法究竟有什么区别？" class="headerlink" title="12.说一下”==”和equals方法究竟有什么区别？"></a>12.说一下”==”和equals方法究竟有什么区别？</h3><p>非常经典的一个面试题？先说清楚一个，再来说另一个？</p><p>==用来判断两个变量之间的的值是否相等。变量就可以分为基本数据类型变量，引用类型。</p><p><strong>如果是基本数据类型的变量直接比较值而引用类型要比较对应的引用的内存的首地址。</strong></p><p><img data-src="1.png" alt="1.png"></p><p>equals 用来比较两个对象长得是否一样。判断两个对象的某些特征是否一样。实际上就是调用对象的equals方法进行比较。</p><h3 id="13-讲一下String和StringBuilder的区别-final-？StringBuffer和StringBuilder的区别"><a href="#13-讲一下String和StringBuilder的区别-final-？StringBuffer和StringBuilder的区别" class="headerlink" title="13.讲一下String和StringBuilder的区别(final)？StringBuffer和StringBuilder的区别?"></a>13.讲一下String和StringBuilder的区别(final)？StringBuffer和StringBuilder的区别?</h3><p>String 不可变 StringBuilder StringBuff 是可变的 StringBuffer是线程安全得多 StringBuilder不是线程安全的。</p><p>1.在java中提供三个类String StringBuillder StringBuffer来表示和操作字符串。字符串就是多个字符的集合。</p><p><strong>String是内容不可变的字符串</strong>。String底层使用了一个不可变的字符数组(final char[])</p><p>String str =new String(“bbbb”);</p><p><img data-src="2.png" alt="2.png"></p><p><strong>而StringBuillder StringBuffer,是内容可以改变的字符串</strong>。StringBuillder StringBuffer底层使用的可变的字符数<br>组（没有使用final来修饰） </p><p><img data-src="3.png" alt="3.png"></p><p>2.最经典就是拼接字符串。</p><p>1、String进行拼接.String c = “a”+”b”;</p><p>2、StringBuilder或者StringBuffer </p><p>StringBuilder sb = new StringBuilder(); sb.apend(“a”).apend(“b”) </p><p>拼接字符串不能使用String进行拼接，要使用StringBuilder或者StringBuffer。 </p><p>3.StringBuilder是线程不安全的，效率较高，而StringBuffer是线程安全的，效率较低。</p><h3 id="14-讲一下java中的集合"><a href="#14-讲一下java中的集合" class="headerlink" title="14.讲一下java中的集合?"></a>14.讲一下java中的集合?</h3><p>Java中的集合分为value，key–vale(Conllection Map)两种。</p><p>存储值有分为<strong>List</strong> 和<strong>Set</strong>.</p><p>List是有序的，可以重复的。</p><p>Set是无序的，不可以重复的。根据equals和hashcode判断，也就是如果</p><p><strong>一个对象要存储在Set中，必须重写equals和hashCode方法。</strong></p><p>存储key-value的为map.</p><h4 id="List又分为两种："><a href="#List又分为两种：" class="headerlink" title="List又分为两种："></a><strong>List又分为两种：</strong></h4><p><strong>ArrayList和LinkedList的区别?</strong></p><p>List常用的ArrayList和LinkedList。区别和使用场景?</p><p>ArrayList底层使用时<strong>数组</strong>。LinkedList底层使用的是<strong>链表</strong>。</p><p>数组查询具有所有<strong>查询</strong>特定元素比较<strong>快</strong>。而<strong>插入和删除和修改比较慢(</strong>数组在内存中是一块连续的内存，如果插入或删除是需要移动内=存)。</p><p>链表不要求内存是连续的，在当前元素中存放下一个或上一个元素的地址。<strong>查询时需要从头部开始，一个一个的找。所以查询效率低</strong>。<strong>插入时不需要移动内存，只需改变引用指向即可。所以插入或者删除的效率高</strong>。 </p><p><strong>ArrayList使用在查询比较多，但是插入和删除比较少的情况，而LinkedList使用在查询比较少而插入和删除比较多的情况。</strong></p><h3 id="15-讲一下HashMap哈HashTable的区别-HashTable和ConcurrentHashMap的区别"><a href="#15-讲一下HashMap哈HashTable的区别-HashTable和ConcurrentHashMap的区别" class="headerlink" title="15.讲一下HashMap哈HashTable的区别?HashTable和ConcurrentHashMap的区别?"></a>15.讲一下HashMap哈HashTable的区别?HashTable和ConcurrentHashMap的区别?</h3><p>相同点：HashMap和HasheTalbe都可以使用来存储key–value的数据。</p><p>区别：</p><p>1、HashMap是可以把null作为key或者value的，而HashTable是不可以的。</p><p>2、HashMap是线程不安全的，效率较高。而HashTalbe是线程安全的，效率较低。</p><p> 线程安全但是我又想效率高？</p><p>通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</p><h3 id="16-讲一下线程的几种实现方式-启动方式？区分方式？"><a href="#16-讲一下线程的几种实现方式-启动方式？区分方式？" class="headerlink" title="16.讲一下线程的几种实现方式?启动方式？区分方式？"></a>16.讲一下线程的几种实现方式?启动方式？区分方式？</h3><h4 id="①实现方式"><a href="#①实现方式" class="headerlink" title="①实现方式"></a>①实现方式</h4><p>1、<strong>通过继承Thread类实现一个线程</strong></p><p>2、<strong>通过实现Runnable接口实现一个线程</strong></p><p>   继承扩展性不强，java总只支持单继承，如果一个类继承Thread就不能继承其他的类了。</p><h4 id="②怎么启动？"><a href="#②怎么启动？" class="headerlink" title="②怎么启动？"></a>②怎么启动？</h4><p>   Thread thread = new Thread(继承了Thread的对象/实现了Runnable的对象)</p><p>   thread.setName(“设置一个线程名称”);</p><p>   thread.start();</p><p>   启动线程使用start方法，而启动了以后执行的是run方法。</p><h4 id="③怎么区分线程？在一个系统中有很多线程，每个线程都会打印日志，我想区分是哪个线程打印的怎么办？"><a href="#③怎么区分线程？在一个系统中有很多线程，每个线程都会打印日志，我想区分是哪个线程打印的怎么办？" class="headerlink" title="③怎么区分线程？在一个系统中有很多线程，每个线程都会打印日志，我想区分是哪个线程打印的怎么办？"></a>③怎么区分线程？在一个系统中有很多线程，每个线程都会打印日志，我想区分是哪个线程打印的怎么办？</h4><p>   thread.setName(“设置一个线程名称”); 这是一种规范，在创建线程完成后，都需要设置名称。</p><h3 id="17-有没有使用过线程并发库"><a href="#17-有没有使用过线程并发库" class="headerlink" title="17.有没有使用过线程并发库?"></a>17.有没有使用过线程并发库?</h3><p>简单了解过？</p><p>JDK5中增加了Doug Lea的并发库，这一引进给Java线程的管理和使用提供了强大的便利性。 java.util.current包中提供了对线程优化、管理的各项操作，使得线程的使用变得的心应手。该包提供了线程的运行，线程池的创建，线程生命周期的控制.</p><p><strong>Java通过Executors提供四个静态方法创建四种线程池</strong>，分别为：</p><p><strong>newCachedThreadPool</strong>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p><strong>newFixedThreadPool</strong> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p><strong>newScheduledThreadPool</strong> 创建一个定长线程池，支持定时及周期性任务执行。</p><p><strong>newSingleThreadExecutor</strong> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p><h3 id="18-线程池的作用？"><a href="#18-线程池的作用？" class="headerlink" title="18.线程池的作用？"></a>18.线程池的作用？</h3><p>1、限定线程的个数，不会导致由于线程过多导致系统运行缓慢或崩溃</p><p>2、线程池不需要每次都去创建或销毁，节约了资源、</p><p>3、线程池不需要每次都去创建，响应时间更快。</p><p>连接池也是一样</p><h3 id="19-讲一下什么是设计模式？常用的设计模式有哪些？"><a href="#19-讲一下什么是设计模式？常用的设计模式有哪些？" class="headerlink" title="19.讲一下什么是设计模式？常用的设计模式有哪些？"></a>19.讲一下什么是设计模式？常用的设计模式有哪些？</h3><p>设计模式就是<strong>经过前人无数次的实践总结出的</strong>，设计过程中可以反复使用的、可以解决特定问题的<strong>设计方法</strong>。</p><h4 id="单例-饿汉模式、懒汉模式"><a href="#单例-饿汉模式、懒汉模式" class="headerlink" title="单例(饿汉模式、懒汉模式)"></a>单例(饿汉模式、懒汉模式)</h4><p>1、构造方法私有化，除了自己类中能创建外其他地方都不能创建</p><p>2、在自己的类中创建一个单实例（<strong>饿汉模式是一出来就创建创建单实例，而懒汉模式需要的时候才创建</strong>）</p><p>3、提供一个方法获取该实例对象(<strong>创建时需要进行方法同步</strong>)</p><h4 id="工厂模式-Spring-IOC就是使用了工厂模式"><a href="#工厂模式-Spring-IOC就是使用了工厂模式" class="headerlink" title="工厂模式:Spring IOC就是使用了工厂模式."></a>工厂模式:Spring IOC就是使用了工厂模式.</h4><p>​       对象的创建交给一个工厂去创建。</p><h4 id="代理模式-Spring-AOP就是使用的动态代理。"><a href="#代理模式-Spring-AOP就是使用的动态代理。" class="headerlink" title="代理模式:Spring AOP就是使用的动态代理。"></a>代理模式:Spring AOP就是使用的动态代理。</h4><h2 id="JAVA-Web部分"><a href="#JAVA-Web部分" class="headerlink" title="JAVA Web部分"></a>JAVA Web部分</h2><h3 id="1-讲一下http-get和post请求的区别"><a href="#1-讲一下http-get和post请求的区别" class="headerlink" title="1.讲一下http get和post请求的区别?"></a>1.讲一下http get和post请求的区别?</h3><p>GET和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作,具体点来讲GET一般用于获取/查询资源信息，而POST一般用于更新资源信息</p><p>1、<strong>Get请求提交的数据会在地址栏显示出来，而post请求不会再地址栏显示出来.</strong></p><p>GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；</p><p>POST提交：把提交的数据放置在是HTTP包的包体中。 <strong>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</strong></p><p>2、传输数据的大小</p><p>http <strong>Get请求</strong>由于浏览器对<strong>地址长度</strong>的限制而导致传输的数据<strong>有限制</strong>。而POST请求不会因为地址长度限制而导致传输数据限制。</p><p>3、安全性,<strong>POST的安全性要比GET的安全性高</strong>。由于数据是会在地址中呈现，所以可以通过历史记录找到密码等关键信息。</p><h3 id="2-说一下你对servlet的理解？或者servlet是什么？"><a href="#2-说一下你对servlet的理解？或者servlet是什么？" class="headerlink" title="2.说一下你对servlet的理解？或者servlet是什么？"></a>2.说一下你对servlet的理解？或者servlet是什么？</h3><p><strong>Servlet</strong>（Server Applet），全称<strong>Java Servlet</strong>， <strong>是用Java编写的服务器端程序</strong>。而这些Sevlet都要实现Servlet这个接口。<strong>其主要功能在于交互式地浏览和修改数据，生成动态Web内容</strong>。Servlet运行于支持Java的应用服务器中。</p><p> HttpServlet 重写doGet和doPost方法或者你也可以重写service方法完成对get和post请求的响应</p><h3 id="3-简单说一下servlet的生命周期"><a href="#3-简单说一下servlet的生命周期" class="headerlink" title="3.简单说一下servlet的生命周期?"></a>3.简单说一下servlet的生命周期?</h3><p>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。</p><p><strong>加载Servlet的class—-&gt;实例化Servlet—–&gt;调用Servlet的init完成初始化—-&gt;响应请求（Servlet的service方法）—–&gt;Servlet容器关闭时(Servlet的destory方法)</strong></p><p>Servlet启动时，开始加载servlet生命周期开始。Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候(服务器关闭)调用其destroy方法。</p><h3 id="4-Servlet-API中forward-与redirect-的区别？"><a href="#4-Servlet-API中forward-与redirect-的区别？" class="headerlink" title="4.Servlet API中forward() 与redirect()的区别？"></a>4.Servlet API中forward() 与redirect()的区别？</h3><p>1、forward是服务器端的转向而redirect是客户端的跳转。 请求转发—–重定向</p><p>2、使用forward浏览器的地址不会发生改变。而redirect会发生改变。</p><p>3、Forward是一次请求中完成。而redirect是重新发起请求。</p><p>4、Forward是在服务器端完成，而不用客户端重新发起请求，效率较高。</p><h3 id="5-JSP和Servlet有哪些相同点和不同点"><a href="#5-JSP和Servlet有哪些相同点和不同点" class="headerlink" title="5.JSP和Servlet有哪些相同点和不同点?"></a>5.JSP和Servlet有哪些相同点和不同点?</h3><p>JSP是Servlet技术的扩展，所有的jsp文件都会被翻译为一个继承HttpServlet的类。也就是jsp最终也是一个Servlet.这个Servlet对外提供服务。</p><p><img data-src="4.png" alt="4.png"></p><p><strong>Servlet和JSP最主要的不同点在于JSP侧重于视图，Servlet主要用于控制逻辑。</strong></p><p>Servlet如果要实现html的功能，必须使用Writer输出对应的html,比较麻烦。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件,做界面展示比较方便而嵌入逻辑比较复杂。</p><h3 id="6-jsp有哪些内置对象-作用分别是什么"><a href="#6-jsp有哪些内置对象-作用分别是什么" class="headerlink" title="6. jsp有哪些内置对象?作用分别是什么?"></a>6. jsp有哪些内置对象?作用分别是什么?</h3><p><strong>9个内置的对象：</strong> </p><p>request 用户端请求，此请求会包含来自GET/POST请求的参数 </p><p>response 网页传回用户端的回应 </p><p>pageContext 网页的属性是在这里管理 </p><p>session 与请求有关的会话期 </p><p>application servlet正在执行的内容 </p><p>out 用来传送回应的输出 </p><p>config servlet的构架部件 </p><p>page JSP网页本身 </p><p>exception 针对错误网页，未捕捉的例外 </p><p><strong>四大作用域</strong>：<strong>pageContext request session application</strong> 可以通过jstl从四大作用域中取值.</p><p>Jsp传递值request session application cookie也能传值</p><h3 id="7-说一下session和cookie的区别？你在项目中都有哪些地方使用了？"><a href="#7-说一下session和cookie的区别？你在项目中都有哪些地方使用了？" class="headerlink" title="7.说一下session和cookie的区别？你在项目中都有哪些地方使用了？"></a>7.说一下session和cookie的区别？你在项目中都有哪些地方使用了？</h3><p>Session和cookie都是会话(Seesion)跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。但是Session的实现依赖于Cookie,sessionId(session的唯一标识需要存放在客户端).</p><h4 id="cookie-和session-的区别："><a href="#cookie-和session-的区别：" class="headerlink" title="cookie 和session 的区别："></a>cookie 和session 的区别：</h4><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>    考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：<br>    将<strong>登陆信息等重要信息存放为SESSION</strong><br>    其他信息如果需要保留，可以放在COOKIE中，比如<strong>购物车</strong></p><p><strong>购物车最好使用cookie，但是cookie是可以在客户端禁用的，这时候我们要使用cookie+数据库的方式实现，当从cookie中不能取出数据时，就从数据库获取。</strong></p><h3 id="8-MVC的各个部分都有那些技术来实现"><a href="#8-MVC的各个部分都有那些技术来实现" class="headerlink" title="8.MVC的各个部分都有那些技术来实现?"></a>8.MVC的各个部分都有那些技术来实现?</h3><p>M(Model) 模型 javabean</p><p>V(View) 视图  html jsp volicity freemaker</p><p>C(Control) 控制器 Servlet,Action</p><p>Jsp+Servlet+javabean 最经典mvc模式,实际上就是model2的实现方式，就是把视图和逻辑隔离开来</p><p>Model1的方式 jsp+service+dao</p><p>MOdel2的方式 jsp+servlet+service+dao</p><p>使用struts2和springmvc这样的mvc框架后，jsp+核心控制器+action+javabean</p><h2 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h2><h3 id="1-数据库的分类及常用的数据库"><a href="#1-数据库的分类及常用的数据库" class="headerlink" title="1.数据库的分类及常用的数据库"></a>1.数据库的分类及常用的数据库</h3><p>数据库分为：<strong>关系型数据库</strong>和<strong>非关系型数据库</strong></p><p>​          关系型：mysql oracle sqlserver等</p><p>​          非关系型：redis,memcache,mogodb,hadoop等</p><h3 id="2-简单介绍一下关系数据库三范式？"><a href="#2-简单介绍一下关系数据库三范式？" class="headerlink" title="2.简单介绍一下关系数据库三范式？"></a>2.简单介绍一下关系数据库三范式？</h3><p>范式就是规范,就是关系型数据库在设计表时，要遵循的三个规范。</p><p>要想满足第二范式必须先满足第一范式，要满足第三范式必须先满足第二范式。</p><p>第一范式（1NF）是指<strong>数据库表的每一列都是不可分割的基本数据项</strong>，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。列数据的不可分割</p><p>二范式（2NF）<strong>要求数据库表中的每个行必须可以被唯一地区分</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。(主键)</p><p> 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求<strong>一个数据库表中不包含已在其它表中已包含的非主关键字信息</strong>。(外键)</p><p>1NF:字段不可分;</p><p>2NF:有主键，非主键字段依赖主键;</p><p>3NF:非主键字段不能相互依赖;</p><p>反三范式,<strong>有的时候为了效率，可以设置重复或者可以推导出的字段.</strong><br>        订单（总价）和订单项（单价）</p><h3 id="3-事务四个基本特征或-ACID-特性。"><a href="#3-事务四个基本特征或-ACID-特性。" class="headerlink" title="3.事务四个基本特征或 ACID 特性。"></a>3.事务四个基本特征或 ACID 特性。</h3><p><strong>事务是并发控制的单位，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。</strong><br>一个转账必须 A账号扣钱成功，B账号加钱成功，才算正真的转账成功。</p><p>  <strong>事务必须满足四大特征</strong>:原子性,一致性,隔离性,持久性/持续性</p><p> 原子性：表示事务内操作不可分割。要么都成功、要么都是失败.</p><p> 一致性：要么都成功、要么都是失败.后面的失败了要对前面的操作进行回滚。</p><p> 隔离性：一个事务开始后，不能受其他事务干扰。</p><p> 持久性/持续性：表示事务开始了，就不能终止。</p><h3 id="4-mysql数据库的默认的最大连接数？"><a href="#4-mysql数据库的默认的最大连接数？" class="headerlink" title="4. mysql数据库的默认的最大连接数？"></a>4. mysql数据库的默认的最大连接数？</h3><p>100</p><p>为什么需要最大连接数？特定服务器上面的数据库只能支持一定数目同时连接，这时候我们一般都会设置最大连接数（最多同时服务多少连接）。在数据库安装时都会有一个默认的最大连接数为100</p><p><img data-src="5.png" alt="5.png"></p><h3 id="5-说一下msyql的分页？Oracle的分页？"><a href="#5-说一下msyql的分页？Oracle的分页？" class="headerlink" title="5.说一下msyql的分页？Oracle的分页？"></a>5.说一下msyql的分页？Oracle的分页？</h3><p>为什么需要分页？在很多数据是，不可能完全显示数据。进行分段显示.</p><p>Mysql是使用关键字limit来进行分页的 limit offset,size 表示从多少索引去多少位.</p><p>Oracle的分页，大部分情况下，我们是记不住的。说思路，要使用三层嵌套查询。</p><p>Oracle的分页有点儿记不住了，只记得一些大概。是使用了三层嵌套查询。如果在工作中使用了，可以到原来的项目中拷贝或上网查询。</p><p><strong>mysql:</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql =  <span class="string">"select * from students order by id limit "</span> + pageSize*(pageNumber-<span class="number">1</span>) + <span class="string">","</span> + pageSize;</span><br></pre></td></tr></table></figure><p>​              </p><p><strong>oracle:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String sql = </span><br><span class="line"></span><br><span class="line">         <span class="string">"select * from "</span> +  </span><br><span class="line">          (select *,<span class="function">rownum rid <span class="title">from</span> <span class="params">(select * from students order by postime desc)</span> where rid&lt;</span>=<span class="string">" + pagesize*pagenumber + "</span>) as t<span class="string">" + </span></span><br><span class="line"><span class="string">          "</span>where t&gt;<span class="string">" + pageSize*(pageNumber-1);</span></span><br></pre></td></tr></table></figure><p>​         </p><h3 id="6-简单讲一下数据库的触发器的使用场景？"><a href="#6-简单讲一下数据库的触发器的使用场景？" class="headerlink" title="6.简单讲一下数据库的触发器的使用场景？"></a>6.简单讲一下数据库的触发器的使用场景？</h3><p><strong>触发器，需要有触发条件，当条件满足以后做什么操作。</strong></p><p>触发器用处还是很多的，比如校内网、开心网、Facebook，你发一个日志，自动通知好友，其实就是在增加日志时做一个后触发，再向通知表中写入条目。因为触发器效率高。而UCH没有用触发器，效率和数据处理能力都很低。</p><p>每插入一个帖子，都希望将版面表中的最后发帖时间，帖子总数字段进行同步更新，用触发器做效率就很高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> board1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>),ar</span><br><span class="line">ticleCount <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> article1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,title <span class="built_in">varchar</span>(<span class="number">50</span>)</span><br><span class="line">,bid <span class="built_in">int</span> <span class="keyword">references</span> board1(<span class="keyword">id</span>));</span><br><span class="line"></span><br><span class="line">delimiter |<span class="comment">#把分割符;改成|</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> insertArticle_Trigger <span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> article1 <span class="keyword">for</span> <span class="keyword">each</span> ro</span><br><span class="line">w <span class="keyword">begin</span></span><br><span class="line">    -&gt; <span class="keyword">update</span> board1 <span class="keyword">set</span> articleCount=articleCount+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>= NEW.bid;</span><br><span class="line">    -&gt; end;</span><br><span class="line">    -&gt; |</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> board1 <span class="keyword">value</span> (<span class="literal">null</span>,<span class="string">'test'</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> article1 <span class="keyword">value</span>(<span class="literal">null</span>,<span class="string">'test'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="7-简单讲一下数据库的存储过程的使用场景？"><a href="#7-简单讲一下数据库的存储过程的使用场景？" class="headerlink" title="7.简单讲一下数据库的存储过程的使用场景？"></a>7.简单讲一下数据库的存储过程的使用场景？</h3><p><strong>数据库存储过程具有如下优点：</strong></p><p>1、存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次，因此使用存储过程可以大大提高数据库执行速度。</p><p>2、通常，复杂的业务逻辑需要多条 SQL 语句。这些语句要分别地从客户机发送到服务器，当客户机和服务器之间的操作很多时，将产生大量的网络传输。如果将这些操作放在一个存储过程中，那么客户机和服务器之间的网络传输就会大大减少，降低了网络负载。</p><p>3、存储过程创建一次便可以重复使用，从而可以减少数据库开发人员的工作量。</p><p>4、<strong>安全性高</strong>，存储过程可以屏蔽对底层数据库对象的直接访问，使用 EXECUTE 权限调用存储过程，无需拥有访问底层数据库对象的显式权限。</p><p>正是由于存储过程的上述优点，目前常用的数据库都支持存储过程，例如 IBM DB2，Microsoft SQL Server，Oracle，Access 等，开源数据库系统 MySQL 也在 5.0 的时候实现了对存储过程的支持。</p><p>定义存储过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_Student (_name <span class="built_in">varchar</span>(<span class="number">50</span>),_age <span class="built_in">int</span> ,<span class="keyword">out</span> _id <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">value</span>(<span class="literal">null</span>,_name,_age);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(stuId) <span class="keyword">into</span> _id <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> insert_Student(<span class="string">'wfz'</span>,<span class="number">23</span>,@<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">select</span> @<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><h3 id="8-用jdbc怎么调用存储过程？"><a href="#8-用jdbc怎么调用存储过程？" class="headerlink" title="8.用jdbc怎么调用存储过程？"></a>8.用jdbc怎么调用存储过程？</h3><p><strong>贾琏欲执事</strong></p><p>加载驱动</p><p>获取连接</p><p>设置参数</p><p>执行</p><p>释放连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.CallableStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Types;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Connection cn = <span class="keyword">null</span>;</span><br><span class="line">CallableStatement cstmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里最好不要这么干，因为驱动名写死在程序中了</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//实际项目中，这里应用DataSource数据，如果用框架，</span></span><br><span class="line"><span class="comment">//这个数据源不需要我们编码创建，我们只需Datasource ds = context.lookup()</span></span><br><span class="line"><span class="comment">//cn = ds.getConnection();</span></span><br><span class="line">cn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///test"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">cstmt = cn.prepareCall(<span class="string">"&#123;call insert_Student(?,?,?)&#125;"</span>);</span><br><span class="line">cstmt.registerOutParameter(<span class="number">3</span>,Types.INTEGER);</span><br><span class="line">cstmt.setString(<span class="number">1</span>, <span class="string">"wangwu"</span>);</span><br><span class="line">cstmt.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line">cstmt.execute();</span><br><span class="line"><span class="comment">//get第几个，不同的数据库不一样，建议不写</span></span><br><span class="line">System.out.println(cstmt.getString(<span class="number">3</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*try&#123;cstmt.close();&#125;catch(Exception e)&#123;&#125;</span></span><br><span class="line"><span class="comment">try&#123;cn.close();&#125;catch(Exception e)&#123;&#125;*/</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(cstmt != <span class="keyword">null</span>)</span><br><span class="line">cstmt.close();</span><br><span class="line"><span class="keyword">if</span>(cn != <span class="keyword">null</span>)</span><br><span class="line">cn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-简单说一下你对jdbc的理解？"><a href="#9-简单说一下你对jdbc的理解？" class="headerlink" title="9.简单说一下你对jdbc的理解？"></a>9.简单说一下你对jdbc的理解？</h3><p><strong>1.什么是 JDBC ？</strong></p><p>JDBC（Java Data Base Connectivity，java数据库连接）是一种用于执行SQL语句的Java API（Application Programming Interface），可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。</p><p><strong>简单说：</strong>  它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。</p><p><img data-src="6.png" alt="6.png"></p><p><strong>2.JDBC 有什么用 ？</strong></p><p>我们用JAVA就能连接到数据库；创建SQL或者MYSQL语句；执行SQL或MYSQL的查询数据库；查看和修改结果记录。</p><p><strong>3.JDBC API 介绍及接口</strong></p><p>JDBC API主要做三件事：<strong>与数据库建立连接，发送SQL语句，处理结果</strong>。</p><p>提供的接口包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JAVA API：提供对JDBC的管理链接；</span><br><span class="line"></span><br><span class="line">JAVA Driver API：支持JDBC管理到驱动器连接。</span><br><span class="line"></span><br><span class="line">DriverManager：这个类管理数据库驱动程序的列表，查看加载的驱动是否符合JAVA Driver API的规范。 装载驱动程序，并为创建新的数据库连接提供支持。</span><br><span class="line"></span><br><span class="line">Connection：与数据库中的所有的通信是通过唯一的连接对象。负责连接数据库并担任传送数据的任务。</span><br><span class="line"></span><br><span class="line">Statement：把创建的SQL对象，转而存储到数据库当中。由Connection产生，负责执行SQL语句。</span><br><span class="line"></span><br><span class="line">ResultSet：它是一个迭代器，用于检索查询数据。负责保存和处理Statement中心执行后所产生的查询结果。</span><br></pre></td></tr></table></figure><p><strong>4.采用JDBC访问数据库的基本步骤：</strong></p><p><strong>a) 注册驱动</strong>  </p><p><strong>b) 建立数据库连接(Connection)</strong>  </p><p><strong>c) 准备 SQL 语句</strong>  </p><p><strong>d) 获取 SQL 语句发送器(Statement)</strong> </p><p> <strong>e) 发送并执行 SQL 语句, 得到结果集(ResultSet)</strong>  </p><p><strong>f) 处理结果集</strong>  </p><p><strong>g) 关闭资源(ResultSet, Statement, Connection)</strong></p><p><strong>5.执行查询操作</strong></p><h3 id="10-JDBC中的PreparedStatement相比Statement的好处"><a href="#10-JDBC中的PreparedStatement相比Statement的好处" class="headerlink" title="10.JDBC中的PreparedStatement相比Statement的好处"></a>10.JDBC中的PreparedStatement相比Statement的好处</h3><p><strong>大多数我们都使用PreparedStatement代替Statement</strong></p><p><strong>1：PreparedStatement是预编译的，比Statement速度快</strong> </p><p><strong>2：代码的可读性和可维护性</strong></p><p>虽然用PreparedStatement来代替Statement会使代码多出几行,但这样的代码无论从可读性还是可维护性上来说.都比直接用Statement的代码高很多档次：</p><p>stmt.executeUpdate(“insert into tb_name (col1,col2,col2,col4) values (‘“+var1+”‘,’”+var2+”‘,”+var3+”,’”+var4+”‘)”); </p><p>perstmt = con.prepareStatement(“insert into tb_name (col1,col2,col2,col4) values (?,?,?,?)”);</p><p>perstmt.setString(1,var1);</p><p>perstmt.setString(2,var2);</p><p>perstmt.setString(3,var3);</p><p>perstmt.setString(4,var4);</p><p>perstmt.executeUpdate();</p><p>不用我多说,对于第一种方法，别说其他人去读你的代码，就是你自己过一段时间再去读,都会觉得伤心。</p><p><strong>3：安全性</strong></p><p><strong>PreparedStatement可以防止SQL注入攻击，而Statement却不能</strong>。比如说：</p><p>String sql = “select * from tb_name where name= ‘“+varname+”‘ and passwd=’”+varpasswd+”‘“;</p><p>如果我们把[‘ or ‘1’ = ‘1]作为varpasswd传入进来.用户名随意,看看会成为什么?</p><p>select * from tb_name = ‘随意’ and passwd = ‘’ or ‘1’ = ‘1’;</p><p>因为’1’=’1’肯定成立，所以可以任何通过验证，更有甚者：</p><p>把[‘;drop table tb_name;]作为varpasswd传入进来,则：</p><p>select * from tb_name = ‘随意’ and passwd = ‘’;drop table tb_name;有些数据库是不会让你成功的，但也有很多数据库就可以使这些语句得到执行。</p><p>而如果你使用预编译语句你传入的任何内容就不会和原来的语句发生任何匹配的关系，只要全使用预编译语句你就用不着对传入的数据做任何过虑。而如果使用普通的statement,有可能要对drop等做费尽心机的判断和过虑。</p><h3 id="11-数据库连接池作用"><a href="#11-数据库连接池作用" class="headerlink" title="11.数据库连接池作用"></a>11.数据库连接池作用</h3><p>1、限定数据库的个数，不会导致由于数据库连接过多导致系统运行缓慢或崩溃</p><p>2、数据库连接不需要每次都去创建或销毁，节约了资源</p><p>3、数据库连接不需要每次都去创建，响应时间更快。</p><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><h3 id="1-简单说一下html-css-javascript在网页开发中的定位"><a href="#1-简单说一下html-css-javascript在网页开发中的定位" class="headerlink" title="1.简单说一下html,css,javascript在网页开发中的定位?"></a>1.简单说一下html,css,javascript在网页开发中的定位?</h3><p>HTML 超文本标记语言 <strong>定义网页的结构</strong></p><p>CSS 层叠样式表，<strong>用来美化页面</strong></p><p>JavaScript主要用来验证表单，<strong>做动态交互(</strong>其中ajax)</p><h3 id="2-简单介绍一下Ajax"><a href="#2-简单介绍一下Ajax" class="headerlink" title="2.简单介绍一下Ajax?"></a>2.简单介绍一下Ajax?</h3><h4 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax?"></a>什么是Ajax?</h4><p>异步的javascript和xml（局部刷新，异步交互）</p><h4 id="作用是什么？"><a href="#作用是什么？" class="headerlink" title="作用是什么？"></a>作用是什么？</h4><p>通过AJAX与服务器进行数据交换，AJAX可以使网页实现布局更新。</p><p>这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><h4 id="怎么来实现Ajax"><a href="#怎么来实现Ajax" class="headerlink" title="怎么来实现Ajax"></a>怎么来实现Ajax</h4><p>XmlHttpRequest对象，使用这个对象可以异步向服务器发送请求，获取获取响应，完成局部更新。Open send responseText/responseXML 局部响应.</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>登陆失败时不跳转页面，注册时提示用户名是否存在,二级联动等等使用场景</p><h3 id="3-js和jQuery的关系"><a href="#3-js和jQuery的关系" class="headerlink" title="3.js和jQuery的关系?"></a>3.js和jQuery的关系?</h3><p> jQuery是一个js框架，封装了js的属性和方法。让用户使用起来更加便利,并且增强了js的功能。</p><p>使用原生js时要处理很多兼容性的问题(注册事件等)，由jQuery封装了底层，就不用处理兼容性问题。</p><p>原生的js的dom和事件绑定和Ajax等操作非常麻烦，jQuery封装以后操作非常方便。</p><h3 id="4-jQuery的常用选择器？"><a href="#4-jQuery的常用选择器？" class="headerlink" title="4.jQuery的常用选择器？"></a>4.jQuery的常用选择器？</h3><p><strong>ID选择器</strong>   通过ID获取一个元素</p><p><strong>Class选择器</strong> 通过类(css)获取元素</p><p><strong>标签选择器</strong> 通过标签获取元素</p><p><strong>通用选择器(*)</strong> 获取所以的元素</p><p>div.myCls  获取有myCls这个类的div</p><p><strong>层次选择器</strong></p><p>​     儿子选择器 &gt; 获取下面的子元素</p><p>​     后代选择器 空格 获取下面后代，包括儿子、孙子等后代</p><p><strong>属性选择器</strong></p><p>​    Tag[attrName=’test’] 获取有属性名为xxxx并且属性的值为test的所有xxx标签</p><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>/&gt;</span> 吃饭<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>/&gt;</span> 睡觉<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>   Input[name=’hobby’],表示获取属性名为name并且name属性值为hobby的的所有input标签元素 </p><h3 id="5-Jquery的Ajax和原生Js实现Ajax有什么关系？"><a href="#5-Jquery的Ajax和原生Js实现Ajax有什么关系？" class="headerlink" title="5.Jquery的Ajax和原生Js实现Ajax有什么关系？"></a>5.Jquery的Ajax和原生Js实现Ajax有什么关系？</h3><p><strong>jQuery中的Ajax也是通过原生的js封装的。封装完成后让我们使用起来更加便利，不用考虑底层实现或兼容性等处理。</strong></p><p>如果采用原生js实现Ajax是非常麻烦的，并且每次都是一样的。如果我们不使用jQuery我们也要封装Ajax对象的方法和属性。有像jQuery这些已经封装完成，并经过很多企业实际的框架，比较可靠并且开源。我们就不需要封装，直接使用成熟的框架(jQuery)即可.</p><h2 id="框架部分"><a href="#框架部分" class="headerlink" title="框架部分"></a>框架部分</h2><h3 id="1-什么是框架"><a href="#1-什么是框架" class="headerlink" title="1.什么是框架?"></a>1.什么是框架?</h3><p>框架（Framework）是一个框子——指其约束性，也是一个架子——指其支撑性。</p><p>  IT语境中的框架，特指<strong>为解决一个开放性问题而设计的具有一定约束性的支撑结构</strong>。在此结构上可以根据具体问题<strong>扩展、安插更多的组成部分，从而更迅速和方便地构建完整的解决问题的方案</strong>。</p><p>1）框架本身一般不完整到可以解决特定问题,但是可以帮助您快速解决特定问题；</p><p>   没有框架所有的工作都从零开始做,有了框架,为我们提供了一定的功能,我们就可以在框 架的基础上开发,极大的解放了生产力。</p><p>不同的框架，是为了解决不同领域的问题。一定要为了解决问题才去学习框架。</p><p>2）框架天生就是为扩展而设计的；</p><p>3）框架里面可以为后续扩展的组件提供很多辅助性、支撑性的方便易用的实用工具（utilities），也就是说框架时常配套了一些帮助解决某类问题的库（libraries）或工具（tools）。</p><p>  java中就是一系列的jar包，其本质就是对jdk功能的扩展.</p><h3 id="2-MVC模式"><a href="#2-MVC模式" class="headerlink" title="2.MVC模式"></a>2.MVC模式</h3><p>MVC全名是<strong>Model View Controller</strong>，是<strong>模型(model)－视图(view)－控制器(controller)</strong>的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p><p><strong>最简单的、最经典就是Jsp(view) +Servlet(controller) + JavaBean(model)</strong></p><p><img data-src="7.png" alt="7.png"></p><p>1、当控制器收到来自用户的请求</p><p>2、控制器调用JavaBean完成业务</p><p>3、完成业务后通过控制器跳转JSP页面的方式给用户反馈信息</p><p>4、Jsp个 用户做出响应。</p><p>​    控制器都是核心</p><h3 id="3-MVC框架"><a href="#3-MVC框架" class="headerlink" title="3.MVC框架"></a>3.MVC框架</h3><p><strong>什么是MVC框架？</strong></p><p>  是为了解决传统MVC模式(Jsp + Servlet + JavaBean)的一些问题而出现的框架。</p><p><strong>传统MVC模式问题</strong></p><p>1、所有的Servlet和Servlet映射都要配置在web.xml中，如果项目太大，web.xml就太庞大，并且不能实现模块化管理。</p><p>2、Servlet的主要功能就是<strong>接受参数、调用逻辑、跳转页面</strong>，比如像其他字符编码、文件上传等功能也要写在Servlet中，不能让Servlet主要功能而需要做处理一下特例。</p><p>3、接受参数比较麻烦(String name = request.getParameter(“name”),User user=new User user.setName(name))，不能通过model接收，只能单个接收，接收完成后转换封装model.</p><p>4、跳转页面方式比较单一(forword,redirect),并且当我的页面名称发生改变时需要修改Servlet源代码.</p><p><strong>现在比较常用的MVC框架有：</strong></p><p>   struts</p><p>   webwork</p><p>   <strong>Struts2</strong></p><p>   <strong>Spring MVC</strong></p><h3 id="4-简单讲一下SpringMVC的执行流程？"><a href="#4-简单讲一下SpringMVC的执行流程？" class="headerlink" title="4. 简单讲一下SpringMVC的执行流程？"></a>4. 简单讲一下SpringMVC的执行流程？</h3><p><img data-src="8.png" alt="8.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588473268676.png" alt="1588473268676"></p><ol><li><p>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</p></li><li><p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</p></li><li><p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（<strong>附注</strong>：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）</p></li><li><p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p><p><strong>HttpMessageConveter：</strong> 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p></li></ol><p>​      <strong>数据转换</strong>：对请求消息进行数据转换。如String转换成Integer、Double等</p><p>​      <strong>数据格式化：</strong>对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p><p>​      <strong>数据验证：</strong> 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p><p>5.Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</p><p>6.根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</p><p>​      7. ViewResolver 结合Model和View，来渲染视图</p><p>​      8. 将渲染结果返回给客户端。</p><h4 id="面试："><a href="#面试：" class="headerlink" title="面试："></a>面试：</h4><p>1、 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获(<strong>捕获</strong>)</p><p>2、 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；(<strong>查找handler)</strong></p><p>3、 DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller), Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象(<strong>执行handler</strong>)</p><p>4、DispatcherServlet 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver) (<strong>选择ViewResolver</strong>)</p><p>5、通过ViewResolver 结合Model和View，来渲染视图,DispatcherServlet 将渲染结果返回给客户端。（<strong>渲染返回</strong>）</p><h4 id="快速记忆技巧："><a href="#快速记忆技巧：" class="headerlink" title="快速记忆技巧："></a>快速记忆技巧：</h4><p>核心控制器捕获请求、查找Handler、执行Handler、选择ViewResolver,通过ViewResolver渲染视图并返回</p><h3 id="5-说一下struts2和springMVC有什么不同？"><a href="#5-说一下struts2和springMVC有什么不同？" class="headerlink" title="5.说一下struts2和springMVC有什么不同？"></a>5.说一下struts2和springMVC有什么不同？</h3><p>目前企业中使用SpringMVC的比例已经远远超过Struts2,那么两者到底有什么区别，是很多初学者比较关注的问题，下面我们就来对SpringMvc和Struts2进行各方面的比较:</p><ol><li>核心控制器（前端控制器、预处理控制器）：对于使用过mvc框架的人来说这个词应该不会陌生，核心控制器的主要用途是处理所有的请求，然后对那些特殊的请求 （控制器）统一的进行处理(字符编码、文件上传、参数接受、异常处理等等),<strong>spring mvc核心控制器是Servlet，而Struts2是Filter</strong>。</li><li>控制器实例：Spring Mvc会比Struts快一些（理论上）。Spring Mvc是基于方法设计，而Sturts是基于对象，每次发一次请求都会实例一个action，每个action都会被注入 属性，而Spring更像Servlet一样，只有一个实例，每次请求执行对应的方法即可(注意：由于是单例实例，所以应当避免全局变量的修改，这样会产生线程安全问题)。</li><li>管理方式：大部分的公司的核心架构中，就会使用到spring,而spring mvc又是spring中的一个模块，所以spring对于spring mvc的控制器管理更加简单方便，而且提供了全 注解方式进行管理，各种功能的注解都比较全面，使用简单，而struts2需要采用XML很多的配置参数来管理（虽然也可以采用注解，但是几乎没有公司那 样使用）。</li><li>参数传递：Struts2中自身提供多种参数接受，其实都是通过（ValueStack）进行传递和赋值，而SpringMvc是通过方法的参数进行接收。</li><li>学习难度：Struts更加很多新的技术点，比如拦截器、值栈及OGNL表达式，学习成本较高，springmvc 比较简单，很较少的时间都能上手。</li><li>intercepter 的实现机制：struts有以自己的interceptor机制，spring mvc用的是独立的AOP方式。这样导致struts的配置文件量还是比spring mvc大，虽然struts的配置能继承，所以我觉得论使用上来讲，spring mvc使用更加简洁，开发效率Spring MVC确实比struts2高。spring mvc是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上spring3 mvc就容易实现restful url。struts2是类级别的拦截，一个类对应一个request上下文；实现restful url要费劲，因为struts2 action的一个方法可以对应一个url；而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。spring3 mvc的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架方法之间不共享变量，而struts2搞的就比较乱，虽然方法之间 也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码，读程序时带来麻烦。</li><li>spring mvc处理ajax请求,直接通过返回数据，方法中使用注解@ResponseBody，spring mvc自动帮我们对象转换为JSON数据。而struts2是通过插件的方式进行处理</li></ol><p>在SpringMVC流行起来之前，Struts2在MVC框架中占核心地位，随着SpringMVC的出现，SpringMVC慢慢的取代struts2,但是很多企业都是原来搭建的框架，使用Struts2较多。</p><h3 id="6-说一下Spring中的两大核心？"><a href="#6-说一下Spring中的两大核心？" class="headerlink" title="6.说一下Spring中的两大核心？"></a>6.说一下Spring中的两大核心？</h3><p><strong>Spring是什么？</strong></p><p>spring是<strong>J2EE应用程序框架</strong>，是轻量级的<strong>IoC和AOP的容器框架</strong>(相对于重量级的EJB)，主要是针对javaBean的生命周期进行管理的<strong>轻量级容器</strong>，可以单独使用，也可以和Struts框架，ibatis框架等组合使用。</p><p><strong>1、IOC(Inversion of Control )或DI(Dependency Injection)</strong></p><p>​       IOC控制权反转</p><p>​          原来：我的Service需要调用DAO，Service就需要创建DAO</p><p>​          Spring:Spring发现你Service依赖于dao,就给你注入.</p><p>​       核心原理：就是配置文件+反射(工厂也可以)+容器(map)  </p><p><strong>2、AOP:面向切面编程</strong></p><p>​       核心原理：使用动态代理的设计模式在执行方法前后或出现异常后加入相关逻辑。</p><p>​      我们主要使用AOP来做：</p><p>​      1、事务处理    执行方法前，开启事务、执行完成后关闭事务、出现异常后回滚事务</p><p>​      2、权限判断    在执行方法前，判断是否具有权限</p><p>​      3、日志      在执行前进行日志处理</p><p>​      4、….</p><h3 id="7-讲一下Spring的事务传播特性"><a href="#7-讲一下Spring的事务传播特性" class="headerlink" title="7.讲一下Spring的事务传播特性"></a>7.讲一下Spring的事务传播特性</h3><p>多个事务存在是怎么处理的策略</p><ol><li>PROPAGATION_REQUIRED:<br>如果存在一个事务，则支持当前事务。如果没有事务则开启</li><li>PROPAGATION_SUPPORTS: 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</li><li>PROPAGATION_MANDATORY: 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</li><li>PROPAGATION_REQUIRES_NEW: 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</li><li>PROPAGATION_NOT_SUPPORTED: 总是非事务地执行，并挂起任何存在的事务。</li><li>PROPAGATION_NEVER: 总是非事务地执行，如果存在一个活动事务，则抛出异常</li><li>PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED<br>属性执行</li></ol><p><strong>Propagation</strong></p><p><strong>Required</strong> <strong>需要</strong> 如果存在一个事务，则支持当前事务。如果没有事务，则开启</p><p><strong>Supports 支持</strong> 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</p><p><strong>Mandatory 必要的</strong> 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p><p><strong>required_new</strong> 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p><p><strong>Not_support</strong> 总是非事务地执行，并挂起任何存在的事务。</p><p><strong>Never</strong> <strong>绝不</strong> 总是非事务地执行，如果存在一个活动事务，则抛出异常</p><p><strong>Nested 嵌套的</strong> 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</p><h3 id="8-什么是ORM"><a href="#8-什么是ORM" class="headerlink" title="8.什么是ORM?"></a>8.什么是ORM?</h3><p>对象关系映射（<strong>Object Relational Mapping</strong>，简称ORM）模式是一种<strong>为了解决面向对象与关系数据库存在的互不匹配的现象的技术</strong>。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。那么，到底如何实现持久化呢？<strong>一种简单的方案是采用硬编码方式(jdbc操作sql方式)</strong>，为每一种可能的数据库访问操作提供单独的方法。</p><p><strong>这种方案存在以下不足：</strong> </p><p>​    1.持久化层缺乏弹性。一旦出现业务需求的变更，就必须修改持久化层的接口 </p><p>​    2.持久化层同时与域模型与关系数据库模型绑定，不管域模型还是关系数据库模型发生变化，都要修改持久化层的相关程序代码，增加了软件的维护难度。 </p><p>   <strong>ORM提供了实现持久化层的另一种模式，它采用映射元数据来描述对象关系的映射，使得ORM中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁</strong>。</p><p>Java典型的ORM框架有:Hibernate,ibatis(mybatis),speedframework。</p><p>   <strong>ORM的方法论基于三个核心原则：</strong> </p><p>　　   简单：以最基本的形式建模数据。 </p><p>　　   传达性：数据库结构被任何人都能理解的语言文档化。 </p><p>　　   精确性：基于数据模型创建正确标准化了的结构。</p><h4 id="面试：-1"><a href="#面试：-1" class="headerlink" title="面试："></a>面试：</h4><p>   对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向<strong>对象</strong>与<strong>关系</strong>数据库存在的互不匹配的现象的技术。可以简单的方案是采用硬编码方式(jdbc操作sql方式)，为每一种可能的数据库访问操作提供单独的方法。这种方法存在很多缺陷</p><p>使用ORM框架(为了解决解决面向<strong>对象</strong>与<strong>关系</strong>数据库存在的互不匹配的现象的框架)来解决. </p><p>   Hibernate,ibatis(mybatis),</p><h3 id="9-mybatis与Hibernate有什么不同"><a href="#9-mybatis与Hibernate有什么不同" class="headerlink" title="9.mybatis与Hibernate有什么不同?"></a>9.mybatis与Hibernate有什么不同?</h3><p>相同点：</p><p>   <strong>都是java中orm框架、屏蔽jdbc api的底层访问细节，使用我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。</strong>jdbc api编程流程固定，还将sql语句与java代码混杂在了一起，经常需要拼凑sql语句，细节很繁琐。</p><h4 id="mybatis的好处："><a href="#mybatis的好处：" class="headerlink" title="mybatis的好处："></a>mybatis的好处：</h4><p>屏蔽jdbc api的底层访问细节；<strong>将sql语句与java代码进行分离</strong>;提供了将结果集自动封装称为实体对象和对象的集合的功能.queryForList返回对象集合，用queryForObject返回单个对象；<strong>提供了自动将实体对象的属性传递给sql语句的参数</strong>。</p><h4 id="Hibername的好处："><a href="#Hibername的好处：" class="headerlink" title="Hibername的好处："></a>Hibername的好处：</h4><p>Hibernate是一个全自动的orm映射工具，它可以自动生成sql语句，并执行并返回java结果。</p><p>不同点：</p><p>   1、hibernate要比mybatis功能强大很多。因为hibernate自动生成sql语句。</p><p>   2、mybatis需要我们自己在xml配置文件中写sql语句，hibernate我们无法直接控制该语句，我们就无法去写特定的高效率的sql。对于一些不太复杂的sql查询，hibernate可以很好帮我们完成，但是，对于特别复杂的查询，hibernate就很难适应了，这时候用mybatis就是不错的选择，因为mybatis还是由我们自己写sql语句。</p><p>  <strong>mybatis可以出来复杂语句，而hibernate不能。</strong></p><p>   3、mybatis要比hibernate简单的多。mybatis是面向sql的，<strong>不用考虑对象间一些复杂的映射关系</strong>。</p><h3 id="10-Hibernate映射对象的状态"><a href="#10-Hibernate映射对象的状态" class="headerlink" title="10.Hibernate映射对象的状态"></a>10.Hibernate映射对象的状态</h3><p><strong>临时状态/瞬时状态</strong>(transient)：刚刚用new语句创建，没有被持久化，不处于session中(没有使用session的方法去操作临时对象)。该对象成为临时对象</p><p><strong>持久化状态</strong>/托管状态(persistent)：已经被持久化，加入到session的缓存中。session是没有关闭的，该状态的对象为持久化对象。</p><p><strong>游离状态</strong>/脱管状态(detached)：已经被持久化，但不处于session中。该状态的对象为游离对象。</p><p><strong>删除状态</strong>(removed)：对象有关联的ID，并且在Session管理下，但是已经被计划(事务提交的时候,commit())删除。如果没有事务就不能删除</p><p>相互转换</p><p><img data-src="9.png" alt="9.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588490670148.png" alt="1588490670148"></p><h3 id="11-介绍一下Hibernate的缓存"><a href="#11-介绍一下Hibernate的缓存" class="headerlink" title="11.介绍一下Hibernate的缓存?"></a>11.介绍一下Hibernate的缓存?</h3><h4 id="一、why（为什么要用Hibernate缓存？）"><a href="#一、why（为什么要用Hibernate缓存？）" class="headerlink" title="一、why（为什么要用Hibernate缓存？）"></a>一、why（为什么要用Hibernate缓存？）</h4><p>Hibernate是一个持久层框架，经常访问物理数据库。 </p><p><strong>为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能。</strong></p><p>缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。 </p><p><strong>为了提供访问速度，把磁盘或数据库访问变成内存访问。</strong></p><h4 id="二、what（Hibernate缓存原理是怎样的？）"><a href="#二、what（Hibernate缓存原理是怎样的？）" class="headerlink" title="二、what（Hibernate缓存原理是怎样的？）"></a>二、what（Hibernate缓存原理是怎样的？）</h4><p>Hibernate缓存包括两大类：Hibernate<strong>一级缓存</strong>和Hibernate<strong>二级缓存</strong>。</p><p>1.Hibernate一级缓存又称为“<strong>Session的缓存</strong>”。 </p><p>Session缓存内置不能被卸载，Session的缓存是事务范围的缓存（Session对象的生命周期通常对应一个数据库事务或者一个应用事务）。 </p><p>一级缓存中，持久化类的每个实例都具有唯一的OID。</p><p>2.Hibernate二级缓存又称为“<strong>SessionFactory的缓存</strong>”。 </p><p>由于SessionFactory对象的生命周期和应用程序的整个过程对应，因此Hibernate二级缓存是进程范围或者集群范围的缓存，<strong>有可能出现并发问题</strong>，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。</p><p><strong>第二级缓存是可选的，是一个可配置的插件，默认下SessionFactory不会启用这个插件</strong>。</p><p>Hibernate提供了org.hibernate.cache.CacheProvider接口,它充当缓存插件与Hibernate之间的适配器。</p><h4 id="面试：-2"><a href="#面试：-2" class="headerlink" title="面试："></a>面试：</h4><p>   Hibernate中的缓存分一级缓存和二级缓存。</p><p>   一级缓存就是Session级别的缓存，在事务范围内有效是,内置的不能被卸载。二级缓存是SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。</p><p>​    保存数据库后，在内存中保存一份，如果更新了数据库就要同步更新。</p><p> <strong>什么样的数据适合存放到第二级缓存中？</strong> 　　</p><p>1) 很少被修改的数据 　帖子的最后回复时间　</p><p>2) 经常被查询的数据   电商的地点</p><p>3) 不是很重要的数据，允许出现偶尔并发的数据 　　</p><p>4) 不会被并发访问的数据 　　</p><p>5) 常量数据 </p><p>扩展：hibernate的二级缓存默认是不支持分布式缓存的。使用memcahe,redis等中央缓存来代替二级缓存。</p><h3 id="12-简单讲一下webservice使用的场景？"><a href="#12-简单讲一下webservice使用的场景？" class="headerlink" title="12.简单讲一下webservice使用的场景？"></a>12.简单讲一下webservice使用的场景？</h3><p>webservice是一个SOA（<strong>面向服务的编程</strong>）的架构，它是<strong>不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用</strong>，通过Internet进行<strong>基于Http协议的网络应用间的交互</strong>。</p><p>1、<strong>异构系统(不同语言)的整合</strong></p><p>2、<strong>不同客户端的整合</strong>  浏览器、手机端(android,ios.塞班)、微信单、PC端等终端来访问</p><p><img data-src="10.png" alt="10.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588519415640.png" alt="1588519415640"></p><p>3、实实在在的列子：</p><p>​       <strong>天气预报</strong>：可以通过实现webservice客户端调用远程天气服务实现的。</p><p>​       <strong>单点登录</strong>：一个服务是所有系统的登录</p><h2 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a>高级部分</h2><h3 id="1-有没有用过linux-你都用它来做什么？"><a href="#1-有没有用过linux-你都用它来做什么？" class="headerlink" title="1.有没有用过linux?你都用它来做什么？"></a>1.有没有用过linux?你都用它来做什么？</h3><p>Linux是一个<strong>长时间运行比较稳定</strong>的操作系统，所有我们<strong>一般会拿它作为服务器</strong>(web,db,app等)。</p><p>Linux本身具有C的编译环境、我们的一些软件是没有软件包(redis、nginx等)的，需要在Linux的C编译环境编译得到软件包.</p><h3 id="2-说一下linux下面的一下常用命令？"><a href="#2-说一下linux下面的一下常用命令？" class="headerlink" title="2.说一下linux下面的一下常用命令？"></a>2.说一下linux下面的一下常用命令？</h3><p>常用：</p><ul><li>Pwd 获取当前路径</li><li>Cd 跳转到目录</li><li>Su -u 切换到管理员</li><li>Ls ls 列举目录</li></ul><p>文件操作命令：</p><ul><li>文件<ul><li>tail 查看</li><li>rm -rf  删除</li><li>vi  修改</li></ul></li><li>文件夹<ul><li>mkdir  创建</li><li>rm -r 删除</li></ul></li></ul><h3 id="3-你是使用什么来连接远程的Linux服务器的？"><a href="#3-你是使用什么来连接远程的Linux服务器的？" class="headerlink" title="3.你是使用什么来连接远程的Linux服务器的？"></a>3.你是使用什么来连接远程的Linux服务器的？</h3><p>需要依赖于Linux服务器安装ssh服务端，一般这个ssh服务的端口22.</p><p>需要依赖于Linux服务器安装sftp服务端，一般这个sftp服务的端口25.</p><p><strong>使用ssh客户端连接linux服务器</strong>，就有点儿像windows下面的远程连接。但是linux通过ssh连接上以后是没有图形界面，全是命令行。</p><p>Putty</p><p><strong>Xshell</strong></p><p><strong>使用sftp客户端来连接sftp服务端</strong>，来上传和下载文件.(上传安装包，修改了配置文件上传。)</p><p>Winscp</p><p><strong>xftp</strong></p><p>企业中常用的两种组合:</p><p>​     putty+winscp </p><p>​     Xshell+xftp=xmanager</p><p><img data-src="file:///C:/Users/zhy/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><h4 id="面试：-3"><a href="#面试：-3" class="headerlink" title="面试："></a>面试：</h4><p><strong>使用xshell、putty等ssh客户端来连接服务器，使用xftp、winscp等sftp客户端来上传和下载文件。连接和上传、下载必须依赖于服务器的ssh、sftp服务，也就是linux服务器需要启动这两个服务。</strong></p><h3 id="4-有没有使用过云主机？"><a href="#4-有没有使用过云主机？" class="headerlink" title="4.有没有使用过云主机？"></a>4.有没有使用过云主机？</h3><p>使用过，在原来的公司，我们没有使用自己的服务器，而是租用阿里的云主机。</p><p>没有使用过，但是有所了解。 </p><p>云主机就是一些云服务运营商(阿里、华为、西部数码、新浪等)，提供的远程的服务器功能，我们开发者或者企业只需按需付费就可以租用对应的服务器。 </p><p>使用ssh和sftp来进行操作。</p><h3 id="5-有没有做过数据库优化方面的事情"><a href="#5-有没有做过数据库优化方面的事情" class="headerlink" title="5.有没有做过数据库优化方面的事情?"></a>5.有没有做过数据库优化方面的事情?</h3><p> 做过mysql数据库的优化、其他数据库类似</p><p>定位：查找、定位慢查询</p><h4 id="优化手段："><a href="#优化手段：" class="headerlink" title="优化手段："></a>优化手段：</h4><p>a)       <strong>创建索引</strong>:创建合适的索引，我们就可以现在索引中查询，查询到以后直接找对应的记录。</p><p>b)       <strong>分表</strong>：当一张表的数据比较多或者一张表的某些字段的值比较多并且很少使用时，采用<strong>水平分表和垂直分表</strong>来优化</p><p>c)        <strong>读写分离</strong>：当一台服务器不能满足需求时，采用读写分离的方式进行集群。</p><p>d)       <strong>缓存</strong>:使用redis来进行缓存</p><p>e)       一些常用优化技巧</p><h3 id="6-数据库优化之遵循范式？"><a href="#6-数据库优化之遵循范式？" class="headerlink" title="6.数据库优化之遵循范式？"></a>6.数据库优化之遵循范式？</h3><p> <strong>数据库表设计时需要遵循方式</strong></p><p> 表的范式，是<strong>首先符合1NF, 才能满足2NF , 进一步满足3NF</strong></p><p><strong>1NF: 即表的列的具有原子性,不可再分解</strong>，即列的信息，不能分解.只要数据库是关系型数据库(mysql/oracle/db2/sysbase/sql server)，就自动的满足1NF.关系型数据库中是不允许分割列的。</p><p><strong>2NF:表中的记录是唯一的</strong>.通常我们设计一个主键来实现</p><p><strong>3NF:即表中不要有冗余数据</strong>, 就是说，<strong>表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放</strong>.(外键)</p><p>反3NF :<strong>没有冗余的数据库未必是最好的数据库</strong>，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余<strong>。</strong> 订单和订单项、相册浏览次数和照片的浏览次数</p><h3 id="7-选择合适的存储引擎"><a href="#7-选择合适的存储引擎" class="headerlink" title="7.选择合适的存储引擎"></a>7.选择合适的存储引擎</h3><p>在开发中，我们经常使用的存储引擎 <strong>myisam / innodb/ memory</strong></p><p><strong>MyISAM存储引擎</strong></p><p>如果表<strong>对事务要求不高，同时是以查询和添加为主的</strong>，我们考虑使用myisam存储引擎. 比如 bbs 中的 <strong>发帖表，回复表</strong>.</p><p><strong>INNODB存储引擎:</strong> </p><p><strong>对事务要求高，保存的数据都是重要数据</strong>，我们建议使用INNODB,比如<strong>订单表，账号表</strong>.</p><p><strong>Memory 存储</strong></p><p>我们<strong>数据变化频繁，不需要入库，同时又频繁的查询和修改</strong>，我们考虑使用memory, 速度极快.</p><h4 id="问-MyISAM-和-INNODB的区别-主要"><a href="#问-MyISAM-和-INNODB的区别-主要" class="headerlink" title="问 MyISAM 和 INNODB的区别(主要)"></a><strong>问 MyISAM 和 INNODB的区别(主要)</strong></h4><ol><li><p>事务安全 myisam不支持事务而innodb支持</p></li><li><p>查询和添加速度 myisam不用支持事务就不用考虑同步锁，查找和添加和添加的速度快</p></li><li><p>支持全文索引 myisam支持innodb不支持</p></li><li><p>锁机制 myisam支持表锁而innodb支持行锁(事务)</p></li><li><p>外键 MyISAM 不支持外键， INNODB支持外键. (通常不设置外键，通常是在程序中保证数据的一致)</p></li></ol><p><img data-src="11.png" alt="11.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588522546110.png" alt="1588522546110"></p><h3 id="8-数据库优化之创建合适的索引"><a href="#8-数据库优化之创建合适的索引" class="headerlink" title="8.数据库优化之创建合适的索引?"></a>8.数据库优化之创建合适的索引?</h3><p><strong>索引（Index）是帮助DBMS高效获取数据的数据结构。</strong></p><p>分类：普通索引/唯一索引/主键索引/全文索引</p><ul><li>普通索引:<strong>允许重复的值出现</strong></li><li>唯一索引:除了<strong>不能有重复的记录</strong>外，其它和普通索引一样(用户名、用户身份证、email,tel)</li><li>主键索引：是随着设定主键而创建的，也就是把某个列设为主键的时候，数据库就会給改列创建索引。这就是主键索引.<strong>唯一且没有null值</strong></li><li>全文索引:<strong>用来对表中的文本域(char，varchar，text)进行索引</strong>， 全文索引针对MyIsam</li></ul><p>explain select * from articles where match(title,body) against(‘database’);【会使用全文索引】</p><h3 id="9-索引使用小技巧？"><a href="#9-索引使用小技巧？" class="headerlink" title="9.索引使用小技巧？"></a>9.索引使用小技巧？</h3><h4 id="索引弊端"><a href="#索引弊端" class="headerlink" title="索引弊端"></a><strong>索引弊端</strong></h4><p>1.占用磁盘空间。</p><p>2.对dml(插入、修改、删除)操作有影响，变慢。</p><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a><strong>使用场景：</strong></h4><p>a: 肯定在where条件经常使用,如果不做查询就没有意义</p><p>b: 该字段的内容不是唯一的几个值(sex) </p><p>c: 字段内容不是频繁变化.</p><h4 id="具体技巧："><a href="#具体技巧：" class="headerlink" title="具体技巧："></a><strong>具体技巧：</strong></h4><ol><li><strong>对于创建的多列索引（复合索引），不是使用的第一部分就不会使用索引。</strong></li></ol><p>alter table dept add index my_ind (dname,loc); // dname 左边的列,loc就是右边的列</p><p>explain select * from dept where dname=’aaa’\G 会使用到索引</p><p>explain select * from dept where loc=’aaa’\G 就不会使用到索引</p><ol start="2"><li><p><strong>对于使用like的查询，查询如果是’%aaa’不会使用到索引而‘aaa%’会使用到索引。</strong></p><p>explain select * from dept where dname like ‘%aaa’\G不能使用索引</p><p>explain select * from dept where dname like ‘aaa%’\G使用索引.</p></li></ol><p>所以在like查询时，‘关键字’的最前面不能使用 % 或者 _这样的字符.，如果一定要前面有变化的值，则考虑使用 全文索引-&gt;sphinx.</p><ol start="3"><li>如果条件中有or，<strong>有条件没有使用索引,即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段,都必须单独使用时能使用索引.</strong></li></ol><p>​    </p><ol start="4"><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。</li></ol><p>expain select * from dept where dname=’111’;</p><p>expain select * from dept where dname=111;（数值自动转字符串）</p><p>expain select * from dept where dname=qqq;报错</p><p>也就是，如果列是字符串类型，无论是不是字符串数字就一定要用 ‘’ 把它包括起来.</p><ol start="5"><li><p>如果mysql估计使用全表扫描要比使用索引快，则不使用索引。</p><p>表里面只有一条记录</p></li></ol><h3 id="10-数据库优化之分表？"><a href="#10-数据库优化之分表？" class="headerlink" title="10.数据库优化之分表？"></a>10.数据库优化之分表？</h3><p>分表分为<strong>水平(按行)分表和垂直(按列)分表</strong></p><p>根据经验，Mysql表数据一般达到<strong>百万级别，查询效率会很低，容易造成表锁，甚至堆积很多连接，直接挂掉；水平分表能够很大程度较少这些压力。</strong></p><p>按行数据进行分表。</p><p><strong>如果一张表中某个字段值非常多(长文本、二进制等)，而且只有在很少的情况下会查询。这时候就可以把字段多个单独放到一个表，通过外键关联起来。</strong></p><p>​     考试详情，一般我们只关注分数，不关注详情。</p><h4 id="水平分表策略："><a href="#水平分表策略：" class="headerlink" title="水平分表策略："></a>水平分表策略：</h4><h5 id="1-按时间分表"><a href="#1-按时间分表" class="headerlink" title="1.按时间分表"></a>1.按时间分表</h5><p>这种分表方式有一定的局限性，当数据有较强的实效性，如<strong>微博发送记录、微信消息记录</strong>等，<strong>这种数据很少有用户会查询几个月前的数据</strong>，如就<strong>可以按月分表</strong>。</p><h5 id="2-按区间范围分表"><a href="#2-按区间范围分表" class="headerlink" title="2.按区间范围分表"></a>2.按区间范围分表</h5><p><strong>一般在有严格的自增id需求上，如按照user_id水平分表：</strong></p><p>table_1  user_id从1~100w </p><p>table_2  user_id从101~200w </p><p>table_3  user_id从201~300w </p><h5 id="3-hash分表"><a href="#3-hash分表" class="headerlink" title="3.hash分表"></a>3.hash分表</h5><p>通过一个原始目标的ID或者名称通过一定的hash算法计算出数据存储表的表名，然后访问相应的表。</p><h3 id="11-数据库优化之读写分离"><a href="#11-数据库优化之读写分离" class="headerlink" title="11.数据库优化之读写分离"></a>11.数据库优化之读写分离</h3><p>一台数据库支持的最大并发连接数是有限的，如果用户并发访问太多。一台服务器满足不了要求时就可以集群处理。Mysql的集群处理技术最常用的就是读写分离。 </p><p><img data-src="12.png" alt="12.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588523931634.png" alt="1588523931634"></p><p><strong>主从同步</strong></p><p>数据库最终会把数据持久化到磁盘，如果集群必须确保每个数据库服务器的数据是一直的。<strong>能改变数据库数据的操作都往主数据库去写</strong>，<strong>而其他的数据库从主数据库上同步数据。</strong></p><p><strong>读写分离</strong></p><p>   使用负载均衡来实现写的操作都往主数据库去，而读的操作往从服务器去。</p><h3 id="12-数据库优化之缓存"><a href="#12-数据库优化之缓存" class="headerlink" title="12.数据库优化之缓存"></a>12.数据库优化之缓存</h3><p>在<strong>持久层(dao)和数据库(db)</strong>之间添加一个<strong>缓存层</strong>，如果用户访问的数据已经缓存起来时，在用户访问时直接从缓存中获取，不用访问数据库。而<strong>缓存是在操作内存级</strong>，访问速度快。</p><p>作用：减少数据库服务器压力，减少访问时间。</p><p>Java中常用的缓存有，</p><p>   1、hibernate的二级缓存。该缓存不能完成分布式缓存。</p><p><img data-src="13.png" alt="13.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588553532967.png" alt="1588553532967"></p><p>2、可以使用redis(memcahe等)来作为中央缓存。</p><p>​        对缓存的数据进行集中处理</p><h3 id="13-语句优化小技巧"><a href="#13-语句优化小技巧" class="headerlink" title="13.语句优化小技巧"></a>13.语句优化小技巧</h3><h4 id="DDL优化"><a href="#DDL优化" class="headerlink" title="DDL优化:"></a>DDL优化:</h4><p>1 、通过禁用索引来提供导入数据性能 。 这个操作主要针对有数据库的表，追加数据</p><p>//去除键</p><p>alter table test3 DISABLE keys;</p><p>//批量插入数据</p><p>insert into test3 select * from test;</p><p>//恢复键</p><p>alter table test3 ENABLE keys;</p><p>2、 关闭唯一校验</p><p>set unique_checks=0  关闭</p><p>set unique_checks=1  开启</p><p>3、修改事务提交方式(导入)（变多次提交为一次）</p><p>set autocommit=0   关闭</p><p>//批量插入</p><p>set autocommit=1   开启</p><h4 id="DML优化（变多次提交为一次）"><a href="#DML优化（变多次提交为一次）" class="headerlink" title="DML优化（变多次提交为一次）"></a>DML优化（变多次提交为一次）</h4><p>insert into test values(1,2);</p><p>insert into test values(1,3);</p><p>insert into test values(1,4);</p><p>//合并多条为一条</p><p>insert into test values(1,2),(1,3),(1,4)</p><h4 id="DQL优化"><a href="#DQL优化" class="headerlink" title="DQL优化"></a>DQL优化</h4><h5 id="Order-by优化"><a href="#Order-by优化" class="headerlink" title="Order by优化"></a>Order by优化</h5><p>​                1、多用索引排序</p><p>2、普通结果排序（非索引排序）Filesort</p><h5 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h5><p>​      是使用order by null,取消默认排序</p><h5 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h5><p>在客户列表找到不在支付列表的客户</p><p>#在客户列表找到不在“支付列表”的客户 , 查询没买过东西的客户</p><p>explain</p><p>select * from customer where customer_id not in (select DISTINCT customer_id from payment); #子查询      – 这种是基于func外链</p><p>explain </p><p>select * from customer c left join payment p on(c.customer_id=p.customer_id) where p.customer_id is null   – 这种是基于“索引”外链</p><h5 id="Or优化"><a href="#Or优化" class="headerlink" title="Or优化"></a>Or优化</h5><p>在两个独立索引上使用or的性能优于 </p><p>1、 or两边都是用索引字段做判断，性能好！！</p><p>2、 or两边，有一边不用，性能差</p><p>3、 如果employee表的name和email这两列是一个复合索引，但是如果是 :name=’A’ OR email=’B’ 这种方式，不会用到索引！</p><h5 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h5><p>select film_id,description from film order by title limit 50,5;</p><p>select a.film_id,a.description from film a inner join (select film_id from film order by title limit 50,5)b on a.film_id=b.film_id</p><h3 id="14-jdbc批量插入几百万数据怎么实现？-重要"><a href="#14-jdbc批量插入几百万数据怎么实现？-重要" class="headerlink" title="14.jdbc批量插入几百万数据怎么实现？(重要)"></a>14.jdbc批量插入几百万数据怎么实现？(重要)</h3><p>1、变多次提交为一次</p><p>2、使用批量操作</p><p><img data-src="14.png" alt="14.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588554137522.png" alt="1588554137522"></p><p>省出的时间可观。</p><p>像这样的批量插入操作能不使用代码操作就不使用，可以使用存储过程来实现</p><h3 id="15-有没有使用过redis-Redis是什么"><a href="#15-有没有使用过redis-Redis是什么" class="headerlink" title="15.有没有使用过redis? Redis是什么"></a>15.有没有使用过redis? Redis是什么</h3><p>Redis是一个<strong>key-value</strong>的<strong>nosql数据库</strong>.先存到内存中，会根据一定的策略持久化到磁盘,<strong>即使断电也不会丢失数据</strong>。支持的数据类型比较多。</p><p>主要用来<strong>做缓存数据库的数据和web集群时当做中央缓存存放seesion</strong></p><h3 id="16-简单说一下redis的使用场景？"><a href="#16-简单说一下redis的使用场景？" class="headerlink" title="16.简单说一下redis的使用场景？"></a>16.简单说一下redis的使用场景？</h3><h4 id="缓存："><a href="#缓存：" class="headerlink" title="缓存："></a><strong>缓存：</strong></h4><p>把<strong>经常需要查询的、很少修改的数据</strong>，放到读速度很快的空间(内存)，以便下次访问减少时间。减轻压力，减少访问时间.</p><h4 id="计数器："><a href="#计数器：" class="headerlink" title="计数器："></a><strong>计数器：</strong></h4><p>​     redis中的<strong>计数器是原子性的内存操作</strong>。                            </p><p>​       可以<strong>解决库存溢出问题</strong>.进销存系统库存溢出。                  </p><h4 id="session缓存服务器："><a href="#session缓存服务器：" class="headerlink" title="session缓存服务器："></a><strong>session缓存服务器：</strong></h4><p>web集群时作为session缓存服务器</p><p><img data-src="15.png" alt="15.png"></p><p><img data-src="C:%5CUsers%5Czhy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1588554427301.png" alt="1588554427301"></p><h3 id="17-redis对象保存方式？"><a href="#17-redis对象保存方式？" class="headerlink" title="17. redis对象保存方式？"></a>17. redis对象保存方式？</h3><p><strong>Json字符串:</strong></p><p>需要把对象转换为json字符串，当做字符串处理。直接使用set和get来设置或者获取。</p><p>优点：设置和获取比较简单</p><p>缺点：没有提供专门的方法，需要把把对象转换为json。(jsonlib)</p><p><strong>字节:</strong></p><p>   需要做序列号，就是把对象序列化为字节保存。</p><p>如果是担心JSON转对象会消耗资源的情况，这个问题需要考量几个地方，</p><p>第一点：就是使用的JSON转换lib是否就会存在性能问题。</p><p>第二点：就是数据的数据量级别，<strong>如果是存储百万级的大数据对象，建议采用存储序列化对象方式。如果是少量的数据级对象，或者是数据对象字段不多，还是建议采用JSON转换成String方式</strong>。</p><p>毕竟redis对存储字符类型这部分优化的非常好。具体采用的方式与方法，还要看你所使用的场景。 </p><h3 id="18-Java访问Redis"><a href="#18-Java访问Redis" class="headerlink" title="18.Java访问Redis"></a>18.Java访问Redis</h3><p>1、使用jedis java客户端来访问redis服务器，有点类似通过jdbc访问mysql一样。</p><p>2、当然如果是spring进行集成时，可以使用spring data来访问redis,spring data只是对jedis的二次封装。jdbcTemplate jdbc关系一样。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL存储引擎介绍</title>
      <link href="/2020/04/26/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/04/26/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>MySQL5.5以后默认使用<strong>InnoDB</strong>存储引擎，其中<strong>InnoDB和BDB提供事务安全表</strong>，其它存储引擎都是非事务安全表。<br>若要<strong>修改默认引擎</strong>，可以修改配置文件中的default-storage-engine。</p><p>可以通过：show variables like ‘default_storage_engine’;查看当前数据库到默认引擎。</p><p>命令：<em>show engines</em>和<em>show variables like ‘have%’</em>可 以列出当前数据库所支持到引擎。</p><p>其中Value显示为disabled的记录表示数据库支持此引擎，而在数据库启动时被禁用。</p><p>在MySQL5.1以 后，INFORMATION_SCHEMA数据库中存在一个ENGINES的表，它提供的信息与show engines;语句完全一样，可以使用下面语句来查询哪些存储引擎支持事物处理：</p><p>select engine from information_chema.engines where transactions = ‘yes’;<br>可以通过engine关键字在创建或修改数据库时指定所使用到引擎。</p><h2 id="主要存储引擎：MyISAM、InnoDB、MEMORY和MERGE介绍："><a href="#主要存储引擎：MyISAM、InnoDB、MEMORY和MERGE介绍：" class="headerlink" title="主要存储引擎：MyISAM、InnoDB、MEMORY和MERGE介绍："></a>主要存储引擎：MyISAM、InnoDB、MEMORY和MERGE介绍：</h2><p>在创建表到时候通过<em>engine=…</em>或<em>type=…</em>来指定所要使用到引擎。<em>show table status from DBname</em>来查看指定表到引擎。</p><p><strong>(一)MyISAM</strong>　　它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。<br>每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但是扩展名分别为：</p><ul><li>.frm(存储表定义)</li><li>MYD(MYData，存储数据)</li><li>MYI(MYIndex，存储索引)</li></ul><p>　　数据文件和索引文件可以放置在不同的目录，平均分配IO，获取更快的速度。要指定数据文件和索引文件的路径，需要在创建表的时候通过DATA DIRECTORY和INDEX DIRECTORY语句指定，文件路径需要使用绝对路径。<br>　 　每个MyISAM表都有一个标志，服务器或myisamchk程序在检查MyISAM数据表时会对这个标志进行设置。MyISAM表还有一个标志用来表 明该数据表在上次使用后是不是被正常的关闭了。如果服务器以为当机或崩溃，这个标志可以用来判断数据表是否需要检查和修复。如果想让这种检查自动进行，可 以在启动服务器时使用–myisam-recover现象。这会让服务器在每次打开一个MyISAM数据表是自动检查数据表的标志并进行必要的修复处 理。MyISAM类型的表可能会损坏，可以使用CHECK TABLE语句来检查MyISAM表的健康，并用REPAIR TABLE语句修复一个损坏到MyISAM表。<br>　　MyISAM的表还支持3种不同的存储格式：</p><ul><li>静态(固定长度)表</li><li>动态表</li><li>压缩表</li></ul><p>　　其中静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现 故障容易恢复；缺点是占用的空间通常比动态表多。静态表在数据存储时会根据列定义的宽度定义补足空格，但是在访问的时候并不会得到这些空格，这些空格在返 回给应用之前已经去掉。同时需要注意：在某些情况下可能需要返回字段后的空格，而使用这种格式时后面到空格会被自动处理掉。<br>　　动态表包含变长字段，记录不是固定长度的，这样存储的优点是占用空间较少，但是频繁到更新删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk -r命令来改善性能，并且出现故障的时候恢复相对比较困难。<br>　　压缩表由myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。<br><strong>(二)InnoDB</strong>　　</p><p>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。<br><em>1)自动增长列：</em>　　</p><p>​        InnoDB 表的自动增长列可以手工插入，但是插入的如果是空或0，则实际插入到则是自动增长后到值。可以通过”ALTER TABLE…AUTO_INCREMENT=n;”语句强制设置自动增长值的起始值，默认为1，但是该强制到默认值是保存在内存中，数据库重启后该值 将会丢失。可以使用LAST_INSERT_ID()查询当前线程最后插入记录使用的值。如果一次插入多条记录，那么返回的是第一条记录使用的自动增长 值。<br>对于InnoDB表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于MyISAM表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引到前面几列排序后递增的。<br><em>2)外键约束：</em>　　</p><p>​        MySQL支持外键的存储引擎只有InnoDB，在创建外键的时候，父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。<br>​      在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括restrict、cascade、set null和no action。其中restrict和no action相同，是指限制在子表有关联的情况下，父表不能更新；casecade表示父表在更新或删除时，更新或者删除子表对应的记录；set null 则表示父表在更新或者删除的时候，子表对应的字段被set null。<br>　　当某个表被其它表创建了外键参照，那么该表对应的索引或主键被禁止删除。<br>　　可以使用set foreign_key_checks=0;临时关闭外键约束，set foreign_key_checks=1;打开约束。<br><strong>(三)MEMORY</strong>　　memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm。MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。<br>​      默认情况下，memory数据表使用散列索引，利用这种索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了。因此，散列索引值适合使用 在”=”和”&lt;=&gt;”的操作符中，不适合使用在”&lt;”或”&gt;”操作符中，也同样不适合用在order by字句里。如果确实要使用”&lt;”或”&gt;”或betwen操作符，可以使用btree索引来加快速度。<br>　　存储在MEMORY数据表里的数据行使用的是长度不变的格式，因此加快处理速度，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型。VARCHAR是一种长度可变的类型，但因为它在MySQL内部当作长度固定不变的CHAR类型，所以可以使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_memory <span class="keyword">engine</span>=<span class="keyword">memory</span> <span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age,addr <span class="keyword">from</span> man <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><p>使用USING HASH/BTREE来指定特定到索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> mem_hash <span class="keyword">using</span> <span class="keyword">hash</span> <span class="keyword">on</span> tab_memory(city_id);</span><br></pre></td></tr></table></figure><p>在启动MySQL服务的时候使用–init-file选项，把insert into…select或load data infile 这样的语句放入到这个文件中，就可以在服务启动时从持久稳固的数据源中装载表。<br>　　服务器需要足够的内存来维持所在的在同一时间使用的MEMORY表，当不再使用MEMORY表时，要释放MEMORY表所占用的内存，应该执行DELETE FROM或truncate table或者删除整个表。<br>　　每个MEMORY表中放置到数据量的大小，受到max_heap_table_size系统变量的约束，这个系统变量的初始值是16M，同时在创建MEMORY表时可以使用MAX_ROWS子句来指定表中的最大行数。</p><p><strong>(四)MERGE</strong>　　merge 存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，MERGE表中并没有数据，对MERGE类型的表可以进行查询、更新、删除的 操作，这些操作实际上是对内部的MyISAM表进行操作。对于对MERGE表进行的插入操作，是根据INSERT_METHOD子句定义的插入的表，可以 有3个不同的值，first和last值使得插入操作被相应的作用在第一个或最后一个表上，不定义这个子句或者为NO，表示不能对这个MERGE表进行插 入操作。可以对MERGE表进行drop操作，这个操作只是删除MERGE表的定义，对内部的表没有任何影响。MERGE在磁盘上保留2个以MERGE表 名开头文件：.frm文件存储表的定义；.MRG文件包含组合表的信息，包括MERGE表由哪些表组成，插入数据时的依据。可以通过修改.MRG文件来修 改MERGE表，但是修改后要通过flush table刷新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> man_all(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>))<span class="keyword">engine</span>=<span class="keyword">merge</span> <span class="keyword">union</span>=(man1,man2) insert_methos=<span class="keyword">last</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-平衡二叉树</title>
      <link href="/2020/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="平衡二叉树-AVL-树"><a href="#平衡二叉树-AVL-树" class="headerlink" title="平衡二叉树(AVL 树)"></a>平衡二叉树(AVL 树)</h2><h3 id="二叉排序树可能的问题"><a href="#二叉排序树可能的问题" class="headerlink" title="二叉排序树可能的问题"></a>二叉排序树可能的问题</h3><p>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.</p><p>左边 BST 存在的问题分析:</p><p>1) 左子树全部为空，从形式上看，更像一个单链表.<br>2) 插入速度没有影响<br>3) 查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比<br>单链表还慢</p><p>4) 解决方案-平衡二叉树(AVL)</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1) 平衡二叉树也叫平衡 <strong>二叉搜索树</strong>（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。<br>2) 具有以下特点：它是 <strong>一棵空树</strong>或 <strong>它的左右两个子树的高度差的绝对值不超过 1</strong>，并且 <strong>左右两个子树都是一棵</strong><br><strong>平衡二叉树</strong>。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。<br>3) 举例说明, 看看下面哪些 AVL 树, 为什么?</p><p><img data-src="1.png" alt="1.png"></p><h3 id="应用案例-单旋转-左旋转"><a href="#应用案例-单旋转-左旋转" class="headerlink" title="应用案例-单旋转(左旋转)"></a>应用案例-单旋转(左旋转)</h3><p>1) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8}</p><p>2) 思路分析(示意图)</p><p><img data-src="2.png" alt="2.png"></p><p><strong>左旋转的目的就是降低右子树的高度</strong></p><p>3) 代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建新的结点，以当前根结点的值</span></span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line"><span class="comment">// 把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line"><span class="comment">// 把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">newNode.right = <span class="keyword">this</span>.right.left;</span><br><span class="line"><span class="comment">// 把当前结点的值替换成右子结点的值</span></span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.right.value;</span><br><span class="line"><span class="comment">// 把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line"><span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line"><span class="comment">// 把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line"><span class="keyword">this</span>.left = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用案例-单旋转-右旋转"><a href="#应用案例-单旋转-右旋转" class="headerlink" title="应用案例-单旋转(右旋转)"></a>应用案例-单旋转(右旋转)</h3><p>1) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}<br>2) 思路分析(示意图)</p><p><img data-src="3.png" alt="3.png"></p><p>3) 代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line"><span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line"><span class="keyword">this</span>.right = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改add方法"><a href="#修改add方法" class="headerlink" title="修改add方法"></a>修改add方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line"><span class="keyword">if</span> (rightHeight()-leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">leftRotate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line"><span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">rightRotate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用案例-双旋转"><a href="#应用案例-双旋转" class="headerlink" title="应用案例-双旋转"></a>应用案例-双旋转</h3><p>前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转<br>不能完成平衡二叉树的转换。比如数列<br>int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树.<br>int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成 AVL 树</p><p>1) 问题分析</p><p><img data-src="4.png" alt="4.png"></p><p>2) 解决思路分析</p><ol><li><p>当符合右旋转的条件时</p></li><li><p>如果它的<strong>左子树的右子树高度大于它的左子树的左子树</strong>的高度（2 &gt; 1）</p></li><li><p>先对当前这个结点的左节点进行左旋转</p></li><li><p>在对当前结点进行右旋转的操作即可</p></li></ol><p><img data-src="5.png" alt="5.png"></p><p>左旋后</p><p><img data-src="6.png" alt="6.png"></p><p>所以原树变为</p><p><img data-src="7.png" alt="7.png"></p><p>在进行右旋，变为</p><p><img data-src="8.png" alt="8.png"></p><p>3) 代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line"><span class="keyword">if</span> (rightHeight()-leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.leftHeight() &gt; <span class="keyword">this</span>.right.rightHeight()) &#123;</span><br><span class="line"><span class="comment">//先对右子结点进行右旋转</span></span><br><span class="line"><span class="keyword">this</span>.right.rightRotate();</span><br><span class="line"><span class="comment">//然后在对当前结点进行左旋转</span></span><br><span class="line"><span class="keyword">this</span>.leftRotate();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//直接进行左旋转即可</span></span><br><span class="line">leftRotate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//处理完一个不能继续往下走</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line"><span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.rightHeight()&gt;<span class="keyword">this</span>.left.leftHeight())&#123;</span><br><span class="line"><span class="comment">//先对当前结点的左结点(左子树)-&gt;左旋转</span></span><br><span class="line"><span class="keyword">this</span>.left.leftRotate();</span><br><span class="line"><span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">rightRotate();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//直接进行右旋转即可</span></span><br><span class="line">rightRotate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AVL树全部代码"><a href="#AVL树全部代码" class="headerlink" title="AVL树全部代码"></a>AVL树全部代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int[] arr = &#123;4,3,6,5,7,8&#125;;</span></span><br><span class="line"><span class="comment">//int[] arr = &#123; 10, 12, 8, 9, 7, 6 &#125;;</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;  </span><br><span class="line"><span class="comment">//创建一个 AVLTree对象</span></span><br><span class="line">AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line"><span class="comment">// 添加结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">avlTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"中序遍历"</span>);</span><br><span class="line">avlTree.infixOrder();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"在没有平衡处理前~~"</span>);</span><br><span class="line">System.out.println(<span class="string">"树的高度="</span> + avlTree.getRoot().height()); <span class="comment">//3</span></span><br><span class="line">System.out.println(<span class="string">"树的左子树高度="</span> + avlTree.getRoot().leftHeight()); <span class="comment">// 2</span></span><br><span class="line">System.out.println(<span class="string">"树的右子树高度="</span> + avlTree.getRoot().rightHeight()); <span class="comment">// 2</span></span><br><span class="line">System.out.println(<span class="string">"当前的根结点="</span> + avlTree.getRoot());<span class="comment">//8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建AVLTree</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写方法: </span></span><br><span class="line"><span class="comment">//1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">//2. 删除node 为根结点的二叉排序树的最小结点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">Node target = node;</span><br><span class="line"><span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line"><span class="keyword">while</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">target = target.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时 target就指向了最小结点</span></span><br><span class="line"><span class="comment">// 删除最小结点</span></span><br><span class="line">delNode(target.value);</span><br><span class="line"><span class="keyword">return</span> target.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">Node targetNode = search(value);</span><br><span class="line"><span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点 targetNode == root</span></span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">Node parent = searchParent(value);</span><br><span class="line"><span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是右子结点</span></span><br><span class="line">parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line"><span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">targetNode.value = minVal;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//删除只有一颗子树的结点</span></span><br><span class="line"><span class="comment">//如果要删除的结点有左子结点 </span></span><br><span class="line"><span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.left;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.left;</span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要删除的结点有右子结点 </span></span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回 以该结点为根结点的树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.max(left == <span class="keyword">null</span> ? <span class="number">0</span> : left.height(), right == <span class="keyword">null</span> ? <span class="number">0</span> : right.height())+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回左子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回右子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> right.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 希望删除的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到则返回该节点，否则，返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;<span class="comment">//说明就是该节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="comment">//如果左子节点为空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果查找的值不小于（大于或等于）当前节点，向右子树递归查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找要删除节点的父节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要找的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的是要删除的节点的父节点 如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果当前节点就是要删除的结点的父节点，就返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value || </span><br><span class="line"><span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要查找的值小于当前结点的值，并且当前结点的左子结点不为空，</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有找到父节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line"><span class="keyword">if</span> (rightHeight()-leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.leftHeight() &gt; <span class="keyword">this</span>.right.rightHeight()) &#123;</span><br><span class="line"><span class="comment">//先对右子结点进行右旋转</span></span><br><span class="line"><span class="keyword">this</span>.right.rightRotate();</span><br><span class="line"><span class="comment">//然后在对当前结点进行左旋转</span></span><br><span class="line"><span class="keyword">this</span>.leftRotate();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//直接进行左旋转即可</span></span><br><span class="line">leftRotate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//处理完一个不能继续往下走</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line"><span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.rightHeight()&gt;<span class="keyword">this</span>.left.leftHeight())&#123;</span><br><span class="line"><span class="comment">//先对当前结点的左结点(左子树)-&gt;左旋转</span></span><br><span class="line"><span class="keyword">this</span>.left.leftRotate();</span><br><span class="line"><span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">rightRotate();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//直接进行右旋转即可</span></span><br><span class="line">rightRotate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左旋转方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建新的结点，以当前根结点的值</span></span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line"><span class="comment">// 把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line"><span class="comment">// 把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">newNode.right = <span class="keyword">this</span>.right.left;</span><br><span class="line"><span class="comment">// 把当前结点的值替换成右子结点的值</span></span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.right.value;</span><br><span class="line"><span class="comment">// 把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line"><span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line"><span class="comment">// 把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line"><span class="keyword">this</span>.left = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line"><span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line"><span class="keyword">this</span>.right = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-二叉排序树</title>
      <link href="/2020/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
      <url>/2020/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉排序树介绍"><a href="#二叉排序树介绍" class="headerlink" title="二叉排序树介绍"></a>二叉排序树介绍</h2><p><strong>二叉排序树：BST</strong>: (Binary Sort(Search) Tree), 对于二叉排序树的 <strong>任何一个非叶子节点</strong>，要求 <strong>左子节点的值比当</strong><br><strong>前节点的值小， 右子节点的值比当前节点的值大。</strong><br><strong>特别说明</strong>：如果有相同的值，可以将该节点放在左子节点或右子节点<br>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p><p><img data-src="1.png" alt="1.png"></p><h2 id="二叉排序树创建和遍历"><a href="#二叉排序树创建和遍历" class="headerlink" title="二叉排序树创建和遍历"></a>二叉排序树创建和遍历</h2><h3 id="1-先创建Node节点和中序遍历"><a href="#1-先创建Node节点和中序遍历" class="headerlink" title="1.先创建Node节点和中序遍历"></a>1.先创建Node节点和中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Node节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建二叉排序树和添加方法"><a href="#2-创建二叉排序树和添加方法" class="headerlink" title="2.创建二叉排序树和添加方法"></a>2.创建二叉排序树和添加方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h2><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑</p><p>1) 点 删除叶子节点 (比如：2, 5, 9, 12)<br>2) 删除点 只有一颗子树的节点 (比如：1)<br>3) 删除 有两颗子树的节点. (比如：7, 3，10 )<br>4) 操作的思路分析</p><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况:"></a>第一种情况:</h3><p>删除叶子节点 (比如：2, 5, 9, 12)</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>(1) 需求先去找到要删除的结点  targetNode</p><p>(2)  找到targetNode 的 父结点 parent </p><p>(3)  确定 targetNode 是 parent的左子结点 还是右子结点</p><p>(4)  根据前面的情况来对应删除</p><p>左子结点 parent.left = null</p><p>右子结点 parent.right = null;</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line"><span class="comment">//循环的添加结点到二叉排序树</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">System.out.println(<span class="string">"中序遍历二叉排序树~"</span>);</span><br><span class="line">binarySortTree.infixOrder();<span class="comment">// 1, 3, 5, 7, 9, 10, 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一下删除叶子结点   </span></span><br><span class="line">    binarySortTree.delNode(<span class="number">12</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"删除结点后"</span>);</span><br><span class="line">binarySortTree.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">Node targetNode = search(value);</span><br><span class="line"><span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点 targetNode == root</span></span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">Node parent = searchParent(value);</span><br><span class="line"><span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是右子结点</span></span><br><span class="line">parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 希望删除的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到则返回该节点，否则，返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;<span class="comment">//说明就是该节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="comment">//如果左子节点为空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果查找的值不小于（大于或等于）当前节点，向右子树递归查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找要删除节点的父节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要找的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的是要删除的节点的父节点 如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果当前节点就是要删除的结点的父节点，就返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value || </span><br><span class="line"><span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要查找的值小于当前结点的值，并且当前结点的左子结点不为空，</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有找到父节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种情况-删除只有一颗子树的节点-比如：1"><a href="#第二种情况-删除只有一颗子树的节点-比如：1" class="headerlink" title="第二种情况: 删除只有一颗子树的节点 (比如：1 )"></a>第二种情况: <strong>删除只有一颗子树的节点</strong> (比如：1 )</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>(1) 需求先去找到要删除的结点  targetNode</p><p>(2)  找到targetNode 的 父结点 parent </p><p>(3) 确定targetNode 的子结点是左子结点还是右子结点</p><p>(4) targetNode 是 parent 的左子结点还是右子结点</p><p>(5) 如果targetNode 有左子结点</p><p>5.1 如果 targetNode 是 parent 的左子结点</p><p>parent.left = targetNode.left;</p><p>5.2  如果 targetNode 是 parent 的右子结点</p><p>parent.right = targetNode.left;</p><p>(6) 如果targetNode 有右子结点</p><p>6.1 如果 targetNode 是 parent 的左子结点</p><p>parent.left = targetNode.right;</p><p>6.2 如果 targetNode 是 parent 的右子结点</p><p>parent.right = targetNode.right</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line"><span class="comment">//循环的添加结点到二叉排序树</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">System.out.println(<span class="string">"中序遍历二叉排序树~"</span>);</span><br><span class="line">binarySortTree.infixOrder();<span class="comment">// 1, 3, 5, 7, 9, 10, 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一下删除叶子结点   </span></span><br><span class="line">    binarySortTree.delNode(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"删除结点后"</span>);</span><br><span class="line">binarySortTree.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">Node targetNode = search(value);</span><br><span class="line"><span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点 targetNode == root</span></span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">Node parent = searchParent(value);</span><br><span class="line"><span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是右子结点</span></span><br><span class="line">parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//删除只有一颗子树的结点</span></span><br><span class="line"><span class="comment">//如果要删除的结点有左子结点 </span></span><br><span class="line"><span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.left;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.left;</span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要删除的结点有右子结点 </span></span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 希望删除的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到则返回该节点，否则，返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;<span class="comment">//说明就是该节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="comment">//如果左子节点为空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果查找的值不小于（大于或等于）当前节点，向右子树递归查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找要删除节点的父节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要找的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的是要删除的节点的父节点 如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果当前节点就是要删除的结点的父节点，就返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value || </span><br><span class="line"><span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要查找的值小于当前结点的值，并且当前结点的左子结点不为空，</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有找到父节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况三-：-删除有两颗子树的节点-比如：7-3，10"><a href="#情况三-：-删除有两颗子树的节点-比如：7-3，10" class="headerlink" title="情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 )"></a>情况三 ： 删除有两颗子树的节点. (比如：7, 3，<strong>10</strong> )</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>(1) 需求先去找到要删除的结点  targetNode</p><p>(2)  找到targetNode 的 父结点 parent </p><p>(3)  从targetNode 的<strong>右子树</strong>找到<strong>最小的结点</strong>(左子树则要最大值)</p><p>(4) 用一个临时变量，将 最小结点的值保存 temp </p><p>(5)  删除该最小结点</p><p>(6)  targetNode.value = temp</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line"><span class="comment">//循环的添加结点到二叉排序树</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">System.out.println(<span class="string">"中序遍历二叉排序树~"</span>);</span><br><span class="line">binarySortTree.infixOrder();<span class="comment">// 1, 3, 5, 7, 9, 10, 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一下删除叶子结点   </span></span><br><span class="line">    binarySortTree.delNode(<span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"删除结点后"</span>);</span><br><span class="line">binarySortTree.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写方法: </span></span><br><span class="line"><span class="comment">//1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">//2. 删除node 为根结点的二叉排序树的最小结点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">Node target = node;</span><br><span class="line"><span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line"><span class="keyword">while</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">target = target.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时 target就指向了最小结点</span></span><br><span class="line"><span class="comment">// 删除最小结点</span></span><br><span class="line">delNode(target.value);</span><br><span class="line"><span class="keyword">return</span> target.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">Node targetNode = search(value);</span><br><span class="line"><span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点 targetNode == root</span></span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">Node parent = searchParent(value);</span><br><span class="line"><span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是右子结点</span></span><br><span class="line">parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line"><span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">targetNode.value = minVal;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//删除只有一颗子树的结点</span></span><br><span class="line"><span class="comment">//如果要删除的结点有左子结点 </span></span><br><span class="line"><span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.left;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.left;</span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要删除的结点有右子结点 </span></span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">root.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.infixOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉排序树为空，不能遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 希望删除的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到则返回该节点，否则，返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;<span class="comment">//说明就是该节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="comment">//如果左子节点为空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果查找的值不小于（大于或等于）当前节点，向右子树递归查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找要删除节点的父节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要找的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的是要删除的节点的父节点 如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果当前节点就是要删除的结点的父节点，就返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value || </span><br><span class="line"><span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果要查找的值小于当前结点的值，并且当前结点的左子结点不为空，</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有找到父节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加节点的方法</span></span><br><span class="line"><span class="comment">//递归的形式 添加节点，需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断传入的节点的值，和当前子树的根节点的值的关系</span></span><br><span class="line"><span class="keyword">if</span> (node.value &lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//添加的节点小于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左子树递归</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//添加的节点大于当前节点的值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商项目整理</title>
      <link href="/2020/04/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86/"/>
      <url>/2020/04/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-解决浮点型商业运算中丢失精度的问题"><a href="#1-解决浮点型商业运算中丢失精度的问题" class="headerlink" title="1.解决浮点型商业运算中丢失精度的问题"></a>1.解决浮点型商业运算中丢失精度的问题</h2><h3 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h3><p>我们知道整数类型没有精度丢失的问题，但是浮点数有精度丢失的问题，下面我们来探究一下其精度丢失的原因所在。</p><p><strong>浮点数，分单精度（float）和双精度（double）：</strong></p><p>float ，介于 -3.402823e38 和 +3.402823e38 之间的32位数字；</p><p>double ，介于 -1.79769313486232e308 和 +1.79769313486232e308 之间的64位数字；</p><p>我们知道，计算机只识别 0 和 1，所以数值都是以二进制的方式储存在内存中的。<br>所以要知道数值在内存中是如何储存的，需先将数值转为二进制<br>根据 IEEE 754 标准，任意一个二进制浮点数 V 均可表示为：V = (-1 ^ s) * M * (2 ^ e)。<br>其中 s ∈ {0, 1}；M ∈ [1, 2)；e 表示偏移指数。</p><p>具体浮点数的 IEEE 754表示方法在我之前的博客有所讲解，不清楚的可以查看，这里就不解释了。</p><h4 id="精度丢失原因"><a href="#精度丢失原因" class="headerlink" title="精度丢失原因"></a>精度丢失原因</h4><p>首先计算机进行的是二进制运算，我们输入的十进制数字会先转换成二进制，进行运算后再转换为十进制输出。Float和Double提供了快速的运算，然而问题在于转换为二进制的时候，有些数字不能完全转换，<strong>只能无限接近于原本的值</strong>，这就导致了在后来的运算会出现不正确结果的情况。</p><p>我们先探究一下int 和 float同样都是用32位表示，但是为什么float范围就比int大很多呢？</p><p>int取值范围：-2147483648~2147483647，远远不足float： -3.402823e38 ~+3.402823e38</p><p>我们知道int数值是连续且等分的，而float数值是跳跃的，并且间隔不一定相等。都是用32位表示，也就是说int和float可存储数值的最大数量是相等的，为2的32次方。</p><p>文字理解有点抽象，下面我们上图来看</p><p><img data-src="3.png" alt="3.png"></p><p>大概意思我们可以看到，在负数值范围内，float可以表示更加精确的数（图中较为密集的部分），但是在正数范围中，float表示的就不如int精确了，并且float数值不是等分表示的，这就造成了float的精度丢失。</p><p>这样应该就能理解浮点数精度丢失的原因了，其实最根本原因还是计算机只能采取二进制存储数据</p><h3 id="普通测试"><a href="#普通测试" class="headerlink" title="普通测试"></a>普通测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="number">0.05</span> + <span class="number">0.01</span>);</span><br><span class="line">       System.out.println(<span class="number">1.0</span> - <span class="number">0.42</span>);</span><br><span class="line">       System.out.println(<span class="number">4.015</span> * <span class="number">100</span>);</span><br><span class="line">       System.out.println(<span class="number">123.3</span> / <span class="number">100</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img data-src="1.png" alt="1.png"></p><p>如图所示，在进行加减乘除运算时，得到的结果并不是我们预期的结果，假设我们在电商项目内进行价格计算时就会出现问题，很有可能造成余额为 9.99999999999999，但是无法购买10元的商品。</p><h3 id="使用Integer类型的BigDecimal构造器进行运算"><a href="#使用Integer类型的BigDecimal构造器进行运算" class="headerlink" title="使用Integer类型的BigDecimal构造器进行运算"></a>使用Integer类型的BigDecimal构造器进行运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(<span class="number">0.05</span>);</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(<span class="number">0.01</span>);</span><br><span class="line">    System.out.println(b1.add(b2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="2.png" alt="2.png"></p><p>结果如图所示，结果也不正确，支付时也会出现问题。</p><h3 id="使用String类型的BigDecimal构造器进行运算"><a href="#使用String类型的BigDecimal构造器进行运算" class="headerlink" title="使用String类型的BigDecimal构造器进行运算"></a>使用String类型的BigDecimal构造器进行运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.05"</span>);</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.01"</span>);</span><br><span class="line">    System.out.println(b1.add(b2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为0.06，正确</p>]]></content>
      
      
      <categories>
          
          <category> 电商项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试宝典-GC</title>
      <link href="/2020/04/20/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-GC/"/>
      <url>/2020/04/20/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-GC/</url>
      
        <content type="html"><![CDATA[<h2 id="●-请简单描述一下垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？"><a href="#●-请简单描述一下垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？" class="headerlink" title="● 请简单描述一下垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？"></a>● 请简单描述一下垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？</h2><p>考察点：垃圾回收</p><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p><h2 id="●-请问，在java中会存在内存泄漏吗？请简单描述一下。"><a href="#●-请问，在java中会存在内存泄漏吗？请简单描述一下。" class="headerlink" title="● 请问，在java中会存在内存泄漏吗？请简单描述一下。"></a>● 请问，在java中会存在内存泄漏吗？请简单描述一下。</h2><p>考察点：内存</p><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Java中的确存在Java的内存泄漏, 并且事态可以变得相当严重</p><p>Java garbage collector自动释放哪些内存里面程序不在需要的对象, 以此避免大多数的其他程序上下文的内存泄漏. 但是Java应用程序依旧会有相当的内存泄漏. 查找原因会十分困难.<br>有两类主要的Java内存泄漏:<br>* 不再需要的对象引用<br>* 未释放的系统资源<br>2.2 非必要的对象引用<br>Java代码常常保留对于不再需要的对象引用, 并且这组织了内存的垃圾收集器的工作. Java对象通常被其他对象包含引用, 为此一个单一对象可以保持整个对象树在内存中, 于是导致了如下问题:<br>* 在向数组添加对象以后遗漏了对于他们的处理<br>* 直到你再次使用对象的时候都不释放引用. 比如一个菜单指令可以插件一个对象实例引用并且不释放便于以后再次调用的时候使用, 但是也许永远不会发生.<br>* 在其他引用依然需要旧有状态的时候贸然修改对象状态. 比如当你为了在一个文本文件里面保存一些属性而使用一个数组, 诸如”字符个数”等字段在不再需要的时候依然保留在内存当中.<br>* 允许一个长久执行的线程所引用的对象. 设置引用为NULL也无济于事, 在线程退出和空闲之前, 对象不会被收集释放<br>2.3 未释放的系统资源<br>Java方法可以定位Java实例意外的堆内存, 诸如针对视窗和位图的内存资源. Java常常通过JNI(Java Native Interface)调用C/C++子程序定位这些资源.</p><h2 id="●-请说明一下垃圾回收的优点以及原理。"><a href="#●-请说明一下垃圾回收的优点以及原理。" class="headerlink" title="● 请说明一下垃圾回收的优点以及原理。"></a>● 请说明一下垃圾回收的优点以及原理。</h2><p>考察点：垃圾回收</p><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Java 语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</p><h2 id="●-请问GC是什么-还有为什么要有GC"><a href="#●-请问GC是什么-还有为什么要有GC" class="headerlink" title="● 请问GC是什么? 还有为什么要有GC?"></a>● 请问GC是什么? 还有为什么要有GC?</h2><p>考察点：回收</p><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p><h2 id="●-请简述一下GC算法"><a href="#●-请简述一下GC算法" class="headerlink" title="● 请简述一下GC算法"></a>● 请简述一下GC算法</h2><p>考察点：JVM</p><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>①GC（GarbageCollection 垃圾收集），GC的对象是堆空间和永久区</p><p>②GC算法包含：引用计数法，标记清除，标记压缩，复制算法。</p><p>③引用计数器的实现很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。</p><p>④标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。与标记-清除算法相比，复制算法是一种相对高效的回收方法不适用于存活对象较多的场合如老年代将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p><h2 id="●-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？请简要说明一下"><a href="#●-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？请简要说明一下" class="headerlink" title="● 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？请简要说明一下"></a>● 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？请简要说明一下</h2><p>考察点：GC</p><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><h3 id="minor-gc运行的很频繁可能是什么原因引起的？"><a href="#minor-gc运行的很频繁可能是什么原因引起的？" class="headerlink" title="minor gc运行的很频繁可能是什么原因引起的？"></a>minor gc运行的很频繁可能是什么原因引起的？</h3><p>1、 产生了太多朝生夕灭的对象导致需要频繁minor gc</p><p>2、 新生代空间设置的比较小</p><h3 id="minor-gc运行的很慢有可能是什么原因引起的？"><a href="#minor-gc运行的很慢有可能是什么原因引起的？" class="headerlink" title="minor gc运行的很慢有可能是什么原因引起的？"></a>minor gc运行的很慢有可能是什么原因引起的？</h3><p>1、 新生代空间设置过大。</p><p>2、 对象引用链较长，进行可达性分析时间较长。</p><p>3、 新生代survivor区设置的比较小，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销。</p><p>4、 内存分配担保失败，由minor gc转化为full gc</p><p>5、 采用的垃圾收集器效率较低，比如新生代使用serial收集器</p><h2 id="●-请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？"><a href="#●-请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？" class="headerlink" title="● 请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？"></a>● 请问java中内存泄漏是什么意思？什么场景下会出现内存泄漏的情况？</h2><p>考察点：内存泄漏</p><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试宝典 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试宝典-锁</title>
      <link href="/2020/04/20/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-%E9%94%81/"/>
      <url>/2020/04/20/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="●-请你简述一下synchronized与java-util-concurrent-locks-Lock的相同之处和不同之处？"><a href="#●-请你简述一下synchronized与java-util-concurrent-locks-Lock的相同之处和不同之处？" class="headerlink" title="● 请你简述一下synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处？"></a>● 请你简述一下synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处？</h2><p>考察点：锁机制</p><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>主要相同点：Lock能完成synchronized所实现的所有功能</p><p>主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。</p><h2 id="●-JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？"><a href="#●-JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？" class="headerlink" title="● JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？"></a>● JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？</h2><p>考察点：死锁</p><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p><p>预防死锁，预先破坏产生死锁的四个条件。互斥不可能破坏，所以有如下三种方法：</p><p>1.破坏请求和保持条件，进程必须等所有要请求的资源都空闲时才能申请资源，这种方法会使资源浪费严重(有些资源可能仅在运行初期或结束时才使用，甚至根本不使用). 允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源，比如有一个进程的任务是把数据复制到磁盘中再打印，前期只需获得磁盘资源而不需要获得打印机资源，待复制完毕后再释放掉磁盘资源。这种方法比第一种方法好，会使资源利用率上升。</p><p>2.破坏不可抢占条件，这种方法代价大，实现复杂。</p><p>3.破坏循坏等待条件，对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对资源的利用率比前两种都高，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制。</p><h2 id="●-请问什么是死锁-deadlock"><a href="#●-请问什么是死锁-deadlock" class="headerlink" title="● 请问什么是死锁(deadlock)?"></a>● 请问什么是死锁(deadlock)?</h2><p>考察点：线程死锁</p><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。</p><p>例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。</p><h2 id="●-请说明一下锁和同步的区别。"><a href="#●-请说明一下锁和同步的区别。" class="headerlink" title="● 请说明一下锁和同步的区别。"></a>● 请说明一下锁和同步的区别。</h2><p>考察点：锁</p><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>用法上的不同：<br>synchronized既可以加在方法上，也可以加载特定代码块上，而lock需要显示地指定起始位置和终止位置。<br>synchronized是托管给JVM执行的，lock的锁定是通过代码实现的，它有比synchronized更精确的线程语义。<br>性能上的不同：<br>lock接口的实现类ReentrantLock，不仅具有和synchronized相同的并发性和内存语义，还多了超时的获取锁、定时锁、等候和中断锁等。<br>在竞争不是很激烈的情况下，synchronized的性能优于ReentrantLock，竞争激烈的情况下synchronized的性能会下降的非常快，而ReentrantLock则基本不变。<br>锁机制不同：<br>synchronized获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且是自动解锁。而Lock则需要开发人员手动释放，并且必须在finally中释放，否则会引起死锁。</p><h2 id="●-请说明一下synchronized的可重入怎么实现。"><a href="#●-请说明一下synchronized的可重入怎么实现。" class="headerlink" title="● 请说明一下synchronized的可重入怎么实现。"></a>● 请说明一下synchronized的可重入怎么实现。</h2><p>考察点：锁</p><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。</p><h2 id="●-请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。"><a href="#●-请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。" class="headerlink" title="● 请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。"></a>● 请讲一下非公平锁和公平锁在reetrantlock里的实现过程是怎样的。</h2><p>考察点：锁</p><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，FIFO。对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试宝典 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试宝典-集合</title>
      <link href="/2020/04/20/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-%E9%9B%86%E5%90%88/"/>
      <url>/2020/04/20/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="●-请说明List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#●-请说明List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="● 请说明List、Map、Set三个接口存取元素时，各有什么特点？"></a>● 请说明List、Map、Set三个接口存取元素时，各有什么特点？</h2><p>考察点：List</p><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p><h2 id="●-阐述ArrayList、Vector、LinkedList的存储性能和特性"><a href="#●-阐述ArrayList、Vector、LinkedList的存储性能和特性" class="headerlink" title="● 阐述ArrayList、Vector、LinkedList的存储性能和特性"></a>● 阐述ArrayList、Vector、LinkedList的存储性能和特性</h2><p>考察点：ArrayList</p><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p><h2 id="●-请判断List、Set、Map是否继承自Collection接口？"><a href="#●-请判断List、Set、Map是否继承自Collection接口？" class="headerlink" title="● 请判断List、Set、Map是否继承自Collection接口？"></a>● 请判断List、Set、Map是否继承自Collection接口？</h2><p>考察点：collection接口</p><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p><h2 id="●-请讲讲你所知道的常用集合类以及主要方法？"><a href="#●-请讲讲你所知道的常用集合类以及主要方法？" class="headerlink" title="● 请讲讲你所知道的常用集合类以及主要方法？"></a>● 请讲讲你所知道的常用集合类以及主要方法？</h2><p>考察点：集合</p><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>最常用的集合类是List 和 Map。</p><p>List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。</p><p>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。</p><h2 id="●-请说明Collection-和-Collections的区别。"><a href="#●-请说明Collection-和-Collections的区别。" class="headerlink" title="● 请说明Collection 和 Collections的区别。"></a>● 请说明Collection 和 Collections的区别。</h2><p>考察点：集合</p><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Collection是集合类的上级接口，继承与他的接口主要有Set 和List.</p><p>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p><h2 id="●-请说明ArrayList和LinkedList的区别？"><a href="#●-请说明ArrayList和LinkedList的区别？" class="headerlink" title="● 请说明ArrayList和LinkedList的区别？"></a>● 请说明ArrayList和LinkedList的区别？</h2><p>考察点：ArrayList</p><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：<br>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。<br>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p><h2 id="●-请你说明HashMap和Hashtable的区别？"><a href="#●-请你说明HashMap和Hashtable的区别？" class="headerlink" title="● 请你说明HashMap和Hashtable的区别？"></a>● 请你说明HashMap和Hashtable的区别？</h2><p>考察点：集合</p><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：<br>HashMap允许键和值是null，而Hashtable不允许键或者值是null。<br>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。<br>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。<br>一般认为Hashtable是一个遗留的类。</p><h2 id="●-请说说快速失败-fail-fast-和安全失败-fail-safe-的区别？"><a href="#●-请说说快速失败-fail-fast-和安全失败-fail-safe-的区别？" class="headerlink" title="● 请说说快速失败(fail-fast)和安全失败(fail-safe)的区别？"></a>● 请说说快速失败(fail-fast)和安全失败(fail-safe)的区别？</h2><p>考察点：集合</p><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p><h2 id="●-请你说说Iterator和ListIterator的区别？"><a href="#●-请你说说Iterator和ListIterator的区别？" class="headerlink" title="● 请你说说Iterator和ListIterator的区别？"></a>● 请你说说Iterator和ListIterator的区别？</h2><p>考察点：迭代器</p><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Iterator和ListIterator的区别是：<br>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p><h2 id="●-请简单说明一下什么是迭代器？"><a href="#●-请简单说明一下什么是迭代器？" class="headerlink" title="● 请简单说明一下什么是迭代器？"></a>● 请简单说明一下什么是迭代器？</h2><p>考察点：JAVA迭代器</p><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口,<br>每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作.<br>有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除.</p><h2 id="●-请解释为什么集合类没有实现Cloneable和Serializable接口？"><a href="#●-请解释为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="● 请解释为什么集合类没有实现Cloneable和Serializable接口？"></a>● 请解释为什么集合类没有实现Cloneable和Serializable接口？</h2><p>考察点：JAVA集合</p><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p><p>考察点：JAVA集合集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：Collection：代表一组对象，每一个对象都是它的子元素。Set：不包含重复元素的Collection。List：有顺序的collection，并且可以包含重复元素。Map：可以把键(key)映射到值(value)的对象，键不能重复。</p><h2 id="●-请你说明一下ConcurrentHashMap的原理？"><a href="#●-请你说明一下ConcurrentHashMap的原理？" class="headerlink" title="● 请你说明一下ConcurrentHashMap的原理？"></a>● 请你说明一下ConcurrentHashMap的原理？</h2><p>考察点：JAVA内存模型</p><h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;                       <span class="comment">// 声明 key 为 final 型</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;                   <span class="comment">// 声明 hash 值为 final 型</span></span><br><span class="line">       <span class="keyword">volatile</span> V value;                 <span class="comment">// 声明 value 为 volatile 型</span></span><br><span class="line">       <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;      <span class="comment">// 声明 next 为 final 型</span></span><br><span class="line">  </span><br><span class="line">       HashEntry(K key, <span class="keyword">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图：</p><p>图1. 插入三个节点后桶的结构示意图：</p><p><img data-src="1.png" alt="1.png"></p><p>注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。</p><p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。</p><h2 id="●-请解释一下TreeMap"><a href="#●-请解释一下TreeMap" class="headerlink" title="● 请解释一下TreeMap?"></a>● 请解释一下TreeMap?</h2><p>考察点：key-value集合</p><h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>TreeMap是一个有序的key-value集合，基于红黑树（Red-Black tree）的 NavigableMap实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator进行排序，具体取决于使用的构造方法。</p><p>考点：集合</p><h3 id="参考回答：-13"><a href="#参考回答：-13" class="headerlink" title="参考回答："></a>参考回答：</h3><p>ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；ArrayList并发add()可能出现数组下标越界异常。</p><h2 id="●-请你说明concurrenthashmap有什么优势以及1-7和1-8区别？"><a href="#●-请你说明concurrenthashmap有什么优势以及1-7和1-8区别？" class="headerlink" title="● 请你说明concurrenthashmap有什么优势以及1.7和1.8区别？"></a>● 请你说明concurrenthashmap有什么优势以及1.7和1.8区别？</h2><p>考点：集合</p><h3 id="参考回答：-14"><a href="#参考回答：-14" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Concurrenthashmap线程安全的，1.7是在jdk1.7中采用Segment + HashEntry的方式进行实现的，lock加在Segment上面。1.7size计算是先采用不加锁的方式，连续计算元素的个数，最多计算3次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数；</p><p>1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数；</p><h2 id="●-请你说明一下TreeMap的底层实现？"><a href="#●-请你说明一下TreeMap的底层实现？" class="headerlink" title="● 请你说明一下TreeMap的底层实现？"></a>● 请你说明一下TreeMap的底层实现？</h2><p>考点：集合</p><h3 id="参考回答：-15"><a href="#参考回答：-15" class="headerlink" title="参考回答："></a>参考回答：</h3><p>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。</p><p>红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑树性质：</p><p>性质1：每个节点要么是红色，要么是黑色。</p><p>性质2：根节点永远是黑色的。</p><p>性质3：所有的叶节点都是空节点（即 null），并且是黑色的。</p><p>性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</p><p>性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p><h2 id="●-请你说明ConcurrentHashMap锁加在了哪些地方？"><a href="#●-请你说明ConcurrentHashMap锁加在了哪些地方？" class="headerlink" title="● 请你说明ConcurrentHashMap锁加在了哪些地方？"></a>● 请你说明ConcurrentHashMap锁加在了哪些地方？</h2><p>考点：集合</p><h3 id="参考回答：-16"><a href="#参考回答：-16" class="headerlink" title="参考回答："></a>参考回答：</h3><p>加在每个Segment 上面。</p><h2 id="●-请你解释HashMap的容量为什么是2的n次幂？"><a href="#●-请你解释HashMap的容量为什么是2的n次幂？" class="headerlink" title="● 请你解释HashMap的容量为什么是2的n次幂？"></a>● 请你解释HashMap的容量为什么是2的n次幂？</h2><p>考点：集合</p><h3 id="参考回答：-17"><a href="#参考回答：-17" class="headerlink" title="参考回答："></a>参考回答：</h3><p>负载因子默认是0.75， 2^n是为了让散列更加均匀，例如出现极端情况都散列在数组中的一个下标，那么hashmap会由O（1）复杂退化为O（n）的。</p><h2 id="●-请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？"><a href="#●-请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？" class="headerlink" title="● 请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？"></a>● 请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？</h2><p>考点：集合</p><h3 id="参考回答：-18"><a href="#参考回答：-18" class="headerlink" title="参考回答："></a>参考回答：</h3><p>ArrayList采用数组数组实现的，查找效率比LinkedList高。LinkedList采用双向链表实现的，插入和删除的效率比ArrayList要高。一直在list的尾部添加元素，LinkedList效率要高。</p><h2 id="●-如果hashMap的key是一个自定义的类，怎么办？"><a href="#●-如果hashMap的key是一个自定义的类，怎么办？" class="headerlink" title="● 如果hashMap的key是一个自定义的类，怎么办？"></a>● 如果hashMap的key是一个自定义的类，怎么办？</h2><p>考点：集合</p><h3 id="参考回答：-19"><a href="#参考回答：-19" class="headerlink" title="参考回答："></a>参考回答：</h3><p>使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。</p><h2 id="●-请你解释一下hashMap具体如何实现的？"><a href="#●-请你解释一下hashMap具体如何实现的？" class="headerlink" title="● 请你解释一下hashMap具体如何实现的？"></a>● 请你解释一下hashMap具体如何实现的？</h2><p>考点：集合</p><h3 id="参考回答：-20"><a href="#参考回答：-20" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Hashmap基于数组实现的，通过对key的hashcode &amp; 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。put时在多线程情况下，会形成环从而导致死循环。数组长度一般是2n，从0开始编号，所以hashcode &amp; （2n-1），（2n-1）每一位都是1，这样会让散列均匀。需要注意的是，HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><h2 id="●-请你说明一下Map和ConcurrentHashMap的区别？"><a href="#●-请你说明一下Map和ConcurrentHashMap的区别？" class="headerlink" title="● 请你说明一下Map和ConcurrentHashMap的区别？"></a>● 请你说明一下Map和ConcurrentHashMap的区别？</h2><p>考点：集合</p><h3 id="参考回答：-21"><a href="#参考回答：-21" class="headerlink" title="参考回答："></a>参考回答：</h3><p>hashmap是线程不安全的，put时在多线程情况下，会形成环从而导致死循环。CoucurrentHashMap是线程安全的，采用分段锁机制，减少锁的粒度。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试宝典 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>底层源码分析 Spring 的核心功能和执行流程？（下）</title>
      <link href="/2020/04/19/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Spring-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B(%E4%B8%8B)/"/>
      <url>/2020/04/19/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Spring-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B(%E4%B8%8B)/</url>
      
        <content type="html"><![CDATA[<p>上一课时我们讲了Bean 相关的内容，它其实也是属于loC的具体实现之一，本课时我们就来讲讲Spring 中其他几个高频的面试点，希望能起到抛砖引玉的作用，能为你理解 Spring 打开一扇门。因为Spring 涉及的内容和知识点太多了，用它来写一本书也绰绰有余，因此这里我们只讲核心的内容，希望下来你能查漏补缺，完善自己的Spring 技术栈。</p><p><strong>我们本课时的面试题是，谈一谈你对loC和DI的理解。</strong></p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p><strong>loC</strong>（Inversion of Control，翻译为“控制反转”）不是一个具体的技术，而是一种设计思想。与传统控制流相比，loC会颠倒控制流，在传统的编程中需要开发者自行创建并销毁对象，而在loC中会把这些操作交给框架来处理，这样开发者就不用关注具体的实现细节了，拿来直接用就可以了，这就是<strong>控制反转</strong>。</p><p>loC很好的体现出了面向对象的设计法则之一——好莱坞法则：“别找我们，我们找你”。即由loC<br>容器帮对象找到相应的依赖对象并注入，而不是由对象主动去找。</p><p>举个例子，比如说传统找对象，先要设定好你的要求，如身高、体重、长相等，然后再一个一个的主动去找符合要求的对象，而loC相当于，你把这些要求直接告诉婚介中心，由他们直接给你匹配到符合要求的对象，理想情况下是直接会帮你找到合适的对象，这就是传统编程模式和loC的区别。</p><p><strong>DI</strong>（Dependency Injection，翻译为“<strong>依赖注入</strong>”）表示组件间的依赖关系交由容器在运行期自动生成，也就是说，由容器动态的将某个依赖关系注入到组件之中，这样就能提升组件的重用频率。通过依赖注入机制，我们只需要通过简单的配置，就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心资源来自哪里、由谁实现等问题。<br>loC和DI其实是同一个概念从不同角度的描述的，由于控制反转这个概念比较含糊（可能只理解成了容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年被开发者尊称为“教父”的Martin Fowler（世界顶级专家，敏捷开发方法的创始人之一）又给出了一个新的名字“依赖注入”，相对loC而言，“依赖注入”<strong>明确描述了“被注入对象依赖loC容器配置依赖对象</strong>”。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>loC和DI为Spring框架设计的精髓所在，也是面试中必问的考点之一，这个优秀的设计思想对于初学者来说可能理解起来比较困难，但对于Spring的使用者来说可以很快的看懂。因此如果对于此概念还有疑问的话，建议先上手使用Spring 实现几个小功能再回头来看这些概念，相信你会豁然开朗。</p><p>Spring 相关的高频面试题，还有以下这些：</p><ul><li>Spring loC有哪些优势？</li><li>loC的注入方式有哪些？</li><li>谈一谈你对AOP的理解。</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-Spring-loC的优点"><a href="#1-Spring-loC的优点" class="headerlink" title="1.Spring loC的优点"></a>1.Spring loC的优点</h3><p>loC的优点有以下几个：</p><ul><li>使用更方便，拿来即用，无需显式的创建和销毁的过程；·可以很容易提供众多服务，比如事务管理、消息服务等；</li><li>提供了单例模式的支持；</li><li>提供了AOP抽象，利用它很容易实现权限拦截、运行期监控等功能；</li><li>更符合面向对象的设计法则；</li><li>低侵入式设计，代码的污染极低，降低了业务对象替换的复杂性。</li></ul><h3 id="2-Spring-loC注入方式汇总"><a href="#2-Spring-loC注入方式汇总" class="headerlink" title="2.Spring loC注入方式汇总"></a>2.Spring loC注入方式汇总</h3><p>loC的注入方式有三种：构造方法注入、Setter注入和接口注入。</p><h4 id="①构造方法注入"><a href="#①构造方法注入" class="headerlink" title="①构造方法注入"></a>①构造方法注入</h4><p>构造方法注入主要是依赖于构造方法去实现，构造方法可以是有参的也可以是无参的，我们平时new对象时就是通过类的构造方法来创建类对象的，每个类对象默认会有一个无参的构造方法，Spring通过构造方法注入的代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 忽略 Setter、Getter 的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applicationContext.xml 配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.Person"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="②Setter-注入"><a href="#②Setter-注入" class="headerlink" title="②Setter 注入"></a>②Setter 注入</h4><p>Setter 方法注入的方式是目前Spring 主流的注入方式，它可以利用Java Bean规范所定义的Setter/Getter方法来完成注入，可读性和灵活性都很高，它不需要使用声明式构造方法，而是使用Setter 注入直接设置相关的值，实现示例如下：    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Java"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="③接口注入"><a href="#③接口注入" class="headerlink" title="③接口注入"></a>③接口注入</h4><p>接口注入方式是比较古老的注入方式，因为它需要被依赖的对象实现不必要的接口，带有侵入性，因此现在已经被完全舍弃了，所以本文也不打算做过多的描述，大家只要知道有这回事就行了。</p><h3 id="3-Spring-AOP"><a href="#3-Spring-AOP" class="headerlink" title="3.Spring AOP"></a>3.Spring AOP</h3><p>AOP（Aspect-OrientedProgramming，面向切面编程）可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善，OOP引入封装、继承和多态性等概念来建立一种公共对象处理的能力，当我们需要处理公共行为的时候，OOP就会显得无能为力，而AOP的出现正好解决了这个问题。比如统一的日志处理模块、授权验证模块等都可以使用AOP很轻松的处理。<br>Spring AOP目前提供了三种配置方式：</p><ul><li>基于JavaAPl的方式；</li><li>基于@AspectJ（Java）注解的方式；</li><li>基于XML&lt;aop/&gt;标签的方式。</li></ul><h4 id="①基于JavaAPI的方式"><a href="#①基于JavaAPI的方式" class="headerlink" title="①基于JavaAPI的方式"></a>①基于JavaAPI的方式</h4><p>此配置方式需要实现相关的接口，例如MethodBeforeAdvice和AfterReturningAdvice，并且在<br>XML配置中定义相应的规则即可实现。<br>我们先来定义一个实体类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person <span class="title">findPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"JDK"</span>);</span><br><span class="line">      System.out.println(<span class="string">"findPerson 被执行"</span>);</span><br><span class="line">      <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> Integer id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="comment">// 忽略 Getter、Setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个 advice 类，用于对拦截方法的调用之前和调用之后进行相关的业务处理，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span>, <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"准备执行方法: "</span> + method.getName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(method.getName() + <span class="string">" 方法执行结束"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后需要在 application.xml 文件中配置相应的拦截规则，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义 advisor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAdvice"</span> <span class="attr">class</span>=<span class="string">"org.springframework.advice.MyAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置规则，拦截方法名称为 find* --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"myAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"org.springframework.beans.*.find.*"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义 DefaultAdvisorAutoProxyCreator 使所有的 advisor 配置自动生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从以上配置中可以看出，我们需要配置一个拦截方法的规则，然后定义一个<br>DefaultAdvisorAutoProxyCreator 让所有的 advisor 配置自动生效。<br>最后，我们使用测试代码来完成调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ApplicationContext context =</span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath*:application.xml"</span>);</span><br><span class="line">      Person person = context.getBean(<span class="string">"person"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      person.findPerson();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">准备执行方法: findPerson</span><br><span class="line">findPerson 被执行</span><br><span class="line">findPerson 方法执行结束</span><br></pre></td></tr></table></figure><p>可以看出AOP的拦截已经成功了。</p><h4 id="②基于-AspectJ注解的方式"><a href="#②基于-AspectJ注解的方式" class="headerlink" title="②基于@AspectJ注解的方式"></a>②基于@AspectJ注解的方式</h4><p>首先需要在项目中添加aspectjweaver的jar包，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此jar包来自于AspectJ，因为Spring 使用了Aspect提供的一些注解，因此需要添加此jar包。之后，我们需要开启@Aspect的注解，开启方式有两种。</p><p>可以在application.xml 配置如下代码中开启@AspectJ的注解：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用 @EnableAspectJAutoProxy 注解开启，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们需要声明拦截器的类和拦截方法，以及配置相应的拦截规则，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectJ</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 配置拦截类 Person</span></span><br><span class="line">   <span class="meta">@Pointcut</span>(<span class="string">"execution(* org.springframework.beans.Person.*(..))"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"执行 doBefore 方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@After</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"执行 doAfter 方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们只需要在 application.xml 配置中添加注解类，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.advice.MyAspectJ"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>紧接着，我们添加一个需要拦截的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要拦截的 Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person <span class="title">findPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"JDK"</span>);</span><br><span class="line">      System.out.println(<span class="string">"执行 findPerson 方法"</span>);</span><br><span class="line">      <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 获取其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们开启测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ApplicationContext context =</span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath*:application.xml"</span>);</span><br><span class="line">      Person person = context.getBean(<span class="string">"person"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      person.findPerson();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 doBefore 方法</span><br><span class="line">执行 findPerson 方法</span><br><span class="line">执行 doAfter 方法</span><br></pre></td></tr></table></figure><p>可以看出AOP拦截成功了。</p><h4 id="③基于XML-lt-aop-gt-标签的方式"><a href="#③基于XML-lt-aop-gt-标签的方式" class="headerlink" title="③基于XML&lt;aop/&gt;标签的方式"></a>③基于XML&lt;aop/&gt;标签的方式</h4><p>基于XML的方式与基于注解的方式类似，只是无需使用注解，把相关信息配置到application.xml中即可，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 拦截处理类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myPointcut"</span> <span class="attr">class</span>=<span class="string">"org.springframework.advice.MyPointcut"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截规则配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcutConfig"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">expression</span>=<span class="string">"execution(* org.springframework.beans.Person.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截方法配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"myPointcut"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"doBefore"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcutConfig"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"doAfter"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcutConfig"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后，添加一个普通的类来进行拦截业务的处理，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPointcut</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"执行 doBefore 方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"执行 doAfter 方法"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截的方法和测试代码与第二种注解的方式相同，这里就不在熬述。<br>最后执行程序，执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 doBefore 方法</span><br><span class="line">执行 findPerson 方法</span><br><span class="line">执行 doAfter 方法</span><br></pre></td></tr></table></figure><p>可以看出AOP拦截成功了。<br>Spring AOP的原理其实很简单，它其实就是一个动态代理，我们在调用getBean(）方法的时候返回的其实是代理类的实例，而这个代理类在Spring中使用的是JDK Proxy或CgLib实现的，它的核心代码在DefaultAopProxyFactory#createAopProxy（..）中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&amp;lt;?&amp;gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line"><span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 判断目标类是否为接口</span></span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">                <span class="comment">// 是接口使用 jdk 的代理</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 其他情况使用 CgLib 代理</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 忽略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong><br>本课时讲了loC和DI概念，以及loC的优势和loC注入的三种方式：构造方法注入、Setter注入和接口注入，最后讲了Spring AOP的概念与它的三种配置方式：基于JavaAPI的方式、基于Java注解的方式和基于XML标签的方式。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>底层源码分析 Spring 的核心功能和执行流程？（上）</title>
      <link href="/2020/04/19/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Spring-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B(%E4%B8%8A)/"/>
      <url>/2020/04/19/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Spring-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<p>Spring Framework 已是公认的Java标配开发框架了，甚至还有人说Java编程就是面向Spring编程的，可见Spring在整个Java体系中的重要位置。</p><p>Spring 中包含了众多的功能和相关模块，比如 spring-core、spring-beans、spring-aop、spring-<br>context、spring-expression、spring-test等，本课时先从面试中必问的问题出发，来帮你更好的<br>Spring框架。</p><p><strong>我们本课时的面试题是，Spring Bean的作用域有哪些？它的注册方式有几种？</strong></p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>在Spring 容器中管理一个或多个Bean，这些Bean的定义表示为BeanDefinition对象，这些对象包含以下重要信息：</p><ul><li>Bean的实际实现类</li><li>Bean的作用范围</li><li>Bean的引用或者依赖项</li></ul><p>Bean的注册方式有三种：</p><ul><li>XML配置文件的注册方式</li><li>Java 注解的注册方式</li><li>Java APl的注册方式</li></ul><h2 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h2><h3 id="1-XML-配置文件注册方式"><a href="#1-XML-配置文件注册方式" class="headerlink" title="1.XML 配置文件注册方式"></a>1.XML 配置文件注册方式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Java"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-Java-注解注册方式"><a href="#2-Java-注解注册方式" class="headerlink" title="2.Java 注解注册方式"></a>2.Java 注解注册方式</h3><p>可以使用 @Component 注解方式来注册 Bean，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Integer id;</span><br><span class="line">   <span class="keyword">private</span> String name</span><br><span class="line">   <span class="comment">// 忽略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用 @Bean 注解方式来注册 Bean，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person  <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="comment">// 忽略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中@Configuration可理解为XML配置里的&lt;beans&gt;标签，而@Bean可理解为用XML配置里面的&lt;bean&gt;标签。</p><h3 id="3-Java-API-注册方式"><a href="#3-Java-API-注册方式" class="headerlink" title="3.Java API 注册方式"></a>3.Java API 注册方式</h3><p>使用 BeanDefinitionRegistry.registerBeanDefinition() 方法的方式注册 Bean，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanDefinitionRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        RootBeanDefinition personBean = <span class="keyword">new</span> RootBeanDefinition(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 新增 Bean</span></span><br><span class="line">registry.registerBeanDefinition(<span class="string">"person"</span>, personBean);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean-的作用域一共有-5-个。"><a href="#Bean-的作用域一共有-5-个。" class="headerlink" title="Bean 的作用域一共有 5 个。"></a>Bean 的作用域一共有 5 个。</h2><p>（1）<strong>singleton作用域</strong>：表示在Spring容器中只有一个Bean实例，以单例的形式存在，是默认的<br>Bean 作用域。<br>配置方式，缺省即可，XML的配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）<strong>prototype 作用域</strong>：原型作用域，每次调用 Bean 时都会创建一个新实例，也就是说每次调用getBean() 方法时，相当于执行了 new Bean()。</p><p>XML 的配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）<strong>request 作用域</strong>：每次 Http 请求时都会创建一个新的 Bean，该作用域仅适应于WebApplicationContext 环境。</p><p>XML 的配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"request"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java 注解的配置方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(WebApplicationContext.SCOPE_REQUEST)</span><br></pre></td></tr></table></figure><p>或是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestScope</span>(WebApplicationContext.SCOPE_REQUEST)</span><br></pre></td></tr></table></figure><p>（4）<strong>session作用域</strong>：同一个Http Session共享一个Bean对象，不同的Session拥有不同的<br>Bean 对象，仅适用于WebApplicationContext环境。</p><p>XML的配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"session"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java 注解的配置方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(WebApplicationContext.SCOPE_SESSION)</span><br></pre></td></tr></table></figure><p>或是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestScope</span>(WebApplicationContext.SCOPE_SESSION)</span><br></pre></td></tr></table></figure><p>（5）<strong>application 作用域</strong>：全局的 Web 作用域，类似于 Servlet 中的 Application。</p><p>XML 的配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"application"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java 注解的配置方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(WebApplicationContext.SCOPE_APPLICATION)</span><br></pre></td></tr></table></figure><p>或是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestScope</span>(WebApplicationContext.SCOPE_APPLICATION)</span><br></pre></td></tr></table></figure><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>在Spring中最核心的概念是AOP（面向切面编程）、loC（控制反转）、DI（依赖注入）等（此内容将会在下一课时中讲到），而最实用的功能则是Bean，他们是概念和具体实现的关系。和Bean相关的面试题，还有以下几个：</p><ul><li>什么是同名Bean？它是如何产生的？应该如何避免？</li><li>聊一聊Bean的生命周期。</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-同名Bean-问题"><a href="#1-同名Bean-问题" class="headerlink" title="1.同名Bean 问题"></a>1.同名Bean 问题</h3><p>每个Bean拥有一个或多个标识符，在基于XML的配置中，我们可以使用id或者name来作为<br>Bean 的标识符。通常Bean的标识符由字母组成，允许使用特殊字符。</p><p>同一个Spring配置文件中Bean的id和name是不能够重复的，否则Spring 容器启动时会报错。<br>但如果Spring加载了多个配置文件的话，可能会出现同名Bean的问题。同名Bean指的是多个<br>Bean 有相同的name或者id。</p><p><strong>Spring 对待同名Bean的处理规则是使用最后面的Bean覆盖前面的Bean</strong>，所以我们在定义Bean<br>时，尽量使用长命名非重复的方式来定义，避免产生同名Bean的问题。</p><p>Bean的id 或name 属性并非必须指定，如果留空的话，容器会为Bean自动生成一个唯一的名称，这样也不会出现同名Bean的问题。</p><h3 id="2-Bean-生命周期"><a href="#2-Bean-生命周期" class="headerlink" title="2.Bean 生命周期"></a>2.Bean 生命周期</h3><p>对于Spring Bean来说，并不是启动阶段就会触发Bean的实例化，只有当客户端通过显式或者隐式的方式调用BeanFactory的getBean()方法时，它才会触发该类的实例化方法。当然对于BeanFactory 来说，也不是所有的getBean(）方法都会实例化Bean对象，例如作用域为singleton时，只会在第一次，实例化该Bean对象，之后会直接返回该对象。但如果使用的是ApplicationContext 容器，则会在该容器启动的时候，立即调用注册到该容器所有Bean的实例化方法。</p><p>getBean()既然是Bean对象的入口，我们就先从这个方法说起，getBean(）方法是属于<br>BeanFactory 接口的，它的真正实现是AbstractAutowireCapableBeanFactory的createBean()方法，而createBean(）是通过doCreateBean()来实现的，具体源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">    <span class="comment">// 确定并加载 Bean 的 class</span></span><br><span class="line">    Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证以及准备需要覆盖的方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 给BeanPostProcessors 一个机会来返回代理对象来代替真正的 Bean 实例，在这里实现创建代理对象功能</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Bean</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doCreateBean 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化 bean，BeanWrapper 对象提供了设置和获取属性值的功能</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果 RootBeanDefinition 是单例，则移除未完成的 FactoryBean 实例的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建 bean 实例</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 BeanWrapper 中封装的 Object 对象，其实就是 bean 对象的实例</span></span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    <span class="comment">// 获取 BeanWrapper 中封装 bean 的 Class</span></span><br><span class="line">    Class&amp;lt;?&amp;gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 应用 MergedBeanDefinitionPostProcessor 后处理器，合并 bean 的定义信息</span></span><br><span class="line">    <span class="comment">// Autowire 等注解信息就是在这一步完成预解析，并且将注解需要的信息放入缓存</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; <span class="keyword">this</span>.allowCircularReferences &amp;amp;&amp;amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了避免循环依赖，在 bean 初始化完成前，就将创建 bean 实例的 ObjectFactory 放入工厂缓存（singletonFactories）</span></span><br><span class="line">        addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 bean 属性进行填充</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 调用初始化方法，如 init-method 注入 Aware 对象</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;amp;&amp;amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 如果存在循环依赖，也就是说该 bean 已经被其他 bean 递归加载过，放入了提早公布的 bean 缓存中</span></span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 exposedObject 没有在 initializeBean 初始化方法中被增强</span></span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">// 依赖检测</span></span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&amp;lt;String&amp;gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&amp;lt;&amp;gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 actualDependentBeans 不为空，则表示依赖的 bean 并没有被创建完，即存在循环依赖</span></span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                                    StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                    <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                                    <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                                    <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                                    <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注册 DisposableBean 以便在销毁时调用</span></span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码中可以看出，在doCreateBean()方法中，首先对Bean进行了实例化工作，它是通过调用createBeanlnstance()方法来实现的，该方法返回一个BeanWrapper对象。BeanWrapper对象是Spring中一个基础的Bean 结构接口，说它是基础接口是因为它连基本的属性都没有。</p><p>BeanWrapper 接口有一个默认实现类BeanWrapperlmpl，其主要作用是对Bean进行填充，比如填充和注入Bean的属性等。</p><p>当Spring完成Bean 对象实例化并且设置完相关属性和依赖后，则会调用Bean的初始化方法initializeBean()，初始化第一个阶段是检查当前Bean 对象是否实现了BeanNameAware、BeanClassLoaderAware、BeanFactoryAware等接口，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，BeanNameAware是把Bean对象定义的beanName设置到当前对象实例中；<br>BeanClassLoaderAware 是将当前Bean对象相应的ClassLoader注入到当前对象实例中；<br>BeanFactoryAware是BeanFactory 容器会将自身注入到当前对象实例中，这样当前对象就会拥有一个BeanFactory 容器的引用。</p><p>初始化第二个阶段则是BeanPostProcessor 增强处理，它主要是对Spring 容器提供的Bean实例对象进行有效的扩展，允许Spring在初始化Bean阶段对其进行定制化修改，比如处理标记接口或者为其提供代理实现。</p><p>在初始化的前置处理完成之后就会检查和执行InitializingBean和init-method方法。</p><p>InitializingBean 是一个接口，它有一个afterPropertiesSet()方法，在Bean初始化时会判断当前<br>Bean 是否实现了InitializingBean，如果实现了则调用 afterPropertiesSet()方法，进行初始化工作；然后再检查是否也指定了init-method，如果指定了则通过反射机制调用指定的init-method方法，它的实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前 Bean 是否实现了 InitializingBean，如果是的话需要调用 afterPropertiesSet()</span></span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;amp;&amp;amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123; <span class="comment">// 安全模式</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&amp;lt;Object&amp;gt;) () -&amp;gt; &#123;</span><br><span class="line">                    ((InitializingBean) bean).afterPropertiesSet(); <span class="comment">// 属性初始化</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="keyword">throw</span> pae.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet(); <span class="comment">// 属性初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否指定了 init-method()</span></span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;amp;&amp;amp; bean.getClass() != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        String initMethodName = mbd.getInitMethodName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;amp;&amp;amp;</span><br><span class="line">                !(isInitializingBean &amp;amp;&amp;amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;amp;&amp;amp;</span><br><span class="line">                !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">            <span class="comment">// 利用反射机制执行指定方法</span></span><br><span class="line">            invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完成之后就可以正常的使用Bean对象了，在Spring 容器关闭时会执行销毁方法，但是<br>Spring 容器不会自动去调用销毁方法，而是需要我们主动的调用。</p><p>如果是BeanFactory 容器，那么我们需要主动调用destroySingletons()方法，通知BeanFactory<br>容器去执行相应的销毁方法；如果是ApplicationContext容器，那么我们需要主动调用<br>registerShutdownHook()方法，告知ApplicationContext 容器执行相应的销毁方法。</p><p><strong>注：本课时源码基于 Spring 5.2.2.RELEASE。</strong></p><p><strong>小结</strong><br>本课时我们讲了Bean的三种注册方式：XML、Java注解和JavaAPl，以及Bean的五个作用域：<br>singleton、prototype、request、session和application；还讲了读取多个配置文件可能会出现同名Bean的问题，以及通过源码讲了Bean执行的生命周期，它的生命周期如下图所示：.</p><p><img data-src="1.png" alt="1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何手写一个消息队列和延迟消息队列</title>
      <link href="/2020/04/19/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2020/04/19/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>第一次听到“消息队列”这个词时，不知你是不是和我反应一样，感觉很高阶很厉害的样子，其实当我们了解了消息队列之后，发现它与普通的技术类似，当我们熟悉之后，也能很快地上手并使用。</p><p>我们本课时的面试题是，消息队列的使用场景有哪些？如何手动实现一个消息队列和延迟消息队列？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>消息队列的使用场景有很多，最常见的使用场景有以下几个。</p><h3 id="1-商品秒杀"><a href="#1-商品秒杀" class="headerlink" title="1.商品秒杀"></a>1.商品秒杀</h3><p>比如，我们在做秒杀活动时，会发生短时间内出现爆发式的用户请求，如果不采取相关的措施，会导致服务器忙不过来，响应超时的问题，轻则会导致服务假死，重则会让服务器直接宕机，给用户带来的体验也非常不好。如果这个时候加上了消息队列，服务器接收到用户的所有请求后，先把这些请求全部写入到消息队列中再排队处理，这样就不会导致同时处理多个请求的情况；如果消息队列长度超过可以承载的最大数量，那么我们可以抛弃当前用户的请求，通知前台用户“页面出错啦，请重新刷新”等提示，这样就会有更好的交互体验。</p><h3 id="2-系统解耦"><a href="#2-系统解耦" class="headerlink" title="2.系统解耦"></a>2.系统解耦</h3><p>使用了消息队列之后，我们可以<strong>把系统的业务功能模块化</strong>，实现系统的解耦。例如，在没有使用消息队列之前，当前台用户完善了个人信息之后，首先我们需要更新用户的资料，再添加一条用户信息修改日志。但突然有一天产品经理提了一个需求，在前台用户信息更新之后，需要给此用户的增加一定的积分奖励，然后没过几天产品经理又提了一个需求，在前台用户信息更新之后，不但要增加积分奖励，还要增加用户的经验值，但没过几天产品经理的需求又变了，他要求完善资料无需增加用户的积分了，这样反反复复、来来回回的折腾，我想研发的同学一定受不了，但这是互联网公司的常态，那我们有没有一劳永逸的办法呢？</p><p>没错，这个时候我们想到了使用消息队列来实现系统的解耦，每个功能的实现独立开，只需要一个订阅或者取消订阅的开关就可以了，当需要增加功能时，只需要打开订阅“用户信息完善”的队列就行，如果过两天不用了，再把订阅的开关关掉就行了，这样我们就不用来来回回的改业务代码了，也就轻松的实现了系统模块间的解耦。</p><h3 id="3-日志记录"><a href="#3-日志记录" class="headerlink" title="3.日志记录"></a>3.日志记录</h3><p>我们大部分的日志记录行为其实是和前台用户操作的主业务没有直接关系的，只是我们的运营人和经营人员需要拿到这部分用户操作的日志信息，来进行用户行为分析或行为监控。在我们没有使用消息队列之前，笼统的做法是当有用户请求时，先处理用户的请求再记录日志，这两个操作是放在一起的，而前台用户也需要等待日志添加完成之后才能拿到后台的响应信息，这样其实浪费了前台用户的部分时间。此时我们可以使用消息队列，当响应完用户请求之后，只需要把这个操作信息放入消息队列之后，就可以直接返回结果给前台用户了，无序等待日志处理和日志添加完成，从而缩短了前台用户的等待时间。</p><p>我们可以通过JDK提供的Queue来实现自定义消息队列，使用DelayQueue实现延迟消息队列。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>对于消息队列的考察更侧重于消息队列的核心思想，因为只有理解了什么是消息队列？以及什么情况下要用消息队列？才能解决我们日常工作中遇到的问题，而消息队列的具体实现，只需要掌握一个消息中间件的使用即可，因为消息队列中间件的核心实现思路是一致的，不但如此，消息队列中间件的使用也大致类似，只要掌握了一个就能触类旁通的用好其他消息中间件。</p><p>和本课时相关的面试题，还有以下这两个：</p><ul><li>介绍一个你熟悉的消息中间件？</li><li>如何手动实现消息队列？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-常用消息中间件-RabbitMQ"><a href="#1-常用消息中间件-RabbitMQ" class="headerlink" title="1.常用消息中间件 RabbitMQ"></a>1.常用消息中间件 RabbitMQ</h3><p>目前市面上比较常用的MQ（Message Queue，消息队列）中间件有RabbitMQ、Kafka、<br>RocketMQ，如果是轻量级的消息队列可以使用Redis提供的消息队列，本课时我们先来介绍一下<br>RabbitMQ，其他消息中间件将会在第15课时中单独介绍。</p><p>RabbitMQ 是一个老牌开源的消息中间件，它实现了标准的AMQP（Advanced Message Queuing Protocol，高级消息队列协议）消息中间件，使用Erlang 语言开发，支持集群部署，和多种客户端语言混合调用，它支持的主流开发语言有以下这些：</p><ul><li>Java and Spring</li><li>.NET</li><li>Ruby</li><li>Python</li><li>PHP</li><li>JavaScript and Node</li><li>Objective-C and Swift</li><li>Rust</li><li>Scala</li><li>Go</li></ul><p>更多支持语言，<a href="https://www.rabbitmq.com/devtools.html" target="_blank" rel="noopener">点击这里访问官网查看</a>。</p><p>RabbitMQ中有3个重要的概念：生产者、消费者和代理。</p><ul><li>生产者：消息的创建者，负责创建和推送数据到消息服务器。</li><li>消费者：消息的接收方，用于处理数据和确认消息。</li><li>代理：也就是RabbitMQ服务本身，它用于扮演“快递”的角色，因为它本身并不生产消息，只是扮演了“快递”的角色，把消息进行暂存和传递。</li></ul><p>它们的运行流程，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><h4 id="RabbitMQ具备以下几个优点："><a href="#RabbitMQ具备以下几个优点：" class="headerlink" title="RabbitMQ具备以下几个优点："></a>RabbitMQ具备以下几个优点：</h4><ul><li><strong>支持持久化</strong>，RabbitMQ支持磁盘持久化功能，保证了消息不会丢失；</li><li><strong>高并发</strong>，RabbitMQ使用了Erlang 开发语言，Erlang是为电话交换机开发的语言，天生自带高并发光环和高可用特性；</li><li><strong>支持分布式集群</strong>，正是因为Erlang 语言实现的，因此RabbitMQ集群部署也非常简单，只需要启动每个节点并使用–link 把节点加入到集群中即可，并且RabbitMQ支持自动选主和自动容灾；</li><li><strong>支持多种语言</strong>，比如Java、NET、PHP、Python、JavaScript、Ruby、Go等；</li><li><strong>支持消息确认</strong>，支持消息消费确认（ack）保证了每条消息可以被正常消费；</li><li><strong>它支持很多插件</strong>，比如网页控制台消息管理插件、消息延迟插件等，RabbitMQ的插件很多并且使用都很方便。</li></ul><h4 id="RabbitMQ的消息型，分为以下四种："><a href="#RabbitMQ的消息型，分为以下四种：" class="headerlink" title="RabbitMQ的消息型，分为以下四种："></a>RabbitMQ的消息型，分为以下四种：</h4><ul><li><strong>direct</strong>（默认类型）模式，此模式为一对一的发送方式，也就是一条消息只会发送给一个消费者；</li><li><strong>headers</strong> 模式，允许你匹配消息的header 而非路由键（RoutingKey），除此之外headers和<br>direct的使用完全一致，但因为headers匹配的性能很差，几乎不会被用到；</li><li><strong>fanout</strong>模式，为多播的方式，会把一个消息分发给所有的订阅者；</li><li><strong>topic</strong>模式，为主题订阅模式，允许使用通配符（#、*）匹配一个或者多个消息，我可以使用<br>“cn.mq.#”匹配到多个前缀是“cn.mq.xxx”的消息，比如可以匹配到”cn.mq.rabbit”、<br>“cn.mq.kafka”等消息。</li></ul><h3 id="2-自定义消息队列"><a href="#2-自定义消息队列" class="headerlink" title="2.自定义消息队列"></a>2.自定义消息队列</h3><p>我们可使用Queue来实现消息队列，Queue大体可分为以下三类：</p><ul><li>双端队列（Deque）是Queue的子类也是Queue的补充类，头部和尾部都支持元素插入和获取；</li><li>阻塞队列指的是在元素操作时（添加或删除），如果没有成功，会阻塞等待执行，比如当添加元素时，如果队列元素已满，队列则会阻塞等待直到有空位时再插入；</li><li>非阻塞队列，和阻塞队列相反，它会直接返回操作的结果，而非阻塞等待操作，双端队列也属于非阻塞队列。</li></ul><p>自定义消息队列的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        producer(); <span class="comment">// 调用生产者</span></span><br><span class="line">        consumer(); <span class="comment">// 调用消费者</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加消息</span></span><br><span class="line">        queue.add(<span class="string">"first message."</span>);</span><br><span class="line">        queue.add(<span class="string">"second message."</span>);</span><br><span class="line">        queue.add(<span class="string">"third message."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 消费消息</span></span><br><span class="line">            System.out.println(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first message.</span><br><span class="line">second message.</span><br><span class="line">third message.</span><br></pre></td></tr></table></figure><p>可以看出消息是以<strong>先进先出</strong>顺序进行消费的。</p><p>实现自定义延迟队列需要实现 Delayed 接口，重写 getDelay() 方法，延迟队列完整实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义延迟队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDelayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 延迟消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DelayQueue delayQueue = <span class="keyword">new</span> DelayQueue();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        producer(); <span class="comment">// 调用生产者</span></span><br><span class="line">        consumer(); <span class="comment">// 调用消费者</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加消息</span></span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> MyDelay(<span class="number">1000</span>, <span class="string">"消息1"</span>));</span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> MyDelay(<span class="number">3000</span>, <span class="string">"消息2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 消费者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始执行时间："</span> +</span><br><span class="line">                           DateFormat.getDateTimeInstance().format(<span class="keyword">new</span> Date()));</span><br><span class="line">        <span class="keyword">while</span> (!delayQueue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(delayQueue.take());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"结束执行时间："</span> +</span><br><span class="line">                DateFormat.getDateTimeInstance().format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义延迟队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDelay</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 延迟截止时间（单位：毫秒）</span></span><br><span class="line">        <span class="keyword">long</span> delayTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 借助 lombok 实现</span></span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        <span class="meta">@Setter</span></span><br><span class="line">        <span class="keyword">private</span> String msg;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> delayTime 设置延迟执行时间</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> msg       执行的消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyDelay</span><span class="params">(<span class="keyword">long</span> delayTime, String msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.delayTime = (<span class="keyword">this</span>.delayTime + delayTime);</span><br><span class="line">            <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取剩余时间</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> unit.convert(delayTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 队列里元素的排序依据</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始执行时间：<span class="number">2020</span>-<span class="number">4</span>-<span class="number">2</span> <span class="number">16</span>:<span class="number">17</span>:<span class="number">28</span></span><br><span class="line">消息<span class="number">1</span></span><br><span class="line">消息<span class="number">2</span></span><br><span class="line">结束执行时间：<span class="number">2020</span>-<span class="number">4</span>-<span class="number">2</span> <span class="number">16</span>:<span class="number">17</span>:<span class="number">31</span></span><br></pre></td></tr></table></figure><p>可以看出，消息 1 和消息 2 都实现了延迟执行的功能。</p><p><strong>小结</strong><br>本课时讲了消息队列的使用场景：商品秒杀、系统解耦和日志记录，我们还介绍了RabbitMQ以及它的消息类型和它的特点等内容，同时还使用Queue的子类LinkedList 实现了自定义消息队列，使用<br>DelayQueue 实现了自定义延迟消息队列。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-赫夫曼编码</title>
      <link href="/2020/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
      <url>/2020/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol><li>赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</li><li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li><li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间</li><li>赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码</li></ol><h2 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h2><h3 id="通信领域中信息的处理方式-1-定长编码"><a href="#通信领域中信息的处理方式-1-定长编码" class="headerlink" title="通信领域中信息的处理方式 1-定长编码"></a>通信领域中信息的处理方式 1-定长编码</h3><p><img data-src="1.png" alt="1.png"></p><h3 id="通信领域中信息的处理方式-2-变长编码"><a href="#通信领域中信息的处理方式-2-变长编码" class="headerlink" title="通信领域中信息的处理方式 2-变长编码"></a>通信领域中信息的处理方式 2-变长编码</h3><p><img data-src="2.png" alt="2.png"></p><h3 id="通信领域中信息的处理方式-3-赫夫曼编码"><a href="#通信领域中信息的处理方式-3-赫夫曼编码" class="headerlink" title="通信领域中信息的处理方式 3-赫夫曼编码"></a>通信领域中信息的处理方式 3-赫夫曼编码</h3><p><strong>步骤如下:</strong></p><ol><li>传输的字符串: i like like like java do you like a java</li><li>各个字符对应的个数：d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9</li><li>按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值<br>构成赫夫曼树的步骤：<br>1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树<br>2) 取出根节点权值最小的两颗二叉树<br>3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和<br>4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li></ol><p><img data-src="3.png" alt="3.png"></p><p>​    4.根据赫夫曼树,给各个字符,规定编码 (前缀编码)， <strong>向左的路径为 0 向右的路径为 1</strong> ， 编码如下:</p><p>​        o: 1000 u: 10010 d: 100110 y: 100111 i: 101<br>​        a : 110 k: 1110 e: 1111 j: 0000 v: 0001<br>​        l: 001  : 01</p><p>​    5.按照上面的赫夫曼编码，我们的”i like like like java do you like a java” 字符串对应的编码为 (注<br>​        意这里我们使用的无损压缩)</p><p>​        <strong>101</strong>01<strong>001</strong>101111011110100110111101111010011011110111101000011000011100110011110000110<br>​        01111000100100100110111101111011100100001100001110</p><p>​    6. 通过赫夫曼编码处理长度为 ： 133</p><p>说明:<br>原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%</p><p>此编码满足<strong>前缀编码</strong>, 即字符的编码都不能是其他字符编码的前缀。<strong>不会造成匹配的多义性</strong><br>赫夫曼编码是无损处理方案</p><h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><h3 id="1-将字节数组转成集合并统计每个字符出现的次数"><a href="#1-将字节数组转成集合并统计每个字符出现的次数" class="headerlink" title="1.将字节数组转成集合并统计每个字符出现的次数"></a>1.将字节数组转成集合并统计每个字符出现的次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的就是 List 形式   [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]......],</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line"><span class="comment">//1创建一个ArrayList</span></span><br><span class="line">ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储每个byte出现的次数 -&gt;map</span></span><br><span class="line"><span class="comment">//遍历 bytes , 统计 每一个byte出现的次数-&gt;map[key,value]</span></span><br><span class="line">Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">byte</span> b:bytes)&#123;</span><br><span class="line">Integer count = counts.get(b);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123; <span class="comment">// Map还没有这个字符数据,第一次</span></span><br><span class="line">counts.put(b, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把每一个键值对转成一个Node 对象，并加入到nodes集合</span></span><br><span class="line"><span class="comment">//遍历map</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Byte, Integer&gt; entry :counts.entrySet())&#123;</span><br><span class="line">nodes.add(<span class="keyword">new</span> Node(entry.getKey(),entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-通过list创建赫夫曼树"><a href="#2-通过list创建赫夫曼树" class="headerlink" title="2.通过list创建赫夫曼树"></a>2.通过list创建赫夫曼树</h3><p>定义Node类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Node ,带数据和权值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;  </span>&#123;</span><br><span class="line">Byte data; <span class="comment">// 存放数据(字符)本身，比如'a' =&gt; 97 ' ' =&gt; 32</span></span><br><span class="line"><span class="keyword">int</span> weight; <span class="comment">//权值, 表示字符出现的次数</span></span><br><span class="line">Node left;</span><br><span class="line">Node right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line"><span class="keyword">this</span>.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 从小到大排序</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [data = "</span> + data + <span class="string">" weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过List 创建对应的赫夫曼树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过List 创建对应的赫夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//排序 从小到大</span></span><br><span class="line">Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出根节点权值最小的两颗二叉树 </span></span><br><span class="line"><span class="comment">//(1) 取出权值最小的结点（二叉树）</span></span><br><span class="line">Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//(2) 取出权值第二小的结点（二叉树）</span></span><br><span class="line">Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//(3)构建一颗新的二叉树</span></span><br><span class="line">Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>,leftNode.weight + rightNode.weight);</span><br><span class="line">parent.left = leftNode;</span><br><span class="line">parent.right = rightNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">nodes.remove(leftNode);</span><br><span class="line">nodes.remove(rightNode);</span><br><span class="line"><span class="comment">//(5)将parent加入到nodes</span></span><br><span class="line">nodes.add(parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回哈夫曼树的root结点</span></span><br><span class="line"><span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-生成赫夫曼树对应的赫夫曼编码"><a href="#3-生成赫夫曼树对应的赫夫曼编码" class="headerlink" title="3.生成赫夫曼树对应的赫夫曼编码"></a>3.生成赫夫曼树对应的赫夫曼编码</h3><p>思路:<br>    1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式<br>    2.生成的赫夫曼编码表{32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;Byte,String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径</span></span><br><span class="line"><span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了调用方便，我们重载 getCodes</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理root的左子树</span></span><br><span class="line">getCodes(root.left, <span class="string">"0"</span>, stringBuilder);</span><br><span class="line"><span class="comment">// 处理root的右子树</span></span><br><span class="line">getCodes(root.right, <span class="string">"1"</span>, stringBuilder);</span><br><span class="line"><span class="keyword">return</span> huffmanCodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 传入结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code 路径： 左子结点是 0, 右子结点 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line"><span class="comment">//将code加入到stringBuilder2</span></span><br><span class="line">stringBuilder2.append(code);</span><br><span class="line"><span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123; <span class="comment">//如果node == null 就不处理</span></span><br><span class="line"><span class="comment">//判断当前node 是叶子结点还是非叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (node.data == <span class="keyword">null</span>) &#123;<span class="comment">//data为空 就说明是非叶子结点 </span></span><br><span class="line"><span class="comment">//递归处理</span></span><br><span class="line"><span class="comment">//向左</span></span><br><span class="line">getCodes(node.left, <span class="string">"0"</span>, stringBuilder2);</span><br><span class="line"><span class="comment">//向右递归</span></span><br><span class="line">getCodes(node.right, <span class="string">"1"</span>, stringBuilder2);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//说明是一个叶子结点</span></span><br><span class="line"><span class="comment">//就表示找到了某个叶子结点的最后</span></span><br><span class="line">huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组"><a href="#4-根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组" class="headerlink" title="4.根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组"></a>4.根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</h3><p>举例： String content = “i like like like java do you like a java”; =》 byte[] contentBytes = content.getBytes();<br>      返回的是 字符串 “1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100”<br>      =&gt; 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes<br>      huffmanCodeBytes[0] =  10101000(补码) =&gt; byte  [推导  10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ]<br>      huffmanCodeBytes[1] = -88</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 原始的字符串对应的 byte[]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanCodes 生成的赫夫曼编码map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回赫夫曼编码处理后的 byte[] </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes,Map&lt;Byte, String&gt; huffmanCodes)&#123;</span><br><span class="line"><span class="comment">//1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">byte</span> b: bytes)&#123;</span><br><span class="line">stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将 "1010100010111111110..." 转成 byte[]</span></span><br><span class="line"><span class="comment">//统计返回 的byte[] huffmanCodeBytes 长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">len = stringBuilder.length()/<span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length();i+=<span class="number">8</span>)&#123;<span class="comment">//每8位 对应一个byte 所以步长为8</span></span><br><span class="line">String strByte;</span><br><span class="line"><span class="keyword">if</span>(i+<span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">strByte = stringBuilder.substring(i);<span class="comment">//取到最后</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Integer.parseInt(String s,int radix)返回的结果是一个十进制数</span></span><br><span class="line">huffmanCodeBytes[index] = (<span class="keyword">byte</span>) Integer.parseInt(strByte,<span class="number">2</span>);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-编码封装"><a href="#5-编码封装" class="headerlink" title="5.编码封装"></a>5.编码封装</h3><p>将前面几步封装成一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用一个方法，将前面的方法封装起来，便于我们的调用.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是经过 赫夫曼编码处理后的字节数组(压缩后的数组)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line"><span class="comment">//根据 nodes 创建的赫夫曼树</span></span><br><span class="line">Node huffmanTreeRoot = createHuffmanTree(nodes);</span><br><span class="line"><span class="comment">//对应的赫夫曼编码(根据 赫夫曼树)</span></span><br><span class="line">Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line"><span class="comment">//根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line"><span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据解压"><a href="#数据解压" class="headerlink" title="数据解压"></a>数据解压</h2><p>使用赫夫曼编码来解码数据，具体要求是</p><p>1) 前面我们得到了赫夫曼编码和对应的编码 byte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]<br>2) 现在要求使用赫夫曼编码， 进行解码，又重新得到原来的字符串”i like like like java do you like a java”<br>3) 思路：解码过程，就是编码的一个逆向操作。<br>4) 代码实现</p><h3 id="1-将一个byte-转成一个二进制的字符串"><a href="#1-将一个byte-转成一个二进制的字符串" class="headerlink" title="1.将一个byte 转成一个二进制的字符串"></a>1.将一个byte 转成一个二进制的字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 传入的 byte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是该b 对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToBitString</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用变量保存 b</span></span><br><span class="line"><span class="keyword">int</span> temp = b; <span class="comment">//将 b 转成 int</span></span><br><span class="line"><span class="comment">//如果是正数我们还存在补高位</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">temp |= <span class="number">256</span>; <span class="comment">//按位或256  1 0000 0000  | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">&#125;</span><br><span class="line">String str = Integer.toBinaryString(temp);<span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line"><span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-编写一个方法，完成对压缩数据的解码"><a href="#2-编写一个方法，完成对压缩数据的解码" class="headerlink" title="2.编写一个方法，完成对压缩数据的解码"></a>2.编写一个方法，完成对压缩数据的解码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个方法，完成对压缩数据的解码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表 map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte,String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line"><span class="comment">//1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//将byte数组转成二进制的字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line"><span class="keyword">byte</span> b = huffmanBytes[i];</span><br><span class="line"><span class="comment">//判断是不是最后一个字节</span></span><br><span class="line"><span class="keyword">boolean</span> flag = (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把字符串按照指定的赫夫曼编码进行解码</span></span><br><span class="line"><span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a</span></span><br><span class="line">Map&lt;String, Byte&gt;  map = <span class="keyword">new</span> HashMap&lt;String,Byte&gt;();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Byte, String&gt; entry: huffmanCodes.entrySet()) &#123;</span><br><span class="line">map.put(entry.getValue(), entry.getKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建要给集合，存放byte</span></span><br><span class="line">List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//i 可以理解成就是索引,扫描 stringBuilder </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; stringBuilder.length();)&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">//小的计数器</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">Byte b= <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (flag) &#123;</span><br><span class="line"><span class="comment">//取出一个 '1' '0'</span></span><br><span class="line">String key = stringBuilder.substring(i,i+count);<span class="comment">//i不动 count移动 直到匹配到一个字符</span></span><br><span class="line">b = map.get(key);</span><br><span class="line"><span class="keyword">if</span>(b == <span class="keyword">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">count++;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//匹配到</span></span><br><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">list.add(b);</span><br><span class="line">i +=count; <span class="comment">//i 直接移动到 count</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当for循环结束后，我们list中就存放了所有的字符  "i like like like java do you like a java"</span></span><br><span class="line"><span class="comment">//把list 中的数据放入到byte[] 并返回</span></span><br><span class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; b.length; i++) &#123;</span><br><span class="line">b[i] = list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h2><p>我们学习了通过赫夫曼编码对一个字符串进行编码和解码, 下面我们来完成对文件的压缩和解压， 具体要求：<br>给你一个图片文件，要求对其进行无损压缩, 看看压缩效果如何。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写方法，将一个文件进行压缩</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String srcFile, String dstFile)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建输出流</span></span><br><span class="line">OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 创建文件的输入流</span></span><br><span class="line">FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建文件的输入流</span></span><br><span class="line">is = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line"><span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">is.read(b);</span><br><span class="line"><span class="comment">//直接对源文件压缩</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line"><span class="comment">//创建文件的输出流, 存放压缩文件</span></span><br><span class="line">os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line"><span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line"><span class="comment">//把 赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">oos.writeObject(huffmanBytes); </span><br><span class="line"><span class="comment">//这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line"><span class="comment">//注意一定要把赫夫曼编码 写入压缩文件</span></span><br><span class="line">oos.writeObject(huffmanCodes);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">is.close();</span><br><span class="line">oos.close();</span><br><span class="line">os.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件解压-文件恢复"><a href="#文件解压-文件恢复" class="headerlink" title="文件解压(文件恢复)"></a>文件解压(文件恢复)</h2><p>具体要求：将前面压缩的文件，重新恢复成原来的文件。</p><p>1) 思路：读取压缩文件(数据和赫夫曼编码表)-&gt; 完成解压(文件恢复)<br>2) 代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个方法，完成对压缩文件的解压</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义文件输入流</span></span><br><span class="line">FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 定义一个对象输入流</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 定义文件的输出流</span></span><br><span class="line">OutputStream os = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建文件输入流</span></span><br><span class="line">is = <span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line"><span class="comment">//创建一个和  is关联的对象输入流</span></span><br><span class="line">ois = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line"><span class="comment">//读取byte数组  huffmanBytes</span></span><br><span class="line"><span class="keyword">byte</span>[] huffmanBytes = (<span class="keyword">byte</span>[])ois.readObject();</span><br><span class="line"><span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line"><span class="comment">//将bytes 数组写入到目标文件</span></span><br><span class="line">os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line"><span class="comment">//写数据到 dstFile 文件</span></span><br><span class="line">os.write(bytes);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">os.close();</span><br><span class="line">ois.close();</span><br><span class="line">is.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e2.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-赫夫曼树</title>
      <link href="/2020/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2020/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol><li>给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，<strong>若该树的带权路径长度(wpl) 达到最小</strong>，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</li><li>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近</li></ol><h2 id="赫夫曼树几个重要概念和举例说明"><a href="#赫夫曼树几个重要概念和举例说明" class="headerlink" title="赫夫曼树几个重要概念和举例说明"></a>赫夫曼树几个重要概念和举例说明</h2><ol><li><strong>路径和路径长度</strong>：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。<strong>通路中分支的数目称为路径长度</strong>。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1</li><li><strong>结点的权及带权路径长度</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。 <strong>结</strong><br><strong>点的带权路径长度为</strong>：从根结点到该结点之间的路径长度与该结点的权的乘积</li><li>树的带权路径长度：树的带权路径长度规定为 <strong>所有叶子结点的带权路径长度之和</strong>，<strong>记为 WPL</strong>(weighted path<br>length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</li><li><strong>WPL 最小的就是赫夫曼树</strong></li></ol><p><img data-src="1.png" alt="1.png"></p><h2 id="赫夫曼树创建思路图解"><a href="#赫夫曼树创建思路图解" class="headerlink" title="赫夫曼树创建思路图解"></a>赫夫曼树创建思路图解</h2><p>给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树.</p><p><strong>构成赫夫曼树的步骤：</strong></p><ol><li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li><li>取出根节点权值最小的两颗二叉树</li><li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</li><li>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数<br>据都被处理，就得到一颗赫夫曼树</li><li>图解:</li></ol><p>如何构建一颗 赫夫曼树的步骤</p><p>数组： 13, 7, 8, 3, 29, 6, 1</p><p>排序后：1,3, 6, 7, 8, 13, 29 </p><h3 id="1-挑出-1-和-3-组成新的二叉树"><a href="#1-挑出-1-和-3-组成新的二叉树" class="headerlink" title="1.挑出 1 和 3 组成新的二叉树"></a>1.挑出 1 和 3 组成新的二叉树</h3><p><img data-src="2.png" alt="2.png"></p><p>数组还剩 4,6,7,8,13,29</p><h3 id="2-挑出-4-和-6-组成新的二叉树"><a href="#2-挑出-4-和-6-组成新的二叉树" class="headerlink" title="2.挑出 4 和 6 组成新的二叉树"></a>2.挑出 4 和 6 组成新的二叉树</h3><p><img data-src="3.png" alt="3.png"></p><p>数组还剩 7,8,10,13,29</p><h3 id="3-挑出-7-和-8-组成新的二叉树"><a href="#3-挑出-7-和-8-组成新的二叉树" class="headerlink" title="3.挑出 7 和 8 组成新的二叉树"></a>3.挑出 7 和 8 组成新的二叉树</h3><p><img data-src="4.png" alt="4.png"></p><p>数组还剩 10,13,15,29</p><h3 id="4-挑出-10-和-13-组成新的二叉树"><a href="#4-挑出-10-和-13-组成新的二叉树" class="headerlink" title="4.挑出 10 和 13 组成新的二叉树"></a>4.挑出 10 和 13 组成新的二叉树</h3><p><img data-src="5.png" alt="5.png"></p><p>数组还剩 15,23,29</p><h3 id="5-挑出-15-和-23-组成新的二叉树"><a href="#5-挑出-15-和-23-组成新的二叉树" class="headerlink" title="5.挑出 15 和 23 组成新的二叉树"></a>5.挑出 15 和 23 组成新的二叉树</h3><p><img data-src="6.png" alt="6.png"></p><p>数组还剩  29,38</p><h3 id="6-挑出-29-和-38-组成新的二叉树"><a href="#6-挑出-29-和-38-组成新的二叉树" class="headerlink" title="6.挑出 29 和 38 组成新的二叉树"></a>6.挑出 29 和 38 组成新的二叉树</h3><p><img data-src="7.png" alt="7.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span> &#125;;</span><br><span class="line">Node root = createHuffmanTree(arr);</span><br><span class="line">preOrder(root); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个前序遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.preOrder();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"是空树，不能遍历~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建赫夫曼树的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 需要创建成哈夫曼树的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 创建好后的赫夫曼树的root结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 第一步为了操作方便</span></span><br><span class="line"><span class="comment">// 1. 遍历 arr 数组</span></span><br><span class="line"><span class="comment">// 2. 将arr的每个元素构成成一个Node</span></span><br><span class="line"><span class="comment">// 3. 将Node 放入到ArrayList中</span></span><br><span class="line">List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> value : arr)&#123;</span><br><span class="line">nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后只有根节点</span></span><br><span class="line"><span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//排序 从小到大</span></span><br><span class="line">Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出根节点权值最小的两颗二叉树 </span></span><br><span class="line"><span class="comment">//(1) 取出权值最小的结点（二叉树）</span></span><br><span class="line">Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//(2) 取出权值第二小的结点（二叉树）</span></span><br><span class="line">Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//(3)构建一颗新的二叉树</span></span><br><span class="line">Node parent = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line">parent.left = leftNode;</span><br><span class="line">parent.right = rightNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">nodes.remove(leftNode);</span><br><span class="line">nodes.remove(rightNode);</span><br><span class="line"><span class="comment">//(5)将parent加入到nodes</span></span><br><span class="line">nodes.add(parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回哈夫曼树的root结点</span></span><br><span class="line"><span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建结点类</span></span><br><span class="line"><span class="comment">//为了让Node 对象持续排序Collections集合排序</span></span><br><span class="line"><span class="comment">//让Node 实现Comparable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value; <span class="comment">// 结点权值</span></span><br><span class="line"><span class="keyword">char</span> c; <span class="comment">//字符</span></span><br><span class="line">Node left; <span class="comment">// 指向左子结点</span></span><br><span class="line">Node right; <span class="comment">// 指向右子结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写一个前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//表示从小到大排序</span></span><br><span class="line"><span class="comment">//如果指定的数与参数相等返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果指定的数小于参数返回 -1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果指定的数大于参数返回 1。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.value - o.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-堆排序</title>
      <link href="/2020/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序基本介绍"><a href="#堆排序基本介绍" class="headerlink" title="堆排序基本介绍"></a>堆排序基本介绍</h2><p>1) 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复<br>杂度均为 <strong>O(nlogn)</strong>，它也是不稳定排序。</p><p>2) 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有<br>要求结点的左孩子的值和右孩子的值的大小关系。</p><p>3) 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p><p>4) 大顶堆举例说明</p><p><img data-src="1.png" alt="1.png"></p><p>5) 小顶堆举例说明</p><p><img data-src="2.png" alt="2.png"></p><p>6) 一般升序采用大顶堆，降序采用小顶堆</p><h2 id="堆排序基本思想"><a href="#堆排序基本思想" class="headerlink" title="堆排序基本思想"></a>堆排序基本思想</h2><p><strong>堆排序的基本思想是：</strong></p><ol><li>将待排序序列构造成一个大顶堆</li><li>此时，整个序列的最大值就是堆顶的根节点。</li><li>将其与末尾元素进行交换，此时末尾就为最大值。</li><li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。</li></ol><p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p><h2 id="堆排序步骤图解说明"><a href="#堆排序步骤图解说明" class="headerlink" title="堆排序步骤图解说明"></a>堆排序步骤图解说明</h2><p>要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。</p><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p>构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。原始的数组 [4, 6, 8, 5, 9]</p><p>1) .假设给定无序序列结构如下</p><p><img data-src="3.png" alt="3.png"></p><p>2) .此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点,arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。</p><p><img data-src="4.png" alt="4.png"></p><p>3) .找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。</p><p><img data-src="5.png" alt="5.png"></p><p>4) 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。</p><p><img data-src="6.png" alt="6.png"></p><p>此时，我们就将一个无序序列构造成了一个大顶堆。</p><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p>将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</p><p>1) .将堆顶元素 9 和末尾元素 4 进行交换</p><p><img data-src="7.png" alt="7.png"></p><p>2) .重新调整结构，使其继续满足堆定义</p><p><img data-src="8.png" alt="8.png"></p><p>3) .再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.</p><p><img data-src="9.png" alt="9.png"></p><p>4) 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p><p><img data-src="10.png" alt="10.png"></p><h2 id="再简单总结下堆排序的基本思路："><a href="#再简单总结下堆排序的基本思路：" class="headerlink" title="再简单总结下堆排序的基本思路："></a>再简单总结下堆排序的基本思路：</h2><p>1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p><p>2).将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</p><p>3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，<br>直到整个序列有序。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//要求将数组进行升序排序</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">heapSort(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个堆排序的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">System.out.println(<span class="string">"堆排序!!"</span>);</span><br><span class="line"><span class="comment">//1.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> -<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;<span class="comment">//第一个非叶子结点 =arr.length/2-1</span></span><br><span class="line">adjustHeap(arr, i, arr.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</span></span><br><span class="line"><span class="comment">//3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length-<span class="number">1</span>; j&gt;<span class="number">0</span> ; j--)&#123;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = temp;</span><br><span class="line">adjustHeap(arr, <span class="number">0</span>, j); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"数组="</span> + Arrays.toString(arr)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将一个数组(二叉树), 调整成一个大顶堆</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆</span></span><br><span class="line"><span class="comment"> * 举例  int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 &#123;4, 9, 8, 5, 6&#125;</span></span><br><span class="line"><span class="comment"> * 如果我们再次调用  adjustHeap 传入的是 i = 0 =&gt;  &#123;4, 9, 8, 5, 6&#125; =&gt; adjustHeap =&gt; &#123;9,6,8,5, 4&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待调整的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 表示非叶子结点在数组中索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 表示对多少个元素继续调整， length 是在逐渐的减少</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先取出当前元素的值，保存在临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="comment">//开始调整</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. k = i * 2 + 1 k 是 i结点的左子结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k = k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (k+<span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k+<span class="number">1</span>]) &#123;<span class="comment">//说明左子节点的值小于右子节点的值</span></span><br><span class="line">k++;<span class="comment">//k指向右子节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[k] &gt; temp) &#123; <span class="comment">//如果子节点大于父节点  将最大的放到顶部</span></span><br><span class="line">arr[i] = arr[k];<span class="comment">//把较大的值赋给当前结点</span></span><br><span class="line">i = k;<span class="comment">//!!! i 指向 k,继续循环比较</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部调成大顶堆)</span></span><br><span class="line">arr[i] = temp;<span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8000000条数据 2 秒</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-线索化二叉树</title>
      <link href="/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="线索二叉树基本介绍"><a href="#线索二叉树基本介绍" class="headerlink" title="线索二叉树基本介绍"></a>线索二叉树基本介绍</h2><ol><li>n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向<br>该结点在<strong>某种遍历次序下</strong>的前驱和后继结点的指针（这种附加的指针称为”线索”）</li><li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</li><li>一个结点的前一个结点，称为<strong>前驱</strong>结点</li><li>一个结点的后一个结点，称为<strong>后继</strong>结点</li></ol><h2 id="线索二叉树应用案例"><a href="#线索二叉树应用案例" class="headerlink" title="线索二叉树应用案例"></a>线索二叉树应用案例</h2><p>应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}</p><p><img data-src="1.png" alt="1.png"></p><p><strong>思路分析:</strong> 中序遍历的结果：{8, 3, 10, 1, 14, 6}</p><p><img data-src="2.png" alt="2.png"></p><p>说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:</p><p>1) left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的<br>就是前驱节点.</p><p>2) right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向<br>的是后继节点.</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试一把中序线索二叉树的功能</span></span><br><span class="line">HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"tom"</span>);</span><br><span class="line">HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"jack"</span>);</span><br><span class="line">HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">"smith"</span>);</span><br><span class="line">HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">"mary"</span>);</span><br><span class="line">HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">"king"</span>);</span><br><span class="line">HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">"dim"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树，后面我们要递归创建, 现在简单处理使用手动创建</span></span><br><span class="line">root.setLeft(node2);</span><br><span class="line">root.setRight(node3);</span><br><span class="line">node2.setLeft(node4);</span><br><span class="line">node2.setRight(node5);</span><br><span class="line">node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试中序线索化</span></span><br><span class="line">ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">threadedBinaryTree.setRoot(root);</span><br><span class="line">threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试: 以10号节点测试</span></span><br><span class="line">HeroNode leftNode = node5.getLeft();</span><br><span class="line">HeroNode rightNode = node5.getRight();</span><br><span class="line">System.out.println(<span class="string">"10号结点的前驱结点是 ="</span> + leftNode); <span class="comment">// 3</span></span><br><span class="line">System.out.println(<span class="string">"10号结点的后继结点是="</span> + rightNode); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当线索化二叉树后，能在使用原来的遍历方法</span></span><br><span class="line"><span class="comment">// threadedBinaryTree.infixOrder();</span></span><br><span class="line">System.out.println(<span class="string">"使用线索化的方式遍历 线索化二叉树"</span>);</span><br><span class="line">threadedBinaryTree.threadedList(); <span class="comment">// 8, 3, 10, 1, 14, 6</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义ThreadedBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了实现线索化，需要创建要给指向当前结点的前驱结点的指针</span></span><br><span class="line"><span class="comment">//在递归进行线索化时，pre 总是保留前一个结点</span></span><br><span class="line"><span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载一把threadedNodes方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.threadedNodes(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历线索化二叉树的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line">HeroNode node = root;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 循环的找到leftType == 1的结点，第一个找到就是8结点</span></span><br><span class="line"><span class="comment">// 后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化</span></span><br><span class="line"><span class="comment">// 处理后的有效结点</span></span><br><span class="line"><span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">node = node.getLeft();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印当前这个结点</span></span><br><span class="line">System.out.println(node);</span><br><span class="line"><span class="comment">// 如果当前结点的右指针指向的是后继结点,就一直输出</span></span><br><span class="line"><span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 获取到当前结点的后继结点</span></span><br><span class="line">node = node.getRight();</span><br><span class="line">System.out.println(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 替换这个遍历的结点</span></span><br><span class="line">node = node.getRight();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写对二叉树进行中序线索化的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 就是当前需要线索化的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果node==null, 不能线索化</span></span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(一)先线索化左子树</span></span><br><span class="line">threadedNodes(node.getLeft());</span><br><span class="line"><span class="comment">//(二)线索化当前结点[有难度]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理当前结点的前驱结点</span></span><br><span class="line"><span class="comment">//以8结点来理解 8没有前驱节点，所以为空</span></span><br><span class="line"><span class="comment">//8结点的.left = null , 8结点的.leftType = 1</span></span><br><span class="line"><span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//让当前结点的左指针指向前驱结点 </span></span><br><span class="line">node.setLeft(pre); </span><br><span class="line"><span class="comment">//修改当前结点的左指针的类型,指向前驱结点</span></span><br><span class="line">node.setLeftType(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理后继结点</span></span><br><span class="line"><span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//让前驱结点的右指针指向当前结点</span></span><br><span class="line">pre.setRight(node);</span><br><span class="line"><span class="comment">//修改前驱结点的右指针类型</span></span><br><span class="line">pre.setRightType(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">pre = node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(三)在线索化右子树</span></span><br><span class="line">threadedNodes(node.getRight());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点</span></span><br><span class="line"><span class="comment">//2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> leftType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rightType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.left = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-顺序存储二叉树</title>
      <link href="/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="顺序存储二叉树的概念"><a href="#顺序存储二叉树的概念" class="headerlink" title="顺序存储二叉树的概念"></a>顺序存储二叉树的概念</h2><h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><p>从数据存储来看，数组存储方式和树的存储方式可以相互转换，即 <strong>数组可以转换成树， 树也可以转换成数组</strong>，<br>看下面的示意图。</p><p><img data-src="1.png" alt="1.png"></p><h3 id="要求"><a href="#要求" class="headerlink" title="要求:"></a>要求:</h3><p>1) 右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]<br>2) 要求在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历</p><h3 id="顺序存储二叉树的特点"><a href="#顺序存储二叉树的特点" class="headerlink" title="顺序存储二叉树的特点:"></a>顺序存储二叉树的特点:</h3><p>1) 顺序二叉树通常只考虑完全二叉树<br><strong>2) 第 n 个元素的左子节点为 2 * n + 1</strong><br><strong>3) 第 n 个元素的右子节点为 2 * n + 2</strong><br><strong>4) 第 n 个元素的父节点为 (n-1) / 2</strong><br>5) n : 表示二叉树中的第几个元素(按 <strong>0</strong> 开始编号如图所示)</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求:"></a>需求:</h3><p> 给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为<br>1,2,4,5,3,6,7</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="comment">//创建一个 ArrBinaryTree</span></span><br><span class="line">ArrBinaryTree arrBinaryTree = <span class="keyword">new</span> ArrBinaryTree(arr);</span><br><span class="line">arrBinaryTree.preOrder(); <span class="comment">// 1,2,4,5,3,6,7</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个ArrBinaryTree, 实现顺序存储二叉树遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTree</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存储数据结点的数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.arr = arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载preOrder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个方法，完成顺序存储二叉树的前序遍历</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 数组的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果数组为空，或者 arr.length = 0</span></span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length ==<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"数组为空，不能按照二叉树的前序遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出当前这个元素</span></span><br><span class="line">System.out.println(arr[index]);</span><br><span class="line"><span class="comment">//向左递归遍历</span></span><br><span class="line"><span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">preOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向右递归遍历</span></span><br><span class="line"><span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList主要方法和扩容机制</title>
      <link href="/2020/04/09/ArrayList%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/04/09/ArrayList%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList简介："><a href="#ArrayList简介：" class="headerlink" title="ArrayList简介："></a>ArrayList简介：</h2><p>  ArrayList实现了List接口它是一个可调整大小的数组可以用来存放各种形式的数据。并提供了包括CRUD在内的多种方法可以对数据进行操作但是它不是线程安全的，外ArrayList按照插入的顺序来存放数据。</p><h3 id="ArrayList的主要成员变量："><a href="#ArrayList的主要成员变量：" class="headerlink" title="ArrayList的主要成员变量："></a>ArrayList的主要成员变量：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//数组默认初始容量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//定义一个空的数组实例以供其他需要用到空数组的地方调用 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//定义一个空数组，跟前面的区别就是这个空数组是用来判断ArrayList第一添加数据的时候要扩容多少。默认的构造器情况下返回这个空数组 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;<span class="comment">//数据存的地方它的容量就是这个数组的长度，同时只要是使用默认构造器（DEFAULTCAPACITY_EMPTY_ELEMENTDATA ）第一次添加数据的时候容量扩容为DEFAULT_CAPACITY = 10 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//当前数组的长度</span></span><br></pre></td></tr></table></figure><h3 id="ArrayList的构造方法有三种："><a href="#ArrayList的构造方法有三种：" class="headerlink" title="ArrayList的构造方法有三种："></a>ArrayList的构造方法有三种：</h3><p><img data-src="1.png" alt="1.png"></p><p>第一个构造方法用来返回一个初始容量为10的数组（具体过程后面会提到），第二个用来生成一个带数据的ArrayList这边不再赘述，第三个构造方法就是自定义初始容量。下面我将根据默认的构造方法来展开下文。</p><p>可以看到默认的构造器就是用了参数DEFAULTCAPACITY_EMPTY_ELEMENTDATA返回了一个空的数组，所以这边我们可以了解到ArrayList在创建的时候如果没有指定初始容量的话就会返回一个长度为0的空数组。下面我想从ArrayList的扩容机制开始解析，因为在所有添加数据的操作上面都要需要判断当前数组容量是否足以容纳新的数据，如果不够的话就需要进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="扩容机制："><a href="#扩容机制：" class="headerlink" title="扩容机制："></a>扩容机制：</h2><p>ArrayList扩容的核心从ensureCapacityInternal方法说起。可以看到前面介绍成员变量的提到的ArrayList有两个默认的空数组：</p><p><strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA：</strong>是用来使用默认构造方法时候返回的空数组。如果第一次添加数据的话那么数组扩容长度为DEFAULT_CAPACITY=10。</p><p><strong>EMPTY_ELEMENTDATA：</strong>出现在需要用到空数组的地方，其中一处就是使用自定义初始容量构造方法时候如果你指定初始容量为0的时候就会返回。</p><p>从下面可以看到如果是使用了空数组EMPTY_ELEMENTDATA话，那么不会返回默认的初始容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断当前数组是否是默认构造方法生成的空数组，如果是的话minCapacity=10反之则根据原来的值传入下一个方法去完成下一步的扩容判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//minCapacitt表示修改后的数组容量，minCapacity = size + 1 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断看看是否需要扩容</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面谈谈ensureExplicitCapacity方法（modCount设计到Java的快速报错机制后面会谈到），可以看到如果修改后的数组容量大于当前的数组长度那么就需要调用grow进行扩容，反之则不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//判断当前ArrayList是否需要进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快速报错机制</span></span><br><span class="line">    modCount++;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后看下ArrayList扩容的核心方法grow()，下面将针对三种情况对该方法进行解析：</p><ol><li>当前数组是由默认构造方法生成的空数组并且第一次添加数据。此时minCapacity等于默认的容量（10）那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。而后的数组扩容才是按照当前容量的1.5倍进行扩容；</li><li>当前数组是由自定义初始容量构造方法创建并且指定初始容量为0。此时minCapacity等于1那么根据下面逻辑可以看到最后数组的容量会从0变成1。这边可以看到一个严重的问题，一旦我们执行了初始容量为0，那么根据下面的算法前四次扩容每次都 +1，在第5次添加数据进行扩容的时候才是按照当前容量的1.5倍进行扩容。</li><li>当扩容量（newCapacity）大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值（溢出为负数）那么抛出OutOfMemoryError（内存溢出）否则的话根据与MAX_ARRAY_SIZE的比较情况确定是返回Integer最大值还是MAX_ARRAY_SIZE。这边也可以看到ArrayList允许的最大容量就是Integer的最大值（-2的31次方~2的31次方减1）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList扩容的核心方法，此方法用来决定扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h2 id="Java容器的快速报错机制ConcurrentModificationException："><a href="#Java容器的快速报错机制ConcurrentModificationException：" class="headerlink" title="Java容器的快速报错机制ConcurrentModificationException："></a>Java容器的快速报错机制ConcurrentModificationException：</h2><p>Java容器有一种保护机制，能够防止多个进程同时修改同一个容器的内容。如果你在迭代遍历某个容器的过程中，另一个进程介入其中，并且插入，删除或修改此容器的某个对象，就会立刻抛出ConcurrentModificationException。</p><p>前文提到的迭代遍历指的就是使用迭代器Iterator(ListIterator)或者forEach语法，实际上一个类要使用forEach就必须实现Iterable接口并且重写它的Iterator方法所以forEach本质上还是使用Iterator。</p><p><img data-src="2.png" alt="2.png"></p><p> 从下面方法可以看到在迭代遍历的过程中都调用了方法checkForComodification来判断当前ArrayList是否是同步的。现在来举一个栗子，假设你往一个Integer类型的ArrayList插入了10条数据，那么每操作一次modCount（继承自父类AbstractList）就加一所以就变成10，而当你对这个集合进行遍历的时候就把modCount传到expectedModCount这个变量里，然后ArrayList在checkForComodification中通过判断两个变量是否相等来确认当前集合是否是同步的，如果不同步就抛出ConcurrentModificationException。所谓的不同步指的就是，如果你在遍历的过程中对ArrayList集合本身进行add,remove等操作时候就会发生。当然如果你用的是Iterator那么使用它的remove是允许的因为此时你直接操作的不是ArrayList集合而是它的Iterator对象。在代码后面将贴出前面提到的三种情况。此外在多线程也会存在这种情况，但是如果你在多线程中使用CopyOnWriteArrayList就可以避免了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// 下一个要返回的索引</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 返回最后一个元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">//防止篇幅过长省去了其中代码</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//防止篇幅过长省去其中代码</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一种情况使用Iterator：</strong></p><p><img data-src="3.png" alt="3.png"></p><p><strong>第二种情况使用forEach：</strong></p><p><img data-src="4.png" alt="4.png"></p><p><strong>第三种情况使用Iterator自身删除数据：</strong></p><p><img data-src="5.png" alt="5.png"></p><h2 id="ArrayList的主要方法："><a href="#ArrayList的主要方法：" class="headerlink" title="ArrayList的主要方法："></a>ArrayList的主要方法：</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p><img data-src="6.png" alt="6.png"></p><p><strong>1.add(E e)</strong></p><p>​    从add(E e)方法可以看到每次添加数据ArrayList都会先调用ensureCapacityInternal来判断是否需要扩容，接着再插入数据并且每次末尾插入，所以ArrayList是按插入的顺序排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.add(int index,E element)</strong></p><p>add(int index,E element)与前面的add只多了一个参数index，index表示你要插入的位置。此时会先判断是否会出现数组越界，然后再调用ensureCapacityInternal方法紧接着可以看到调用了System.arraycopy方法来进行操作因为该方法为本地方法（native）所以并不是用Java来实现的。根据这个方法的参数解释我们可以了解到ArrayList每次指定位置添加数据的时候都会进行数组的复制，复制的过程为把相对于当前插入位置（index）后面的数据都向后移动一位（如下图所示）。因此我们说ArrayList在对数据的插入上效率比较差，随着数据量的增大花费的时间越多。这也是我们常说的ArrayList在随机插入数据的效率上比不上LinkedList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index表示element要插入的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断插入的位置是否当前数组长度或是小于0,是的话会抛出IndexOutOfBoundsException</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"> </span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//每一次插入数据都要把相对于当前index后面的数据向后移动一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*src - 源数组</span></span><br><span class="line"><span class="comment">  srcPos - 源数组中的起始位置 </span></span><br><span class="line"><span class="comment">  dest - 目标数组</span></span><br><span class="line"><span class="comment">  destPos - 目的地数据中的起始位置</span></span><br><span class="line"><span class="comment">  length - 要复制的数组元素的数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,  <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p><img data-src="7.png" alt="7.png"></p><p><strong>3.addAll(Collection&lt;? extends E&gt; c)</strong></p><p>下面看看addAll的两个方法。首先可以看到接受的参数对象为一个集合类型。如果你试图把跟当前类型不同的集合添加进来的话有两种情况会发生：</p><p><strong>第一种</strong>：如果你用了泛型，那么你在试图把Integer的类型的集合addAll到String类型的集合中就会在编译器抛出错误信息。</p><p><strong>第二种：</strong>如果你不使用泛型（Object），那么你可以在一个String类型的集合中，放入Integer，类对象等等。但是当你遍历ArrayList集合要取出当中的数据进行操作的时候，除非你每次强制转换都正确，不然就会抛出ClassCastException。所以这也是使用泛型的一个好处之一吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.addAll(int index, Collection&lt;? extends E&gt; c)</strong></p><p>接下来可以看到addAll方法也提供了一个随机插入的方法。这跟前文提到的add大相径庭这边就不再赘述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"> </span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"> </span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p><img data-src="8.png" alt="8.png"></p><p>可以看到jdk1.8新增了一个方法removeIf (实现Collection接口),下面将按照顺序来依次解析。</p><p>​    <strong>1.remobe(int index)</strong></p><p>很明显remove在删除的时候也用了System的本地方法arraycopy，跟前文add不同的是它把相对于插入位置的后几位数据全部向前移动一位并且，此外该方法会返回被删掉的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//防止数组越界</span></span><br><span class="line">    </span><br><span class="line">    modCount++;<span class="comment">//用于快速报错机制</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work 消除过期对象的引用</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>2.remove(Object o)</strong></p><p>接着看看ArrayLsit对Object对象的remove，从方法中可以看到ArrayList在对Object对象删除操作上区分开了Null，重点要注意的是在对非空对象进行删除的时候ArrayList是调用了equals来匹配数组中的数据。也就是说<strong>如果你的集合（不局限于ArrayList）是对类进行操作，而你的类没有重写hashCode以及equals，那么你通过该方法来删除数据都是无法成功的，总之如果你要在集合中对类对象进行操作就需要重写上述的两个方法。此外就算你ArrayList中存有多个相同的Obejct对象，执行该方法也只会删除一次。</strong>或许有人会有疑问，既然使用equals那直接重写equals不就好了何必跟着重写hashCode呢？答案是如果你只重写equals是可以完成删除操作，但是你重写equals没有重写hashCode那么你在使用散列数据结构HashMap，HashSet对该类进行操作的话会出错（jdk1.8 HashMap工作原理(Get,Put)和扩容机制）。而<strong>在Object规范中提到的第二点要求就是如果两个对象经过equals比较后相同，那么他们的hashCode一定相同。所以这就是为什么要hashCode跟euqals两者同时重写。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//对传进来的对象进行区分处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">             <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 fastRemove(index);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//只删除一次就返回</span></span><br><span class="line">             &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">             <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                 fastRemove(index);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work 消除过期对象的引用</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从测试用例可以看到，如果我们的对象没有重写hashCode以及equals的话，那么是没有办法完成操作的。因为每一次创建的对象他们的首地址都是不同的，那么在remove的时候ArrayList就会匹配不到。</p><p><img data-src="9.png" alt="9.png"></p><p> 如果当我们对类进行hashCode以及equals重写之后可以看到，以及可以正常删除数据。这边可涉及到hashCode以及equals的重写规范在此处不再赘述。</p><p><img data-src="10.png" alt="10.png"></p><p><strong>3.removeAll(Collection&lt;?&gt; c)</strong></p><p>可以看到removeAll是针对集合进行删除，首先会对集合参数进行NPE判断接着可以看到ArrayList通过contains方法来对两个集合数据进行循环比较。contains实际上就是调用indexOf方法而indexOf方法又是调用的equals。紧接着拿到匹配的数据进行删除，值得一提的是这个方法可以删掉所有匹配的数据，源码后面是测试用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);<span class="comment">//判空,是的话抛出空指针异常</span></span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];<span class="comment">//拿到所有c容器中跟当前ArrayList匹配的数据</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;<span class="comment">//删除</span></span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="comment">//缩减篇幅删去代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img data-src="11.png" alt="11.png"></p><p><strong>4.removeIf(Predicate&lt;? super E&gt; filter)</strong></p><p>接着看看jdk1.8中新增的方法，支持使用Lambda表达式。下面来解析一下，首先可以看到用到了BitSet，它的底层数据结构就是一个long[]数组，而long是64位的可以用来存储大的内容。所以这个方法应该也是针对需要对大量对象操作才使用的吧，不然就有点浪费空间了。源码下面是实例可以看到通过lambda表达式可以很容易的完成过滤。针对代码中调用nextClearBit这个方法就是用来返回下标索引，当中用到了一堆的移位操作符，这边就不再赘述。</p><p><img data-src="12.png" alt="12.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="comment">// figure out which elements are to be removed</span></span><br><span class="line">    <span class="comment">// any exception thrown from the filter predicate at this stage</span></span><br><span class="line">    <span class="comment">// will leave the collection unmodified</span></span><br><span class="line">    <span class="keyword">int</span> removeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> BitSet removeSet = <span class="keyword">new</span> BitSet(size);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">final</span> E element = (E) elementData[i];</span><br><span class="line">        <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">            removeSet.set(i);<span class="comment">//匹配出所有要删除的数据下标并放入BitSet中</span></span><br><span class="line">            removeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;<span class="comment">//快速报错机制</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// shift surviving elements left over the spaces left by removed elements</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> anyToRemove = removeCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newSize = size - removeCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">            i = removeSet.nextClearBit(i);</span><br><span class="line">            elementData[j] = elementData[i];<span class="comment">//覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">            elementData[k] = <span class="keyword">null</span>;  <span class="comment">// Let gc do its work</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size = newSize;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> anyToRemove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="13.png" alt="13.png"></p><p><strong>5.removeRange(int fromIndex, int toIndex)</strong></p><p>最后一种removeRange因为是protected类型的所以其他包中没有继承它的类无法直接调用，这边就不演示了。</p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p><img data-src="14.png" alt="14.png"></p><p>ArrayList就提供了set这个方法来更新数组中的数据，具体过程如此简单，不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检查IndexOutOfBoundsException</span></span><br><span class="line"> </span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p><img data-src="15.png" alt="15.png"></p><p>跟更新数据一样，ArrayList也只提供了get方法来进行数据获取。没有什么好说的，自己看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检查IndexOutOfBoundsException</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现本地缓存和分布式缓存？</title>
      <link href="/2020/04/08/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
      <url>/2020/04/08/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>缓存（Cache）是指将程序或系统中常用的数据对象存储在像内存这样特定的介质中，以避免在每次程序调用时，重新创建或组织数据所带来的性能损耗，从而提高了系统的整体运行速度。</p><p>以目前的系统架构来说，用户的请求一般会先经过缓存系统，如果缓存中没有相关的数据，就会在其他系统中查询到相应的数据并保存在缓存中，最后返回给调用方。</p><p>缓存既然如此重要，那本课时我们就来重点看一下，应该如何实现本地缓存和分布式缓存？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>本地缓存是指程序级别的缓存组件，它的特点是本地缓存和应用程序会运行在同一个进程中，所以本地缓存的操作会非常快，因为在同一个进程内也意味着不会有网络上的延迟和开销。</p><p>本地缓存适用于单节点非集群的应用场景，它的优点是快，缺点是多程序无法共享缓存，比如分布式用户Session会话信息保存，由于每次用户访问的服务器可能是不同的，如果不能共享缓存，那么就意味着每次的请求操作都有可能被系统阻止，因为会话信息只保存在某一个服务器上，当请求没有被转发到这台存储了用户信息的服务器时，就会被认为是非登录的违规操作。</p><p>除此之外，无法共享缓存可能会造成系统资源的浪费，这是因为每个系统都单独维护了一份属于自己的缓存，而同一份缓存有可能被多个系统单独进行存储，从而浪费了系统资源。</p><p><strong>分布式缓存是指将应用系统和缓存组件进行分离的缓存机制</strong>，这样多个应用系统就可以共享一套缓存数据了，它的特点是共享缓存服务和可集群部署，为缓存系统提供了高可用的运行环境，以及缓存共享的程序运行机制。本地缓存可以使用EhCache和Google的Guava来实现，而分布式缓存可以使用Redis或Memcached来实现。</p><p>由于Redis本身就是独立的缓存系统，因此可以作为第三方来提供共享的数据缓存，而Redis的分布式支持主从、哨兵和集群的模式，所以它就可以支持分布式的缓存，而Memcached的情况也是类似的。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>本课时的面试题显然不只是为了问你如何实现本地缓存和分布式缓存这么简单，主要考察的是你对缓存系统的理解，以及对缓存本质原理的洞察，和缓存相关的面试题还有这些：</p><ul><li>更加深入的谈谈 EhCache和Guava。</li><li>如何自己手动实现一个缓存系统？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-EhCache和Guava的使用及特点分析"><a href="#1-EhCache和Guava的使用及特点分析" class="headerlink" title="1.EhCache和Guava的使用及特点分析"></a>1.EhCache和Guava的使用及特点分析</h3><p>EhCache是目前比较流行的开源缓存框架，是用纯Java语言实现的简单、快速的Cache组件。</p><p>EhCache 支持内存缓存和磁盘缓存，支持LRU（Least Recently Used，最近很少使用）、LFU（Least Frequently Used，最近不常被使用）和FIFO（First In First Out，先进先出）等多种淘汰算法，并且支持分布式的缓存系统。</p><p>EhCache最初是独立的本地缓存框架组件，在后期的发展中（从1.2版）开始支持分布式缓存，分布式缓存主要支持RMI、JGroups、EhCache Server等方式。</p><h4 id="LRU和LFU的区别"><a href="#LRU和LFU的区别" class="headerlink" title="LRU和LFU的区别"></a>LRU和LFU的区别</h4><p>LRU算法有一个缺点，比如说很久没有使用的一个键值，如果最近被访问了一次，那么即使它是使用次数最少的缓存，它也不会被淘汰；而LFU算法解决了偶尔被访问一次之后，数据就不会被淘汰的问题，它是根据总访问次数来淘汰数据的，其核心思想是“如果数据过去被访问多次，那么将来它被访问次数也会比较多”。因此LFU可以理解为比LRU更加合理的淘汰算法。</p><h4 id="EhCache-基础使用"><a href="#EhCache-基础使用" class="headerlink" title="EhCache 基础使用"></a>EhCache 基础使用</h4><p>首先，需要在项目中添加EhCache框架，如果为Maven项目，则需要在pom.xml中添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.ehcache/ehcache --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>无配置参数的 EhCache 3.x 使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.ehcache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.ehcache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.ehcache.config.builders.CacheConfigurationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.ehcache.config.builders.CacheManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.ehcache.config.builders.ResourcePoolsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EhCacheExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建缓存管理器</span></span><br><span class="line">        CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build();</span><br><span class="line">        <span class="comment">// 初始化 EhCache</span></span><br><span class="line">        cacheManager.init();</span><br><span class="line">        <span class="comment">// 创建缓存（存储器）</span></span><br><span class="line">        Cache&lt;String, String&gt; myCache = cacheManager.createCache(<span class="string">"MYCACHE"</span>,</span><br><span class="line">                                                                 CacheConfigurationBuilder.newCacheConfigurationBuilder(</span><br><span class="line">                                                                     String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">ResourcePoolsBuilder</span>.<span class="title">heap</span>(10)))</span>; <span class="comment">// 设置缓存的最大容量</span></span><br><span class="line">        <span class="comment">// 设置缓存</span></span><br><span class="line">        myCache.put(<span class="string">"key"</span>, <span class="string">"Hello,Java."</span>);</span><br><span class="line">        <span class="comment">// 读取缓存</span></span><br><span class="line">        String value = myCache.get(<span class="string">"key"</span>);</span><br><span class="line">        <span class="comment">// 输出缓存</span></span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">// 关闭缓存</span></span><br><span class="line">        cacheManager.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>CacheManager：是缓存管理器，可以通过单例或者多例的方式创建，也是Ehcache的入口类；</li><li>Cache：每个CacheManager 可以管理多个Cache，每个Cache 可以采用hash的方式存储多个元素。</li></ul><p>它们的关系如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p>更多使用方法，<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=59#/detail/pc?id=1769" target="_blank" rel="noopener">请参考官方文档</a></p><p>EhCache的特点是，它使用起来比较简单，并且本身的jar包不是不大，简单的配置之后就可以正常使用了。EhCache的使用比较灵活，它支持多种缓存策略的配置，它同时支持内存和磁盘缓存两种方式，在EhCache1.2之后也开始支持分布式缓存了。</p><p>Guava Cache是Google 开源的Guava里的一个子功能，它是一个内存型的本地缓存实现方案，提供了线程安全的缓存操作机制。</p><p>Guava Cache 的架构设计灵感来源于ConcurrentHashMap，它使用了多个segments方式的细粒度锁，在保证线程安全的同时，支持了高并发的使用场景。Guava Cache 类似于Map集合的方式对键值对进行操作，只不过多了过期淘汰等处理逻辑。</p><p>在使用 Guava Cache 之前，我们需要先在 pom.xml 中添加 Guava 框架，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.2-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Guava Cache 的创建有两种方式，一种是 LoadingCache，另一种是 Callable，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.cache.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建方式一：LoadingCache</span></span><br><span class="line">        LoadingCache&lt;String, String&gt; loadCache = CacheBuilder.newBuilder()</span><br><span class="line">            <span class="comment">// 并发级别设置为 5，是指可以同时写缓存的线程数</span></span><br><span class="line">                .concurrencyLevel(<span class="number">5</span>)</span><br><span class="line">            <span class="comment">// 设置 8 秒钟过期</span></span><br><span class="line">                .expireAfterWrite(<span class="number">8</span>, TimeUnit.SECONDS)</span><br><span class="line">            <span class="comment">//设置缓存容器的初始容量为 10</span></span><br><span class="line">                .initialCapacity(<span class="number">10</span>)</span><br><span class="line">            <span class="comment">// 设置缓存最大容量为 100，超过之后就会按照 LRU 算法移除缓存项</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">            <span class="comment">// 设置要统计缓存的命中率</span></span><br><span class="line">                .recordStats()</span><br><span class="line">            <span class="comment">// 设置缓存的移除通知</span></span><br><span class="line">                .removalListener(<span class="keyword">new</span> RemovalListener&lt;Object, Object&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;Object, Object&gt; notification)</span> </span>&#123;</span><br><span class="line">                        System.out.println(notification.getKey() + <span class="string">" was removed, cause is "</span> + notification.getCause());</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 指定 CacheLoader，缓存不存在时，可自动加载缓存</span></span><br><span class="line">            .build(</span><br><span class="line">                        <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                <span class="comment">// 自动加载缓存的业务</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="string">"cache-value:"</span> + key;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 设置缓存</span></span><br><span class="line">        loadCache.put(<span class="string">"c1"</span>, <span class="string">"Hello, c1."</span>);</span><br><span class="line">        <span class="comment">// 查询缓存</span></span><br><span class="line">        String val = loadCache.get(<span class="string">"c1"</span>);</span><br><span class="line">        System.out.println(val);</span><br><span class="line">        <span class="comment">// 查询不存在的缓存</span></span><br><span class="line">        String noval = loadCache.get(<span class="string">"noval"</span>);</span><br><span class="line">        System.out.println(noval);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建方式二：Callable</span></span><br><span class="line">        Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">            .maximumSize(<span class="number">2</span>) <span class="comment">// 设置缓存最大长度</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 设置缓存</span></span><br><span class="line">        cache.put(<span class="string">"k1"</span>, <span class="string">"Hello, k1."</span>);</span><br><span class="line">        <span class="comment">// 查询缓存</span></span><br><span class="line">        String value = cache.get(<span class="string">"k1"</span>, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 缓存不存在时，执行</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"nil"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 输出缓存值</span></span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">// 查询缓存</span></span><br><span class="line">        String nokey = cache.get(<span class="string">"nokey"</span>, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 缓存不存在时，执行</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"nil"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="comment">// 输出缓存值</span></span><br><span class="line">        System.out.println(nokey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello, c1.</span><br><span class="line">cache-value:noval</span><br><span class="line">Hello, k1.</span><br><span class="line">nil</span><br></pre></td></tr></table></figure><p>可以看出Guava Cache 使用了编程式的build 生成器进行创建和管理，让使用者可以更加灵活地操纵代码，并且Guava Cache提供了灵活多样的个性化配置，以适应各种使用场景。</p><h3 id="2-手动实现一个缓存系统"><a href="#2-手动实现一个缓存系统" class="headerlink" title="2.手动实现一个缓存系统"></a>2.手动实现一个缓存系统</h3><p>上面我们讲了通过EhCache和Guava实现缓存的方式，接下来我们来看看自己如何自定义一个缓存系统，当然这里说的是自己手动实现一个本地缓存。</p><p>要自定义一个缓存，首先要考虑的是数据类型，我们可以使用Map 集合中的HashMap、Hashtable<br>或ConcurrentHashMap来实现，非并发情况下我们可以使用HashMap，并发情况下可以使用</p><p>Hashtable 或 ConcurrentHashMap，由于ConcurrentHashMap的性能比Hashtable的高，因此在高并发环境下我们可以倾向于选择 ConcurrentHashMap，不过它们对元素的操作都是类似的。</p><p>选定了数据类型之后，我们还需要考虑缓存过期和缓存淘汰等问题，在这里我们可以借鉴Redis对待过期键的处理策略。</p><p>目前比较常见的过期策略有以下三种：</p><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><p><strong>定时删除</strong>是指在设置键值的过期时间时，创建一个定时事件，当到达过期时间后，事件处理器会执行删除过期键的操作。它的优点是可以及时的释放内存空间，缺点是需要开启多个延迟执行事件来处理清除任务，这样就会造成大量任务事件堆积，占用了很多系统资源。</p><p><strong>惰性删除</strong>不会主动删除过期键，而是在每次请求时才会判断此值是否过期，如果过期则删除键值，否则就返回null。它的优点是只会占用少量的系统资源，缺点是清除不够及时，会造成一定的空间浪费。</p><p><strong>定期删除</strong>是指每隔一段时间检查一次数据库，随机删除一些过期键值。</p><p>Redis 使用的是定期删除和惰性删除这两种策略，我们本课时也会参照这两种策略。</p><p>先来说一下自定义缓存的实现思路，首先需要定义一个存放缓存值的实体类，这个类里包含了缓存的相关信息，比如缓存的key和value，缓存的存入时间、最后使用时间和命中次数（预留字段，用于支持LFU缓存淘汰），再使用ConcurrentHashMap保存缓存的key和value对象（缓存值的实体类），然后再新增一个缓存操作的工具类，用于添加和删除缓存，最后再缓存启动时，开启一个无限循环的线程用于检测并删除过期的缓存，实现代码如下。</p><p>首先，定义一个缓存值实体类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">CacheValue</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存键</span></span><br><span class="line">    <span class="keyword">private</span> Object key;</span><br><span class="line">    <span class="comment">// 缓存值</span></span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">    <span class="comment">// 最后访问时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTime;</span><br><span class="line">    <span class="comment">// 创建时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> writeTime;</span><br><span class="line">    <span class="comment">// 存活时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime;</span><br><span class="line">    <span class="comment">// 命中次数</span></span><br><span class="line">    <span class="keyword">private</span> Integer hitCount;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(CacheValue o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hitCount.compareTo(o.hitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个全局缓存对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache 全局类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheGlobal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 全局缓存对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConcurrentMap&lt;String, MyCache&gt; concurrentMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义过期缓存检测类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过期缓存检测线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpireThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 每十秒检测一次</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="comment">// 缓存检测和清除的方法</span></span><br><span class="line">                expireCache();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存检测和清除的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expireCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"检测缓存是否过期缓存"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : CacheGlobal.concurrentMap.keySet()) &#123;</span><br><span class="line">            MyCache cache = CacheGlobal.concurrentMap.get(key);</span><br><span class="line">            <span class="comment">// 当前时间 - 写入时间</span></span><br><span class="line">            <span class="keyword">long</span> timoutTime = TimeUnit.NANOSECONDS.toSeconds(</span><br><span class="line">                System.nanoTime() - cache.getWriteTime());</span><br><span class="line">            <span class="keyword">if</span> (cache.getExpireTime() &gt; timoutTime) &#123;</span><br><span class="line">                <span class="comment">// 没过期</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清除过期缓存</span></span><br><span class="line">            CacheGlobal.concurrentMap.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们要新增一个缓存操作的工具类，用于查询和存入缓存，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存操作工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断，借助 commons-lang3</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(key)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 当缓存存在时，更新缓存</span></span><br><span class="line">        <span class="keyword">if</span> (CacheGlobal.concurrentMap.containsKey(key)) &#123;</span><br><span class="line">            MyCache cache = CacheGlobal.concurrentMap.get(key);</span><br><span class="line">            cache.setHitCount(cache.getHitCount() + <span class="number">1</span>);</span><br><span class="line">            cache.setWriteTime(System.currentTimeMillis());</span><br><span class="line">            cache.setLastTime(System.currentTimeMillis());</span><br><span class="line">            cache.setExpireTime(expire);</span><br><span class="line">            cache.setValue(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建缓存</span></span><br><span class="line">        MyCache cache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        cache.setKey(key);</span><br><span class="line">        cache.setValue(value);</span><br><span class="line">        cache.setWriteTime(System.currentTimeMillis());</span><br><span class="line">        cache.setLastTime(System.currentTimeMillis());</span><br><span class="line">        cache.setHitCount(<span class="number">1</span>);</span><br><span class="line">        cache.setExpireTime(expire);</span><br><span class="line">        CacheGlobal.concurrentMap.put(key, cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(key)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 字典中不存在</span></span><br><span class="line">        <span class="keyword">if</span> (CacheGlobal.concurrentMap.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!CacheGlobal.concurrentMap.containsKey(key)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        MyCache cache = CacheGlobal.concurrentMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 惰性删除，判断缓存是否过期</span></span><br><span class="line">        <span class="keyword">long</span> timoutTime = TimeUnit.NANOSECONDS.toSeconds(</span><br><span class="line">            System.nanoTime() - cache.getWriteTime());</span><br><span class="line">        <span class="keyword">if</span> (cache.getExpireTime() &lt;= timoutTime) &#123;</span><br><span class="line">            <span class="comment">// 缓存过期</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除过期缓存</span></span><br><span class="line">        CacheGlobal.concurrentMap.remove(key);</span><br><span class="line">        cache.setHitCount(cache.getHitCount() + <span class="number">1</span>);</span><br><span class="line">        cache.setLastTime(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> cache.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是调用缓存的测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CacheUtils cache = <span class="keyword">new</span> CacheUtils();</span><br><span class="line">        <span class="comment">// 存入缓存</span></span><br><span class="line">        cache.put(<span class="string">"key"</span>, <span class="string">"老王"</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 查询缓存</span></span><br><span class="line">        String val = (String) cache.get(<span class="string">"key"</span>);</span><br><span class="line">        System.out.println(val);</span><br><span class="line">        <span class="comment">// 查询不存在的缓存</span></span><br><span class="line">        String noval = (String) cache.get(<span class="string">"noval"</span>);</span><br><span class="line">        System.out.println(noval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">老王</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>到目前为止，自定义缓存系统就已经实现完了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时讲解了本地缓存和分布式缓存这两个概念和实现的具体方式，其中本地缓存可以通过自己手动编码或借助 Guava Cache来实现，而分布式缓存可以使用Redis或EhCache来实现。此外，本课时重点演示了手动实现缓存代码的方式和实现思路，并使用定期删除和惰性删除策略来实现缓存的清除，希望学完本课时后能对你有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理是如何实现的？JDK Proxy 和 CGLib 有什么区别？</title>
      <link href="/2020/04/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84JDK-Proxy-%E5%92%8C-CGLib-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/04/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84JDK-Proxy-%E5%92%8C-CGLib-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>90%的程序员都直接或者间接的使用过动态代理，无论是日志框架或Spring框架，它们都包含了动态代理的实现代码。动态代理是程序在运行期间动态构建代理对象和动态调用代理方法的一种机制。</p><p>我们本课时的面试题是，如何实现动态代理？JDK Proxy和CGLib有什么区别？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>动态代理的常用实现方式是反射。<strong>反射机制</strong>是指程序在运行期间可以访问、检测和修改其本身状态或行为的一种能力，使用反射我们可以调用任意一个类对象，以及类对象中包含的属性及方法。</p><p>但动态代理不止有反射一种实现方式，例如，动态代理可以通过CGLib来实现，而CGLib是基于ASM（一个Java字节码操作框架）而非反射实现的。简单来说，动态代理是一种行为方式，而反射或ASM只是它的一种实现手段而已。</p><p>JDK Proxy和CGLib的区别主要体现在以下几个方面：</p><ul><li>JDK Proxy是Java 语言自带的功能，无需通过加载第三方类实现；</li><li>Java对JDKProxy提供了稳定的支持，并且会持续的升级和更新JDK Proxy，例如Java8版本中的JDK Proxy性能相比于之前版本提升了很多；</li><li>JDK Proxy 是通过拦截器加反射的方式实现的；</li><li>JDK Proxy 只能代理继承接口的类；</li><li>JDK Proxy 实现和调用起来比较简单；</li><li>CGLib是第三方提供的工具，基于ASM实现的，性能比较高；</li><li>CGLib无需通过接口来实现，它是通过实现子类的方式来完成调用的。</li></ul><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>本课时考察的是你对反射、动态代理及CGLib的了解，很多人经常会把反射和动态代理划为等号，但从严格意义上来说，这种想法是不正确的，真正能搞懂它们之间的关系，也体现了你扎实Java的基本功。和这个问题相关的知识点，还有以下几个：</p><ul><li>你对JDKProxy和CGLib的掌握程度。</li><li>Lombok是通过反射实现的吗？</li><li>动态代理和静态代理有什么区别？</li><li>动态代理的使用场景有哪些？</li><li>Spring中的动态代理是通过什么方式实现的？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-JDK-Proxy-和CGLib的使用及代码分析"><a href="#1-JDK-Proxy-和CGLib的使用及代码分析" class="headerlink" title="1.JDK Proxy 和CGLib的使用及代码分析"></a>1.JDK Proxy 和CGLib的使用及代码分析</h3><h4 id="JDK-Proxy-动态代理实现"><a href="#JDK-Proxy-动态代理实现" class="headerlink" title="JDK Proxy 动态代理实现"></a>JDK Proxy 动态代理实现</h4><p>JDK Proxy 动态代理的实现无需引用第三方类，只需要实现InvocationHandler接口，重写invoke0方法即可，整个实现代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK Proxy 相关示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"The bus is running."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"The taxi is running."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDK Proxy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object target; <span class="comment">// 代理对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取到代理对象</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.target = target;</span><br><span class="line">            <span class="comment">// 取得代理对象</span></span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                                          target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行代理方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> proxy  代理对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> method 代理方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> args   方法的参数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"动态代理之前的业务处理."</span>);</span><br><span class="line">            Object result = method.invoke(target, args); <span class="comment">// 执行调用方法（此方法执行前后，可以进行相关业务处理）</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行 JDK Proxy</span></span><br><span class="line">        JDKProxy jdkProxy = <span class="keyword">new</span> JDKProxy();</span><br><span class="line">        Car carInstance = (Car) jdkProxy.getInstance(<span class="keyword">new</span> Taxi());</span><br><span class="line">        carInstance.running();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动态代理之前的业务处理.</span><br><span class="line">The taxi is running.</span><br></pre></td></tr></table></figure><p>可以看出JDK Proxy 实现动态代理的核心是实现Invocation 接口，我们查看Invocation的源码，会发现里面其实只有一个invoke()方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为在动态代理中有一个重要的角色也就是代理器，它用于统一管理被代理的对象，显然<br>InvocationHandler 就是这个代理器，而invoke()方法则是触发代理的执行方法，我们通过实现<br>Invocation 接口来拥有动态代理的能力。</p><h4 id="CGLib的实现"><a href="#CGLib的实现" class="headerlink" title="CGLib的实现"></a>CGLib的实现</h4><p>在使用CGLib之前，我们要先在项目中引入CGLib框架，在pom.xml中添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CGLib 实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lagou.interview;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"The car is running."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CGLib 代理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object target; <span class="comment">// 代理对象</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.target = target;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            <span class="comment">// 设置父类为实例类</span></span><br><span class="line">            enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">            <span class="comment">// 回调方法</span></span><br><span class="line">            enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 创建代理对象</span></span><br><span class="line">            <span class="keyword">return</span> enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"方法调用前业务处理."</span>);</span><br><span class="line">            Object result = methodProxy.invokeSuper(o, objects); <span class="comment">// 执行方法调用</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 CGLib 的方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 CGLib 代理类</span></span><br><span class="line">        CGLibProxy proxy = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line">        <span class="comment">// 初始化代理对象</span></span><br><span class="line">        Car car = (Car) proxy.getInstance(<span class="keyword">new</span> Car());</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        car.running();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法调用前业务处理.</span><br><span class="line">The car is running.</span><br></pre></td></tr></table></figure><p>可以看出CGLib和JDK Proxy的实现代码比较类似，都是通过实现代理器的接口，再调用某一个方法完成动态代理的，唯一不同的是，CGLib在初始化被代理类时，是通过Enhancer 对象把代理对象设置为被代理类的子类来实现动态代理的。因此被代理类不能被关键字final修饰，如果被final修饰，再使用Enhancer设置父类时会报错，动态代理的构建会失败。</p><h3 id="2-Lombok-原理分析"><a href="#2-Lombok-原理分析" class="headerlink" title="2.Lombok 原理分析"></a>2.Lombok 原理分析</h3><p>在开始讲Lombok的原理之前，我们先来简单地介绍一下Lombok，它属于Java的一个热门工具类，使用它可以有效的解决代码工程中那些繁琐又重复的代码，如Setter、Getter、toString、<br>equals和hashCode等等，向这种方法都可以使用Lombok 注解来完成。</p><p>例如，我们使用比较多的Setter和Getter方法，在没有使用Lombok之前，代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 Lombok 之后，代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出Lombok 让代码简单和优雅了很多。<br>小贴士：如果在项目中使用了Lombok的Getter和Setter 注解，那么想要在编码阶段成功调用对象的set或get方法，我们需要在IDE中安装Lombok 插件才行，比如ldea的插件如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p>接下来讲讲Lombok的原理。</p><p>Lombok 的实现和反射没有任何关系，前面我们说了反射是程序在运行期的一种自省（introspect）<br>能力，而Lombok的实现是在编译期就完成了，为什么这么说呢？</p><p>回到我们刚才Setter/Getter的方法，当我们打开Person的编译类就会发现，使用了Lombok的<br>@Data注解后的源码竟然是这样的：</p><p><img data-src="2.png" alt="2.png"></p><p>可以看出Lombok是在编译期就为我们生成了对应的字节码。</p><p>其实Lombok 是基于Java 1.6实现的JSR269：Pluggable Annotation Processing APl来实现的，也就是通过编译期自定义注解处理器来实现的，它的执行步骤如下：</p><p><img data-src="3.png" alt="3.png"></p><p>从流程图中可以看出，在编译期阶段，当Java 源码被抽象成语法树（AST）之后，Lombok会根据自己的注解处理器动态修改AST，增加新的代码（节点），在这一切执行之后就生成了最终的字节码（.class）文件，这就是Lombok的执行原理。</p><h3 id="3-动态代理知识点扩充"><a href="#3-动态代理知识点扩充" class="headerlink" title="3.动态代理知识点扩充"></a>3.动态代理知识点扩充</h3><p>当面试官问动态代理的时候，经常会问到它和静态代理的区别？静态代理其实就是事先写好代理类，可以手工编写也可以使用工具生成，但它的缺点是每个业务类都要对应一个代理类，特别不灵活也不方便，于是就有了动态代理。</p><p>动态代理的常见使用场景有RPC框架的封装、AOP（面向切面编程）的实现、JDBC的连接等。</p><p>Spring 框架中同时使用了两种动态代理JDK Proxy和CGLib，当Bean 实现了接口时，Spring就会使用JDK Proxy，在没有实现接口时就会使用CGLib，我们也可以在配置中指定强制使用CGLib，只需要在Spring 配置中添加&lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们介绍了JDK Proxy和CGLib的区别，JDK Proxy是Java语言内置的动态代理，必须要通过实现接口的方式来代理相关的类，而CGLib是第三方提供的基于ASM的高效动态代理类，它通过实现被代理类的子类来实现动态代理的功能，因此被代理的类不能使用final修饰。<br>除了JDKProxy和CGLib之外，我们还讲了Java中常用的工具类Lombok的实现原理，它其实和反射是没有任何关系的；最后讲了动态代理的使用场景以及Spring中动态代理的实现方式，希望本文可以帮助到你。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-二叉树</title>
      <link href="/2020/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="为什么需要树这种数据结构"><a href="#为什么需要树这种数据结构" class="headerlink" title="为什么需要树这种数据结构"></a>为什么需要树这种数据结构</h2><h3 id="1-数组存储方式的分析"><a href="#1-数组存储方式的分析" class="headerlink" title="1.数组存储方式的分析"></a>1.数组存储方式的分析</h3><p><strong>优点</strong>：通过 <strong>下标方式访问元素</strong>，速度快。对于有序数组，还可使用 <strong>二分查找</strong>提高检索速度。<br><strong>缺点：</strong>如果要检索具体某个值，或者 <strong>插入值( 按一定顺序) 会整体移动</strong>，效率较低 [示意图]<br>画出操作示意图：</p><p><img data-src="1.png" alt="1.png"></p><h3 id="2-链式存储方式的分析"><a href="#2-链式存储方式的分析" class="headerlink" title="2.链式存储方式的分析"></a>2.链式存储方式的分析</h3><p><strong>优点：</strong>在一定程度上对数组存储方式有优化(比如： <strong>插入</strong>一个数值节点，只需要将插入节点，链接到链表中即可，<br><strong>删除</strong>效率也很好)。<br><strong>缺点：</strong>在进行 <strong>检索时</strong>，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 【示意图】<br>操作示意图：</p><p><img data-src="2.png" alt="2.png"></p><h3 id="3-树存储方式的分析"><a href="#3-树存储方式的分析" class="headerlink" title="3.树存储方式的分析"></a>3.树存储方式的分析</h3><p>能提高数据 <strong>存储 ， 读取</strong>的效率, 比如利用  <strong>二叉排序树</strong>(Binary Sort Tree)，既可以保证数据的检索速度，同时也<br>可以保证数据的 <strong>插入，删除，修改</strong>的速度。【示意图,后面详讲】<br><strong>案例:</strong> [7, 3, 10, 1, 5, 9, 12]</p><p><img data-src="3.png" alt="3.png"></p><h2 id="树的常用语"><a href="#树的常用语" class="headerlink" title="树的常用语"></a>树的常用语</h2><p><img data-src="4.png" alt="4.png"></p><p>树的常用术语(结合示意图理解):</p><ol><li>节点</li><li>根节点</li><li>父节点</li><li>子节点</li><li>叶子节点 (没有子节点的节点)</li><li>节点的权(节点值)</li><li>路径(从 root 节点找到该节点的路线)</li><li>层</li><li>子树</li><li>树的高度(最大层数)</li><li>森林 :多颗子树构成森林</li></ol><h2 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h2><ol><li>树有很多种，每个节点 最多只能有两个子节点的一种形式称为二叉树。</li><li>二叉树的子节点分为左节点和右节点</li><li>示意图</li></ol><p><img data-src="5.png" alt="5.png"></p><p>   4.如果该二叉树的所有 叶子节点都在 最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。</p><p><img data-src="6.png" alt="6.png"></p><p>   5.如果该二叉树的所有 叶子节点都在 最后一层或者 倒数第二层，而且最后一层的叶子节点在左边连续，倒数第   二层的叶子节点在右边连续，我们称为完全二叉树</p><p><img data-src="7.png" alt="7.png"></p><h2 id="二叉树遍历的说明"><a href="#二叉树遍历的说明" class="headerlink" title="二叉树遍历的说明"></a>二叉树遍历的说明</h2><ul><li>前序遍历: 先输出父节点，再遍历左子树和右子树</li><li>中序遍历: 先遍历左子树，再输出父节点，再遍历右子树</li><li>后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点</li></ul><p><strong>小结:</strong> 看输出父节点的顺序，就确定是前序，中序还是后序</p><h2 id="二叉树遍历应用实例-前序-中序-后序"><a href="#二叉树遍历应用实例-前序-中序-后序" class="headerlink" title="二叉树遍历应用实例(前序,中序,后序)"></a>二叉树遍历应用实例(前序,中序,后序)</h2><p><img data-src="8.png" alt="8.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先需要创建一颗二叉树</span></span><br><span class="line">BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line"><span class="comment">// 创建需要的结点</span></span><br><span class="line">HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"吴用"</span>);</span><br><span class="line">HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>);</span><br><span class="line">HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">"关胜"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">root.setLeft(node2);</span><br><span class="line">root.setRight(node3);</span><br><span class="line">node3.setRight(node4);</span><br><span class="line">node3.setLeft(node5);</span><br><span class="line">binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">System.out.println(<span class="string">"前序遍历"</span>); <span class="comment">// 1,2,3,5,4</span></span><br><span class="line">binaryTree.preOrder();</span><br><span class="line"><span class="comment">//测试 </span></span><br><span class="line">System.out.println(<span class="string">"中序遍历"</span>);</span><br><span class="line">binaryTree.infixOrder(); <span class="comment">// 2,1,5,3,4</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">System.out.println(<span class="string">"后序遍历"</span>);</span><br><span class="line">binaryTree.postOrder(); <span class="comment">// 2,5,4,3,1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.preOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.postOrder();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.left = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写前序遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>); <span class="comment">// 先输出父结点</span></span><br><span class="line"><span class="comment">// 递归向左子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归向右子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 递归向左子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出父结点</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 递归向右子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.postOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.postOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树-查找指定节点"><a href="#二叉树-查找指定节点" class="headerlink" title="二叉树-查找指定节点"></a>二叉树-查找指定节点</h2><p><strong>要求</strong></p><p>1) 请编写前序查找，中序查找和后序查找的方法。<br>2) 并分别使用三种查找方式，查找 heroNO = 5 的节点<br>3) 并分析各种查找方式，分别比较了多少次<br>4) 思路分析图解</p><p><img data-src="9.png" alt="9.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先需要创建一颗二叉树</span></span><br><span class="line">BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line"><span class="comment">// 创建需要的结点</span></span><br><span class="line">HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"吴用"</span>);</span><br><span class="line">HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>);</span><br><span class="line">HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">"关胜"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">root.setLeft(node2);</span><br><span class="line">root.setRight(node3);</span><br><span class="line">node3.setRight(node4);</span><br><span class="line">node3.setLeft(node5);</span><br><span class="line">binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="comment">//前序遍历的次数 ：4 </span></span><br><span class="line">System.out.println(<span class="string">"前序遍历方式~~~"</span>);</span><br><span class="line">HeroNode resNode = binaryTree.preOrderSearch(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">"找到了，信息为 no=%d name=%s"</span>, resNode.getNo(), resNode.getName());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"没有找到 no = %d 的英雄"</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历查找</span></span><br><span class="line"><span class="comment">// 中序遍历3次</span></span><br><span class="line">System.out.println(<span class="string">"中序遍历方式~~~"</span>);</span><br><span class="line">HeroNode resNode2 = binaryTree.infixOrderSearch(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (resNode2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">"找到了，信息为 no=%d name=%s"</span>, resNode2.getNo(), resNode2.getName());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"没有找到 no = %d 的英雄"</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line"><span class="comment">// 后序遍历查找</span></span><br><span class="line"><span class="comment">// 后序遍历查找的次数 2次</span></span><br><span class="line">System.out.println(<span class="string">"后序遍历方式~~~"</span>);</span><br><span class="line">HeroNode resNode3 = binaryTree.postOrderSearch(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (resNode3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">"找到了，信息为 no=%d name=%s"</span>, resNode3.getNo(), resNode3.getName());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"没有找到 no = %d 的英雄"</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.root.postOrderSearch(no);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.left = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历查找</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> no 查找no</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到就返回该Node ,如果没有找到返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"进入前序遍历"</span>);</span><br><span class="line"><span class="comment">//比较当前节点是不是</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line"><span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line"><span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"进入中序遍历"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前结点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;<span class="comment">// 说明在左子树找到</span></span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果左子树没有找到，则向右子树递归进行后序遍历查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">resNode = <span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"进入后序查找"</span>);</span><br><span class="line"><span class="comment">// 如果左右子树都没有找到，就比较当前结点是不是</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树-删除节点"><a href="#二叉树-删除节点" class="headerlink" title="二叉树-删除节点"></a>二叉树-删除节点</h2><p>要求</p><p>1) 如果删除的节点是叶子节点，则删除该节点<br>2) 如果删除的节点是非叶子节点，则删除该子树.<br>3) 测试，删除掉 5 号叶子节点 和 3 号子树.<br>4) 完成删除思路分析</p><p><img data-src="10.png" alt="10.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先需要创建一颗二叉树</span></span><br><span class="line">BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line"><span class="comment">// 创建需要的结点</span></span><br><span class="line">HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"吴用"</span>);</span><br><span class="line">HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>);</span><br><span class="line">HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">"关胜"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">root.setLeft(node2);</span><br><span class="line">root.setRight(node3);</span><br><span class="line">node3.setRight(node4);</span><br><span class="line">node3.setLeft(node5);</span><br><span class="line">binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"删除前,前序遍历"</span>);</span><br><span class="line">binaryTree.preOrder(); <span class="comment">//  1,2,3,5,4</span></span><br><span class="line">binaryTree.delNode(<span class="number">5</span>);</span><br><span class="line">binaryTree.delNode(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"删除后，前序遍历"</span>);</span><br><span class="line">binaryTree.preOrder(); <span class="comment">// 1,2,3,4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.root = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line"><span class="keyword">if</span> (root.getNo() == no) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 递归删除</span></span><br><span class="line">root.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"空树，不能删除~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.preOrder();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.root.postOrder();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line"><span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.left = left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写前序遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>); <span class="comment">// 先输出父结点</span></span><br><span class="line"><span class="comment">// 递归向左子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归向右子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 递归向左子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出父结点</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 递归向右子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.postOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.postOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归删除节点</span></span><br><span class="line"><span class="comment">// 1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line"><span class="comment">// 2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no)&#123;</span><br><span class="line"><span class="keyword">this</span>.left =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-哈希表</title>
      <link href="/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表的基本介绍"><a href="#哈希表的基本介绍" class="headerlink" title="哈希表的基本介绍"></a>哈希表的基本介绍</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通<br>过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组<br>叫做散列表。</p><p><img data-src="1.png" alt="1.png"></p><p><img data-src="2.png" alt="2.png"></p><h2 id="google-公司的一个上机题"><a href="#google-公司的一个上机题" class="headerlink" title="google 公司的一个上机题:"></a>google 公司的一个上机题:</h2><p>有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的 id 时,<br>要求查找到该员工的 所有信息.</p><p><strong>要求:</strong></p><ol><li>不使用数据库,,速度越快越好=&gt;哈希表(散列)</li><li>添加时，保证按照 id 从低到高插入 [课后思考： 如果 id  不是从低到高插入，但要求各条链表仍是从低到<br>高，怎么解决?]</li><li>使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息]</li><li>思路分析并画出示意图</li></ol><p><img data-src="3.png" alt="3.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建哈希表</span></span><br><span class="line">HashTab hashTab = <span class="keyword">new</span> HashTab(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个简单的菜单</span></span><br><span class="line">String key = <span class="string">""</span>;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"add:  添加雇员"</span>);</span><br><span class="line">System.out.println(<span class="string">"list: 显示雇员"</span>);</span><br><span class="line">System.out.println(<span class="string">"find: 查找雇员"</span>);</span><br><span class="line">System.out.println(<span class="string">"delete: 删除雇员"</span>);</span><br><span class="line">System.out.println(<span class="string">"exit: 退出系统"</span>);</span><br><span class="line"></span><br><span class="line">key = scanner.next();</span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">System.out.println(<span class="string">"输入id"</span>);</span><br><span class="line"><span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">"输入名字"</span>);</span><br><span class="line">String name = scanner.next();</span><br><span class="line"><span class="comment">// 创建 雇员</span></span><br><span class="line">Emp emp = <span class="keyword">new</span> Emp(id, name);</span><br><span class="line">hashTab.add(emp);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"list"</span>:</span><br><span class="line">hashTab.list();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"find"</span>:</span><br><span class="line">System.out.println(<span class="string">"请输入要查找的id"</span>);</span><br><span class="line">id = scanner.nextInt();</span><br><span class="line"> hashTab.findEmpById(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"delete"</span>:</span><br><span class="line">System.out.println(<span class="string">"请输入要删除的id"</span>);</span><br><span class="line">id = scanner.nextInt();</span><br><span class="line"> hashTab.delEmpById(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">scanner.close();</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示一个雇员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> Emp next;<span class="comment">// next 默认为空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HashTable 管理多条链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTab</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// 表示共有多少条链表</span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.size = size;</span><br><span class="line"><span class="comment">// 初始化 empLinkedListArr</span></span><br><span class="line">empLinkedListArray = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line"><span class="comment">//不要忘了分别初始化每个链表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">empLinkedListArray[i] = <span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加雇员</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据员工的id 得到该员工应当添加到哪条链表</span></span><br><span class="line"><span class="keyword">int</span> empLinkedListNo = hashFun(emp.id);</span><br><span class="line"><span class="comment">// 将emp加入到对应的链表中</span></span><br><span class="line">empLinkedListArray[empLinkedListNo].add(emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个散列函数 使用一个简单的取模法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id % size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的链表,遍历hashtab</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">empLinkedListArray[i].list(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据输入的id,查找雇员</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据员工的id 得到该员工应当添加到哪条链表</span></span><br><span class="line"><span class="keyword">int</span> empLinkedListNo = hashFun(id);</span><br><span class="line">Emp emp = empLinkedListArray[empLinkedListNo].findEmpById(id);</span><br><span class="line"><span class="keyword">if</span>(emp != <span class="keyword">null</span>) &#123;<span class="comment">//找到</span></span><br><span class="line">System.out.printf(<span class="string">"在第%d条链表中找到 雇员 %s id = %d\n"</span>, (empLinkedListNo + <span class="number">1</span>),emp.name, id);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"在哈希表中，没有找到该雇员~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据输入的id,删除雇员</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据员工的id 得到该员工应当添加到哪条链表</span></span><br><span class="line"><span class="keyword">int</span> empLinkedListNo = hashFun(id);</span><br><span class="line"><span class="keyword">boolean</span> flag = empLinkedListArray[empLinkedListNo].delEmpById(id);</span><br><span class="line"><span class="keyword">if</span> (flag ) &#123;<span class="comment">// 找到</span></span><br><span class="line">System.out.printf(<span class="string">"在第%d条链表中删除 雇员  id = %d\n"</span>, (empLinkedListNo + <span class="number">1</span>), id);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"在哈希表中，没有找到该雇员~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建EmpLinkedList，表示链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">// 头指针，指向第一个雇员 所以这个链表的head是有效的 指向第一个Emp</span></span><br><span class="line"><span class="keyword">public</span> Emp head;<span class="comment">// 默认为空</span></span><br><span class="line"><span class="comment">// 添加雇员到链表</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大</span></span><br><span class="line"><span class="comment">// 因此我们将该雇员直接加入到本链表的最后即可</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果是添加第一个雇员</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">head = emp;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后</span></span><br><span class="line">Emp curEmp = head;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (curEmp != <span class="keyword">null</span> &amp;&amp; curEmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curEmp = curEmp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出时直接将emp 加入链表</span></span><br><span class="line">curEmp.next = emp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表的雇员信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;<span class="comment">// 链表为空</span></span><br><span class="line">System.out.println(<span class="string">"第 "</span> + (no + <span class="number">1</span>) + <span class="string">" 链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">"第 "</span> + (no + <span class="number">1</span>) + <span class="string">" 链表的信息为"</span>);</span><br><span class="line">Emp curEmp = head; <span class="comment">// 辅助指针</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">" =&gt; id=%d name=%s\t"</span>, curEmp.id, curEmp.name);</span><br><span class="line"><span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curEmp = curEmp.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据id查找雇员</span></span><br><span class="line"><span class="comment">//如果查找到，就返回Emp, 如果没有找到，就返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找辅助指针</span></span><br><span class="line">Emp curEmp = head;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (curEmp.id == id) &#123;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//这时curEmp就指向要查找的雇员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出</span></span><br><span class="line"><span class="keyword">if</span>(curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明遍历当前链表没有找到该雇员</span></span><br><span class="line">curEmp = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curEmp = curEmp.next;<span class="comment">//以后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> curEmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head.id == id) &#123;</span><br><span class="line">head =head.next;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找辅助指针</span></span><br><span class="line">Emp curEmp = head;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (curEmp.next.id == id) &#123;</span><br><span class="line"><span class="keyword">if</span> (curEmp.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">curEmp.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">curEmp.next = curEmp.next.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出</span></span><br><span class="line"><span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明遍历当前链表没有找到该雇员</span></span><br><span class="line">curEmp = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">curEmp = curEmp.next;<span class="comment">// 以后</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-斐波那契查找</title>
      <link href="/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="斐波那契-黄金分割法-查找基本介绍"><a href="#斐波那契-黄金分割法-查找基本介绍" class="headerlink" title="斐波那契(黄金分割法)查找基本介绍:"></a>斐波那契(黄金分割法)查找基本介绍:</h2><ol><li>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位<br>数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神<br>奇的数字，会带来意向不大的效果。</li><li>斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值<br>0.618</li></ol><h2 id="斐波那契-黄金分割法-原理"><a href="#斐波那契-黄金分割法-原理" class="headerlink" title="斐波那契(黄金分割法)原理:"></a>斐波那契(黄金分割法)原理:</h2><p>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位<br>于黄金分割点附近，即 mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示</p><p><img data-src="1.png" alt="1.png"></p><h3 id="对-F-k-1-1-的理解："><a href="#对-F-k-1-1-的理解：" class="headerlink" title="对 F(k-1)-1  的理解："></a>对 F(k-1)-1  的理解：</h3><ol><li>由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：<br>只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间位置为 mid=low+F(k-1)-1</li><li>类似的，每一子段也可以用相同的方式分割</li><li>但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使<br>得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置），<br>都赋为 n 位置的值即可。while(n&gt;fib(k)-1)     k++;</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSearch</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize =<span class="number">20</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">89</span>,<span class="number">1000</span>,<span class="number">1234</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"index="</span> + fibSearch(arr, <span class="number">89</span>));<span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为后面的公式 mid=low+F(k-1)-1,需要使用到斐波那契数列 ，所以 需要先获取到一个斐波那契数列</span></span><br><span class="line"><span class="comment">//非递归的方式 得到一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line"><span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写斐波那契查找算法</span></span><br><span class="line"><span class="comment">//非递归的方式</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 需要查找的关键码（值）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回对应下标 如果没有返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = a.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//表示斐波那契分割数值的下标 即公式中的k</span></span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>;<span class="comment">//存放mid</span></span><br><span class="line"><span class="keyword">int</span> f[]=fib();<span class="comment">//获取到斐波那契数列</span></span><br><span class="line"><span class="comment">//获取到k</span></span><br><span class="line"><span class="comment">// 获取斐波那契分割数值下标 </span></span><br><span class="line"><span class="keyword">while</span> (high &gt;f[k]-<span class="number">1</span> ) &#123;<span class="comment">//这里的 k 值只要能使得 F[k]-1 恰好大于或等于 顺序表长度 即可</span></span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span></span><br><span class="line"><span class="comment">//不足的部分会使用0填充</span></span><br><span class="line"><span class="keyword">int</span>[] temp = Arrays.copyOf(a, f[k]-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//实际上需要使用a数组的最后的数 填充 temp</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = high+<span class="number">1</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">temp[i] = a[high];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用while来循环处理，找到我们的数 key</span></span><br><span class="line"><span class="keyword">while</span> (low&lt;=high) &#123;<span class="comment">// 只要这个条件满足，就可以找</span></span><br><span class="line">mid = low+f[k-<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (key &lt; temp[mid]) &#123;<span class="comment">//说明继续向左侧查找</span></span><br><span class="line">high = mid-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//为什么是 k--</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line"><span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line"><span class="comment">//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]</span></span><br><span class="line"><span class="comment">//即 在 f[k-1] 的前面继续查找 k--</span></span><br><span class="line"><span class="comment">//即下次循环 mid = f[k-1-1]-1</span></span><br><span class="line">k--;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; temp[mid]) &#123; <span class="comment">// 我们应该继续向数组的后面查找(右边)</span></span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//为什么是k -=2</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line"><span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line"><span class="comment">//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-2] = f[k-3] + f[k-4]</span></span><br><span class="line"><span class="comment">//4. 即在f[k-2] 的前面进行查找 k -=2</span></span><br><span class="line"><span class="comment">//5. 即下次循环 mid = f[k - 1 - 2] - 1</span></span><br><span class="line">k-=<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123; <span class="comment">//找到</span></span><br><span class="line"><span class="comment">//需要确定，返回的是哪个下标</span></span><br><span class="line"><span class="keyword">if</span>(mid &lt;= high) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-插值查找</title>
      <link href="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="插值查找算法"><a href="#插值查找算法" class="headerlink" title="插值查找算法"></a>插值查找算法</h2><ul><li><p>插值查找原理介绍:插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。</p></li><li><p>将折半查找中的求 mid 索引的公式 , low 表示左边索引 left, high 表示右边索引 right.<br>key 就是前面我们讲的 findVal</p><p><img data-src="1.png" alt="1.png"></p></li><li><p>int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;/<em>插值索引</em>/<br>对应前面的代码公式：<br>int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])</p></li><li><p>举例说明插值查找算法 1-100 的数组</p></li></ul><p><img data-src="2.png" alt="2.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertValueSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">arr[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> index = insertValueSearch(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, <span class="number">50</span>);</span><br><span class="line">System.out.println(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写插值查找算法</span></span><br><span class="line"><span class="comment">//说明：插值查找算法，也要求数组是有序的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> findVal 查找值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到，就返回对应的下标，如果没有找到，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"插值查找次数~~"</span>);</span><br><span class="line"><span class="comment">//注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要</span></span><br><span class="line"><span class="comment">//否则我们得到的 mid 可能越界</span></span><br><span class="line"><span class="keyword">if</span> (left&gt;right || findVal &lt;arr[left] || findVal&gt;arr[right] ) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = left+(right-left)*(findVal-arr[left])/(arr[right]-arr[left]);</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"><span class="keyword">if</span> (findVal&gt;midVal) &#123;<span class="comment">//向右递归</span></span><br><span class="line"><span class="keyword">return</span> insertValueSearch(arr, mid+<span class="number">1</span>, right, findVal);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123;</span><br><span class="line"><span class="keyword">return</span> insertValueSearch(arr, left, mid-<span class="number">1</span>, findVal);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是等差数列 只需一次查找！！ 斜率。</p><h2 id="插值查找注意事项："><a href="#插值查找注意事项：" class="headerlink" title="插值查找注意事项："></a>插值查找注意事项：</h2><ol><li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快.</li><li>关键字分布不均匀的情况下，该方法不一定比折半查找要好</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-二分查找</title>
      <link href="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h1><h2 id="二分查找："><a href="#二分查找：" class="headerlink" title="二分查找："></a>二分查找：</h2><p>请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下<br>标，如果没有就提示”没有这个数”。</p><h2 id="二分查找算法的思路"><a href="#二分查找算法的思路" class="headerlink" title="二分查找算法的思路"></a>二分查找算法的思路</h2><p><img data-src="1.png" alt="1.png"></p><h2 id="递归实现二分查找"><a href="#递归实现二分查找" class="headerlink" title="递归实现二分查找"></a>递归实现二分查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>,<span class="number">1000</span>, <span class="number">1234</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> resIndex = binarySearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line"> System.out.println(<span class="string">"resIndex="</span> + resIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> findVal 要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到就返回下标，如果没找到就返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归结束条件</span></span><br><span class="line"><span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line"><span class="keyword">if</span> (left&gt;right || findVal &lt;arr[left] || findVal&gt;arr[right] ) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"><span class="keyword">if</span> (findVal&gt;midVal) &#123;<span class="comment">//需要向右递归 </span></span><br><span class="line"><span class="keyword">return</span> binarySearch(arr, mid+<span class="number">1</span>, right, findVal);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (findVal&lt;midVal) &#123;</span><br><span class="line"><span class="keyword">return</span> binarySearch(arr, left, mid-<span class="number">1</span>, findVal);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h2><p> {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 完成一个课后思考题:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 课后思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，</span></span><br><span class="line"><span class="comment"> * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路分析 </span></span><br><span class="line"><span class="comment"> * 1. 在找到mid 索引值，不要马上返回 </span></span><br><span class="line"><span class="comment"> * 2. 向mid 索引值的左边扫描，将所有满足 1000，的元素的下标，加入到集合ArrayList </span></span><br><span class="line"><span class="comment"> * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment"> * 4. 将Arraylist返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归结束条件</span></span><br><span class="line"><span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right || findVal &lt; arr[left] || findVal &gt; arr[right]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"><span class="keyword">if</span> (findVal &gt; midVal) &#123;<span class="comment">// 需要向右递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch2(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123;</span><br><span class="line"><span class="keyword">return</span> binarySearch2(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">List&lt;Integer&gt; resIndexlist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="keyword">int</span> temp =  mid-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; <span class="number">0</span> || arr[temp] != findVal) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则就把temp放入到集合中</span></span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp = temp-<span class="number">1</span>;<span class="comment">//temp左移</span></span><br><span class="line">&#125;</span><br><span class="line">resIndexlist.add(mid);<span class="comment">//中间的mid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始向右扫描</span></span><br><span class="line">temp = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp &gt; arr.length-<span class="number">1</span> || arr[temp] != findVal) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp = temp+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resIndexlist;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-线性查找</title>
      <link href="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">9</span>, <span class="number">11</span>, -<span class="number">1</span>, <span class="number">34</span>, <span class="number">89</span> &#125;;<span class="comment">// 没有顺序的数组</span></span><br><span class="line"><span class="keyword">int</span> index = seqSearch(arr, -<span class="number">11</span>);</span><br><span class="line"><span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"没有找到到"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"找到，下标为="</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里我们实现的线性查找是找到一个满足条件的值，就返回</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线性查找是逐一比对，发现有相同值，就返回下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == value) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-基数排序</title>
      <link href="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="基数排序-桶排序-介绍"><a href="#基数排序-桶排序-介绍" class="headerlink" title="基数排序(桶排序)介绍:"></a>基数排序(桶排序)介绍:</h2><ol><li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</li><li>基数排序法是属于稳定性的排序，基数排序法的是效率高的 稳定性排序法</li><li>基数排序(Radix Sort)是桶排序的扩展</li><li>基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个<br>位数分别比较。</li></ol><h2 id="基数排序基本思想"><a href="#基数排序基本思想" class="headerlink" title="基数排序基本思想"></a>基数排序基本思想</h2><p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。<br>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><h2 id="基数排序图文说明"><a href="#基数排序图文说明" class="headerlink" title="基数排序图文说明"></a>基数排序图文说明</h2><p>将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序</p><p>第一轮</p><p><img data-src="1.png" alt="1.png"></p><p>第二轮</p><p><img data-src="2.png" alt="2.png"></p><p>第三轮</p><p><img data-src="3.png" alt="3.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span> &#125;;</span><br><span class="line">radixSort(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 第1轮(针对每个元素的个位进行排序处理)</span></span><br><span class="line"><span class="comment">// 定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. 二维数组包含10个一维数组</span></span><br><span class="line"><span class="comment">// 2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line"><span class="comment">// 3. 名明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line"><span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"><span class="comment">// 为了记录每个桶中实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line"><span class="comment">// 可以这里理解</span></span><br><span class="line"><span class="comment">// 比如：bucketElementCounts[0] , 记录的就是 bucket[0] 桶的放入数据个数</span></span><br><span class="line"><span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 找到数组中最大的数</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到是几位数</span></span><br><span class="line"><span class="keyword">int</span> maxLength = (max + <span class="string">""</span>).length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line"><span class="comment">// 取出每个元素的个位的值</span></span><br><span class="line"><span class="keyword">int</span> digitOfElement = arr[j] / n % <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 放入到对应的桶中</span></span><br><span class="line">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">bucketElementCounts[digitOfElement]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line"><span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="keyword">if</span> (bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line"><span class="comment">// 取出元素放入到arr</span></span><br><span class="line">arr[index++] = bucket[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"排序后"</span> + Arrays.toString(arr));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第1轮(针对每个元素的个位进行排序处理)</span></span><br><span class="line"><span class="comment">for(int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">//取出每个元素的个位的值</span></span><br><span class="line"><span class="comment">int digitOfElement = arr[j] / 1 % 10;</span></span><br><span class="line"><span class="comment">//放入到对应的桶中</span></span><br><span class="line"><span class="comment">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">bucketElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line"><span class="comment">int index = 0;</span></span><br><span class="line"><span class="comment">//遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="comment">for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="comment">if(bucketElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">//循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line"><span class="comment">for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">//取出元素放入到arr</span></span><br><span class="line"><span class="comment">arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line"><span class="comment">bucketElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">System.out.println("第1轮，对个位的排序处理 arr =" + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//==========================================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第2轮(针对每个元素的十位进行排序处理)</span></span><br><span class="line"><span class="comment">for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">// 取出每个元素的十位的值</span></span><br><span class="line"><span class="comment">int digitOfElement = arr[j] / 10  % 10; //748 / 10 =&gt; 74 % 10 =&gt; 4</span></span><br><span class="line"><span class="comment">// 放入到对应的桶中</span></span><br><span class="line"><span class="comment">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">bucketElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line"><span class="comment">index = 0;</span></span><br><span class="line"><span class="comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="comment">for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="comment">if (bucketElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line"><span class="comment">for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">// 取出元素放入到arr</span></span><br><span class="line"><span class="comment">arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line"><span class="comment">bucketElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">System.out.println("第2轮，对个位的排序处理 arr =" + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第3轮(针对每个元素的百位进行排序处理)</span></span><br><span class="line"><span class="comment">for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">// 取出每个元素的百位的值</span></span><br><span class="line"><span class="comment">int digitOfElement = arr[j] / 100 % 10; // 748 / 100 =&gt; 7 % 10 = 7</span></span><br><span class="line"><span class="comment">// 放入到对应的桶中</span></span><br><span class="line"><span class="comment">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">bucketElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line"><span class="comment">index = 0;</span></span><br><span class="line"><span class="comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="comment">for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="comment">if (bucketElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line"><span class="comment">for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">// 取出元素放入到arr</span></span><br><span class="line"><span class="comment">arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line"><span class="comment">bucketElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">System.out.println("第3轮，对个位的排序处理 arr =" + Arrays.toString(arr)); */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8000000条数据不到1秒！</p><p>再大会有内存溢出的可能  OutOfMempryError</p><h2 id="基数排序的说明"><a href="#基数排序的说明" class="headerlink" title="基数排序的说明:"></a>基数排序的说明:</h2><ol><li>基数排序是对传统桶排序的扩展，速度很快.</li><li>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。</li><li>基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些<br>记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且 r[i]在 r[j]之前，而在排序后的序列中，r[i]仍在 r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的]rv</li><li>有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9" target="_blank" rel="noopener">https://code.i-harness.com/zh-CN/q/e98fa9</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-归并排序</title>
      <link href="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序介绍"><a href="#归并排序介绍" class="headerlink" title="归并排序介绍:"></a>归并排序介绍:</h2><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的 <strong>分治 （divide-and-conquer ）策略</strong>（分治法将问题分(divide)成一些 <strong>小的问题然后递归求解</strong>，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><h2 id="归并排序思想示意图-1-基本思想"><a href="#归并排序思想示意图-1-基本思想" class="headerlink" title="归并排序思想示意图 1-基本思想:"></a>归并排序思想示意图 1-基本思想:</h2><p><img data-src="1.png" alt="1.png"></p><h2 id="归并排序思想示意图-2-合并相邻有序子序列"><a href="#归并排序思想示意图-2-合并相邻有序子序列" class="headerlink" title="归并排序思想示意图 2-合并相邻有序子序列:"></a>归并排序思想示意图 2-合并相邻有序子序列:</h2><p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将<br>[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤</p><p><img data-src="2.png" alt="2.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int arr[]=&#123;8,4,5,7,1,3,6,2&#125;;</span></span><br><span class="line"><span class="comment">int temp[] = new int[arr.length]; //归并排序需要一个额外空间</span></span><br><span class="line"><span class="comment"> mergeSort(arr, 0, arr.length - 1, temp);*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试快排的执行速度</span></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8000000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; <span class="comment">// 归并排序需要一个额外空间</span></span><br><span class="line">mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"><span class="comment">// System.out.println("归并排序后=" + Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分+合的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start&lt;end) &#123;<span class="comment">//当子序列中只有一个元素时结束递归</span></span><br><span class="line"><span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line"><span class="comment">//向左递归进行分解</span></span><br><span class="line">mergeSort(arr, start, mid, temp);<span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line"><span class="comment">//向右递归分解</span></span><br><span class="line">mergeSort(arr, mid+<span class="number">1</span>, end, temp);<span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line">merge(arr, start, mid, end, temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//合并的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid 中间索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp 做中转的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = left; <span class="comment">//初始化i，左边有序序列的初始索引</span></span><br><span class="line"><span class="keyword">int</span> j = mid+<span class="number">1</span>; <span class="comment">//初始化j，表示右边有序序列的初始索引</span></span><br><span class="line"><span class="keyword">int</span> t= <span class="number">0</span>; <span class="comment">//指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. </span></span><br><span class="line"><span class="comment">//先把左右两边的数据（此时已经有序），按照规则 填充到 temp数组，</span></span><br><span class="line"><span class="comment">//直到左右两边的有序序列 有一边处理完毕为止</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line"><span class="comment">// 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line"><span class="comment">// 即将左边的当前元素，填充到 temp数组</span></span><br><span class="line"><span class="comment">// 然后 t++, i++</span></span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">temp[t] = arr[i];</span><br><span class="line">i++;</span><br><span class="line">t++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 反之,将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">temp[t] = arr[j];</span><br><span class="line">j++;</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="comment">//把有剩余的一边的数据依次全部填充到temp</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid) &#123;</span><br><span class="line">temp[t] = arr[i];</span><br><span class="line">i++;</span><br><span class="line">t++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j&lt;=right) &#123;</span><br><span class="line">temp[t] = arr[j];</span><br><span class="line">j++;</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="comment">//将temp数组的元素重新copy到 arr</span></span><br><span class="line"><span class="comment">//注意，并不是每次都拷贝所有 </span></span><br><span class="line"><span class="comment">//temp长度和原数组一样，每次只用了其中一部分，不能全覆盖</span></span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tempLeft = left;</span><br><span class="line"><span class="comment">//第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3</span></span><br><span class="line"><span class="comment">//最后一次 tempLeft = 0  right = 7</span></span><br><span class="line"><span class="keyword">while</span> (tempLeft &lt;= right) &#123;</span><br><span class="line">arr[tempLeft] = temp[t];</span><br><span class="line">t++;</span><br><span class="line">tempLeft++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8000000条数据 1秒</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深克隆和浅克隆有什么区别？它的实现方式有哪些？</title>
      <link href="/2020/04/03/%E6%B7%B1%E5%85%8B%E9%9A%86%E5%92%8C%E6%B5%85%E5%85%8B%E9%9A%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
      <url>/2020/04/03/%E6%B7%B1%E5%85%8B%E9%9A%86%E5%92%8C%E6%B5%85%E5%85%8B%E9%9A%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<p>使用克隆可以为我们快速地构建出一个已有对象的副本，它属于Java基础的一部分，也是面试中常被问到的知识点之一。<br>我们本课时的面试题是，什么是浅克隆和深克隆？如何实现克隆？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p><strong>浅克隆（Shadow Clone）</strong>是把原型对象中成员变量为值类型的属性都复制给克隆对象，把原型对象中成员变量为引用类型的引用地址也复制给克隆对象，也就是原型对象中如果有成员变量为引用对象，则此引用对象的地址是共享给原型对象和克隆对象的。</p><p>简单来说就是浅克隆只会复制原型对象，但不会复制它所引用的对象，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p><strong>深克隆（Deep Clone）</strong>是将原型对象中的所有类型，无论是值类型还是引用类型，都复制一份给克隆对象，也就是说深克隆会把原型对象和原型对象所引用的对象，都复制一份给克隆对象，如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><p>在Java 语言中要实现克隆则需要实现Cloneable接口，并重写Object类中的clone0方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被赋值对象</span></span><br><span class="line">        People p1 = <span class="keyword">new</span> People();</span><br><span class="line">        p1.setId(<span class="number">1</span>);</span><br><span class="line">        p1.setName(<span class="string">"Java"</span>);</span><br><span class="line">        <span class="comment">// 克隆 p1 对象</span></span><br><span class="line">        People p2 = (People) p1.clone();</span><br><span class="line">        <span class="comment">// 打印名称</span></span><br><span class="line">        System.out.println(<span class="string">"p2:"</span> + p2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性</span></span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写 clone 方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行的结果为：</p><p><strong>p2:Java</strong></p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>克隆相关的面试题不算太难，但因为使用频率不高，因此很容易被人忽略，面试官通常会在一面或者二面的时候问到此知识点，和它相关的面试题还有以下这些：</p><ul><li>在java.lang.Object中对clone0方法的约定有哪些？</li><li>Arrays.copyOf0是深克隆还是浅克隆？</li><li>深克隆的实现方式有几种？</li><li>Java中的克隆为什么要设计成，既要实现空接口Cloneable，还要重写Object的clone0方法？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p><strong>clone（）源码分析</strong><br>要想真正的了解克隆，首先要从它的源码入手，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Creates and returns a copy of this object.The precise meaning</span></span><br><span class="line"><span class="comment">*of "copy"may depend on the class of the object.The general</span></span><br><span class="line"><span class="comment">*intent is that,for any object &#123;<span class="doctag">@code</span> x&#125;,the expression:</span></span><br><span class="line"><span class="comment">*&lt;blockquote〉</span></span><br><span class="line"><span class="comment">*&lt;pre&gt;</span></span><br><span class="line"><span class="comment">*x.clone()!=x〈/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">*will be true,and that the expression:</span></span><br><span class="line"><span class="comment">*&lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">*&lt;pre&gt;</span></span><br><span class="line"><span class="comment">*x.clone).getClass()==x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">*will be &#123;<span class="doctag">@code</span> true&#125;,but these are not absolute requirements.</span></span><br><span class="line"><span class="comment">*While it is typically the case that:</span></span><br><span class="line"><span class="comment">*&lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">*&lt;pre&gt;</span></span><br><span class="line"><span class="comment">*x.clone().equals(x)〈/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">*will be &#123;<span class="doctag">@code</span> true&#125;,this is not an absolute requirement.</span></span><br><span class="line"><span class="comment">*&lt;p&gt;</span></span><br><span class="line"><span class="comment">* By convention, the returned object should be obtained by calling</span></span><br><span class="line"><span class="comment">*&#123;@ code super. clone&#125;. If a class and all of its superclasses (except</span></span><br><span class="line"><span class="comment">*&#123;@ code Object&#125;) obey this convention, it will be the case that</span></span><br><span class="line"><span class="comment">*&#123;@ code x. clone). getClass)==x. getClass)&#125;.</span></span><br><span class="line"><span class="comment">*&lt;p&gt;</span></span><br><span class="line"><span class="comment">* By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment">* of this object (which is being cloned). To achieve this independence,</span></span><br><span class="line"><span class="comment">* it may be necessary to modify one or more fields of the object returned</span></span><br><span class="line"><span class="comment">* by &#123;@ code super. clone] before returning it. Typically, this means</span></span><br><span class="line"><span class="comment">* copying any mutable objects that comprise the internal "deep structure"</span></span><br><span class="line"><span class="comment">* of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment">* objects with references to the copies. If a class contains only</span></span><br><span class="line"><span class="comment">* primitive fields or references to immutable objects, then it is usually</span></span><br><span class="line"><span class="comment">* the case that no fields in the object returned by &#123;@ code super. clone&#125;</span></span><br><span class="line"><span class="comment">* need to be modified.</span></span><br><span class="line"><span class="comment">*&lt;p&gt;</span></span><br><span class="line"><span class="comment">protected native Object clone() throws CloneNotSupportedException;</span></span><br></pre></td></tr></table></figure><p>从以上源码的注释信息中我们可以看出，Object对clone0方法的约定有三条：</p><ul><li>对于所有对象来说，x.clone0！=x应当返回true，因为克隆对象与原对象不是同一个对象；</li><li>对于所有对象来说，x.clone0.getClass0==x.getClass0应当返回true，因为克隆对象与原对象的类型是一样的；</li><li>对于所有对象来说，x.clone0.equals（x）应当返回true，因为使用equals 比较时，它们的值都是相同的。</li></ul><p>除了注释信息外，我们看clone0的实现方法，发现clone0是使用native修饰的本地方法，因此执行的性能会很高，并且它返回的类型为Object，因此在调用克隆之后要把对象强转为目标类型才行。</p><h2 id="Arrays-copyOf-）"><a href="#Arrays-copyOf-）" class="headerlink" title="Arrays.copyOf(）"></a>Arrays.copyOf(）</h2><p>如果是数组类型，我们可以直接使用Arrays.copyOf()来实现克隆，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums1 = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">Integer[] nums2 = Arrays.copyOf(nums1, nums1.length);</span><br><span class="line"><span class="comment">// 修改克隆对象的第一个元素的值</span></span><br><span class="line">nums2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"nums1:"</span> + Arrays.toString(nums2));</span><br><span class="line">System.out.println(<span class="string">"nums2:"</span> + Arrays.toString(nums2));</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p><strong>nums1:[5, 5, 7, 9]</strong><br><strong>nums2:[5, 5, 7, 9]</strong></p><p>从结果可以看出，我们在修改克隆对象的第一个元素之后，原型对象的第一个元素也跟着被修改了，这说明Arrays.copyOf0其实是一个浅克隆。</p><p>你可能也发现了，数组中存储的明明是值类型，克隆之后应该是复制相关的值属性才对，但是数组比较特殊，因为数组本身就是引用类型，因此在使用Arrays.copyOf()其实只是把引用地址复制了一份给克隆对象，如果修改了它的引用对象，那么指向它的（引用地址）所有对象都会发生改变，因此看到的结果是，修改了克隆对象的第一个元素，原型对象也跟着被修改了。</p><h2 id="深克隆实现方式汇总"><a href="#深克隆实现方式汇总" class="headerlink" title="深克隆实现方式汇总"></a>深克隆实现方式汇总</h2><p>深克隆的实现方式有很多种，大体可以分为以下几类：</p><ul><li>所有对象都实现克隆方法；</li><li>通过构造方法实现深克隆；</li><li>使用JDK自带的字节流实现深克隆；</li><li>使用第三方工具实现深克隆，比如Apache Commons Lang；</li><li>使用JSON工具类实现深克隆，比如Gson、FastJSON等。</li></ul><p>接下来我们分别来实现以上这些方式，在开始之前先定义一个公共的用户类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address; <span class="comment">// 包含 Address 引用对象</span></span><br><span class="line">    <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出在 People 对象中包含了一个引用对象 Address。</p><h3 id="1-所有对象都实现克隆"><a href="#1-所有对象都实现克隆" class="headerlink" title="1.所有对象都实现克隆"></a>1.所有对象都实现克隆</h3><p>这种方式我们需要修改People和Address类，让它们都实现Cloneable的接口，让所有的引用对象都实现克隆，从而实现People类的深克隆，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被赋值对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        <span class="comment">// 克隆 p1 对象</span></span><br><span class="line">        People p2 = p1.clone();</span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                            <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写 clone 方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> People <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">             People people = (People) <span class="keyword">super</span>.clone();</span><br><span class="line">             people.setAddress(<span class="keyword">this</span>.address.clone()); <span class="comment">// 引用类型克隆赋值</span></span><br><span class="line">             <span class="keyword">return</span> people;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写 clone 方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Address <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p><strong>p1:西安 p2:北京</strong></p><p>从结果可以看出，当我们修改了原型对象的引用属性之后，并没有影响克隆对象，这说明此对象已经实现了深克隆。</p><h3 id="2-通过构造方法实现深克隆"><a href="#2-通过构造方法实现深克隆" class="headerlink" title="2.通过构造方法实现深克隆"></a>2.通过构造方法实现深克隆</h3><p>《Effective Java》中推荐使用构造器（Copy Constructor）来实现深克隆，如果构造器的参数为基本数据类型或字符串类型则直接赋值，如果是对象类型，则需要重新new一个对象，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用构造函数克隆对象</span></span><br><span class="line">         People p2 = <span class="keyword">new</span> People(p1.getId(), p1.getName(),</span><br><span class="line">                                <span class="keyword">new</span> Address(p1.getAddress().getId(), p1.getAddress().getCity()));</span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                           <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p><strong>p1:西安 p2:北京</strong></p><p>从结果可以看出，当我们修改了原型对象的引用属性之后，并没有影响克隆对象，这说明此对象已经实现了深克隆。</p><h3 id="3-通过字节流实现深克隆"><a href="#3-通过字节流实现深克隆" class="headerlink" title="3.通过字节流实现深克隆"></a>3.通过字节流实现深克隆</h3><p>通过JDK自带的字节流实现深克隆的方式，是先将要原型对象写入到内存中的字节流，然后再从这个字节流中读出刚刚存储的信息，来作为一个新的对象返回，那么这个新对象和原型对象就不存在任何地址上的共享，这样就实现了深克隆，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">         <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过字节流实现克隆</span></span><br><span class="line">        People p2 = (People) StreamClone.clone(p1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                           <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过字节流实现克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamClone</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(People obj)</span> </span>&#123;</span><br><span class="line">            T cloneObj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 写入字节流</span></span><br><span class="line">                ByteArrayOutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bo);</span><br><span class="line">                oos.writeObject(obj);</span><br><span class="line">                oos.close();</span><br><span class="line">                <span class="comment">// 分配内存,写入原始对象,生成新对象</span></span><br><span class="line">                ByteArrayInputStream bi = <span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());<span class="comment">//获取上面的输出字节流</span></span><br><span class="line">                ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</span><br><span class="line">                <span class="comment">// 返回生成的新对象</span></span><br><span class="line">                cloneObj = (T) oi.readObject();</span><br><span class="line">                oi.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cloneObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p><strong>p1:西安 p2:北京</strong></p><p>此方式需要注意的是，由于是通过字节流序列化实现的深克隆，因此每个对象必须能被序列化，必须实现Serializable接口，标识自己可以被序列化，否则会抛出异常（java.io.NotSerializableException）。</p><h3 id="4-通过第三方工具实现深克隆"><a href="#4-通过第三方工具实现深克隆" class="headerlink" title="4.通过第三方工具实现深克隆"></a>4.通过第三方工具实现深克隆</h3><p>本课时使用 Apache Commons Lang 来实现深克隆，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.SerializationUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深克隆实现方式四：通过 apache.commons.lang 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FourthExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 apache.commons.lang 克隆对象</span></span><br><span class="line">        People p2 = (People) SerializationUtils.clone(p1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                           <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p><strong>p1:西安 p2:北京</strong></p><p>可以看出此方法和第三种实现方式类似，都需要实现 Serializable 接口，都是通过字节流的方式实现的，只不过这种实现方式是第三方提供了现成的方法，让我们可以直接调用。</p><h3 id="5-通过-JSON-工具类实现深克隆"><a href="#5-通过-JSON-工具类实现深克隆" class="headerlink" title="5.通过 JSON 工具类实现深克隆"></a>5.通过 JSON 工具类实现深克隆</h3><p>本课时我们使用 Google 提供的 JSON 转化工具 Gson 来实现，其他 JSON 转化工具类也是类似的，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深克隆实现方式五：通过 JSON 工具实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FifthExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Address address = <span class="keyword">new</span> Address(<span class="number">110</span>, <span class="string">"北京"</span>);</span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="number">1</span>, <span class="string">"Java"</span>, address);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 Gson 克隆对象</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        People p2 = gson.fromJson(gson.toJson(p1), People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改原型对象</span></span><br><span class="line">        p1.getAddress().setCity(<span class="string">"西安"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出 p1 和 p2 地址信息</span></span><br><span class="line">        System.out.println(<span class="string">"p1:"</span> + p1.getAddress().getCity() +</span><br><span class="line">                           <span class="string">" p2:"</span> + p2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Address address;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="comment">// 忽略构造方法、set、get 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><p><strong>p1:西安 p2:北京</strong></p><p>使用JSON工具类会先把对象转化成字符串，再从字符串转化成新的对象，因为新对象是从字符串转化而来的，因此不会和原型对象有任何的关联，这样就实现了深克隆，其他类似的JSON工具类实现方式也是一样的。</p><h2 id="克隆设计理念猜想"><a href="#克隆设计理念猜想" class="headerlink" title="克隆设计理念猜想"></a>克隆设计理念猜想</h2><p>对于克隆为什么要这样设计，官方没有直接给出答案，我们只能凭借一些经验和源码文档来试着回答一下这个问题。Java 中实现克隆需要两个主要的步骤，一是实现Cloneable空接口，二是重写Object 的clone0方法再调用父类的克隆方法（super.clone()），那为什么要这么做？</p><p>从源码中可以看出Cloneable 接口诞生的比较早，JDK1.0就已经存在了，因此从那个时候就已经有克隆方法了，那我们怎么来标识一个类级别对象拥有克隆方法呢？克隆虽然重要，但我们不能给每个类都默认加上克隆，这显然是不合适的，那我们能使用的手段就只有这几个了：</p><ul><li>在类上新增标识，此标识用于声明某个类拥有克隆的功能，像final关键字一样；</li><li>使用Java中的注解；</li><li>实现某个接口；</li><li>继承某个类。</li></ul><p>先说第一个，为了一个重要但不常用的克隆功能，单独新增一个类标识，这显然不合适；再说第二个，因为克隆功能出现的比较早，那时候还没有注解功能，因此也不能使用；第三点基本满足我们的需求，第四点和第一点比较类似，为了一个克隆功能需要牺牲一个基类，并且Java只能单继承，因此这个方案也不合适。采用排除法，无疑使用实现接口的方式是那时最合理的方案了，而且在Java 语言中一个类可以实现多个接口。</p><p><strong>那为什么要在Object 中添加一个clone()方法呢？</strong></p><p>因为clone()方法语义的特殊性，因此最好能有JVM的直接支持，既然要JVM直接支持，就要找一个API来把这个方法暴露出来才行，最直接的做法就是把它放入到一个所有类的基类Object中，这样所有类就可以很方便地调用到了。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-快速排序</title>
      <link href="/2020/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序法介绍"><a href="#快速排序法介绍" class="headerlink" title="快速排序法介绍:"></a>快速排序法介绍:</h2><p>快速排序（Quicksort）是对 <strong>冒泡排序</strong>的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两<br>部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排<br>序， <strong>整个排序过程可以递归进行</strong>，以此达到整个数据变成有序序列。</p><h2 id="快速排序法示意图"><a href="#快速排序法示意图" class="headerlink" title="快速排序法示意图:"></a>快速排序法示意图:</h2><p><img data-src="1.png" alt="1.png"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>定义两个指针 分别指向传进来的左右两个位置</li><li>定义中间的基准数，下面会按照这个基准数进行排序</li><li>从左侧一直往基准数的位置找，直到有一个数大于或者等于基准数停止，同样 右侧一直找到一个小于等于基准数的位置。</li><li>判断一下这两个指针指向的位置是否相等，若相等则表示 此时基准数左边 和右边 已经排序完成了</li><li>若不等，则将找到的两个位置的数进行交换</li><li>交换后判断换好的的 两个数 是否等于基准数，若左侧等于基准数 则r- - ，反之 若右侧的数等于基准数 则 l++。</li><li>至此 一轮比较结束，但要判断一下 两个指针是否相等，若相等，将两个指针分别往前移动一位。</li><li>左侧和右侧分别开始递归，左侧是 left—–r  右侧是 l—–right</li><li>排序完成</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;-<span class="number">9</span>,<span class="number">78</span>,<span class="number">0</span>,<span class="number">23</span>,-<span class="number">567</span>,<span class="number">70</span>, -<span class="number">1</span>,<span class="number">900</span>, <span class="number">4561</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line">quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"排序后"</span>);</span><br><span class="line">System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//测试快排的执行速度</span></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="comment">int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("排序前");</span></span><br><span class="line"><span class="comment">Date data1 = new Date();</span></span><br><span class="line"><span class="comment">SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");</span></span><br><span class="line"><span class="comment">String date1Str = simpleDateFormat.format(data1);</span></span><br><span class="line"><span class="comment">System.out.println("排序前的时间是=" + date1Str);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">quickSort(arr, 0, arr.length-1);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Date data2 = new Date();</span></span><br><span class="line"><span class="comment">String date2Str = simpleDateFormat.format(data2);</span></span><br><span class="line"><span class="comment">System.out.println("排序前的时间是=" + date2Str);</span></span><br><span class="line"><span class="comment">//System.out.println("arr=" + Arrays.toString(arr));*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = left; <span class="comment">//左下标</span></span><br><span class="line"><span class="keyword">int</span> r = right; <span class="comment">//右下标</span></span><br><span class="line"><span class="comment">//pivot 中轴值</span></span><br><span class="line"><span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">//临时变量，作为交换时使用</span></span><br><span class="line"><span class="comment">//while循环的目的是让比pivot 值小放到左边</span></span><br><span class="line"><span class="comment">//比pivot 值大放到右边</span></span><br><span class="line"><span class="keyword">while</span>( l &lt; r) &#123; </span><br><span class="line"><span class="comment">//在pivot的左边一直找,找到大于等于pivot值,才退出</span></span><br><span class="line"><span class="keyword">while</span>( arr[l] &lt; pivot) &#123;</span><br><span class="line">l += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在pivot的右边一直找,找到小于等于pivot值,才退出</span></span><br><span class="line"><span class="keyword">while</span>(arr[r] &gt; pivot) &#123;</span><br><span class="line">r -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果l == r说明pivot 的左右两的值，已经按照左边全部是</span></span><br><span class="line"><span class="comment">//小于等于pivot值，右边全部是大于等于pivot值</span></span><br><span class="line"><span class="keyword">if</span>( l == r) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line">temp = arr[l];</span><br><span class="line">arr[l] = arr[r];</span><br><span class="line">arr[r] = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移</span></span><br><span class="line"><span class="comment">//为了处理左侧有序，右侧还无序的情况</span></span><br><span class="line"><span class="keyword">if</span>(arr[l] == pivot) &#123;</span><br><span class="line">r -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移</span></span><br><span class="line"><span class="keyword">if</span>(arr[r] == pivot) &#123;</span><br><span class="line">l += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span></span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">l += <span class="number">1</span>;</span><br><span class="line">r -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向左递归</span></span><br><span class="line"><span class="keyword">if</span>(left &lt; r) &#123;</span><br><span class="line">quickSort(arr, left, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向右递归</span></span><br><span class="line"><span class="keyword">if</span>(right &gt; l) &#123;</span><br><span class="line">quickSort(arr, l, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8000000条数据 1 秒</p><h3 id="更简单的代码"><a href="#更简单的代码" class="headerlink" title="更简单的代码"></a>更简单的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSortDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line">quickSort(<span class="number">0</span>, arr.length-<span class="number">1</span>,arr);</span><br><span class="line">System.out.println(<span class="string">"排序后"</span>);</span><br><span class="line">System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line"><span class="keyword">int</span> temp = arr[left];</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">while</span> ( i &lt; j) &#123;</span><br><span class="line"><span class="comment">//右边依次向左递减</span></span><br><span class="line"><span class="keyword">while</span> (j&gt;i &amp;&amp; arr[j] &gt;= temp) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左边依次向右递增</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;j &amp;&amp; arr[i] &lt;= temp) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">t=arr[j];</span><br><span class="line">arr[j] = arr[i];</span><br><span class="line">arr[i] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[left] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line"></span><br><span class="line">quickSort(left, i-<span class="number">1</span>, arr);</span><br><span class="line">quickSort(j+<span class="number">1</span>, right, arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-希尔排序</title>
      <link href="/2020/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="希尔排序法介绍"><a href="#希尔排序法介绍" class="headerlink" title="希尔排序法介绍"></a>希尔排序法介绍</h2><p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种 <strong>插入排序</strong>，它是简单插入排序经过改进之后的一个 <strong>更高效的版本</strong>，也称为 <strong>缩小增量排序</strong>。</p><h2 id="希尔排序法基本思想"><a href="#希尔排序法基本思想" class="headerlink" title="希尔排序法基本思想"></a>希尔排序法基本思想</h2><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含<br>的关键词越来越多， <strong>当增量减至 1  时</strong>，整个文件恰被分成一组，算法便终止</p><h2 id="希尔排序法的示意图"><a href="#希尔排序法的示意图" class="headerlink" title="希尔排序法的示意图"></a>希尔排序法的示意图</h2><p><img data-src="1.png" alt="1.png"></p><p><img data-src="2.png" alt="2.png"></p><h2 id="交换法实现"><a href="#交换法实现" class="headerlink" title="交换法实现"></a>交换法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int arr[] = &#123;8,9,1,7,2,3,5,4,6,0&#125;;</span></span><br><span class="line"><span class="comment">//shellSort2(arr);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line">shellSort(arr); <span class="comment">//交换式</span></span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用逐步推导的方式来编写希尔排序</span></span><br><span class="line"><span class="comment">// 希尔排序时， 对有序序列在插入时采用交换法, </span></span><br><span class="line"><span class="comment">// 思路(算法) ===&gt; 代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 根据前面的逐步分析，使用循环处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="comment">// 遍历各组中所有的元素(共gap组，每组有个元素), 步长gap</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line"><span class="comment">// 如果当前这个元素大于加上这个步长后的那个元素，说明交换</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + gap];</span><br><span class="line">arr[j + gap] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// System.out.println("希尔排序第" + (++count) + "轮 =" + Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//希尔排序的第一轮排序</span></span><br><span class="line"><span class="comment">//因为第1轮排序是将10个数据分成了5组</span></span><br><span class="line"><span class="comment">int temp = 0;</span></span><br><span class="line"><span class="comment">for(int i = 5;i&lt;arr.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//遍历各组中所有的元素（共5组，每组2个元素） 步长是5</span></span><br><span class="line"><span class="comment">for(int j=i-5;j&gt;=0;j-=5)&#123;</span></span><br><span class="line"><span class="comment">//如果当前这个元素大于加上这个步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">if (arr[j]&gt;arr[j+5]) &#123;</span></span><br><span class="line"><span class="comment">temp = arr[j];</span></span><br><span class="line"><span class="comment">arr[j] = arr[j+5];</span></span><br><span class="line"><span class="comment">arr[j+5]=temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">System.out.println("希尔排序1轮后=" + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">// 希尔排序的第2轮排序</span></span><br><span class="line"><span class="comment">// 因为第2轮排序，是将10个数据分成了 5/2 = 2组</span></span><br><span class="line"><span class="comment">for (int i = 2; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line"><span class="comment">for (int j = i - 2; j &gt;= 0; j -= 2) &#123;</span></span><br><span class="line"><span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">if (arr[j] &gt; arr[j + 2]) &#123;</span></span><br><span class="line"><span class="comment">temp = arr[j];</span></span><br><span class="line"><span class="comment">arr[j] = arr[j + 2];</span></span><br><span class="line"><span class="comment">arr[j + 2] = temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("希尔排序2轮后=" + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 希尔排序的第3轮排序</span></span><br><span class="line"><span class="comment">// 因为第3轮排序，是将10个数据分成了 2/2 = 1组</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line"><span class="comment">for (int j = i - 1; j &gt;= 0; j -= 1) &#123;</span></span><br><span class="line"><span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">if (arr[j] &gt; arr[j + 1]) &#123;</span></span><br><span class="line"><span class="comment">temp = arr[j];</span></span><br><span class="line"><span class="comment">arr[j] = arr[j + 1];</span></span><br><span class="line"><span class="comment">arr[j + 1] = temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("希尔排序3轮后=" + Arrays.toString(arr));*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>80000个数据大概7秒</p><h2 id="移位法实现"><a href="#移位法实现" class="headerlink" title="移位法实现"></a>移位法实现</h2><p>先分组再插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int arr[] = &#123;8,9,1,7,2,3,5,4,6,0&#125;;</span></span><br><span class="line"><span class="comment">//shellSort2(arr);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line">shellSort2(arr);<span class="comment">// 移位方式</span></span><br><span class="line"></span><br><span class="line">Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对交换式的希尔排序进行优化-&gt;移位法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据前面的逐步分析，使用循环处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j =i;</span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[j-gap]) &#123;</span><br><span class="line"><span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line"><span class="comment">//移动</span></span><br><span class="line">arr[j] = arr[j-gap];</span><br><span class="line">j-=gap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当退出while后，就给temp找到插入的位置</span></span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// System.out.println("希尔排序后"  + Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>80000个数据不到1秒  8000000个数据  2秒</strong>    ！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-插入排序</title>
      <link href="/2020/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="插入排序法介绍"><a href="#插入排序法介绍" class="headerlink" title="插入排序法介绍:"></a>插入排序法介绍:</h2><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</p><h2 id="插入排序法思想"><a href="#插入排序法思想" class="headerlink" title="插入排序法思想:"></a>插入排序法思想:</h2><p>插入排序（Insertion Sorting）的基本思想是：把 <strong>n  个待排序的元素看成为一个有序表和一个无序表</strong>，开始时有序表中只包含一个元素，无序表中包含有 <strong>n-1  个元素</strong>，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p><h2 id="插入排序思路图"><a href="#插入排序思路图" class="headerlink" title="插入排序思路图:"></a>插入排序思路图:</h2><p><img data-src="1.png" alt="1.png"></p><h2 id="插入排序法应用实例"><a href="#插入排序法应用实例" class="headerlink" title="插入排序法应用实例:"></a>插入排序法应用实例:</h2><p>有一群小牛, 考试成绩分别是 101, 34, 119, 1 请从小到大排序</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">89</span> &#125;;</span><br><span class="line">insertSort(arr); <span class="comment">//调用插入排序算法s</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="comment">int[] arr = new int[80000];</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; 80000; i++) &#123;</span></span><br><span class="line"><span class="comment">arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("插入排序前");</span></span><br><span class="line"><span class="comment">Date data1 = new Date();</span></span><br><span class="line"><span class="comment">SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");</span></span><br><span class="line"><span class="comment">String date1Str = simpleDateFormat.format(data1);</span></span><br><span class="line"><span class="comment">System.out.println("排序前的时间是=" + date1Str);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">insertSort(arr); // 调用插入排序算法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Date data2 = new Date();</span></span><br><span class="line"><span class="comment">String date2Str = simpleDateFormat.format(data2);</span></span><br><span class="line"><span class="comment">System.out.println("排序前的时间是=" + date2Str);*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> insertVal = arr[i];</span><br><span class="line"><span class="keyword">int</span> insertIndex = i-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal&lt;arr[insertIndex]) &#123;</span><br><span class="line">arr[insertIndex+<span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">insertIndex--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line"><span class="comment">// 这里我们判断是否需要赋值</span></span><br><span class="line"><span class="keyword">if</span> (insertIndex+<span class="number">1</span> != i) &#123;</span><br><span class="line">arr[insertIndex+<span class="number">1</span>] = insertVal;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"第"</span>+i+<span class="string">"轮插入"</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 使用逐步推导的方式来讲解，便利理解</span></span><br><span class="line"><span class="comment">// 第1轮 &#123;101, 34, 119, 1&#125;; =&gt; &#123;34, 101, 119, 1&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// &#123;101, 34, 119, 1&#125;; =&gt; &#123;101,101,119,1&#125;</span></span><br><span class="line"><span class="comment">// 定义待插入的数</span></span><br><span class="line"><span class="comment">int insertVal = arr[1];</span></span><br><span class="line"><span class="comment">int insertIndex = 1 - 1; // 即arr[1]的前面这个数的下标</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line"><span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line"><span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line"><span class="comment">while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex]</span></span><br><span class="line"><span class="comment">insertIndex--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line"><span class="comment">// 举例：理解不了，我们一会 debug</span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第1轮插入");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">// 第2轮</span></span><br><span class="line"><span class="comment">insertVal = arr[2];</span></span><br><span class="line"><span class="comment">insertIndex = 2 - 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex]</span></span><br><span class="line"><span class="comment">insertIndex--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment">System.out.println("第2轮插入");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 第3轮</span></span><br><span class="line"><span class="comment">insertVal = arr[3];</span></span><br><span class="line"><span class="comment">insertIndex = 3 - 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex]</span></span><br><span class="line"><span class="comment">insertIndex--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment">System.out.println("第3轮插入");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>80000条数据用时两秒</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】的集成</title>
      <link href="/2020/03/31/MyBatis%E7%9A%84%E9%9B%86%E6%88%90/"/>
      <url>/2020/03/31/MyBatis%E7%9A%84%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="基本准备"><a href="#基本准备" class="headerlink" title="基本准备"></a>基本准备</h2><h3 id="创建Dynamic-Web-Project"><a href="#创建Dynamic-Web-Project" class="headerlink" title="创建Dynamic Web Project"></a>创建Dynamic Web Project</h3><h3 id="引入相关jar包"><a href="#引入相关jar包" class="headerlink" title="引入相关jar包"></a>引入相关jar包</h3><ul><li>Spring框架相关jar包</li><li>MyBatis连接Spring相关jar包</li><li>连接MySQL驱动包</li><li>JSTL标签库包</li></ul><p><img data-src="1.png" alt="1.png"></p><h3 id="添加db-properties文件，该属性文件配置连接数据库相关信息"><a href="#添加db-properties文件，该属性文件配置连接数据库相关信息" class="headerlink" title="添加db.properties文件，该属性文件配置连接数据库相关信息"></a>添加db.properties文件，该属性文件配置连接数据库相关信息</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatisdemo_db?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><h3 id="添加Spring配置文件，在src中新增applicationContext-xml，并引入该属性文件"><a href="#添加Spring配置文件，在src中新增applicationContext-xml，并引入该属性文件" class="headerlink" title="添加Spring配置文件，在src中新增applicationContext.xml，并引入该属性文件"></a>添加Spring配置文件，在src中新增applicationContext.xml，并引入该属性文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入数据库连接信息的属性文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在Spring配置文件中添加DataSource的配置，PooledDataSource为MyBatis实现的数据库连接池"><a href="#在Spring配置文件中添加DataSource的配置，PooledDataSource为MyBatis实现的数据库连接池" class="headerlink" title="在Spring配置文件中添加DataSource的配置，PooledDataSource为MyBatis实现的数据库连接池"></a>在Spring配置文件中添加DataSource的配置，PooledDataSource为MyBatis实现的数据库连接池</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.ibatis.datasource.pooled.PooledDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;user&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在Spring配置文件中添加SqlSessionFactoryBean，用来创建SqlSessionFactory对象"><a href="#在Spring配置文件中添加SqlSessionFactoryBean，用来创建SqlSessionFactory对象" class="headerlink" title="在Spring配置文件中添加SqlSessionFactoryBean，用来创建SqlSessionFactory对象"></a>在Spring配置文件中添加SqlSessionFactoryBean，用来创建SqlSessionFactory对象</h3><ul><li>configLocation：用于指定MyBatis的mybatis.xml配置文件的路径</li><li>dataSource：用于配置数据源，该属性为必选项，可以直接引用已经配置好的dataSource数据库连接池</li><li>mapperLocations：扫描XML映射文件的路径</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载mybatis配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载mapper.xml路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:top/hiasenna/mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在Spring配置文件中添加MapperScannerConfigurer，自动扫描所有的Mapper接口"><a href="#在Spring配置文件中添加MapperScannerConfigurer，自动扫描所有的Mapper接口" class="headerlink" title="在Spring配置文件中添加MapperScannerConfigurer，自动扫描所有的Mapper接口"></a>在Spring配置文件中添加MapperScannerConfigurer，自动扫描所有的Mapper接口</h3><ul><li>basePackage：用于配置基本的包路径</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"top.hiasenna.mapper"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring公共配置 <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Spring上下文的注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用annotation 自动注册bean, 并保证@Required、@Autowired的属性被注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span></span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 属性文件位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span></span></span><br><span class="line"><span class="tag"><span class="attr">location</span>=<span class="string">"classpath:*.properties"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载mybatis配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载mapper.xml路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:top/hiasenna/mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"top.hiasenna.mapper"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="spring-mvc-xml"><a href="#spring-mvc-xml" class="headerlink" title="spring-mvc.xml"></a>spring-mvc.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span></span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将无法mapping到Controller的path交给default servlet handler处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/static/"</span> <span class="attr">mapping</span>=<span class="string">"/static/**"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义JSP文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用annotation定义事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span></span></span><br><span class="line"><span class="tag"><span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>mybatis_spring<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="mybatis-xml"><a href="#mybatis-xml" class="headerlink" title="mybatis.xml"></a>mybatis.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打印SQL语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="dbinfo-properties"><a href="#dbinfo-properties" class="headerlink" title="dbinfo.properties"></a>dbinfo.properties</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql</span></span><br><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatisdemo_db?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈你对锁的理解？如何手动模拟一个死锁？</title>
      <link href="/2020/03/30/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81/"/>
      <url>/2020/03/30/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>在并发编程中有两个重要的概念：<strong>线程和锁</strong>，多线程是一把双刃剑，它在提高程序性能的同时，也带来了编码的复杂性，对开发者的要求也提高了一个档次。而锁的出现就是为了保障多线程在同时操作一组资源时的数据一致性，当我们给资源加上锁之后，只有拥有此锁的线程才能操作此资源，而其他线程只能排队等待使用此锁。当然，在所有的面试中也都少不了关于“锁”方面的相关问题。</p><p>我们本课时的面试题是，如何手动模拟一个死锁？谈谈你对锁的理解？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>死锁是指两个线程同时占用两个资源，又在彼此等待对方释放锁资源，如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p>死锁的代码演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        deadLock(); <span class="comment">// 死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 线程一拥有 lock1 试图获取 lock2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"获取 lock1 成功"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 试图获取锁 lock2</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        <span class="comment">// 线程二拥有 lock2 试图获取 lock1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"获取 lock2 成功"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 试图获取锁 lock1</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取 lock1 成功</span><br><span class="line">获取 lock2 成功</span><br></pre></td></tr></table></figure><p>可以看出当我们使用线程一拥有锁 lock1的同时试图获取lock2，而线程二在拥有lock2的同时试图获取lock1，这样就会造成彼此都在等待对方释放资源，于是就形成了<strong>死锁</strong>。</p><p>锁是指在并发编程中，当有多个线程同时操作一个资源时，为了保证数据操作的正确性，我们需要让多线程排队一个一个的操作此资源，而这个过程就是给资源加锁和释放锁的过程，就好像去公共厕所一样，必须一个一个排队使用，并且在使用时需要锁门和开门一样。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>锁的概念不止出现在Java语言中，比如乐观锁和悲观锁其实很早就存在于数据库中了。锁的概念其实不难理解，但要真正的了解锁的原理和实现过程，才能打动面试官。</p><p>和锁相关的面试问题，还有以下几个：</p><ul><li>什么是乐观锁和悲观锁？它们的应用都有哪些？乐观锁有什么问题？</li><li>什么是可重入锁？用代码如何实现？它的实现原理是什么？</li><li>什么是共享锁和独占锁？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-悲观锁和乐观锁"><a href="#1-悲观锁和乐观锁" class="headerlink" title="1.悲观锁和乐观锁"></a>1.悲观锁和乐观锁</h3><p>悲观锁指的是数据对外界的修改采取保守策略，它认为线程很容易会把数据修改掉，因此在整个数据被修改的过程中都会采取锁定状态，直到一个线程使用完，其他线程才可以继续使用。</p><p>我们来看一下悲观锁的实现流程，以synchronized为例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (LockExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"lock"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用反编译工具查到的结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"LockExample.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">lagou</span>.<span class="title">interview</span>.<span class="title">ext</span>.<span class="title">LockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> com.lagou.interview.ext.LockExample();</span><br><span class="line">    Code:</span><br><span class="line">    <span class="number">0</span>: aload_0</span><br><span class="line">        1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">    0: ldc           #2                  // class com/lagou/interview/ext/LockExample</span><br><span class="line">        <span class="number">2</span>: dup</span><br><span class="line">        <span class="number">3</span>: astore_1</span><br><span class="line">        <span class="number">4</span>: monitorenter <span class="comment">// 加锁</span></span><br><span class="line">        5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        8: ldc           #4                  // String lock</span><br><span class="line">        10:invokevirtual#5//Methodjava/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="number">14</span>: monitorexit <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">        <span class="number">18</span>: astore_2</span><br><span class="line">        <span class="number">19</span>: aload_1</span><br><span class="line">        <span class="number">20</span>: monitorexit</span><br><span class="line">        <span class="number">21</span>: aload_2</span><br><span class="line">        <span class="number">22</span>: athrow</span><br><span class="line">        <span class="number">23</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">          from    to  target type</span><br><span class="line">           <span class="number">5</span>    <span class="number">15</span>    <span class="number">18</span>   any</span><br><span class="line">          <span class="number">18</span>    <span class="number">21</span>    <span class="number">18</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出被synchronized 修饰的代码块，在执行之前先使用monitorenter 指令加锁，然后在执行结束之后再使用monitorexit 指令释放锁资源，在整个执行期间此代码都是锁定的状态，这就是<strong>典型悲观锁的实现流程</strong>。</p><p>乐观锁和悲观锁的概念恰好相反，乐观锁认为一般情况下数据在修改时不会出现冲突，所以在数据访问之前不会加锁，只是在数据提交更改时，才会对数据进行检测。</p><p>Java 中的乐观锁大部分都是通过CAS（Compare And Swap，比较并交换）操作实现的，CAS是一个多线程同步的原子指令，CAS操作包含三个重要的信息，即内存位置、预期原值和新值。如果内存位置的值和预期的原值相等的话，那么就可以把该位置的值更新为新值，否则不做任何修改，我们在第05课时讲解 ReentrantLock时知道了它也是通过CAS实现的。Lock是乐观锁的典型实现案例。</p><p>CAS可能会造成ABA的问题，ABA问题指的是，线程拿到了最初的预期原值A，然而在将要进行<br>CAS的时候，被其他线程抢占了执行权，把此值从A变成了B，然后其他线程又把此值从B变成了A，然而此时的A值已经并非原来的A值了，但最初的线程并不知道这个情况，在它进行CAS的时候，只对比了预期原值为A就进行了修改，这就造成了ABA的问题。</p><p>以警匪剧为例，假如某人把装了100W现金的箱子放在了家里，几分钟之后要拿它去赎人，然而在趁他不注意的时候，进来了一个小偷，用空箱子换走了装满钱的箱子，当某人进来之后看到箱子还是一模一样的，他会以为这就是原来的箱子，就拿着它去赎人了，这种情况肯定有问题，因为箱子已经是空的了，这就是ABA的问题。</p><p>ABA的常见处理方式是添加版本号，每次修改之后更新版本号，拿上面的例子来说，假如每次移动箱子之后，箱子的位置就会发生变化，而这个变化的位置就相当于“版本号”，当某人进来之后发现箱子的位置发生了变化就知道有人动了手脚，就会放弃原有的计划，这样就解决了ABA的问题。</p><p>JDK在1.5时提供了AtomicStampedReference 类也可以解决ABA的问题，此类维护了一个“版本号”Stamp，每次在比较时不止比较当前值还比较版本号，这样就解决了ABA的问题。<br>相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp; <span class="comment">// “版本号”</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较并设置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp, // 原版本号</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123; <span class="comment">// 新版本号</span></span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//.......省略其他源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出它在修改时会进行原值比较和版本号比较，当比较成功之后会修改值并修改版本号。</p><p><strong>小贴士</strong>：乐观锁有一个优点，它在提交的时候才进行锁定的，因此不会造成死锁。</p><h3 id="2-可重入锁"><a href="#2-可重入锁" class="headerlink" title="2.可重入锁"></a>2.可重入锁</h3><p>可重入锁也叫递归锁，指的是同一个线程，如果外面的函数拥有此锁之后，内层的函数也可以继续获取该锁。在Java 语言中ReentrantLock和synchronized都是可重入锁。</p><p>下面我们用synchronized来演示一下什么是可重入锁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        reentrantA(); <span class="comment">// 可重入锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重入锁 A 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reentrantA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"：执行 reentrantA"</span>);</span><br><span class="line">        reentrantB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重入锁 B 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reentrantB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"：执行 reentrantB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的执行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main：执行 reentrantA</span><br><span class="line">main：执行 reentrantB</span><br></pre></td></tr></table></figure><p>从结果可以看出reentrantA 方法和reentrantB方法的执行线程都是“main”，我们调用了reentrantA方法，它的方法中嵌套了reentrantB，如果synchronized是不可重入的话，那么线程会被一直堵塞。</p><p>可重入锁的实现原理，是在锁内部存储了一个线程标识，用于判断当前的锁属于哪个线程，并且锁的内部维护了一个计数器，当锁空闲时此计数器的值为0，当被线程占用和重入时分别加1，当锁被释放时计数器减1，直到减到0时表示此锁为空闲状态。</p><h3 id="3-共享锁和独占锁"><a href="#3-共享锁和独占锁" class="headerlink" title="3.共享锁和独占锁"></a>3.共享锁和独占锁</h3><p>只能被单线程持有的锁叫<strong>独占锁</strong>，可以被多线程持有的锁叫<strong>共享锁</strong>。</p><p>独占锁指的是在任何时候最多只能有一个线程持有该锁，比如 ReentrantLock 就是独占锁，而<br>ReadWriteLock 读写锁允许同一时间内有多个线程进行读操作，它就属于共享锁。</p><p>独占锁可以理解为悲观锁，当每次访问资源时都要加上互斥锁，而共享锁可以理解为乐观锁，它放宽了加锁的条件，允许多线程同时访问该资源。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本课时我们讲了悲观锁和乐观锁，其中悲观锁的典型应用为synchronized，而ReentrantLock为乐观锁的典型应用，乐观锁可能会导致ABA的问题，常见的解决方案是添加版本号来防止ABA问题的发生；同时，还讲了可重入锁，在Java中，synchronized和ReentrantLock 都是可重入锁；最后讲了独占锁和共享锁，其中独占锁可以理解为悲观锁，而共享锁可以理解为乐观锁。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-选择排序</title>
      <link href="/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到<br>排序的目的。</p><h2 id="选择排序思想"><a href="#选择排序思想" class="headerlink" title="选择排序思想:"></a>选择排序思想:</h2><p>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0]<del>arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]</del>arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]<del>arr[n-1]中选取最小值，与 arr[2]交换，…，第 i 次从 arr[i-1]</del>arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p><h2 id="选择排序思路分析图"><a href="#选择排序思路分析图" class="headerlink" title="选择排序思路分析图:"></a>选择排序思路分析图:</h2><p><img data-src="1.png" alt="1.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> [] arr = &#123;<span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">90</span>, <span class="number">123</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">selectSort(arr);</span><br><span class="line">System.out.println(<span class="string">"排序后"</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="comment">//int[] arr = new int[80000];</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; 80000; i++) &#123;</span></span><br><span class="line"><span class="comment">//arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//System.out.println("排序前");</span></span><br><span class="line"><span class="comment">//// System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Date data1 = new Date();</span></span><br><span class="line"><span class="comment">//SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");</span></span><br><span class="line"><span class="comment">//String date1Str = simpleDateFormat.format(data1);</span></span><br><span class="line"><span class="comment">//System.out.println("排序前的时间是=" + date1Str);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//selectSort(arr);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Date data2 = new Date();</span></span><br><span class="line"><span class="comment">//String date2Str = simpleDateFormat.format(data2);</span></span><br><span class="line"><span class="comment">//System.out.println("排序前的时间是=" + date2Str);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">//选择排序时间复杂度是 O(n^2)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> minIndex = i;</span><br><span class="line"><span class="keyword">int</span> min = arr[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (min&gt;arr[j]) &#123;</span><br><span class="line">min=arr[j];</span><br><span class="line">minIndex=j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line"><span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">arr[minIndex] = arr[i];</span><br><span class="line">arr[i]=min;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"轮后~~"</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));<span class="comment">// 1, 34, 119, 101</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//使用逐步推导的方式来，讲解选择排序</span></span><br><span class="line"><span class="comment">//第1轮</span></span><br><span class="line"><span class="comment">//原始的数组 ： 101, 34, 119, 1</span></span><br><span class="line"><span class="comment">//第一轮排序 :   1, 34, 119, 101</span></span><br><span class="line"><span class="comment">//算法 先简单--》 做复杂， 就是可以把一个复杂的算法，拆分成简单的问题-》逐步解决</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第1轮</span></span><br><span class="line"><span class="comment">int minIndex = 0;</span></span><br><span class="line"><span class="comment">int min = arr[0];</span></span><br><span class="line"><span class="comment">for(int j = 0 + 1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">if (min &gt; arr[j]) &#123; //说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">min = arr[j]; //重置min</span></span><br><span class="line"><span class="comment">minIndex = j; //重置minIndex</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//将最小值，放在arr[0], 即交换</span></span><br><span class="line"><span class="comment">if(minIndex != 0) &#123;</span></span><br><span class="line"><span class="comment">arr[minIndex] = arr[0];</span></span><br><span class="line"><span class="comment">arr[0] = min;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第1轮后~~");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));// 1, 34, 119, 101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第2轮</span></span><br><span class="line"><span class="comment">minIndex = 1;</span></span><br><span class="line"><span class="comment">min = arr[1];</span></span><br><span class="line"><span class="comment">for (int j = 1 + 1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">min = arr[j]; // 重置min</span></span><br><span class="line"><span class="comment">minIndex = j; // 重置minIndex</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line"><span class="comment">if(minIndex != 1) &#123;</span></span><br><span class="line"><span class="comment">arr[minIndex] = arr[1];</span></span><br><span class="line"><span class="comment">arr[1] = min;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第2轮后~~");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));// 1, 34, 119, 101</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//第3轮</span></span><br><span class="line"><span class="comment">minIndex = 2;</span></span><br><span class="line"><span class="comment">min = arr[2];</span></span><br><span class="line"><span class="comment">for (int j = 2 + 1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">min = arr[j]; // 重置min</span></span><br><span class="line"><span class="comment">minIndex = j; // 重置minIndex</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line"><span class="comment">if (minIndex != 2) &#123;</span></span><br><span class="line"><span class="comment">arr[minIndex] = arr[2];</span></span><br><span class="line"><span class="comment">arr[2] = min;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("第3轮后~~");</span></span><br><span class="line"><span class="comment">System.out.println(Arrays.toString(arr));// 1, 34, 101, 119 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>80000条数据大概需要<strong>2</strong>秒钟</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-冒泡排序</title>
      <link href="/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）, 依<strong>次比较</strong><br><strong>相邻元素的值，若发现逆序则交换</strong>，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p><p><strong>优化：</strong></p><p>因为排序的过程中，各元素不断接近自己的位置， <strong>如果一趟比较下来没有进行过交换 ， 就说明序列有序</strong>，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行)</p><h2 id="演示冒泡过程的例子-图解"><a href="#演示冒泡过程的例子-图解" class="headerlink" title="演示冒泡过程的例子(图解)"></a>演示冒泡过程的例子(图解)</h2><p><img data-src="1.png" alt="1.png"></p><p>小结上面的图解过程:</p><ol><li>一共进行 数组的大小-1 次 大的循环</li><li>每一趟排序的次数在逐渐的减少</li><li>如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"> System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line"> System.out.println(Arrays.toString(arr));</span><br><span class="line"> bubbleSort(arr);</span><br><span class="line"> System.out.println(<span class="string">"趟排序后的数组"</span>);</span><br><span class="line"> System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">// 测试一下冒泡排序的速度O(n^2), 给80000个数据，测试</span></span><br><span class="line"><span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line"><span class="comment">//int[] arr = new int[80000];</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; 80000; i++) &#123;</span></span><br><span class="line"><span class="comment">//arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Date data1 = new Date();</span></span><br><span class="line"><span class="comment">//SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");</span></span><br><span class="line"><span class="comment">//String date1Str = simpleDateFormat.format(data1);</span></span><br><span class="line"><span class="comment">//System.out.println("排序前的时间是=" + date1Str);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// 测试冒泡排序</span></span><br><span class="line"><span class="comment">//bubbleSort(arr);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Date data2 = new Date();</span></span><br><span class="line"><span class="comment">//String date2Str = simpleDateFormat.format(data2);</span></span><br><span class="line"><span class="comment">//System.out.println("排序后的时间是=" + date2Str);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">// 交换用</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line"><span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123; <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">flag = <span class="keyword">false</span>; <span class="comment">// 重置flag!!!, 进行下次判断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// System.out.println("第" + (i + 1) + "趟排序后的数组");</span></span><br><span class="line"><span class="comment">// System.out.println(Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>80000条数据大概需要<strong>10</strong>秒钟</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-排序算法介绍</title>
      <link href="/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法的介绍"><a href="#排序算法的介绍" class="headerlink" title="排序算法的介绍"></a>排序算法的介绍</h2><p>排序也称排序算法(SortAlgorithm)，排序是将 一组数据，依 指定的顺序进行 排列的过程。</p><h2 id="相关术语解释："><a href="#相关术语解释：" class="headerlink" title="相关术语解释："></a>相关术语解释：</h2><ol><li>稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</li><li>不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 不占用额外内存</li><li>Out-place: 占用额外内存</li></ol><h2 id="排序的分类："><a href="#排序的分类：" class="headerlink" title="排序的分类："></a>排序的分类：</h2><ol><li>内部排序:<br>指将需要处理的所有数据都加载到 内部存储器( 内存)中进行排序。</li><li>外部排序法：<br>数据量过大，无法全部加载到内存中，需要借助 外部存储( 文件等)进行排序。</li><li>常见的排序算法分类</li></ol><p><img data-src="1.png" alt="1.png"></p><h2 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h2><h3 id="度量一个程序-算法-执行时间的两种方法"><a href="#度量一个程序-算法-执行时间的两种方法" class="headerlink" title="度量一个程序(算法)执行时间的两种方法"></a>度量一个程序(算法)执行时间的两种方法</h3><h4 id="事后统计的方法"><a href="#事后统计的方法" class="headerlink" title="事后统计的方法"></a>事后统计的方法</h4><p>这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所<br>得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</p><h4 id="事前估算的方法"><a href="#事前估算的方法" class="headerlink" title="事前估算的方法"></a>事前估算的方法</h4><p>通过分析某个算法的 时间复杂度来判断哪个算法更优.</p><h3 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间<br>就多。 <strong>一个算法中的语句执行次数称为语句频度或时间频度</strong>。记为 T(n)</p><h4 id="举例说明-基本案例"><a href="#举例说明-基本案例" class="headerlink" title="举例说明-基本案例"></a>举例说明-基本案例</h4><p>比如计算 1-100 所有数字之和, 我们设计两种算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//使用for循环计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=end;i++)&#123;</span><br><span class="line">    total+=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T(n)=n+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//直接计算</span></span><br><span class="line">total = (<span class="number">1</span>+end)*end/<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">T(n)=<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="举例说明-忽略常数项"><a href="#举例说明-忽略常数项" class="headerlink" title="举例说明-忽略常数项"></a>举例说明-忽略常数项</h4><p><img data-src="2.png" alt="2.png"></p><p>结论: </p><ol><li>2n+20 和 2n 随着 n 变大，执行曲线无限接近, 20 可以忽略</li><li>3n+10 和 3n 随着 n 变大，执行曲线无限接近, 10 可以忽略</li></ol><h4 id="举例说明-忽略低次项"><a href="#举例说明-忽略低次项" class="headerlink" title="举例说明-忽略低次项"></a>举例说明-忽略低次项</h4><p><img data-src="3.png" alt="3.png"></p><p>结论:</p><ol><li>2n^2+3n+10 和 2n^2 随着 n 变大, 执行曲线无限接近, 可以忽略 3n+10</li><li>n^2+5n+20 和 n^2 随着 n 变大,执行曲线无限接近, 可以忽略 5n+20</li></ol><h4 id="举例说明-忽略系数"><a href="#举例说明-忽略系数" class="headerlink" title="举例说明-忽略系数"></a>举例说明-忽略系数</h4><p><img data-src="4.png" alt="4.png"></p><p>结论:</p><ol><li>随着 n 值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明 这种情况下, 5 和 3 可以忽略。</li><li>而 n^3+5n 和 6n^3+4n ，执行曲线分离，说明多少次方式关键</li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol><li>一般情况下， <strong>算法中的基本操作语句的重复执行次数是问题规模 n  的某个函数</strong>，用 T(n)表示，若有某个辅<br>助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。记作 <strong>T(n)= Ｏ( f(n) )</strong>，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。</li><li>T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同，但时间复杂<br>度相同，都为 <strong>O(n² ²)</strong>。</li><li>计算时间复杂度的方法：<ul><li>用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1</li><li>修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n²</li><li>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li></ul></li></ol><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><ol><li>常数阶 O(1)</li><li>对数阶 O(log2n)</li><li>线性阶 O(n)</li><li>线性对数阶 O(nlog2n)</li><li>平方阶 O(n^2)</li><li>立方阶 O(n^3) </li><li>k 次方阶 O(n^k)</li><li>指数阶 O(2^n)</li></ol><p><img data-src="5.png" alt="5.png"></p><p><strong>说明：</strong></p><ol><li>常见的算法时间复杂度由小到大依次为：<strong>Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n^2)＜Ο(n^3)＜ Ο(n^k) ＜</strong> <strong>Ο(2^n)</strong> ，随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低</li><li>从图中可见，我们应该尽可能避免使用指数阶的算法</li></ol><h2 id="算法的空间复杂度简介"><a href="#算法的空间复杂度简介" class="headerlink" title="算法的空间复杂度简介"></a>算法的空间复杂度简介</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。</li><li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如快速排序和 归并排序算法,  基数排序就属于这种情况。</li><li>在做算法分析时，主要讨论的是时间复杂度。 从用户使用体验上看 ， 更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)</li></ol><h2 id="八种排序算法的时间复杂度"><a href="#八种排序算法的时间复杂度" class="headerlink" title="八种排序算法的时间复杂度"></a>八种排序算法的时间复杂度</h2><h3 id="1、稳定性"><a href="#1、稳定性" class="headerlink" title="1、稳定性"></a>1、稳定性</h3><p>归并排序、冒泡排序、插入排序。基数排序是稳定的</p><p>选择排序、快速排序、希尔排序、堆排序是不稳定的</p><h3 id="2、时间复杂度"><a href="#2、时间复杂度" class="headerlink" title="2、时间复杂度"></a>2、时间复杂度</h3><p>最基础的四个算法：冒泡、选择、插入、快排中，快排的时间复杂度最小O(n*log2n)，其他都是O（n2）</p><table><thead><tr><th>排序法</th><th>平均时间</th><th>最差情形</th><th>稳定度</th><th>额外空间</th><th>备注</th></tr></thead><tbody><tr><td>冒泡</td><td>O(n2)</td><td>O(n2)</td><td>稳定</td><td>O(1)</td><td>n小时较好</td></tr><tr><td>交换</td><td>O(n2)</td><td>O(n2)</td><td>不稳定</td><td>O(1)</td><td>n小时较好</td></tr><tr><td>选择</td><td>O(n2)</td><td>O(n2)</td><td>不稳定</td><td>O(1)</td><td>n小时较好</td></tr><tr><td>插入</td><td>O(n2)</td><td>O(n2)</td><td>稳定</td><td>O(1)</td><td>大部分已排序时较好</td></tr><tr><td>基数</td><td>O(logRB)</td><td>O(logRB)</td><td>稳定</td><td>O(n)</td><td>B是真数(0-9)，R是基数(个十百)</td></tr><tr><td>Shell</td><td>O(nlogn)</td><td>O(ns) 1&lt;s&lt;2</td><td>不稳定</td><td>O(1)</td><td>s是所选分组</td></tr><tr><td>快速</td><td>O(nlogn)</td><td>O(n2)</td><td>不稳定</td><td>O(nlogn)</td><td>n大时较好</td></tr><tr><td>归并</td><td>O(nlogn)</td><td>O(nlogn)</td><td>稳定</td><td>O(1)</td><td>n大时较好</td></tr><tr><td>堆</td><td>O(nlogn)</td><td>O(nlogn)</td><td>不稳定</td><td>O(1)</td><td>n大时较好</td></tr></tbody></table><h3 id="3-排序算法的思想："><a href="#3-排序算法的思想：" class="headerlink" title="3.排序算法的思想："></a>3.排序算法的思想：</h3><h4 id="1-冒泡排序："><a href="#1-冒泡排序：" class="headerlink" title="(1)冒泡排序："></a>(1)冒泡排序：</h4><p>是相邻元素之间的比较和交换，两重循环O(n2)；所以，如果两个相邻元素相等，是不会交换的。所以它是一种稳定的排序方法</p><h4 id="2-选择排序："><a href="#2-选择排序：" class="headerlink" title="(2)选择排序："></a>(2)选择排序：</h4><p>每个元素都与第一个元素相比，产生交换，两重循环O(n2)；举个栗子，5 8 5 2 9，第一遍之后，2会与5交换，那么原序列中两个5的顺序就被破坏了。所以不是稳定的排序算法</p><h4 id="3-插入排序："><a href="#3-插入排序：" class="headerlink" title="(3)插入排序："></a>(3)插入排序：</h4><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。刚开始这个小序列只包含第一个元素，事件复杂度O(n2)。比较是从这个小序列的末尾开始的。想要插入的元素和小序列的最大者开始比起，如果比它大则直接插在其后面，否则一直往前找它该插入的位置。如果遇见了一个和插入元素相等的，则把插入元素放在这个相等元素的后面。所以相等元素间的顺序没有改变，是稳定的。</p><h4 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="(4)快速排序"></a>(4)快速排序</h4><p>​    快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j]交换的时刻。</p><h4 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="(5)归并排序"></a>(5)归并排序</h4><p>​    归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p><h4 id="6-基数排序"><a href="#6-基数排序" class="headerlink" title="(6)基数排序"></a>(6)基数排序</h4><p>   基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。</p><h4 id="7-希尔排序-shell"><a href="#7-希尔排序-shell" class="headerlink" title="(7)希尔排序(shell)"></a>(7)希尔排序(shell)</h4><p>​    希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p><h4 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="(8)堆排序"></a>(8)堆排序</h4><p>   我们知道堆的结构是节点i的孩子为2<em>i和2</em>i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n/2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-八皇后问题</title>
      <link href="/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="八皇后问题算法思路分析"><a href="#八皇后问题算法思路分析" class="headerlink" title="八皇后问题算法思路分析"></a>八皇后问题算法思路分析</h2><ol><li>第一个皇后先放第一行第一列</li><li>第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都<br>放完，找到一个合适</li><li>继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确<br>解</li><li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</li><li>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤</li></ol><p>说明：<br>理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] =<br>{0 , 4, 7, 5, 2, 6, 1, 3} //对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第 i+1 个皇后，放在第 i+1<br>行的第 val+1 列</p><p>示意图：</p><p><img data-src="1.png" alt="1.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个max表示共有多少个皇后</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组array, 保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125;</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> judgeCount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试一把 ， 8皇后是否正确</span></span><br><span class="line">Queen8 Queen8 = <span class="keyword">new</span> Queen8();</span><br><span class="line">Queen8.check(<span class="number">0</span>);</span><br><span class="line">System.out.printf(<span class="string">"一共有%d解法"</span>, count);</span><br><span class="line">System.out.printf(<span class="string">"一共判断冲突的次数%d次"</span>, judgeCount); <span class="comment">// 1.5w</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个方法，放置第n个皇后</span></span><br><span class="line"><span class="comment">// 特别注意： check 是 每一次递归时，进入到check中都有 for(int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == max) &#123; <span class="comment">// n = 8 , 其实8个皇后就既然放好</span></span><br><span class="line">print();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次放入皇后，并判断是否冲突</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line"><span class="comment">// 先把当前这个皇后 n , 放到该行的第1列</span></span><br><span class="line">array[n] = i;</span><br><span class="line"><span class="comment">// 判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line"><span class="keyword">if</span> (judge(n)) &#123; <span class="comment">// 不冲突</span></span><br><span class="line"><span class="comment">// 接着放n+1个皇后,即开始递归</span></span><br><span class="line">check(n + <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> *            表示第n个皇后</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">judgeCount++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. array[i] == array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列</span></span><br><span class="line"><span class="comment">// 2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线 </span></span><br><span class="line"><span class="comment">// n = 1 放置第 2列 1 n = 1 array[1] = 1</span></span><br><span class="line"><span class="comment">// Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1</span></span><br><span class="line"><span class="comment">// 3. 判断是否在同一行, 没有必要，n 每次都在递增</span></span><br><span class="line"><span class="keyword">if</span> (array[i] == array[n] || Math.abs(n-i)==Math.abs(array[n]-array[i])) &#123;<span class="comment">//横坐标差值==纵坐标差值</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">System.out.print(array[i] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-迷宫递归</title>
      <link href="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%B7%E5%AE%AB%E9%80%92%E5%BD%92/"/>
      <url>/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%BF%B7%E5%AE%AB%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先创建一个二维数组 模拟一个迷宫</span></span><br><span class="line"><span class="comment">// 地图</span></span><br><span class="line"><span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line"><span class="comment">// 使用1 表示墙</span></span><br><span class="line"><span class="comment">// 上下全部置为1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左右全部置为1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置挡板, 1 表示</span></span><br><span class="line">map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 输出地图</span></span><br><span class="line">System.out.println(<span class="string">"地图的情况"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">System.out.print(map[i][j] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用递归回溯给小球找路</span></span><br><span class="line">setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//setWay2(map, 1, 1);</span></span><br><span class="line"><span class="comment">// 输出新的地图, 小球走过，并标识过的递归</span></span><br><span class="line">System.out.println(<span class="string">"小球走过，并标识过的 地图的情况"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">System.out.print(map[i][j] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用递归回溯来给小球找路</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. map 表示地图</span></span><br><span class="line"><span class="comment">// 2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line"><span class="comment">// 3. 如果小球能到 map[6][5] 位置，则说明通路找到.</span></span><br><span class="line"><span class="comment">// 4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通</span></span><br><span class="line"><span class="comment">// 5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment"> *            表示地图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> *            从哪个位置开始找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到通路，就返回true, 否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;<span class="comment">// 如果当前这个点还没有走过</span></span><br><span class="line"><span class="comment">// 按照策略 下-&gt;右-&gt;上-&gt;左 走</span></span><br><span class="line">map[i][j] = <span class="number">2</span>;<span class="comment">// 假定该点可以走通</span></span><br><span class="line"><span class="keyword">if</span> (setWay(map, i + <span class="number">1</span>, j)) &#123;<span class="comment">// 向下走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j + <span class="number">1</span>)) &#123;<span class="comment">// 向右走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i - <span class="number">1</span>, j)) &#123;<span class="comment">// 上</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j - <span class="number">1</span>)) &#123; <span class="comment">// 向左走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 说明该点是走不通，是死路</span></span><br><span class="line">map[i][j] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改找路的策略，改成 上-&gt;右-&gt;下-&gt;左</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay2</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123; <span class="comment">// 通路已经找到ok</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123; <span class="comment">// 如果当前这个点还没有走过</span></span><br><span class="line"><span class="comment">// 按照策略 上-&gt;右-&gt;下-&gt;左</span></span><br><span class="line">map[i][j] = <span class="number">2</span>; <span class="comment">// 假定该点是可以走通.</span></span><br><span class="line"><span class="keyword">if</span> (setWay2(map, i - <span class="number">1</span>, j)) &#123;<span class="comment">// 向上走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j + <span class="number">1</span>)) &#123; <span class="comment">// 向右走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i + <span class="number">1</span>, j)) &#123; <span class="comment">// 向下</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j - <span class="number">1</span>)) &#123; <span class="comment">// 向左走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 说明该点是走不通，是死路</span></span><br><span class="line">map[i][j] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img data-src="1.png" alt="1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-逆波兰计算器</title>
      <link href="/2020/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2020/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img data-src="1.png" alt="1.png"></p><h2 id="代码实现-只是整数"><a href="#代码实现-只是整数" class="headerlink" title="代码实现(只是整数)"></a>代码实现(只是整数)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成将一个中缀表达式转成后缀表达式的功能</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. 1+((2+3)×4)-5 =&gt; 转成 1 2 3 + 4 × + 5 –</span></span><br><span class="line"><span class="comment">// 2. 因为直接对str 进行操作，不方便，因此 先将 "1+((2+3)×4)-5" =》 中缀的表达式对应的List</span></span><br><span class="line"><span class="comment">// 即 "1+((2+3)×4)-5" =&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line"><span class="comment">// 3. 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line"><span class="comment">// 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList</span></span><br><span class="line"><span class="comment">// [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line">String expression = <span class="string">"10+((2+3)*4)-5"</span>;<span class="comment">// 注意表达式</span></span><br><span class="line">List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">System.out.println(<span class="string">"中缀表达式对应的List="</span> + infixExpressionList); <span class="comment">// ArrayList</span></span><br><span class="line"><span class="comment">// [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">List&lt;String&gt; suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList);</span><br><span class="line">System.out.println(<span class="string">"后缀表达式对应的List"</span> + suffixExpreesionList); <span class="comment">//ArrayList [1,2,3,+,4,*,+,5,–] </span></span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">"expression=%d"</span>, calculate(suffixExpreesionList)); <span class="comment">// ?</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * // 先定义一个逆波兰表达式 // (3+4)*5-6 =&gt;3 4 + 5 * 6 - // 为了方便，逆波兰表达式的数字和符号用空格隔开</span></span><br><span class="line"><span class="comment"> * String suffixExpression = "30 4 + 5 * 6 -"; // 思路 // 1. 先将</span></span><br><span class="line"><span class="comment"> * "3 4 + 5 × 6 - " =&gt; 放到ArrayList中 // 2. 将 ArrayList 传递给一个方法，遍历</span></span><br><span class="line"><span class="comment"> * ArrayList 配合栈 完成计算 List&lt;String&gt; list =</span></span><br><span class="line"><span class="comment"> * getListString(suffixExpression); System.out.println("list=" + list);</span></span><br><span class="line"><span class="comment"> * int res = calculate(list); System.out.println("计算结果是：" + res);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法：将 中缀表达式转成对应的List</span></span><br><span class="line"><span class="comment">// s="1+((2+3)×4)-5";</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixExpressionList</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义一个List,存放中缀表达式 对应的内容</span></span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 这是一个指针，用于遍历 中缀表达式字符串</span></span><br><span class="line">String str;<span class="comment">// 对多位数的拼接</span></span><br><span class="line"><span class="keyword">char</span> c;<span class="comment">// 每遍历到一个字符就放入到c中</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 如果c是一个非数字，我需要加入到ls</span></span><br><span class="line"><span class="keyword">if</span> ((c = s.charAt(i)) &lt; <span class="number">48</span> || (c = s.charAt(i)) &gt; <span class="number">57</span>) &#123;</span><br><span class="line"><span class="comment">// 此时c不是一个数</span></span><br><span class="line">ls.add(<span class="string">""</span> + c);</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果是一个数，需要考虑是不是多位数</span></span><br><span class="line">str = <span class="string">""</span>;<span class="comment">// 先将str置成空串</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= <span class="number">48</span> &amp;&amp; (c = s.charAt(i)) &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">str += c;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">ls.add(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; s.length());</span><br><span class="line"><span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line"><span class="comment">// 方法：将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpreesionList</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义两个栈</span></span><br><span class="line">Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;String&gt;();<span class="comment">// 符号栈</span></span><br><span class="line"><span class="comment">// 说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span></span><br><span class="line"><span class="comment">// 因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2</span></span><br><span class="line"><span class="comment">// Stack&lt;String&gt; s2 = new Stack&lt;String&gt;(); // 储存中间结果的栈s2</span></span><br><span class="line">List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 储存中间结果的Lists2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历ls</span></span><br><span class="line"><span class="keyword">for</span>(String item: ls) &#123;</span><br><span class="line"><span class="comment">//如果是一个数，加入s2</span></span><br><span class="line"><span class="keyword">if</span>(item.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">s2.add(item);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">")"</span>)) &#123;</span><br><span class="line"><span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line"><span class="keyword">while</span>(!s1.peek().equals(<span class="string">"("</span>))&#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">s1.pop();<span class="comment">// 将 ( 弹出 s1栈， 消除小括号</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较</span></span><br><span class="line"><span class="keyword">while</span> (s1.size()!=<span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item)) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还需将 item 压入栈顶</span></span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将s1中剩余的运算符依次弹出并加入s2</span></span><br><span class="line"><span class="keyword">while</span>(s1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s2; <span class="comment">//注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将 suffixExpression 分割</span></span><br><span class="line">String[] split = suffixExpression.split(<span class="string">" "</span>);</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">list.add(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成对逆波兰表达式的运算</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1)从左至右扫描，将3和4压入堆栈； 2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment"> * 3)将5入栈； 4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 5)将6入栈；</span></span><br><span class="line"><span class="comment"> * 6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个栈,只需要一个栈即可</span></span><br><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line"><span class="comment">// 这里使用正则表达式来取出数</span></span><br><span class="line"><span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>)) &#123;<span class="comment">// 匹配的是多位数</span></span><br><span class="line">stack.push(item);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// pop出两个数，并运算， 再入栈</span></span><br><span class="line"><span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line"><span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (item.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">res = num1 + num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">res = num1 - num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">res = num1 * num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">res = num1 / num2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"运算符有误"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把结果 入栈</span></span><br><span class="line">stack.push(<span class="string">""</span> + res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后留在stack中的数据是运算结果</span></span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个类 Operation 可以返回一个运算符 对应的优先级</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (operation) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">result = ADD;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">result = SUB;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">result = MUL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">result = DIV;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"不存在该运算符"</span> + operation);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整版-精确到小数点"><a href="#完整版-精确到小数点" class="headerlink" title="完整版(精确到小数点)"></a>完整版(精确到小数点)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePolishMultiCalc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 + - * / ( ) 运算符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String SYMBOL = <span class="string">"\\+|-|\\*|/|\\(|\\)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEFT = <span class="string">"("</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RIGHT = <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ADD = <span class="string">"+"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MINUS= <span class="string">"-"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TIMES = <span class="string">"*"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIVISION = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加減 + -</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_01 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘除 * /</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_02 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 括号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_HIGH = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; data = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去除所有空白符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceAllBlank</span><span class="params">(String s )</span></span>&#123;</span><br><span class="line">        <span class="comment">// \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]</span></span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">"\\s+"</span>,<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是数字 int double long float</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">"^[-\\+]?[.\\d]*$"</span>);</span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是运算符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymbol</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(SYMBOL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配运算等级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calcLevel</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"+"</span>.equals(s) || <span class="string">"-"</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_01;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(s) || <span class="string">"/"</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_02;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LEVEL_HIGH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">doMatch</span> <span class="params">(String s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s.trim())) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data is empty"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!isNumber(s.charAt(<span class="number">0</span>)+<span class="string">""</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data illeagle,start not with a number"</span>);</span><br><span class="line"></span><br><span class="line">        s = replaceAllBlank(s);</span><br><span class="line"></span><br><span class="line">        String each;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(s.charAt(i)+<span class="string">""</span>))&#123;</span><br><span class="line">                each = s.charAt(i)+<span class="string">""</span>;</span><br><span class="line">                <span class="comment">//栈为空，(操作符，或者 操作符优先级大于栈顶优先级 &amp;&amp; 操作符优先级不是( )的优先级 及是 ) 不能直接入栈</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || LEFT.equals(each)</span><br><span class="line">                        || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH))&#123;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>( !stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                    <span class="comment">//栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()) )&#123;</span><br><span class="line">                        <span class="keyword">if</span>(calcLevel(stack.peek()) == LEVEL_HIGH)&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(RIGHT.equals(each))&#123;</span><br><span class="line">                    <span class="comment">// ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(LEVEL_HIGH == calcLevel(stack.peek()))&#123;</span><br><span class="line">                            stack.pop();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                start = i ;    <span class="comment">//前一个运算符的位置</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( i == s.length()-<span class="number">1</span> || isSymbol(s.charAt(i+<span class="number">1</span>)+<span class="string">""</span>) )&#123;</span><br><span class="line">                each = start == <span class="number">0</span> ? s.substring(start,i+<span class="number">1</span>) : s.substring(start+<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isNumber(each)) &#123;</span><br><span class="line">                    data.add(each);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data not match number"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列</span></span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        data.addAll(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line"></span><br><span class="line">        System.out.println(data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算出结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">doCalc</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        Double d = <span class="number">0</span>d;</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="keyword">null</span> || list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(list);</span><br><span class="line">            d = Double.valueOf(list.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list1.add(list.get(i));</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(list.get(i)))&#123;</span><br><span class="line">                Double d1 = doTheMath(list.get(i - <span class="number">2</span>), list.get(i - <span class="number">1</span>), list.get(i));</span><br><span class="line">                list1.remove(i);</span><br><span class="line">                list1.remove(i-<span class="number">1</span>);</span><br><span class="line">                list1.set(i-<span class="number">2</span>,d1+<span class="string">""</span>);</span><br><span class="line">                list1.addAll(list.subList(i+<span class="number">1</span>,list.size()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doCalc(list1);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">doTheMath</span><span class="params">(String s1,String s2,String symbol)</span></span>&#123;</span><br><span class="line">        Double result ;</span><br><span class="line">        <span class="keyword">switch</span> (symbol)&#123;</span><br><span class="line">            <span class="keyword">case</span> ADD : result = Double.valueOf(s1) + Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : result = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String math = "9+(3-1)*3+10/2";</span></span><br><span class="line">        String math = <span class="string">"12.8 + (2 - 3.55)*4+10/5.0"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doCalc(doMatch(math));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】注解</title>
      <link href="/2020/03/27/MyBatis%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/03/27/MyBatis%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>MyBatis注解方式就是将SQL语句直接写在映射接口上</p><ul><li>优点：对于需求简单的系统，效率较高</li><li>缺点：当SQL发生变化时，需要重新编译代码</li></ul><p>一般情况下不建议使用注解方式</p><p><strong>使用注解方式时，在主配置文件中关联映射配置时应该使用如下方法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.mybatis.mapper.UserMapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Select注解"><a href="#Select注解" class="headerlink" title="@Select注解"></a>@Select注解</h2><h4 id="在映射接口的查询方法上添加如下注解"><a href="#在映射接口的查询方法上添加如下注解" class="headerlink" title="在映射接口的查询方法上添加如下注解"></a>在映射接口的查询方法上添加如下注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select id, user_name userName, password"</span></span><br><span class="line">         + <span class="string">" from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>@Select注解的参数为字符串类型</strong></p><p>用resultMap方式解决表<strong>字段名与属性名不一致</strong>问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results</span>(&#123;</span><br><span class="line">    <span class="meta">@Result</span>(property=<span class="string">"id"</span>, column=<span class="string">"id"</span>, id=<span class="keyword">true</span>),</span><br><span class="line">    <span class="meta">@Result</span>(property=<span class="string">"userName"</span>, column=<span class="string">"user_name"</span>),</span><br><span class="line">    <span class="meta">@Result</span>(property=<span class="string">"password"</span>, column=<span class="string">"password"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select id, user_name, password"</span></span><br><span class="line">         + <span class="string">" from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>注解@Results对应XML中的resultMap元素</p><p>注解@Result对应XML中的result元素，当参数中出现id=true时，就对应了id元素</p><p>从MyBatis3.3.1开始，映射接口中的多个方法可以共用@Results注解，首先要在@Results注解中加上id属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results</span>(id = <span class="string">"userResult"</span>, value= &#123;</span><br><span class="line">    <span class="meta">@Result</span>(property=<span class="string">"id"</span>,column=<span class="string">"id"</span>,id=<span class="keyword">true</span>),</span><br><span class="line">    <span class="meta">@Result</span>(property=<span class="string">"userName"</span>, column=<span class="string">"user_name"</span>),</span><br><span class="line">    <span class="meta">@Result</span>(property=<span class="string">"password"</span>, column=<span class="string">"password"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select id, user_name, password"</span></span><br><span class="line">         + <span class="string">" from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>在映射接口中添加查询方法，通过@ResultMap注解共用@Results注解</p><p>@ResultMap中参数的值与@Results注解中id属性的值一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResultMap</span>(<span class="string">"userResult"</span>)</span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectAllUsers</span><span class="params">()</span> </span>;</span><br></pre></td></tr></table></figure><h2 id="Insert注解"><a href="#Insert注解" class="headerlink" title="@Insert注解"></a>@Insert注解</h2><h4 id="在映射接口的插入方法上添加如下注解"><a href="#在映射接口的插入方法上添加如下注解" class="headerlink" title="在映射接口的插入方法上添加如下注解"></a>在映射接口的插入方法上添加如下注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into user(id, user_name, password)"</span></span><br><span class="line">        + <span class="string">"value(#&#123;id&#125;, #&#123;userName&#125;, #&#123;password&#125;)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>@Insert注解的参数为字符串类型</strong></p><h4 id="如果需要返回自增主键，需要增加-Options注解"><a href="#如果需要返回自增主键，需要增加-Options注解" class="headerlink" title="如果需要返回自增主键，需要增加@Options注解"></a>如果需要返回自增主键，需要增加@Options注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into user(id, user_name, password)"</span></span><br><span class="line">        + <span class="string">"value(#&#123;id&#125;, #&#123;userName&#125;, #&#123;password&#125;)"</span>)</span><br><span class="line"><span class="meta">@Options</span>(useGeneratedKeys = <span class="keyword">true</span>, keyProperty = <span class="string">"id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>useGeneratedKeys和keyProperty属性同XML中相同</p><h4 id="如果需要返回非自增主键，需要使用-SelectKey注解"><a href="#如果需要返回非自增主键，需要使用-SelectKey注解" class="headerlink" title="如果需要返回非自增主键，需要使用@SelectKey注解"></a>如果需要返回非自增主键，需要使用@SelectKey注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into user(id, user_name, password)"</span></span><br><span class="line">        + <span class="string">"value(#&#123;id&#125;, #&#123;userName&#125;, #&#123;password&#125;)"</span>)</span><br><span class="line"><span class="meta">@SelectKey</span>(statement = <span class="string">"SELECT LAST_INSERT_ID()"</span>,</span><br><span class="line">               keyProperty = <span class="string">"id"</span>,</span><br><span class="line">               resultType = Integer<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">               <span class="title">before</span> </span>= <span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>@SelectKey注解与前面的selectKey元素基本一致，其中before为false时功能等同于order=”AFTER”，before为true时功能等同于order=”BEFORE”</p><h2 id="Update注解"><a href="#Update注解" class="headerlink" title="@Update注解"></a>@Update注解</h2><h4 id="在映射接口的更新方法上添加如下注解"><a href="#在映射接口的更新方法上添加如下注解" class="headerlink" title="在映射接口的更新方法上添加如下注解"></a>在映射接口的更新方法上添加如下注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update</span>(<span class="string">"update user set user_name=#&#123;userName&#125;,"</span></span><br><span class="line">        + <span class="string">"password=#&#123;password&#125; "</span></span><br><span class="line">        + <span class="string">"where id=#&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateById</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>@Update注解的参数为字符串类型</strong></p><h2 id="Delete注解"><a href="#Delete注解" class="headerlink" title="@Delete注解"></a>@Delete注解</h2><h4 id="在映射接口的删除方法上添加如下注解"><a href="#在映射接口的删除方法上添加如下注解" class="headerlink" title="在映射接口的删除方法上添加如下注解"></a>在映射接口的删除方法上添加如下注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Delete</span>(<span class="string">"delete from user where id=#&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>@Delete注解的参数为字符串类型</strong></p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】其他配置</title>
      <link href="/2020/03/27/MyBatis%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/27/MyBatis%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis配置优化"><a href="#MyBatis配置优化" class="headerlink" title="MyBatis配置优化"></a>MyBatis配置优化</h1><p>MyBatis配置文件的元素结构如下：</p><p>configuration（配置）</p><ul><li><p>properties（属性）</p></li><li><p>settings（设置）</p></li><li><p>typeAliases（类型别名）</p></li><li><p>plugins（插件）</p></li><li><p>environments（环境配置）</p><ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li><p>mappers（映射器）</p></li></ul><h2 id="配置别名（typealiases）"><a href="#配置别名（typealiases）" class="headerlink" title="配置别名（typealiases）"></a>配置别名（typealiases）</h2><p>类型别名是为Java 类型命名一个短的名字。它只和XML配置有关, 只用来减少类完全限定名的多余部分。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"net.onest.entity.User"</span> <span class="attr">alias</span>=<span class="string">"User"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的JavaBean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"net.onest.entity"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据源配置（db-properties）"><a href="#数据源配置（db-properties）" class="headerlink" title="数据源配置（db.properties）"></a>数据源配置（db.properties）</h2><p>将数据库配置单独方法一个Java属性文件中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure><p>使用properties元素在mybatis.xml配置文件中引用Java属性文件中的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用properties文件 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"> <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">         ……        </span><br><span class="line">     <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在dataSource中采用${name}的形式引用属性文件中定义的参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="MyBatis中-和-的异同"><a href="#MyBatis中-和-的异同" class="headerlink" title="MyBatis中$和#的异同"></a>MyBatis中$和#的异同</h3><ul><li>可以获取对象中的属性值，${userName}和#{userName}相同</li><li>#可以防止SQL注入，解析时会把所有使用#的地方变成？占位符，再设置参数的值</li><li>$在解析时，会直接使用传入的参数作为字符串直接填充到SQL语句中，会导致SQL注入</li><li>#会把传入的参数使用引号括起来，$则不会</li><li>$一般用传入数据库相关参数，如数据库表名、字段名</li></ul><h1 id="MyBatis分页插件"><a href="#MyBatis分页插件" class="headerlink" title="MyBatis分页插件"></a>MyBatis分页插件</h1><ul><li>MyBatis中要想实现分页功能，需要使用limit子句实现分页的SQL语句，比较麻烦</li><li>PageHelper插件能方便解决MyBatis分页问题，其GitHub源码地址：</li><li><a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">https</a><a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">://github.com/pagehelper/Mybatis-PageHelper</a></li></ul><h2 id="PageHelper使用方法"><a href="#PageHelper使用方法" class="headerlink" title="PageHelper使用方法"></a>PageHelper使用方法</h2><ol><li>引入PageHelper的jar包 pagehelper-xxx.jar jsqlparser-xx.jar</li><li>在MyBatis的XML配置文件中配置拦截器插件</li><li>调用PageHelper类的方法实现分页功能</li></ol><h3 id="在MyBatis的XML配置文件中配置拦截器插件"><a href="#在MyBatis的XML配置文件中配置拦截器插件" class="headerlink" title="在MyBatis的XML配置文件中配置拦截器插件"></a>在MyBatis的XML配置文件中配置拦截器插件</h3><ul><li>MyBatis允许使用插件来拦截方法的调用，如update、query、commit、rollback等方法</li><li>实现插件时，只需定义类实现MyBatis的Interceptor接口，并指定想要拦截的方法名即可</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="调用PageHelper类的方法实现分页功能"><a href="#调用PageHelper类的方法实现分页功能" class="headerlink" title="调用PageHelper类的方法实现分页功能"></a>调用PageHelper类的方法实现分页功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">List&lt;User&gt; users = userMapper.findAllUsers();</span><br></pre></td></tr></table></figure><p>调用PageHelper的startPage静态方法之后，跟在后面的第一个<strong>查询方法</strong>将进行分页查询</p><p>分页查询时，查询方法返回的List对象实际上是Page&lt;E&gt;类型，如果需要取得分页信息，需要将结果强制类型转换为Page&lt;E&gt;类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;User&gt; userPages = (Page&lt;User&gt;)users;</span><br><span class="line">System.out.println(userPages.getTotal());<span class="comment">//总条数</span></span><br><span class="line">System.out.println(userPages.getPageNum());<span class="comment">//当前页数</span></span><br><span class="line">System.out.println(userPages.getPageSize());<span class="comment">//每页条数</span></span><br><span class="line">System.out.println(userPages.getPages());<span class="comment">//总页数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized和ReentrantLock的实现原理是什么它们有什么区别</title>
      <link href="/2020/03/26/synchronized%E5%92%8CReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/03/26/synchronized%E5%92%8CReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>在JDK1.5之前共享对象的协调机制只有 synchronized和 volatile，在JDK1.5中增加了新的机制<br>ReentrantLock，该机制的诞生并不是为了替代synchronized，而是在synchronized不适用的情况下，提供一种可以选择的高级功能。</p><p>我们本课时的面试题是，synchronized和ReentrantLock是如何实现的？它们有什么区别？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a><strong>典型回答</strong></h2><p>synchronized 属于独占式悲观锁，是通过JVM隐式实现的，synchronized只允许同一时刻只有一个线程操作资源。<br>在Java中每个对象都隐式包含一个monitor（监视器）对象，加锁的过程其实就是竞争monitor的过程，当线程进入字节码 monitorenter 指令之后，线程将持有monitor对象，执行monitorexit时释放 monitor对象，当其他线程没有拿到monitor对象时，则需要阻塞等待获取该对象。</p><p>ReentrantLock 是Lock的默认实现方式之一，它是基于AQS（Abstract Queued Synchronizer，队列同步器）实现的，它默认是通过非公平锁实现的，在它的内部有一个state的状态字段用于表示锁是否被占用，如果是0则表示锁未被占用，此时线程就可以把state改为1，并成功获得锁，而其他未获得锁的线程只能去排队等待获取锁资源。</p><p>synchronized和ReentrantLock都提供了锁的功能，具备互斥性和不可见性。在JDK1.5中<br>synchronized 的性能远远低于ReentrantLock，但在JDK 1.6之后synchronized的性能略低于<br>ReentrantLock，它的区别如下：</p><ul><li>synchronized是JVM隐式实现的，而ReentrantLock是Java 语言提供的APl；</li><li>ReentrantLock 可设置为公平锁，而synchronized却不行；</li><li>ReentrantLock 只能修饰代码块，而synchronized可以用于修饰方法、修饰代码块等；</li><li>ReentrantLock 需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而synchronized 无需手动释放锁；</li><li>ReentrantLock 可以知道是否成功获得了锁，而synchronized却不行。</li></ul><h3 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h3><p>synchronized 和ReentrantLock 是比线程池还要高频的面试问题，因为它包含了更多的知识点，且涉及到的知识点更加深入，对面试者的要求也更高，前面我们简要地介绍了synchronized和ReentrantLock的概念及执行原理，但很多大厂会更加深入的追问更多关于它们的实现细节，比如：</p><ul><li>ReentrantLock的具体实现细节是什么？</li><li>JDK1.6时锁做了哪些优化？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="ReentrantLock-源码分析"><a href="#ReentrantLock-源码分析" class="headerlink" title="ReentrantLock 源码分析"></a>ReentrantLock 源码分析</h3><p>本课时从源码出发来解密 ReentrantLock 的具体实现细节，首先来看ReentrantLock的两个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(); <span class="comment">// 非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参的构造函数创建了一个非公平锁，用户也可以根据第二个构造函数，设置一个boolean类型的值，来决定是否使用公平锁来实现线程的调度。</p><h3 id="公平锁VS非公平锁"><a href="#公平锁VS非公平锁" class="headerlink" title="公平锁VS非公平锁"></a>公平锁VS非公平锁</h3><p>公平锁的含义是线程需要按照请求的顺序来获得锁；而非公平锁则允许“插队”的情况存在，所谓的“插队”指的是，线程在发送请求的同时该锁的状态恰好变成了可用，那么此线程就可以跳过队列中所有排队的线程直接拥有该锁。</p><p>而公平锁由于有挂起和恢复所以存在一定的开销，因此性能不如非公平锁，所以ReentrantLock和synchronized 默认都是非公平锁的实现方式。</p><p>ReentrantLock 是通过lock()来获取锁，并通过unlock()释放锁，使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">//......业务处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock中的lock()是通过sync.lock()实现的，但Sync类中的lock()是一个抽象方法，需要子类NonfairSync或FairSync去实现，NonfairSync中的lock()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 将当前线程设置为此锁的持有者</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FairSync中的lock()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出非公平锁比公平锁只是多了一行compareAndSetState方法，该方法是尝试将 state值由0置换为1，如果设置成功的话，则说明当前没有其他线程持有该锁，不用再去排队了，可直接占用该锁，否则，则需要通过acquire方法去排队。</p><p>acquire源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire 方法尝试获取锁，如果获取锁失败，则把它加入到阻塞队列中，来看tryAcquire的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 公平锁比非公平锁多了一行代码 !hasQueuedPredecessors() </span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//尝试获取锁</span></span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">// 获取成功，标记被抢占</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc); <span class="comment">// set state=state+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于此方法来说，公平锁比非公平锁只多一行代码!hasQueuedPredecessors()，它用来查看队列中是否有比它等待时间更久的线程，如果没有，就尝试一下是否能获取到锁，如果获取成功，则标记为已经被占用。</p><p>如果获取锁失败，则调用addWaiter方法把线程包装成Node对象，同时放入到队列中，但<br>addWaiter 方法并不会尝试获取锁，acquireQueued方法才会尝试获取锁，如果获取失败，则此节点会被挂起，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列中的线程尝试获取锁，失败则会被挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">// 获取锁是否成功的状态标识</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">// 线程是否被中断</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前一个节点（前驱节点）</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 当前节点为头节点的下一个节点时，有权尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node); <span class="comment">// 获取成功，将当前节点设置为 head 节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// 原 head 节点出队，等待被 GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">// 获取成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断获取锁失败后是否可以挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 线程若被中断，返回 true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会使用for（;;）无限循环的方式来尝试获取锁，若获取失败，则调用<br>shouldParkAfterFailedAcquire方法，尝试挂起当前线程，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断线程是否可以被挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得前驱节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的状态为 SIGNAL，当前线程可以被挂起（阻塞）</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 若前驱节点状态为 CANCELLED，那就一直往前找，直到找到一个正常等待的状态为止</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 并将当前节点排在它后边</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 把前驱节点的状态修改为 SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程入列被挂起的前提条件是，前驱节点的状态为SIGNAL，SIGNAL状态的含义是后继节点处于等待状态，当前节点释放锁后将会唤醒后继节点。所以在上面这段代码中，会先判断前驱节点的状态，如果为SIGNAL，则当前线程可以被挂起并返回true；如果前驱节点的状态&gt;0，则表示前驱节点取消了，这时候需要一直往前找，直到找到最近一个正常等待的前驱节点，然后把它作为自己的前驱节点；如果前驱节点正常（未取消），则修改前驱节点状态为SIGNAL。</p><p>到这里整个加锁的流程就已经走完了，最后的情况是，没有拿到锁的线程会在队列中被挂起，直到拥有锁的线程释放锁之后，才会去唤醒其他的线程去获取锁资源，整个运行流程如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p>unlock 相比于 lock 来说就简单很多了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放成功</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁的释放流程为，先调用tryRelease方法尝试释放锁，如果释放成功，则查看头结点的状态是否为<br>SIGNAL，如果是，则唤醒头结点的下个节点关联的线程；如果释放锁失败，则返回false。</p><p>tryRelease源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试释放当前线程占有的锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 释放锁后的状态，0 表示释放锁成功</span></span><br><span class="line">    <span class="comment">// 如果拥有锁的线程不是当前线程的话抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 锁被成功释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">// 清空独占线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c); <span class="comment">// 更新 state 值，0 表示为释放锁成功</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在tryRelease方法中，会先判断当前的线程是不是占用锁的线程，如果不是的话，则会抛出异常；如果是的话，则先计算锁的状态值 getState()-releases是否为0，如果为0，则表示可以正常的释放锁，然后清空独占的线程，最后会更新锁的状态并返回执行结果。</p><h3 id="JDK1-6锁优化"><a href="#JDK1-6锁优化" class="headerlink" title="JDK1.6锁优化"></a>JDK1.6锁优化</h3><p><strong>自适应自旋锁</strong></p><p>JDK1.5在升级为JDK1.6时，HotSpot 虚拟机团队在锁的优化上下了很大功夫，比如实现了自适应式自旋锁、锁升级等。</p><p>JDK 1.6引入了自适应式自旋锁意味着自旋的时间不再是固定的时间了，比如在同一个锁对象上，如果通过自旋等待成功获取了锁，那么虚拟机就会认为，它下一次很有可能也会成功（通过自旋获取到锁，因此允许自旋等待的时间会相对的比较长，而当某个锁通过自旋很少成功获得过锁，那么以后在获取该锁时，可能会直接忽略掉自旋的过程，以避免浪费CPU的资源，这就是自适应自旋锁的功能。</p><p><strong>锁升级</strong><br>锁升级其实就是从偏向锁到轻量级锁再到重量级锁升级的过程，这是JDK1.6提供的优化功能，也称之为锁膨胀。</p><p><strong>偏向锁</strong>是指在无竞争的情况下设置的一种锁状态。偏向锁的意思是它会偏向于第一个获取它的线程，当锁对象第一次被获取到之后，会在此对象头中设置标示为“01”，表示偏向锁的模式，并且在对象头中记录此线程的ID，这种情况下，如果是持有偏向锁的线程每次在进入的话，不再进行任何同步操作，如Locking、Unlocking等，直到另一个线程尝试获取此锁的时候，偏向锁模式才会结束，偏向锁可以提高带有同步但无竞争的程序性能。但如果在多数锁总会被不同的线程访问时，偏向锁模式就比较多余了，此时可以通过-XX:-UseBiasedLocking来禁用偏向锁以提高性能。</p><p><strong>轻量锁</strong>是相对于重量锁而言的，在JDK1.6之前，synchronized是通过操作系统的互斥量（mutex lock）来实现的，这种实现方式需要在用户态和核心态之间做转换，有很大的性能消耗，这种传统实现锁的方式被称之为<strong>重量锁</strong>。</p><p>而<strong>轻量锁</strong>是通过比较并交换（CAS，Compare and Swap）来实现的，它对比的是线程和对象的<br>Mark Word（对象头中的一个区域），如果更新成功则表示当前线程成功拥有此锁；如果失败，虚拟机会先检查对象的Mark Word是否指向当前线程的栈帧，如果是，则说明当前线程已经拥有此锁，否则，则说明此锁已经被其他线程占用了。当两个以上的线程争抢此锁时，轻量级锁就膨胀为重量级锁，这就是锁升级的过程，也是JDK1.6锁优化的内容。</p><p><strong>小结</strong></p><p>本课时首先讲了synchronized和ReentrantLock的实现过程，然后讲了 synchronized和ReentrantLock 的区别，最后通过源码的方式讲了ReentrantLock加锁和解锁的执行流程。接着又讲了JDK1.6中的锁优化，包括自适应式自旋锁的实现过程，以及synchronized的三种锁状态和锁升级的执行流程。<br>synchronized刚开始为偏向锁，随着锁竞争越来越激烈，会升级为轻量级锁和重量级锁。如果大多数锁被不同的线程所争抢就不建议使用偏向锁了。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer算法题</title>
      <link href="/2020/03/25/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2020/03/25/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数组中重复的数字"><a href="#1-数组中重复的数字" class="headerlink" title="1.数组中重复的数字"></a>1.数组中重复的数字</h3><p><strong>题目描述</strong></p><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!set.add(numbers[i])) &#123;</span><br><span class="line">duplication[<span class="number">0</span>]= numbers[i];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】缓存配置</title>
      <link href="/2020/03/25/MyBatis%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/25/MyBatis%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>使用缓存可以使应用更快地获取数据，避免频繁的数据库交互，MyBatis将数据缓存设计成两级结构，分为一级缓存、二级缓存：</p><ul><li>一级缓存是SqlSession会话级别的缓存，位于表示一次数据库会话的SqlSession对象之中，又被称之为本地缓存。</li><li>二级缓存是Application级别的缓存，它的作用范围是整个应用程序。</li></ul><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>一级缓存是MyBatis内部实现的一个特性，用户不能配置，默认情况下自动支持的缓存</p><p>MyBatis会在SqlSession对象中创建一个本地缓存(local cache)。对于每一次查询，都会根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中，就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。</p><h3 id="一级缓存的工作流程："><a href="#一级缓存的工作流程：" class="headerlink" title="一级缓存的工作流程："></a>一级缓存的工作流程：</h3><p><img data-src="1.png" alt="1.png"></p><h3 id="一级缓存的生命周期"><a href="#一级缓存的生命周期" class="headerlink" title="一级缓存的生命周期"></a>一级缓存的生命周期</h3><ul><li>MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象；当会话结束时，SqlSession对象也一并释放掉。</li><li>如果SqlSession调用了close()方法，会释放掉一级缓存，一级缓存将不可用；</li><li>如果SqlSession调用了clearCache()，会清空缓存，但是该对象仍可使用；</li><li>在SqlSession中执行了任何一个update操作、insert操作、delete操作，都会清空缓存，但是该对象可以继续使用；</li></ul><h3 id="判断两次查询是否相同"><a href="#判断两次查询是否相同" class="headerlink" title="判断两次查询是否相同"></a>判断两次查询是否相同</h3><p>MyBatis中，如果以下条件都一样，那么就认为它们是完全相同的两次查询：</p><ul><li>传入的 statementId </li><li>查询时要求的结果集中的结果范围 </li><li>这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串</li><li>传递给java.sql.Statement要设置的参数值</li></ul><h3 id="SqlSession的一级缓存性能问题"><a href="#SqlSession的一级缓存性能问题" class="headerlink" title="SqlSession的一级缓存性能问题"></a>SqlSession的一级缓存性能问题</h3><ul><li>MyBatis对会话（Session）级别的一级缓存设计的比较简单，就简单地使用了HashMap来维护，并没有对HashMap的容量和大小进行限制。</li><li>一级缓存是一个粗粒度的缓存，没有更新缓存和缓存过期的概念</li></ul><h3 id="根据一级缓存的特性，在使用的过程中，应该注意以下两点"><a href="#根据一级缓存的特性，在使用的过程中，应该注意以下两点" class="headerlink" title="根据一级缓存的特性，在使用的过程中，应该注意以下两点"></a>根据一级缓存的特性，在使用的过程中，应该注意以下两点</h3><ol><li>对于数据变化频率很大，并且要求高时效准确性的数据，我们使用SqlSession查询的时候，可以手动地适时清空SqlSession中的缓存</li><li>对于只执行或者频繁执行大范围的select操作的SqlSession对象，SqlSession对象的生存时间不应过长。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SqlSession session=MybatisUtil.openSqlSession();</span><br><span class="line"><span class="comment">//一级缓存生效</span></span><br><span class="line">UserMapper userMapper=session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">User user=userMapper.findById(<span class="number">1</span>);</span><br><span class="line">User user2=userMapper.findById(<span class="number">1</span>);<span class="comment">//完全相同命中</span></span><br><span class="line"><span class="comment">//User user3=userMapper.findByUserName("zs");//更改不命中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空缓存增、改、删、手动清空</span></span><br><span class="line"><span class="comment">/*userMapper.insertUser(user);//缓存也会清空</span></span><br><span class="line"><span class="comment">session.commit();*/</span></span><br><span class="line"><span class="comment">//session.clearCache();清空缓存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SqlSession session2=MybatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper2=session2.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">userMapper2.findById(<span class="number">1</span>);<span class="comment">//不同session中不会命中一级缓存</span></span><br><span class="line">userMapper2.updateUser(<span class="string">"ww"</span>, <span class="number">1</span>);</span><br><span class="line">session2.commit();</span><br><span class="line">session2.close();</span><br><span class="line"><span class="comment">//出现数据不准确的情况</span></span><br><span class="line">User user4=userMapper.findById(<span class="number">1</span>);</span><br><span class="line">session.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><h3 id="开启二级缓存"><a href="#开启二级缓存" class="headerlink" title="开启二级缓存"></a>开启二级缓存</h3><p>MyBatis的二级缓存默认为开启状态，在主配置文件中，settings配置中有一个参数cacheEnable，当把该参数的值设置为false时，可关闭二级缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnable"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>MyBatis的二级缓存是和命名空间绑定的，即二级缓存需要配置在映射文件中，有两种配置方式</p><ul><li>为每一个Mapper分配一个Cache缓存对象（使用&lt;cache&gt;元素配置）</li><li>多个Mapper共用一个Cache缓存对象（使用&lt;cache-ref&gt;元素配置）；</li></ul><p>1、保证二级缓存的全局配置开启，并且使用二级缓存的实体类要实现Serializable接口</p><p>2、给UserMapper.xml开启二级缓存，在mapper元素中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="默认的二级缓存效果如下"><a href="#默认的二级缓存效果如下" class="headerlink" title="默认的二级缓存效果如下:"></a>默认的二级缓存效果如下:</h3><ul><li>映射语句文件中的所有 select 语句将会被缓存</li><li>映射语句文件中的所有 insert，update和delete语句会刷新缓存</li><li>缓存会使用 Least Recently Used（LRU，最近最少使用的）算法来收回</li><li>根据时间表（比如 no Flush Interval，没有刷新间隔）, 缓存不会以任何时间顺序来刷新</li><li>缓存会存储集合或对象（无论查询方法返回什么类型）的 1024 个引用</li><li>缓存会被视为是 read/write（可读/可写）的缓存，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改</li></ul><h3 id="刷新和置换策略"><a href="#刷新和置换策略" class="headerlink" title="刷新和置换策略"></a>刷新和置换策略</h3><p>MyBatis主要提供了以下几个刷新和置换策略：</p><ul><li>LRU（Least Recently Used）：最近最少使用算法，移除最长时间不被使用的对象，这是默认值     </li><li>FIFO（First in first out）：先进先出算法，移除最先进入缓存中的对象</li><li>flushInterval：刷新间隔，会以指定的某一个时间间隔将缓存中的数据清空，不设置时仅仅在调用语句时刷新</li><li>size：可以缓存的对象数目，默认值为1024</li><li>readOnly：只读属性，只读的缓存会给调用者返回缓存对象的相同实例，因此这些对象不能被修改；可读写的缓存会返回缓存对象的拷贝，这种方式更安全，因此默认值是false</li></ul><p>以上效果都可以通过cache元素的属性来修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">    <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这个配置创建了一个 FIFO 缓存，并每隔 60 秒刷新，存储结果对象的 512 个引用，而且返回的对象被认为是只读的，因此在不同线程中的调用者之间修改它们会导致冲突</p><h3 id="多个Mapper公用一个Cache缓存"><a href="#多个Mapper公用一个Cache缓存" class="headerlink" title="多个Mapper公用一个Cache缓存"></a>多个Mapper公用一个Cache缓存</h3><p>如果想让多个Mapper公用一个Cache缓存，可以使用&lt;cache-ref namespace=””&gt;元素配置参照缓存，这样不仅能减少配置项，还能解决脏读问题</p><p><img data-src="2.png" alt="2.png"></p><h3 id="MyBatis中开启二级缓存之后，一级缓存和二级缓存的使用顺序为："><a href="#MyBatis中开启二级缓存之后，一级缓存和二级缓存的使用顺序为：" class="headerlink" title="MyBatis中开启二级缓存之后，一级缓存和二级缓存的使用顺序为："></a>MyBatis中开启二级缓存之后，一级缓存和二级缓存的使用顺序为：</h3><p><strong>二级缓存-&gt;一级缓存-&gt;数据库</strong></p><p><img data-src="3.png" alt="3.png"></p><h2 id="集成EhCache缓存"><a href="#集成EhCache缓存" class="headerlink" title="集成EhCache缓存"></a>集成EhCache缓存</h2><p>MyBatis对二级缓存的设计非常灵活，在MyBatis中使用二级缓存有三个选择</p><ul><li>它自己内部基于HashMap实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等</li><li>MyBatis还允许用户自定义Cache接口实现，然后将Cache实现类配置在&lt;cache  type=””&gt;type属性上即可</li><li>MyBatis还支持第三方缓存框架（EhCache、Redis）的集成</li></ul><p>EhCache是一个纯粹的Java进程内的缓存框架，主要特征</p><ul><li>快速、简单</li><li>提供多种缓存策略</li><li>缓存数据有内存和磁盘两种</li></ul><p>MyBatis集成EhCache框架jar包下载地址为：<a href="https://github.com/mybatis/ehcache-cache/releases" target="_blank" rel="noopener">https://github.com/mybatis/ehcache-cache/releases</a></p><h3 id="MyBatis集成EhCache框架的步骤为："><a href="#MyBatis集成EhCache框架的步骤为：" class="headerlink" title="MyBatis集成EhCache框架的步骤为："></a>MyBatis集成EhCache框架的步骤为：</h3><ol><li>添加jar包，并添加到项目的Build Path</li><li>在resources目录下添加ehcache.xml配置文件</li><li>修改映射接口中的缓存配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"org.mybatis.caches.ehcache.LoggingEhcache"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>EhCache提供了2个可选的缓存实现</p><ul><li>org.mybatis.caches.ehcache.EhcacheCache</li><li>org.mybatis.caches.ehcache.LoggingEhcache</li></ul><p>ehcache.xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"../config/ehcache.xsd"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--当二级缓存的对象 超过内存限制时（缓存对象的个数&gt;maxElementsInMemory），存放入的硬盘文件  --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"F:\Ehcache"</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     maxElementsInMemory:设置 在内存中缓存 对象的个数</span></span><br><span class="line"><span class="comment">    maxElementsOnDisk：设置 在硬盘中缓存 对象的个数</span></span><br><span class="line"><span class="comment">    eternal：设置缓存是否 永远不过期</span></span><br><span class="line"><span class="comment">    overflowToDisk：当内存中缓存的对象个数 超过</span></span><br><span class="line"><span class="comment">    maxElementsInMemory的时候，是否转移到硬盘中</span></span><br><span class="line"><span class="comment">    timeToIdleSeconds：当2次访问 超过该值的时候，将缓存对象失效</span></span><br><span class="line"><span class="comment">    timeToLiveSeconds：一个缓存对象 最多存放的时间（生命周期）</span></span><br><span class="line"><span class="comment">    diskExpiryThreadIntervalSeconds：设置每隔多长时间，通过一个线程来清理硬盘中的缓存</span></span><br><span class="line"><span class="comment">    memoryStoreEvictionPolicy：当超过缓存对象的最大值时，处理的策略；LRU，FIFO,LFU</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">maxElementsOnDisk</span>=<span class="string">"1000000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeToIdleSeconds</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeToLiveSeconds</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="脏数据的产生和避免"><a href="#脏数据的产生和避免" class="headerlink" title="脏数据的产生和避免"></a>脏数据的产生和避免</h2><h3 id="二级缓存中脏数据产生的原因"><a href="#二级缓存中脏数据产生的原因" class="headerlink" title="二级缓存中脏数据产生的原因"></a>二级缓存中脏数据产生的原因</h3><ul><li>通常情况下每个Mapper映射文件都有自己的二级缓存</li><li>有些查询需要关联多张表</li><li>涉及这多张表的增删改查操作通常不在一个映射文件中</li><li>当数据有变化时，多表查询的缓存不一定会清空，这种情况下就会出现脏数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession1 = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper = sqlSession1.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(userMapper.findUserAndOrdersById(<span class="number">1</span>));</span><br><span class="line">sqlSession1.close();</span><br><span class="line">SqlSession sqlSession2 = MyBatisUtil.openSqlSession();</span><br><span class="line">OrderMapper orderMapper = sqlSession2.getMapper(OrderMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">orderMapper.deleteOrderById(<span class="number">1</span>);</span><br><span class="line">sqlSession2.commit();</span><br><span class="line">sqlSession2.close();</span><br><span class="line">SqlSession sqlSession3 = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper2 = sqlSession3.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(userMapper2 .findUserAndOrdersById(<span class="number">1</span>));</span><br><span class="line">sqlSession3.close();</span><br></pre></td></tr></table></figure><h3 id="可以使用参照缓存来避免脏数据的产生，通常是让几个会关联的ER表使用同一个二级缓存"><a href="#可以使用参照缓存来避免脏数据的产生，通常是让几个会关联的ER表使用同一个二级缓存" class="headerlink" title="可以使用参照缓存来避免脏数据的产生，通常是让几个会关联的ER表使用同一个二级缓存"></a>可以使用参照缓存来避免脏数据的产生，通常是让几个会关联的ER表使用同一个二级缓存</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"net.onest.mapper.UserMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】动态SQL</title>
      <link href="/2020/03/24/MyBatis%E5%8A%A8%E6%80%81SQL/"/>
      <url>/2020/03/24/MyBatis%E5%8A%A8%E6%80%81SQL/</url>
      
        <content type="html"><![CDATA[<h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><h3 id="映射器接口中方法的参数情况"><a href="#映射器接口中方法的参数情况" class="headerlink" title="映射器接口中方法的参数情况"></a>映射器接口中方法的参数情况</h3><ul><li>当根据单个条件查询时，可以直接以该条件为参数</li><li>当根据多个条件查询时，可以将JavaBean作为参数</li><li>当根据多个条件查询且多个条件不属于某一个JavaBean时，可以Map类型作为参数，且通过Map中的key值来映射XML中SQL使用的参数的名字</li><li>如果要使用多个参数，必须使用@Param注解指定参数名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByNameAndPassword</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Param(<span class="string">"name"</span>)</span>String name, </span></span><br><span class="line"><span class="function">            @<span class="title">Param</span><span class="params">(<span class="string">"password"</span>)</span>String password)</span>;</span><br></pre></td></tr></table></figure><ul><li>映射文件中可以引用@Param注解中指定的参数名称</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByNameAndPassword"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    select * from user where </span><br><span class="line">    user_name = #&#123;name&#125;</span><br><span class="line">    and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="MyBatis动态SQL"><a href="#MyBatis动态SQL" class="headerlink" title="MyBatis动态SQL"></a>MyBatis动态SQL</h2><p>MyBatis 的一个强大的特性之一就是它的动态 SQL 能力。也就是可以根据不同的条件拼接SQL语句。以下是动态SQL在XML中支持的几种元素</p><ul><li>if</li><li>choose (when, otherwise) </li><li>trim (where, set) </li><li>foreach </li><li>bind</li></ul><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><strong>if元素通常用于where语句中，通过判断参数值来决定是否使用某个查询条件</strong></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设现在有一个需求：实现一个用户管理高级查询功能，根据用户输入的条件去检索用户信息</p><p><strong>创建实体类User和映射器接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">//省略构造方法</span></span><br><span class="line">    <span class="comment">//省略getter、setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射器接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User findUserByPhoneOrEmail</span><br><span class="line">         (Map&lt;String, String&gt; map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不使用动态SQL时，实现上述需求的映射文件如下：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByPhoneOrEmail"</span>    </span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">"com.mybatis.mapper.User"</span>&gt;</span></span><br><span class="line">        select id, user_name userName, </span><br><span class="line">            password, phone, email </span><br><span class="line">        from user </span><br><span class="line">        where phone = #&#123;phone&#125; and email = #&#123;email&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>调用该方法时，传入的Map类型的实际参数中，必须存在phone和email这两个key值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; user = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">user.put(<span class="string">"phone"</span>, <span class="string">"123456789"</span>);</span><br><span class="line">user.put(<span class="string">"email"</span>, <span class="string">"test@163.com"</span>); userMapper.findUserByPhoneOrEmail(user);</span><br></pre></td></tr></table></figure><p><strong>不使用动态SQL时，只有同时输入phone和email两个条件时，才能查出正确结果，此时需要if元素来解决这个问题</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByPhoneOrEmail"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">     select id, user_name userName, password, phone, email   </span><br><span class="line">  from user where 1 = 1</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"phone != null and !phone.equals('')"</span>&gt;</span></span><br><span class="line">      and phone = #&#123;phone&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null and !email.equals('')"</span>&gt;</span></span><br><span class="line">      and email = #&#123;email&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>test属性的值为符合<strong>ONGL（Object-Graph Navigation Language对象图导航语言）</strong>要求的判断表达式，表达式中能够出现<strong>方法调用</strong>，但是结果只能为true或者false</p><p>MyBatis常用的ONGL表达式中可以使用的操作符如下：</p><table><thead><tr><th><strong>Java</strong>常用操作符</th><th>+、-、*、/、%、==、!=、&amp;&amp;、||、!、点、[ ]</th></tr></thead><tbody><tr><td><strong>自己特有的操作符</strong></td><td><strong>or、and、eq、neq、lt、lte、gt、gte、not</strong></td></tr></tbody></table><p>如果不想让where条件中出现“1=1”这种表达式时，就需要使用<strong>where</strong>元素</p><p><strong>where元素的作用</strong>：如果该元素中有内容，就在生成SQL语句时加上where条件，如果该元素的内容以AND或者OR开头，就去除这两个单词。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByPhoneOrEmail"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    select id, user_name userName, password, phone, email   </span><br><span class="line">    from user </span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"phone != null and !phone.equals('')"</span>&gt;</span></span><br><span class="line">            and phone = #&#123;phone&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null and !email.equals('')"</span>&gt;</span></span><br><span class="line">            and email = #&#123;email&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="练习1：使用if元素实现动态列更新，即更新用户信息时，只更新有变化的字段"><a href="#练习1：使用if元素实现动态列更新，即更新用户信息时，只更新有变化的字段" class="headerlink" title="练习1：使用if元素实现动态列更新，即更新用户信息时，只更新有变化的字段"></a>练习1：使用if元素实现动态列更新，即更新用户信息时，只更新有变化的字段</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUserByIdSelective"</span>&gt;</span></span><br><span class="line">     update user set </span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null and !userName.equals('')"</span>&gt;</span></span><br><span class="line">         user_name = #&#123;userName&#125;,</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">     ……</span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null and !email.equals('')"</span>&gt;</span></span><br><span class="line">         email = #&#123;email&#125;,</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">     id = #&#123;id&#125;</span><br><span class="line">     where id = #&#123;id&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现动态列更新时，可以使用set元素</p><p><strong>set元素作用</strong>：当该元素有内容时，生成SQL语句时就加上set语句；当set元素的内容以逗号结尾时，去掉逗号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUserByIdSelective"</span>&gt;</span></span><br><span class="line">    update user </span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null and !userName.equals('')"</span>&gt;</span></span><br><span class="line">        user_name = #&#123;userName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password != null and !password.equals('')"</span>&gt;</span></span><br><span class="line">        password = #&#123;password&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"phone != null and !phone.equals('')"</span>&gt;</span></span><br><span class="line">        phone = #&#123;phone&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null and !email.equals('')"</span>&gt;</span></span><br><span class="line">        email = #&#123;email&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span> </span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="练习2：插入用户信息时，如果邮箱为空，就使用数据库中设置的默认值，而不要传入空值"><a href="#练习2：插入用户信息时，如果邮箱为空，就使用数据库中设置的默认值，而不要传入空值" class="headerlink" title="练习2：插入用户信息时，如果邮箱为空，就使用数据库中设置的默认值，而不要传入空值"></a>练习2：插入用户信息时，如果邮箱为空，就使用数据库中设置的默认值，而不要传入空值</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span>&gt;</span></span><br><span class="line">     insert into user(user_name, password, phone</span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null and !email.equals('')"</span>&gt;</span></span><br><span class="line">     ,email</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">     ) values(#&#123;userName&#125;, #&#123;password&#125;, #&#123;phone&#125;</span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null and !email.equals('')"</span>&gt;</span></span><br><span class="line">     ,#&#123;email&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span>)</span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h3><p>choose元素中包含when和otherwise两个子元素</p><ul><li>一个choose元素中至少有一个when子元素</li><li>一个choose元素中可以包含0个或1个otherwise子元素</li></ul><p>使用choose元素可以实现类似if…else…的逻辑</p><h4 id="练习1：当实现查询时，如果id属性有值就使用id查询，如果id没有值在去根据用户名查询"><a href="#练习1：当实现查询时，如果id属性有值就使用id查询，如果id没有值在去根据用户名查询" class="headerlink" title="练习1：当实现查询时，如果id属性有值就使用id查询，如果id没有值在去根据用户名查询"></a>练习1：当实现查询时，如果id属性有值就使用id查询，如果id没有值在去根据用户名查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByIdOrName"</span> <span class="attr">resultType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">select id, user_name userName, password, phone, email</span><br><span class="line">from user where 1 = 1</span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"id != null and id != ''"</span>&gt;</span></span><br><span class="line">and id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"userName != null and userName != ''"</span>&gt;</span></span><br><span class="line">and user_name = #&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">and 1 = 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>trim元素可以实现where和set元素的功能</p><p>trim元素对应的where功能的实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">prefixOverrides</span>=<span class="string">"AND |OR "</span>&gt;</span>……<span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>trim元素对应的set功能的实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"set"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span>……<span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>trim元素的属性，都在<strong>trim元素包含内容时</strong>起作用：</p><ul><li>prefix：给内容增加该属性指定的前缀</li><li>prefixOverrides：把内容中匹配的前缀字符串去掉</li><li>suffix：给内容增加该属性指定的后缀</li><li>suffixOverrides：把内容中匹配的后缀字符串去掉</li></ul><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>foreach可以对数组、Map或实现了Iterable接口（如：List、Set）的对象进行遍历</p><p>映射接口中添加如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByIdList</span><span class="params">(List&lt;Integer&gt; idList)</span></span>;</span><br></pre></td></tr></table></figure><p>映射文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByIdList"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">     select id, user_name userName, password, phone, email</span><br><span class="line">     from user</span><br><span class="line">     where id in</span><br><span class="line">     <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> </span></span><br><span class="line"><span class="tag">              <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">index</span>=<span class="string">"i"</span>&gt;</span></span><br><span class="line">         #&#123;id&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="foreach各个属性的含义"><a href="#foreach各个属性的含义" class="headerlink" title="foreach各个属性的含义"></a>foreach各个属性的含义</h4><table><thead><tr><th align="center"><strong>属性</strong></th><th align="left"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center"><strong>collection</strong></td><td align="left"><strong>必填，值为要迭代循环的属性名</strong></td></tr><tr><td align="center"><strong>item</strong></td><td align="left"><strong>变量名，值为从迭代对象中取出的每一个值</strong></td></tr><tr><td align="center"><strong>index</strong></td><td align="left"><strong>索引的属性名，在遍历集合、数组时为当前索引值，当遍历Map时，该值为Map的key值</strong></td></tr><tr><td align="center"><strong>open</strong></td><td align="left"><strong>整个循环内容开头的字符串</strong></td></tr><tr><td align="center"><strong>close</strong></td><td align="left"><strong>整个循环内容结尾的字符串</strong></td></tr><tr><td align="center"><strong>separator</strong></td><td align="left"><strong>每次循环的分隔符</strong></td></tr></tbody></table><p>collection属性的取值有多种情况:</p><ul><li>当参数为List集合时，collection取值为list</li><li>当参数为数组时，collection取值为array</li><li>当参数为Map类型时，collection取值默认情况下为_parameter，也可以使用@Param注解指定名字，collection取值为该注解指定的名字</li></ul><p>foreach还能实现批量插入。目前支持批量插入的数据库有DB2、SQL Server 2008及以上版本、MySQL等</p><p>在映射接口中添加批量插入的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertList</span><span class="params">(List&lt;User&gt; users)</span></span>;</span><br></pre></td></tr></table></figure><p>使用foreach实现批量插入功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertList"</span>&gt;</span></span><br><span class="line">     insert into user(user_name, password, phone, email)</span><br><span class="line">     values</span><br><span class="line">     <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"user"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">     (#&#123;user.userName&#125;, #&#123;user.password&#125;,</span><br><span class="line">     #&#123;user.phone&#125;, #&#123;user.email&#125;)</span><br><span class="line">     <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MySQL数据库还支持批量插入后，返回所有记录的主键的操作，MyBatis要想实现此功能，需要修改XML映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertList"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">     insert into user(user_name, password, phone, email)</span><br><span class="line">     values</span><br><span class="line">     <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"user"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">     (#&#123;user.userName&#125;, #&#123;user.password&#125;,</span><br><span class="line">     #&#123;user.phone&#125;, #&#123;user.email&#125;)</span><br><span class="line">     <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>foreach实现动态更新，当参数是Map类型时，foreach元素的index属性值对应的不是索引值，而是Map中的key</p><p>实现通过指定的列名和对应的值去更新数据，在映射接口中添加如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure><p>这里key作为列名，对应的值作为该列的值，通过foreach将需要更新的字段拼接在SQL语句中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByMap"</span>&gt;</span></span><br><span class="line">    update user set</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"_parameter"</span> <span class="attr">item</span>=<span class="string">"value"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">index</span>=<span class="string">"key"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        $&#123;key&#125; = #&#123;value&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述方法在调用时，Map类型的实参中的key值要与表中字段名对应</p><p>也可以将映射器接口中方法的参数添加@Param注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateByMap</span><span class="params">(@Param(<span class="string">"map"</span>)</span>Map&lt;String, </span></span><br><span class="line"><span class="function">    Object&gt; map)</span>;</span><br></pre></td></tr></table></figure><p>映射文件修改如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByMap"</span>&gt;</span></span><br><span class="line">    update user set</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"map"</span> <span class="attr">item</span>=<span class="string">"value"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">index</span>=<span class="string">"key"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        $&#123;key&#125; = #&#123;value&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    where id = #&#123;map.id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="扩展：bind用法"><a href="#扩展：bind用法" class="headerlink" title="扩展：bind用法"></a>扩展：bind用法</h3><p>bind可以使用OGNL表达式创建一个变量并将其绑定到上下文中。如：在模糊查询中可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserLike</span><span class="params">(@Param(<span class="string">"name"</span>)</span>String name)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserLike"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"'%' + name + '%'"</span>/&gt;</span></span><br><span class="line">   select * from user </span><br><span class="line">       where user_name like #&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-栈</title>
      <link href="/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88/"/>
      <url>/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="1-栈的一个实际需求"><a href="#1-栈的一个实际需求" class="headerlink" title="1.栈的一个实际需求"></a>1.栈的一个实际需求</h2><p>请输入一个表达式<br>计算式:[7*2*2-5+1-5+3-3]  点击计算</p><h2 id="2-栈的介绍"><a href="#2-栈的介绍" class="headerlink" title="2.栈的介绍"></a>2.栈的介绍</h2><ol><li>栈的英文为(stack)</li><li>栈是一个 <strong>先入后出</strong>(FILO-First In Last Out) 的有序列表。</li><li>栈(stack) 是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。 。 允许插入和删除的一端，为 <strong>变化的一端，称为栈顶(Top)</strong> ，另一端为 <strong>固定的一端，称为栈底(Bottom)</strong> 。</li><li>根据栈的定义可知 ， 最先放入栈中元素在栈底 ， 最后放入的元素在栈顶 ， 而删除元素刚好相反 ， 最后放入的元素最先删除，最先放入的元素最后删除</li><li>图解方式说明出栈(pop) 和入栈(push)</li></ol><h2 id="3-栈的应用场景"><a href="#3-栈的应用场景" class="headerlink" title="3.栈的应用场景"></a>3.栈的应用场景</h2><ol><li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。</li><li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆<br>栈中。</li><li>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</li><li>二叉树的遍历。</li><li>图形的深度优先(depth 一 first)搜索法。</li></ol><h2 id="4-数组实现栈"><a href="#4-数组实现栈" class="headerlink" title="4.数组实现栈"></a>4.数组实现栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试一下ArrayStack 是否正确</span></span><br><span class="line"><span class="comment">// 先创建一个ArrayStack对象-&gt;表示栈</span></span><br><span class="line">ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">String key = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">boolean</span> loop = <span class="keyword">true</span>; <span class="comment">// 控制是否退出菜单</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (loop) &#123;</span><br><span class="line">System.out.println(<span class="string">"show: 表示显示栈"</span>);</span><br><span class="line">System.out.println(<span class="string">"exit: 退出程序"</span>);</span><br><span class="line">System.out.println(<span class="string">"push: 表示添加数据到栈(入栈)"</span>);</span><br><span class="line">System.out.println(<span class="string">"pop: 表示从栈取出数据(出栈)"</span>);</span><br><span class="line">System.out.println(<span class="string">"请输入你的选择"</span>);</span><br><span class="line">key = scanner.next();</span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">stack.list();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">System.out.println(<span class="string">"请输入一个数"</span>);</span><br><span class="line"><span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">stack.push(value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"pop"</span>:</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = stack.pop();</span><br><span class="line">System.out.printf(<span class="string">"出栈的数据是 %d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">scanner.close();</span><br><span class="line">loop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"程序退出~~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">// 栈的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">// 用数组模拟栈，数据就放在 数组中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先判断是否满</span></span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line">stack[top] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line"><span class="keyword">new</span> RuntimeException(<span class="string">"栈空,没有数据~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> value = stack[top];</span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历显示栈 从栈顶开始显示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈空，没有数据~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">System.out.printf(<span class="string">"stack[%d]=%d\n"</span>, i, stack[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-栈实现综合计算器-中缀表达式"><a href="#5-栈实现综合计算器-中缀表达式" class="headerlink" title="5.栈实现综合计算器(中缀表达式)"></a>5.栈实现综合计算器(中缀表达式)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据前面的思路，完成表达式的运算</span></span><br><span class="line">String expression = <span class="string">"70+2*6-4"</span>;</span><br><span class="line"><span class="comment">// 定义两个栈 数栈 符号栈</span></span><br><span class="line">ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(<span class="number">20</span>);</span><br><span class="line">ArrayStack2 operStack = <span class="keyword">new</span> ArrayStack2(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 定义需要的相关变量</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 用于辅助扫描</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> oper = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">' '</span>;<span class="comment">// 将每次扫描得到的char保存到ch</span></span><br><span class="line">String keepNum = <span class="string">""</span>; <span class="comment">// 用于拼接 多位数</span></span><br><span class="line"><span class="comment">// 开始循环扫描expression</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 依次得到expression 的每一个字符</span></span><br><span class="line">ch = expression.charAt(index);</span><br><span class="line"><span class="comment">// 判断ch是什么，然后做相应的处理</span></span><br><span class="line"><span class="keyword">if</span> (operStack.isOper(ch)) &#123;</span><br><span class="line"><span class="comment">// 判断当前的符号栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (!operStack.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数</span></span><br><span class="line"><span class="comment">// 再从符号栈pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的操作符入符号栈</span></span><br><span class="line"><span class="keyword">if</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">num1 = numStack.pop();</span><br><span class="line">num2 = numStack.pop();</span><br><span class="line">oper = operStack.pop();</span><br><span class="line">res = numStack.cal(num1, num2, oper);</span><br><span class="line"><span class="comment">// 运算后把结果入数栈</span></span><br><span class="line">numStack.push(res);</span><br><span class="line"><span class="comment">// 把当前的操作符入符号栈</span></span><br><span class="line">operStack.push(ch);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果当前的操作符的优先级大于栈中的操作符，就直接入栈</span></span><br><span class="line">operStack.push(ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 若符号栈为空 直接入栈</span></span><br><span class="line">operStack.push(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 分析思路</span></span><br><span class="line"><span class="comment">// 1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span></span><br><span class="line"><span class="comment">// 2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line"><span class="comment">// 3. 因此我们需要定义一个变量 字符串，用于拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理多位数</span></span><br><span class="line">keepNum += ch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果ch已经是expression的最后一位，就直接入栈</span></span><br><span class="line"><span class="keyword">if</span> (index == expression.length() - <span class="number">1</span>) &#123;</span><br><span class="line">numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈</span></span><br><span class="line"><span class="comment">// 注意是看后一位，不是index++</span></span><br><span class="line"><span class="keyword">if</span> (operStack.isOper(expression.substring(index + <span class="number">1</span>, index + <span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line"><span class="comment">// 如果后一位是运算符，则入栈 keepNum = "1" 或者 "123"</span></span><br><span class="line">numStack.push(Integer.parseInt(keepNum));</span><br><span class="line"><span class="comment">// 重要的!!!!!!, keepNum清空</span></span><br><span class="line">keepNum = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让index加1 并判断是否扫描到expression最后</span></span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= expression.length()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当表达式扫描完毕，就顺序地从数栈和符号栈中 pop 出相应的数和符号 ，并运算</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 如果符号栈为空，则计算到最后的结果了 数栈中只有一个结果</span></span><br><span class="line"><span class="keyword">if</span> (operStack.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">num1 = numStack.pop();</span><br><span class="line">num2 = numStack.pop();</span><br><span class="line">oper = operStack.pop();</span><br><span class="line">res = numStack.cal(num1, num2, oper);</span><br><span class="line">numStack.push(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将数栈的最后数 pop 出 就是结果</span></span><br><span class="line"><span class="keyword">int</span> res2 = numStack.pop();</span><br><span class="line">System.out.printf(<span class="string">"表达式: %s = %d"</span>, expression, res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个栈</span></span><br><span class="line"><span class="comment">// 需要扩展一些功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack2</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">// 栈的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">// 用数组模拟栈，数据就放在 数组中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayStack2</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先判断是否满</span></span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line">stack[top] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line"><span class="keyword">new</span> RuntimeException(<span class="string">"栈空,没有数据~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> value = stack[top];</span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加一个方法 可以返回当前栈顶的值 但是不是pop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> stack[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历显示栈 从栈顶开始显示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈空，没有数据~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">System.out.printf(<span class="string">"stack[%d]=%d\n"</span>, i, stack[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回运算符的优先级，优先级是程序员来确定的，优先级使用数字表示</span></span><br><span class="line"><span class="comment">// 数字越大，则优先级就越高</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oper == <span class="string">'*'</span> || oper == <span class="string">'/'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">'+'</span> || oper == <span class="string">'-'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是不是一个运算符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val == <span class="string">'+'</span> || val == <span class="string">'-'</span> || val == <span class="string">'*'</span> || val == <span class="string">'/'</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">// 用于存放计算的结果</span></span><br><span class="line"><span class="keyword">switch</span> (oper) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">res = num1 + num2;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">res = num2 - num1; <span class="comment">// 注意运算顺序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">res = num1 * num2;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">res = num2 / num1; <span class="comment">// 顺序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-前缀、后缀、中缀表达式"><a href="#6-前缀、后缀、中缀表达式" class="headerlink" title="6.前缀、后缀、中缀表达式"></a>6.前缀、后缀、中缀表达式</h2><p>三种表达形式，分别为 前缀、后缀 、中缀 表达式。</p><h3 id="前缀表达式："><a href="#前缀表达式：" class="headerlink" title="前缀表达式："></a>前缀表达式：</h3><p>操作符写在操作数的前面，这种方法经常用在计算机上，特别是 编译器的设计。其特点是：从右往左扫描表达式，遇到数字就进栈，遇到操作符就就将将栈顶的两个数字出栈，并进行相应的操作运算，之后将运算结果再进栈。重复上面操作，直至扫描结束。</p><p>比如现在有 前缀表达式 ： -*+ABC/D+EF 。具体过程：</p><p>1.先将 E 和 F 进栈，扫描到 + 号，将 E 和 F 出栈并相加得到 (E+F),再将它进栈。</p><p>2.将 D 进栈，扫描到 / 号 将 D 和 （E+F）出栈，并进行 D/(E+F)运算，然后把结果进栈。</p><p>3.将 A B C 进栈，现在栈顶两个元素是 A 和 B ，扫描到 + 号，将 A B 出栈，并且 进行 A+B 运算，再进栈。</p><p>4.扫描到 * 号，现在栈顶两个元素是（A+B）和 C 所以进行 （A+B）*C 运算，再进栈。</p><p>5扫描到 - 号，此时栈顶两个元素是 （A+B）<em>C 和 D/(E+F)，出栈，进行（A+B）</em>C -D/(E+F)运算，再进栈。</p><p>6.扫描结束 所以运算结果是 （A+B）*C - D/(E+F)</p><h3 id="中缀表达式："><a href="#中缀表达式：" class="headerlink" title="中缀表达式："></a>中缀表达式：</h3><p>其实就是我们平时的算法表达式形式 比如上面的 （A+B）*C - D/(E+F) 就是中缀表达式。</p><h3 id="后缀表达式："><a href="#后缀表达式：" class="headerlink" title="后缀表达式："></a>后缀表达式：</h3><p>跟前缀表达式相反，它将数字写在操作符的前面。我们从左向右扫描即可。</p><p>例如 现在有 后缀表达式  AB+C*DEF+/-  。具体过程：</p><ol><li>A 和 B 进栈，扫描到 + 号，A B出栈并且进行 A+B操作运算，然后再进栈。</li><li>C 进栈，扫描到 * 号，出栈，进行 （A+B）*C操作，再进栈。</li><li>将D E F 进栈，扫描到 + 号 将 E 和 F出栈并且进行 E+F 操作，进栈。</li><li>扫描到 / 号 将 （E+F）和D出栈，进行 （E+F）/D 操作，再进栈</li><li>扫描到 - 号 ，将 （A+B）<em>C 和 （E+F）/D出栈，进行 （A+B）</em>C -（E+F）/D 运算，再进栈。</li><li>扫描结束，所以结果是 （A+B）*C -（E+F）/D</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-约瑟夫环</title>
      <link href="/2020/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
      <url>/2020/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述</strong>：编号为 1-N 的 N 个士兵围坐在一起形成一个圆圈，从编号为 1 的士兵开始依次报数（1，2，3…这样依次报），数到 m 的 士兵会被杀死出列，之后的士兵再从 1 开始报数。直到最后剩下一士兵，求这个士兵的编号。</p><h3 id="1、方法一：数组"><a href="#1、方法一：数组" class="headerlink" title="1、方法一：数组"></a>1、方法一：数组</h3><p>在大一第一次遇到这个题的时候，我是用数组做的，我猜绝大多数人也都知道怎么做。方法是这样的：</p><p>用一个数组来存放 1，2，3 … n 这 n 个编号，如图（这里我们假设n = 6, m = 3）</p><p><img data-src="3.png" alt="3.png"></p><p>然后不停着遍历数组，对于被选中的编号，我们就做一个标记，例如编号 arr[2] = 3 被选中了，那么我们可以做一个标记，例如让 arr[2] = -1，来表示 arr[2] 存放的编号已经出局的了。</p><p><img data-src="4.png" alt="4.png"></p><p>然后就按照这种方法，不停着遍历数组，不停着做标记，直到数组中只有一个元素是非 -1 的，这样，剩下的那个元素就是我们要找的元素了。</p><p><img data-src="5.png" alt="5.png"></p><p>这种方法简单吗？思路简单，但是编码却没那么简单，临界条件特别多，每次遍历到数组最后一个元素的时候，还得重新设置下标为 0，并且遍历的时候还得判断该元素时候是否是 -1。感兴趣的可以动手写一下代码，用这种数组的方式做，千万不要觉得很简单，编码这个过程还是挺考验人的。</p><p>这种做法的时间复杂度是 O(n * m), 空间复杂度是 O(n);</p><h3 id="2、方法二：环形链表"><a href="#2、方法二：环形链表" class="headerlink" title="2、方法二：环形链表"></a>2、方法二：环形链表</h3><p>学过链表的人，估计都会用链表来处理约瑟夫环问题，用链表来处理其实和上面处理的思路差不多，只是用链表来处理的时候，对于被选中的编号，不再是<strong>做标记</strong>，而是<strong>直接移除</strong>，因为从链表移除一个元素的时间复杂度很低，为 O(1)。当然，上面数组的方法你也可以采用移除的方式，不过数组移除的时间复杂度为 O(n)。所以采用链表的解决方法如下：</p><p>1、先创建一个环形链表来存放元素：</p><p><img data-src="1.png" alt="1.png"></p><p>2、然后一边遍历链表一遍删除，直到链表只剩下一个节点</p><p><img data-src="2.png" alt="2.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> date;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span> || n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">// 创建环形链表</span></span><br><span class="line">        Node head = createLinkedList(n);</span><br><span class="line">        <span class="comment">// 遍历删除</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;<span class="comment">//前驱节点</span></span><br><span class="line">        <span class="keyword">while</span> (head.next != head) &#123;</span><br><span class="line">            <span class="comment">// 删除节点</span></span><br><span class="line">            <span class="keyword">if</span> (count == m) &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">                cur = pre.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">createLinkedList</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Node tmp = <span class="keyword">new</span> Node(i);</span><br><span class="line">            next.next = tmp;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 头尾串联</span></span><br><span class="line">        next.next = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这种方法估计是最多人用的，时间复杂度为 O(n * m),空间复杂度是 O(n)。</p><h3 id="3、方法三：递归"><a href="#3、方法三：递归" class="headerlink" title="3、方法三：递归"></a>3、方法三：递归</h3><p>其实这道题还可以用递归来解决，递归是思路是<strong>每次我们删除了某一个士兵之后，我们就对这些士兵重新编号，然后我们的难点就是找出删除前和删除后士兵编号的映射关系</strong>。</p><p>我们定义递归函数 f(n，m) 的返回结果是存活士兵的编号，显然当 n = 1 时，f(n, m) = 1。假如我们能够找出 f(n，m) 和 f(n-1，m) 之间的关系的话，我们就可以用递归的方式来解决了。我们假设人员数为 n, 报数到 m 的人就自杀。则刚开始的编号为</p><p>…<br>1<br>…<br>m - 2</p><p>m - 1</p><p>m</p><p>m + 1</p><p>m + 2<br>…<br>n<br>…</p><p>进行了一次删除之后，删除了编号为 m 的节点。删除之后，就只剩下 n - 1 个节点了，删除前和删除之后的编号转换关系为：</p><p>删除前     —     删除后</p><p>…          —      …</p><p>m - 2     —     n - 2</p><p>m - 1    —      n - 1</p><p>m         —-    无(因为编号被删除了)</p><p>m + 1     —     1(因为下次就从这里报数了)</p><p>m + 2     —-     2</p><p>…         —-         …</p><p>新的环中只有 n - 1 个节点。且删除前编号为 m + 1, m + 2, m + 3 的节点成了删除后编号为 1， 2， 3 的节点。</p><p>假设 old 为删除之前的节点编号， new 为删除了一个节点之后的编号，则 old 与 new 之间的关系为 old = (new + m - 1) % n + 1。</p><p>这样，我们就得出 f(n, m) 与 f(n - 1, m)之间的关系了，而 f(1, m) = 1.所以我们可以采用递归的方式来做。代码如下：</p><p><strong>注</strong>：有些人可能会疑惑为什么不是 old = (new + m ) % n 呢？主要是因为编号是从 1 开始的，而不是从 0 开始的。如果 new + m == n的话，会导致最后的计算结果为 old = 0。所以 old = (new + m - 1) % n + 1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)   <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> (f(n - <span class="number">1</span>, m) + m - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两行代码搞定，而且时间复杂度是 O(n)，空间复杂度是O(1)，牛逼！那如果你想跟别人说，我想一行代码解决约瑟夫问题呢？答是没问题的，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? n : (f(n - <span class="number">1</span>, m) + m - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="另一版本约瑟夫"><a href="#另一版本约瑟夫" class="headerlink" title="另一版本约瑟夫"></a>另一版本约瑟夫</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Josephu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试一把看看构建环形链表，和遍历是否ok</span></span><br><span class="line">CircleSingleLinkedList circleSingleLinkedList = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">circleSingleLinkedList.addBoy(<span class="number">5</span>);<span class="comment">// 加入5个小孩节点</span></span><br><span class="line">circleSingleLinkedList.showBoy();</span><br><span class="line"><span class="comment">// 测试一把小孩出圈是否正确</span></span><br><span class="line">circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line"><span class="comment">// String str = "7*2*2-5+1-5+3-3";</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形的单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个fitst节点，当前没有编号</span></span><br><span class="line"><span class="keyword">private</span> Boy first = <span class="keyword">new</span> Boy(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加小孩节点，构建成一个环形链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 数据校验</span></span><br><span class="line"><span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"nums的值不正确"</span>.</span><br><span class="line">&#125;</span><br><span class="line">Boy curBoy = <span class="keyword">null</span>;<span class="comment">// 辅助指针，帮助构建环形链表</span></span><br><span class="line"><span class="comment">// 循环创建环形列表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line"><span class="comment">// 根据编号，创建小孩节点</span></span><br><span class="line">Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line"><span class="comment">// 如果是第一个小孩</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">first = boy;</span><br><span class="line">first.setNext(first);<span class="comment">// 构成环</span></span><br><span class="line">curBoy = first;<span class="comment">// 让curBoy指向第一个小孩</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">curBoy.setNext(boy);</span><br><span class="line">boy.setNext(first);</span><br><span class="line">curBoy = boy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"没有任何小孩~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">Boy curBoy = first;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">"小孩的编号 %d \n"</span>, curBoy.getNo());</span><br><span class="line"><span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">// 说明已经遍历完毕</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curBoy = curBoy.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startNo</span></span><br><span class="line"><span class="comment"> *            表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> countNum</span></span><br><span class="line"><span class="comment"> *            表示数几下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> *            表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先对数据校验</span></span><br><span class="line"><span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">System.out.println(<span class="string">"参数输入有误， 请重新输入"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建要给辅助指针,帮助完成小孩出圈</span></span><br><span class="line">Boy helper = first;</span><br><span class="line"><span class="comment">// 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (helper.getNext() == first) &#123;<span class="comment">// 说明helper指向最后小孩节点</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">helper = helper.getNext();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小孩报数前，先让 first 和 helper 移动 k - 1次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startNo - <span class="number">1</span>; i++) &#123;</span><br><span class="line">first = first.getNext();</span><br><span class="line">helper = helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当小孩报数时，让first 和 helper 指针同时 的移动 m - 1 次, 然后出圈</span></span><br><span class="line"><span class="comment">// 这里是一个循环操作，知道圈中只有一个节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (helper == first) &#123;<span class="comment">// 说明圈中只有一人</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让 first 和 helper 指针同时 的移动 countNum - 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countNum - <span class="number">1</span>; j++) &#123;</span><br><span class="line">first = first.getNext();</span><br><span class="line">helper = helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时first指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">System.out.printf(<span class="string">"小孩%d出圈\n"</span>, first.getNo());</span><br><span class="line"><span class="comment">// 这时将first指向的小孩节点出圈</span></span><br><span class="line">first = first.getNext();</span><br><span class="line">helper.setNext(first);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">"最后留在圈中的小孩编号%d \n"</span>, first.getNo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;<span class="comment">// 编号</span></span><br><span class="line"><span class="keyword">private</span> Boy next; <span class="comment">// 指向下一个节点,默认null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-双向链表</title>
      <link href="/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>双向链表的每一个结点都有一条指向其后继结点的next链和一条指向其前结点的pre链。双向链表既可以从第一项开始遍历也可以从最后一项开始往前遍历，双向链表可以用下图表示：</p><p><img data-src="1.png" alt="1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">System.out.println(<span class="string">"双向链表的测试"</span>);</span><br><span class="line"><span class="comment">// 先创建节点</span></span><br><span class="line">HeroNode2 hero1 = <span class="keyword">new</span> HeroNode2(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">HeroNode2 hero2 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">HeroNode2 hero3 = <span class="keyword">new</span> HeroNode2(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">HeroNode2 hero4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"><span class="comment">// 创建一个双向链表</span></span><br><span class="line">DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line"><span class="comment">// doubleLinkedList.add(hero1);</span></span><br><span class="line"><span class="comment">// doubleLinkedList.add(hero2);</span></span><br><span class="line"><span class="comment">// doubleLinkedList.add(hero3);</span></span><br><span class="line"><span class="comment">// doubleLinkedList.add(hero4);</span></span><br><span class="line"></span><br><span class="line">doubleLinkedList.addByOrder(hero4);</span><br><span class="line">doubleLinkedList.addByOrder(hero3);</span><br><span class="line">doubleLinkedList.addByOrder(hero2);</span><br><span class="line">doubleLinkedList.addByOrder(hero1);</span><br><span class="line"></span><br><span class="line">doubleLinkedList.list();</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">HeroNode2 newHeroNode = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"公孙胜"</span>, <span class="string">"入云龙"</span>);</span><br><span class="line">doubleLinkedList.update(newHeroNode);</span><br><span class="line">System.out.println(<span class="string">"修改后的链表情况"</span>);</span><br><span class="line">doubleLinkedList.list();</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"删除后的链表情况~~"</span>);</span><br><span class="line">doubleLinkedList.list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个双向链表的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双向链表中删除一个节点</span></span><br><span class="line"><span class="comment">// 说明：对于双向链表 可以直接找到要删除的这个节点，找到后自我删除即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断当前链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空，不能删除"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助指针</span></span><br><span class="line">HeroNode2 temp = head.next;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 已经到链表最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">temp.pre.next = temp.next;</span><br><span class="line"><span class="comment">// 如果是最后一个节点就不需要执行下面这行代码 否则空指针</span></span><br><span class="line"><span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">temp.next.pre = temp.pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>, no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeroNode2 temp = head.next;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line"><span class="comment">// 找到位置</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">temp.name = newHeroNode.name;</span><br><span class="line">temp.nickname = newHeroNode.nickname;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个节点到双向链表的最后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line">HeroNode2 temp = head;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出while循环 ，temp就指向了链表的最后</span></span><br><span class="line"><span class="comment">// 形成一个双向链表</span></span><br><span class="line">temp.next = heroNode;</span><br><span class="line">heroNode.pre = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">// (如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line"><span class="comment">// 因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span></span><br><span class="line">HeroNode2 temp = head;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">// 位置找到了</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">flag = <span class="keyword">true</span>;<span class="comment">// 说明编号存在S</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;<span class="comment">// 否则后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断flag 的值</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123; <span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">System.out.printf(<span class="string">"准备插入的英雄的编号 %d 已经存在了, 不能加入\n"</span>, heroNode.no);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 插入到链表中, temp的后面</span></span><br><span class="line"><span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">heroNode.next = temp.next;</span><br><span class="line">temp.next.pre = heroNode;</span><br><span class="line">&#125;</span><br><span class="line">heroNode.pre = temp;</span><br><span class="line">temp.next = heroNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">HeroNode2 temp = head.next;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(temp);</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HeroNode2节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String nickname;</span><br><span class="line"><span class="keyword">public</span> HeroNode2 next; <span class="comment">// 指向下一个节点</span></span><br><span class="line"><span class="keyword">public</span> HeroNode2 pre; <span class="comment">// 指向前一个节点</span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了显示方法，我们重新toString</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode2 [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span> + nickname + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解 ThreadPoolExecutor 的参数含义及源码执行流程？</title>
      <link href="/2020/03/20/ThreadPoolExecutor-%E7%9A%84%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89%E5%8F%8A%E6%BA%90%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/03/20/ThreadPoolExecutor-%E7%9A%84%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89%E5%8F%8A%E6%BA%90%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="第04讲：详解-ThreadPoolExecutor的参数含义及源码执行流程？"><a href="#第04讲：详解-ThreadPoolExecutor的参数含义及源码执行流程？" class="headerlink" title="第04讲：详解 ThreadPoolExecutor的参数含义及源码执行流程？"></a>第04讲：详解 ThreadPoolExecutor的参数含义及源码执行流程？</h2><p>线程池是为了避免线程频繁的创建和销毁带来的性能消耗，而建立的一种池化技术，它是把已创建的线程放入“池”中，当有任务来临时就可以重用已有的线程，无需等待创建的过程，这样就可以有效提高程序的响应速度。但如果要说线程池的话一定离不开ThreadPoolExecutor，在阿里巴巴的《Java 开发手册》中是这样规定线程池的：<br>线程池不允许使用Executors 去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>说明：Executors 返回的线程池对象的弊端如下：<br>1）FixedThreadPool和 SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。<br>2）Cached ThreadPool 和ScheduledThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。<br>其实当我们去看Executors的源码会发现，Executors.newFixedThreadPool0、<br>Executors.newSingle ThreadExecutor）和Executors.newCachedThreadPool0等方法的底层都是通过ThreadPoolExecutor 实现的，所以本课时我们就重点来了解一下ThreadPoolExecutor的相关知识，比如它有哪些核心的参数？它是如何工作的？</p><h3 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h3><p>ThreadPoolExecutor的核心参数指的是它在构建时需要传递的参数，其构造方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        <span class="comment">// maximumPoolSize 必须大于 0，且必须大于 corePoolSize</span></span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span>?<span class="keyword">null</span>:AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第1个参数：<strong>corePoolSize</strong> 表示线程池的常驻核心线程数。如果设置为0，则表示在没有任何任务时，销毁线程池；如果大于0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程（创建和销毁的原因会在本课时的下半部分讲到）；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值。</p><p>第2个参数：<strong>maximumPoolSize</strong>表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于0，也必须大于等于corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到。</p><p>第3个参数：<strong>keepAliveTime</strong>表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于corePoolSize为止，如果maximumPoolSize等于corePoolSize，那么线程池在空闲的时候也不会销毁任何线程。</p><p>第4个参数：<strong>unit</strong> 表示存活时间的单位，它是配合keepAliveTime参数共同使用的。</p><p>第5个参数：<strong>workQueue</strong>表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行。</p><p>第6个参数：<strong>threadFactory</strong>表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Executors.defaultThreadFactory() 为默认的线程创建工厂 </span></span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认的线程创建工厂，需要实现 ThreadFactory 接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">    </span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">        Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">            poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">"-thread-"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon()) </span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>); <span class="comment">// 创建一个非守护线程</span></span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY); <span class="comment">// 线程优先级设置为默认值</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以自定义一个线程工厂，通过实现<strong>ThreadFactory</strong> 接口来完成，这样就可以自定义线程的名称或线程执行的优先级了。<br>第7个参数：<strong>RejectedExecutionHandler</strong> 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。<br>线程池的工作流程要从它的执行方法<strong>execute()</strong>说起，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前工作的线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 创建新的线程执行此任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查线程池是否处于运行状态，如果是则把任务添加到队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再出检查线程池是否处于运行状态，防止在第一次校验通过后线程池关闭</span></span><br><span class="line">        <span class="comment">// 如果是非运行状态，则将刚加入队列的任务移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池的线程数为 0 时（当 corePoolSize 设置为 0 时会发生）    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 新建线程执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 核心线程都在忙且队列都已爆满，尝试新启动一个线程执行失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) </span><br><span class="line">        <span class="comment">// 执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<strong>addWorker(Runnable firstTask，boolean core)</strong>方法的参数说明如下：</p><ul><li><strong>firstTask</strong>，线程应首先运行的任务，如果没有则可以设置为null；</li><li><strong>core</strong>，判断是否可以创建线程的阀值（最大值），如果等于true则表示使用corePoolSize作为阀值，false 则表示使用maximumPoolSize作为阀值。</li></ul><p><strong>考点分析</strong><br>本课时的这道面试题考察的是你对于线程池和ThreadPoolExecutor的掌握程度，也属于Java的基础知识，几乎所有的面试都会被问到，其中线程池任务执行的主要流程，可以参考以下流程图：</p><p><img data-src="1.png" alt="1.png"></p><p>与ThreadPoolExecutor 相关的面试题还有以下几个：</p><ul><li>ThreadPoolExecutor的执行方法有几种？它们有什么区别？</li><li>什么是线程的拒绝策略？</li><li>拒绝策略的分类有哪些？</li><li>如何自定义拒绝策略？</li><li>ThreadPoolExecutor 能不能实现扩展？如何实现扩展？</li></ul><h3 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h3><h4 id="execute（）VS-submit（）"><a href="#execute（）VS-submit（）" class="headerlink" title="execute（）VS submit（）"></a>execute（）VS submit（）</h4><p>execute(）和submit(）都是用来执行线程池任务的，它们最主要的区别是，submit）方法可以接收线程池执行的返回值，而 execute0不能接收返回值。<br>来看两个方法的且体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10L</span>,                                                    TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">20</span>));</span><br><span class="line"><span class="comment">// execute 使用</span></span><br><span class="line">executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, execute."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// submit 使用</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, submit."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><p>Hello，submit.</p><p>Hello，execute.</p><p>Success</p><p>从以上结果可以看出submit()方法可以配合Futrue来接收线程执行的返回值。它们的另一个区别是<br>execute()方法属于Executor 接口的方法，而submit()方法则是属于ExecutorService接口的方法，它们的继承关系如下图所示：</p><p><img data-src="2.png" alt="2.png"></p><h4 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h4><p>当线程池中的任务队列已经被存满，再有任务添加时会先判断当前线程池中的线程数是否大于等于线程池的最大值，如果是，则会触发线程池的拒绝策略。</p><p>Java自带的拒绝策略有4种：</p><ul><li>AbortPolicy，终止策略，线程池会抛出异常并终止执行，它是默认的拒绝策略；</li><li>CallerRunsPolicy，把任务交给当前线程来执行；</li><li>DiscardPolicy，忽略此任务（最新的任务）；</li><li>DiscardOldestPolicy，忽略最早的任务（最先加入队列的任务）。</li></ul><p>例如，我们来演示一个AbortPolicy的拒绝策略，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>,                                                    TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),                                          <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()); <span class="comment">// 添加 AbortPolicy 拒绝策略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果：<br>pool-1-thread-1<br>pool-1-thread-1<br>pool-1-thread-1<br>pool-1-thread-3<br>pool-1-thread-2<br>Exception in thread”main”java.util.concurrent.RejectedExecutionException:Task com.lagou.interview.ThreadPoolExample$$Lambda$1/1096979270@448139f0 rejected from java.util.concurrent.ThreadPoolExecutor@7cca494b[Running，pool size=3，active threads=<br>3，queued tasks=2，completed tasks=0]</p><p>at<br>java. util. concurrent. ThreadPoolExecutor$AbortPolicy. rejectedExecution(ThreadPoolExecutorj ava:2063)<br>at java. util. concurrent. ThreadPoolExecutor. reject(ThreadPoolExecutor java:830)<br>at java. util. concurrent. ThreadPoolExecutor. execute(ThreadPoolExecutor, java:1379)<br>at com. lagou. interview. ThreadPoolExample. rejected(ThreadPoolExample. java:35)<br>at com. lagou. interview. ThreadPoolExample. main(ThreadPoolExample, java:26)</p><p>可以看出当第6个任务来的时候，线程池则执行了AbortPolicy 拒绝策略，抛出了异常。因为队列最多存储2个任务，最大可以创建3个线程来执行任务（2+3=5），所以当第6个任务来的时候，此线程池就“忙”不过来了。</p><h4 id="自定义拒绝策略"><a href="#自定义拒绝策略" class="headerlink" title="自定义拒绝策略"></a>自定义拒绝策略</h4><p>自定义拒绝策略只需要新建一个RejectedExecutionHandler对象，然后重写它的<br>rejectedExecution0方法即可，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>,                                              TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">                   <span class="keyword">new</span> RejectedExecutionHandler() &#123;  <span class="comment">// 添加自定义拒绝策略</span></span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 业务处理方法</span></span><br><span class="line">                     System.out.println(<span class="string">"执行自定义拒绝策略"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行的结果如下：</p><p>执行自定义拒绝策略<br>pool-1-thread-2</p><p>pool-1-thread-3</p><p>pool-1-thread-1</p><p>pool-1-thread-1</p><p>pool-1-thread-2<br>可以看出线程池执行了自定义的拒绝策略，我们可以在rejectedExecution中添加自己业务处理的代码。</p><h4 id="ThreadPoolExecutor-扩展"><a href="#ThreadPoolExecutor-扩展" class="headerlink" title="ThreadPoolExecutor 扩展"></a>ThreadPoolExecutor 扩展</h4><p>ThreadPoolExecutor 的扩展主要是通过重写它的beforeExecute）和afterExecute0方法实现的，我们可以在扩展方法中添加日志或者实现数据统计，比如统计线程的执行时间，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExtend</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span>&#123;</span><br><span class="line">      <span class="comment">// 线程池扩展调用</span></span><br><span class="line">        MyThreadPoolExecutor executor = <span class="keyword">new</span> MyThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">                     TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                Thread.currentThread().getName();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池扩展</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存线程执行开始时间</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; localTime = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 开始执行之前</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> t 线程</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">            Long sTime = System.nanoTime(); <span class="comment">// 开始时间 (单位：纳秒)</span></span><br><span class="line">            localTime.set(sTime);</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s | before | time=%s"</span>,</span><br><span class="line">                    t.getName(), sTime));</span><br><span class="line">            <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行完成之后</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> t 抛出的异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">            Long eTime = System.nanoTime(); <span class="comment">// 结束时间 (单位：纳秒)</span></span><br><span class="line">            Long totalTime = eTime - localTime.get(); <span class="comment">// 执行总时间</span></span><br><span class="line">            System.out.println(String.format(<span class="string">"%s | after | time=%s | 耗时：%s 毫秒"</span>,                          Thread.currentThread().getName(), eTime, (totalTime / <span class="number">1000000.0</span>)));</span><br><span class="line">            <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果如下所示：</p><p>pool-1-thread-1|before l time=4570298843700</p><p>pool-1-thread-2|before ltime=4570298840000</p><p>pool-1-thread-1|afterl time=4570327059500|耗时：28.2158毫秒</p><p>pool-1-thread-2l afterltime=4570327138100|耗时：28.2981毫秒</p><p>pool-1-thread-1|before ltime=4570328467800</p><p>pool-1-thread-1| after| time=4570328636800|耗时：0.169毫秒</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>最后我们总结一下：线程池的使用必须要通过 ThreadPoolExecutor 的方式来创建，这样才可以更加明确线程池的运行规则，规避资源耗尽的风险。同时，也介绍了ThreadPoolExecutor的七大核心参数，包括核心线程数和最大线程数之间的区别，当线程池的任务队列没有可用空间且线程池的线程数量已经达到了最大线程数时，则会执行拒绝策略，Java自动的拒绝策略有4种，用户也可以通过重写rejectedExecution() 来自定义拒绝策略，我们还可以通过重写beforeExecute0和afterExecute0来实现ThreadPoolExecutor的扩展功能。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】关联映射</title>
      <link href="/2020/03/20/MyBatis%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/20/MyBatis%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="一对一映射"><a href="#一对一映射" class="headerlink" title="一对一映射"></a>一对一映射</h2><p>在某网络购物系统中，一个用户只能拥有一个购物车，用户与购物车的关系可以设计为一对一关系</p><h3 id="数据库表结构（唯一外键关联）"><a href="#数据库表结构（唯一外键关联）" class="headerlink" title="数据库表结构（唯一外键关联）"></a>数据库表结构（唯一外键关联）</h3><p><img data-src="1.png" alt="1.png"></p><h3 id="创建两个实体类和映射接口"><a href="#创建两个实体类和映射接口" class="headerlink" title="创建两个实体类和映射接口"></a>创建两个实体类和映射接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> ShoppingCart shoppingCart;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> user_id;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现根据用户id查询出所有用户信息，包括该用户的购物车信息"><a href="#实现根据用户id查询出所有用户信息，包括该用户的购物车信息" class="headerlink" title="实现根据用户id查询出所有用户信息，包括该用户的购物车信息"></a>实现根据用户id查询出所有用户信息，包括该用户的购物车信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserAndShoppingCartById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyBatis中处理一对一关联关系"><a href="#MyBatis中处理一对一关联关系" class="headerlink" title="MyBatis中处理一对一关联关系"></a>MyBatis中处理一对一关联关系</h3><h4 id="方式一：使用自动映射处理一对一关系，也就是通过别名自动将值匹配到对应的字段上"><a href="#方式一：使用自动映射处理一对一关系，也就是通过别名自动将值匹配到对应的字段上" class="headerlink" title="方式一：使用自动映射处理一对一关系，也就是通过别名自动将值匹配到对应的字段上"></a>方式一：使用自动映射处理一对一关系，也就是通过别名自动将值匹配到对应的字段上</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndShoppingCartById"</span> <span class="attr">resultType</span>=<span class="string">"top.hiasenna.entity.User"</span>&gt;</span></span><br><span class="line">select u.id,username,password,sc.cart_id "shoppingCart.id",price "shoppingCart.price"</span><br><span class="line">from user u </span><br><span class="line">left join shoppingcart sc on u.id=sc.user_id</span><br><span class="line">where u.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复杂的属性映射时，可以多层嵌套，比如将shopping_cart表中的cart_id字段映射到shoppingCart.id属性上</p><h4 id="方式二：在XML映射文件中配置结果映射"><a href="#方式二：在XML映射文件中配置结果映射" class="headerlink" title="方式二：在XML映射文件中配置结果映射"></a>方式二：在XML映射文件中配置结果映射</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"top.hiasenna.entity.User"</span> <span class="attr">id</span>=<span class="string">"userShoppingCartMap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"shoppingCart.id"</span> <span class="attr">column</span>=<span class="string">"cart_id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"shoppingCart.price"</span> <span class="attr">column</span>=<span class="string">"price"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndShoppingCartById2"</span> <span class="attr">resultMap</span>=<span class="string">"userShoppingCartMap"</span>&gt;</span></span><br><span class="line">select u.id, u.username, u.password,</span><br><span class="line">s.cart_id, s.price</span><br><span class="line">from user u</span><br><span class="line">left join shoppingcart s on u.id = s.user_id</span><br><span class="line">where u.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用这种方式同自动映射方式相似之处为，ShoppingCart中的属性配置部分使用了”shoppingCart.”前缀</p><h4 id="方式三：association元素用于和一个复杂的类型进行关联"><a href="#方式三：association元素用于和一个复杂的类型进行关联" class="headerlink" title="方式三：association元素用于和一个复杂的类型进行关联"></a>方式三：association元素用于和一个复杂的类型进行关联</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"top.hiasenna.entity.User"</span> <span class="attr">id</span>=<span class="string">"userShoppingCartMap2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"shoppingCart"</span> <span class="attr">javaType</span>=<span class="string">"top.hiasenna.entity.ShoppingCart"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"cart_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"price"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndShoppingCartById3"</span> <span class="attr">resultMap</span>=<span class="string">"userShoppingCartMap2"</span>&gt;</span></span><br><span class="line">select u.id,u.username, u.password,s.cart_id, s.price</span><br><span class="line">from user u</span><br><span class="line">left join</span><br><span class="line">shoppingcart s on u.id = s.user_id</span><br><span class="line">where u.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>association元素包含以下属性</p><ul><li>property：对应实体类中的属性名，必填项</li><li>javaType：属性对应的java类型，可选项</li><li>resultMap：可以直接使用现有的resultMap，而不需要在这里配置，可选项</li></ul><h4 id="方式四：association元素的嵌套查询"><a href="#方式四：association元素的嵌套查询" class="headerlink" title="方式四：association元素的嵌套查询"></a>方式四：association元素的嵌套查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"top.hiasenna.entity.User"</span> <span class="attr">id</span>=<span class="string">"userShoppingCartMap3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"shoppingCart"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">column</span>=<span class="string">"&#123;user_id=id&#125;"</span> <span class="attr">select</span>=<span class="string">"top.hiasenna.mapper.ShoppingCartMapper.findShoppingCartById"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>association元素的嵌套查询常用的属性如下</p><ul><li>select：另一个查询映射的statement id，MyBatis会额外执行这个查询获取嵌套对象</li><li>column：列名，将主查询中列的结果作为嵌套查询的参数，如column=“{prop1=col1,prop2=col2}”，其中prop1和prop2将作为嵌套查询的参数</li><li>fetchType：数据加载方式，可选值为lazy和eager，分别为延迟加载和积极加载，会覆盖全局的lazyLoadingEnable配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndShoppingCartById4"</span> <span class="attr">resultMap</span>=<span class="string">"userShoppingCartMap3"</span>&gt;</span></span><br><span class="line">select id,</span><br><span class="line">username, password</span><br><span class="line">from user </span><br><span class="line">where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>此处查询语句只包含user表，购物车信息需要在ShoppingCartMapper.xml中配置findShoppingCartById方法进行查询</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"top.hiasenna.entity.ShoppingCart"</span> <span class="attr">id</span>=<span class="string">"shoppingCartMap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"cart_id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"price"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findShoppingCartById"</span> <span class="attr">resultMap</span>=<span class="string">"shoppingCartMap"</span>&gt;</span></span><br><span class="line">select * from shoppingcart where user_id=#&#123;user_id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>嵌套查询会多执行SQL，当查询N条数据时，就会出现N+1次查询问题</p><p>为了解决N+1次查询问题，可以设置延迟加载策略，将association元素的fetchType属性设置为lazy</p><p>在MyBatis主配置文件中有两个延时加载相关settings设置</p><table><thead><tr><th align="center"><strong>设置项</strong></th><th align="center"><strong>描述</strong></th><th align="center"><strong>有效值</strong></th><th align="center"><strong>默认值</strong></th></tr></thead><tbody><tr><td align="center"><strong>lazyLoadingEnabled</strong></td><td align="center"><strong>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 可通过设置fetchType属性来覆盖该项的开关状态</strong></td><td align="center"><strong>true |false</strong></td><td align="center"><strong>false</strong></td></tr><tr><td align="center"><strong>aggressiveLazyLoading</strong></td><td align="center"><strong>当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载</strong></td><td align="center"><strong>true |false</strong></td><td align="center"><strong>false</strong></td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置为延迟加载的对象，默认情况下，当调用该对象的equals、hashCode、toString、clone方法时，就会加载该对象的全部数据</p><h4 id="对比四种方式"><a href="#对比四种方式" class="headerlink" title="对比四种方式"></a>对比四种方式</h4><ul><li>前面的三种方式都属于“关联的嵌套结果映射“,即通过一次SQL查询根据表或指定的属性映射到不同的对象中</li><li>最后一种方式属于“关联的嵌套查询”，利用简单的SQL语句，通过多次查询得到想要的结果，可实现延迟加载效果</li></ul><h2 id="一对多关联映射"><a href="#一对多关联映射" class="headerlink" title="一对多关联映射"></a>一对多关联映射</h2><h3 id="MyBatis中处理一对多关联关系"><a href="#MyBatis中处理一对多关联关系" class="headerlink" title="MyBatis中处理一对多关联关系"></a>MyBatis中处理一对多关联关系</h3><h4 id="方式一：与association类似，集合的嵌套结果映射就是指通过一次SQL查询得到所有的结果"><a href="#方式一：与association类似，集合的嵌套结果映射就是指通过一次SQL查询得到所有的结果" class="headerlink" title="方式一：与association类似，集合的嵌套结果映射就是指通过一次SQL查询得到所有的结果"></a>方式一：与association类似，集合的嵌套结果映射就是指通过一次SQL查询得到所有的结果</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.User"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong>由于此映射会频繁用到，可以将其单独配置，后面可以直接通过id引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.User"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"userAndOrderListMap"</span> <span class="attr">extends</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderList"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">ofType</span>=<span class="string">"com.mybatis.entity.Order"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"order_id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"price"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>resultMap元素中的extends属性可以实现结果映射的继承</li><li>collection的ofType属性指定集合中元素的类型，必选项</li></ul><p>查询映射配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndOrderListById"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">resultMap</span>=<span class="string">"userAndOrderListMap"</span>&gt;</span></span><br><span class="line">    select u.id, u.user_name, u.password,</span><br><span class="line">    o.order_id, o.price</span><br><span class="line">    from user u</span><br><span class="line">    left join orders o on u.id = o.user_id</span><br><span class="line">    where u.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="方式二：集合的嵌套查询同样会执行额外的SQL查询"><a href="#方式二：集合的嵌套查询同样会执行额外的SQL查询" class="headerlink" title="方式二：集合的嵌套查询同样会执行额外的SQL查询"></a>方式二：集合的嵌套查询同样会执行额外的SQL查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.User"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"userAndOrderListMap"</span> <span class="attr">extends</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderList"</span> <span class="attr">column</span>=<span class="string">"&#123;uid=id&#125;"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ofType</span>=<span class="string">"com.mybatis.entity.Order"</span>       <span class="attr">select</span>=<span class="string">"com.mybatis.mapper.OrderMapper.findOrdersByUserId"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndOrderListById"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">resultMap</span>=<span class="string">"userAndOrderListMap"</span>&gt;</span></span><br><span class="line">    select * from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>OrderMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.Order"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"orderMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"order_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"price"</span> <span class="attr">column</span>=<span class="string">"price"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOrdersByUserId"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">resultMap</span>=<span class="string">"orderMap"</span>&gt;</span></span><br><span class="line">    select * from orders where user_id = #&#123;uid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="对比两种方式"><a href="#对比两种方式" class="headerlink" title="对比两种方式"></a>对比两种方式</h4><ul><li>第一种方式属于“关联的嵌套结果映射“,即通过一次SQL查询根据表或指定的属性映射到不同的对象中</li><li>第二种方式属于“关联的嵌套查询”，利用简单的SQL语句，通过多次查询得到想要的结果，也可以实现延迟加载效果</li></ul><h2 id="鉴别器映射"><a href="#鉴别器映射" class="headerlink" title="鉴别器映射"></a>鉴别器映射</h2><ul><li>有时一个单独的数据库查询会返回很多种不同数据类型的结果集。discriminator鉴别器元素可以用来处理这种情况</li><li>以Hibernate中继承映射为例</li></ul><p><img data-src="2.png" alt="2.png"></p><p>数据库表结构</p><p><img data-src="3.png" alt="3.png"></p><h4 id="创建实体类（省略）、映射接口和映射文件"><a href="#创建实体类（省略）、映射接口和映射文件" class="headerlink" title="创建实体类（省略）、映射接口和映射文件"></a>创建实体类（省略）、映射接口和映射文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">findEmployeeById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.Employee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">"EmployeeMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用resultMap的extends属性来映射两个子类的属性"><a href="#使用resultMap的extends属性来映射两个子类的属性" class="headerlink" title="使用resultMap的extends属性来映射两个子类的属性"></a>使用resultMap的extends属性来映射两个子类的属性</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.HourlyEmployee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"HourlyMap"</span> <span class="attr">extends</span>=<span class="string">"EmployeeMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"rate"</span> <span class="attr">column</span>=<span class="string">"rate"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.SalariedEmployee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"SalaryMap"</span> <span class="attr">extends</span>=<span class="string">"EmployeeMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"salary"</span> <span class="attr">column</span>=<span class="string">"salary"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用discriminator元素映射employee-type字段"><a href="#使用discriminator元素映射employee-type字段" class="headerlink" title="使用discriminator元素映射employee_type字段"></a>使用discriminator元素映射employee_type字段</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.Employee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">"selectMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">column</span>=<span class="string">"employee_type"</span>   </span></span><br><span class="line"><span class="tag">        <span class="attr">javaType</span>=<span class="string">"String"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"HE"</span> <span class="attr">resultMap</span>=<span class="string">"HourlyMap"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"SE"</span> <span class="attr">resultMap</span>=<span class="string">"SalaryMap"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>discriminator元素常用的两个属性如下：</p><ul><li>column：该属性用于设置需要进行鉴别比较值的列</li><li>javaType：该属性用于指定列的类型</li></ul><p>discriminator元素可以有1个或者多个case子元素，case元素包含三个属性</p><ul><li>value：该值用来匹配column指定字段的值</li><li>resultMap：当value值和column的值匹配时的结果映射，优先级高于resultType</li><li>resultType：当value值和column的值匹配时的结果类型</li></ul>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-单链表</title>
      <link href="/2020/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="链表-Linked-List-介绍"><a href="#链表-Linked-List-介绍" class="headerlink" title="链表(Linked List)介绍"></a>链表(Linked List)介绍</h2><p>链表是有序的列表，但是它在内存中是存储如下</p><p><img data-src="1.png" alt="1.png"></p><ol><li>链表是以节点的方式来存储,</li><li>每个节点包含 data 域， next 域：指向下一个节点</li><li>如图：发现<strong>链表的各个节点不一定是连续存储</strong></li><li>链表分 <strong>带头节点的链表和 没有头节点的链表</strong>，根据实际的需求来确定</li></ol><h2 id="单链表的应用实例"><a href="#单链表的应用实例" class="headerlink" title="单链表的应用实例"></a>单链表的应用实例</h2><p>使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建要给链表</span></span><br><span class="line">SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入</span></span><br><span class="line"><span class="comment">// singleLinkedList.add(hero1);</span></span><br><span class="line"><span class="comment">// singleLinkedList.add(hero4);</span></span><br><span class="line"><span class="comment">// singleLinkedList.add(hero2);</span></span><br><span class="line"><span class="comment">// singleLinkedList.add(hero3);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入按照编号的顺序</span></span><br><span class="line">singleLinkedList.addByOrder(hero1);</span><br><span class="line">singleLinkedList.addByOrder(hero4);</span><br><span class="line">singleLinkedList.addByOrder(hero2);</span><br><span class="line">singleLinkedList.addByOrder(hero3);</span><br><span class="line"></span><br><span class="line">singleLinkedList.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试修改节点的代码</span></span><br><span class="line"><span class="comment">// HeroNode newHeroNode = new HeroNode(2, "小卢", "玉麒麟~~");</span></span><br><span class="line"><span class="comment">// singleLinkedList.update(newHeroNode);</span></span><br><span class="line"><span class="comment">// 显示一把</span></span><br><span class="line"><span class="comment">// singleLinkedList.list();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个节点</span></span><br><span class="line">singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line">singleLinkedList.del(<span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">"删除后的链表情况~~"</span>);</span><br><span class="line">singleLinkedList.list();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义SingleLinkedList 管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回头节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加节点到单向链表</span></span><br><span class="line"><span class="comment">// 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">// 1. 找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">// 2. 将最后这个节点的next 指向 新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="comment">// 找到链表的最后</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有找到最后, 将将temp后移</span></span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line"><span class="comment">// 将最后这个节点的next 指向 新的节点</span></span><br><span class="line">temp.next = heroNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">// (如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line"><span class="comment">// 因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span></span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">// 位置找到了</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">flag = <span class="keyword">true</span>;<span class="comment">// 说明编号存在S</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;<span class="comment">// 否则后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断flag 的值</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123; <span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">System.out.printf(<span class="string">"准备插入的英雄的编号 %d 已经存在了, 不能加入\n"</span>, heroNode.no);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 插入到链表中, temp的后面</span></span><br><span class="line">heroNode.next = temp.next;</span><br><span class="line">temp.next = heroNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改节点的信息，根据no编号来修改，即no编号不能改</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. 根据 newHeroNode 的 no 来修改即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到需要修改的节点, 根据no编号</span></span><br><span class="line"><span class="comment">// 定义一个辅助变量</span></span><br><span class="line">HeroNode temp = head.next;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 表示是否找到该节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">// 遍历完链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line"><span class="comment">// 找到节点了</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据flag 判断是否找到要修改的节点</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="comment">// 更新信息</span></span><br><span class="line">temp.name = newHeroNode.name;</span><br><span class="line">temp.nickname = newHeroNode.nickname;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line"><span class="comment">// 2. 说明我们在比较时，是temp.next.no 和 需要删除的节点的no比较</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 已经到链表的最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line"><span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">temp.next = temp.next.next;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>, no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示链表[遍历]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">HeroNode temp = head.next;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 判断是否到链表最后</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出节点的信息</span></span><br><span class="line">System.out.println(temp);</span><br><span class="line"><span class="comment">// 将temp后移， 一定小心</span></span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HeroNode节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String nickname;</span><br><span class="line"><span class="keyword">public</span> HeroNode next; <span class="comment">// 指向下一个节点</span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了显示方法，我们重新toString</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span> + nickname + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="1-获取到单链表的节点的个数-如果是带头结点的链表，需求不统计头节点"><a href="#1-获取到单链表的节点的个数-如果是带头结点的链表，需求不统计头节点" class="headerlink" title="1.获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)"></a>1.获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment"> *            </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 空链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">HeroNode node = head.next;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">length++;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-查找单链表中的倒数第k个结点-【新浪面试题】"><a href="#2-查找单链表中的倒数第k个结点-【新浪面试题】" class="headerlink" title="2.查找单链表中的倒数第k个结点 【新浪面试题】"></a>2.查找单链表中的倒数第k个结点 【新浪面试题】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 1. 编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">// 2. index 表示是倒数第index个节点</span></span><br><span class="line"><span class="comment">// 3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span></span><br><span class="line"><span class="comment">// 4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span></span><br><span class="line"><span class="comment">// 5. 如果找到了，则返回该节点，否则返回nulll</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 空链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size = getLength(head);</span><br><span class="line"><span class="comment">// 第二次遍历 size-index 位置，就是我们倒数的第K个节点</span></span><br><span class="line"><span class="comment">// 先做一个index的校验</span></span><br><span class="line"><span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-将单链表反转"><a href="#3-将单链表反转" class="headerlink" title="3. 将单链表反转"></a>3. 将单链表反转</h4><p><img data-src="3.png" alt="3.png"></p><h5 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line">HeroNode next = <span class="keyword">null</span>;<span class="comment">// 指向当前节点[cur]的下一个节点</span></span><br><span class="line">HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">// 遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span></span><br><span class="line"><span class="comment">// 动脑筋</span></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">next = cur.next;<span class="comment">// 先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">cur.next = reverseHead.next;<span class="comment">// 将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">reverseHead.next = cur; <span class="comment">// 将cur 连接到新的链表上</span></span><br><span class="line">cur = next;<span class="comment">// 让cur后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将head.next 指向 reverseHead.next , 实现单链表的反转</span></span><br><span class="line">head.next = reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式2：从尾到头打印单链表-Stack-栈"><a href="#方式2：从尾到头打印单链表-Stack-栈" class="headerlink" title="方式2：从尾到头打印单链表[Stack 栈]"></a>方式2：从尾到头打印单链表[Stack 栈]</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//空链表，不能打印</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建要给一个栈，将各个节点压入栈</span></span><br><span class="line">Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;HeroNode&gt;();</span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line"><span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">stack.push(cur);</span><br><span class="line">cur=cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"><a href="#4-将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。" class="headerlink" title="4.将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"></a>4.将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 类似归并排序中的合并过程</span></span><br><span class="line">        <span class="comment">//虚拟头结点</span></span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任一为空，直接连接另一条链表</span></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur.next = l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-环形队列</title>
      <link href="/2020/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/"/>
      <url>/2020/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h2><h3 id="分析示意图"><a href="#分析示意图" class="headerlink" title="分析示意图"></a>分析示意图</h3><p><img data-src="1.png" alt="1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试一把</span></span><br><span class="line">System.out.println(<span class="string">"测试数组模拟环形队列的案例~~~"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形队列</span></span><br><span class="line">CircleArray queue = <span class="keyword">new</span> CircleArray(<span class="number">4</span>); <span class="comment">// 说明设置4, 其队列的有效数据最大是3</span></span><br><span class="line"><span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">// 接收用户输入</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line"><span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 输出一个菜单</span></span><br><span class="line"><span class="keyword">while</span> (loop) &#123;</span><br><span class="line">System.out.println(<span class="string">"s(show): 显示队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"e(exit): 退出程序"</span>);</span><br><span class="line">System.out.println(<span class="string">"a(add): 添加数据到队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"g(get): 从队列取出数据"</span>);</span><br><span class="line">System.out.println(<span class="string">"h(head): 查看队列头的数据"</span>);</span><br><span class="line">key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">// 接收一个字符</span></span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">queue.showQueue();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">System.out.println(<span class="string">"输出一个数"</span>);</span><br><span class="line"><span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">queue.addQueue(value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'g'</span>: <span class="comment">// 取出数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">// 查看队列头的数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>: <span class="comment">// 退出</span></span><br><span class="line">scanner.close();</span><br><span class="line">loop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line"><span class="comment">// front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素</span></span><br><span class="line"><span class="comment">// front 的初始值 = 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line"><span class="comment">// rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span></span><br><span class="line"><span class="comment">// rear 的初始值 = 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"><span class="comment">// 创建队列的构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">maxSize = maxsize;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">front = <span class="number">0</span>;</span><br><span class="line">rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据到队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列已满，不能加入数据"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[rear] = n;</span><br><span class="line"><span class="comment">// 将 rear 后移, 这里必须考虑取模</span></span><br><span class="line">rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列的数据，出队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 通过抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，不能取数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里需要分析出 front是指向队列的第一个元素</span></span><br><span class="line"><span class="comment">// 1. 先把 front 对应的值保留到一个临时变量</span></span><br><span class="line"><span class="comment">// 2. 将 front 后移, 考虑取模</span></span><br><span class="line"><span class="comment">// 3. 将临时保存的变量返回</span></span><br><span class="line"><span class="keyword">int</span> value = arr[front];</span><br><span class="line">front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size(); i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出当前队列有效数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// rear = 2</span></span><br><span class="line"><span class="comment">// front = 1</span></span><br><span class="line"><span class="comment">// maxSize = 3</span></span><br><span class="line"><span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程的状态有哪些？它是如何工作的？</title>
      <link href="/2020/03/19/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
      <url>/2020/03/19/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>线程（Thread）是并发编程的基础，也是程序执行的最小单元，它依托进程而存在。一个进程中可以包含多个线程，多线程可以共享一块内存空间和一组系统资源，因此线程之间的切换更加节省资源、<br>更加轻量化，也因此被称为轻量级的进程。</p><p>当然，线程也是面试中常被问到的一个知识点，是程序员必备的基础技能，使用它可以有效地提高程序的整体运行速度。</p><p>本课时的面试问题是，线程的状态有哪些？它是如何工作的？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>线程的状态在JDK1.5之后以枚举的方式被定义在Thread的源码中，它总共包含以下6个状态：</p><ul><li>NEW，新建状态，线程被创建出来，但尚未启动时的线程状态；</li><li>RUNNABLE，就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配CPU资源；</li><li>BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行synchronized代码块或者使用synchronized标记的方法；</li><li>WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了Object.wait0方法，那它就在等待另一个线程调用Object.notify0或<br>Object.notifyAll0方法；</li><li>TIMED WAITING，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法Object.wait（long timeout）和Thread.join（long timeout）等这些方法时，它才会进入此状态；</li><li>TERMINATED，终止状态，表示线程已经执行完成。</li></ul><p>线程状态的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建状态，线程被创建出来，但尚未启动时的线程状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 就绪状态，表示可以运行的线程状态，但它在排队等待来自操作系统的 CPU 资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞等待锁的线程状态，表示正在处于阻塞状态的线程</span></span><br><span class="line"><span class="comment">     * 正在等待监视器锁，比如等待执行 synchronized 代码块或者</span></span><br><span class="line"><span class="comment">     * 使用 synchronized 标记的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作。</span></span><br><span class="line"><span class="comment">     * 例如，一个线程调用了 Object.wait() 它在等待另一个线程调用</span></span><br><span class="line"><span class="comment"> * Object.notify() 或 Object.notifyAll()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计时等待状态，和等待状态 (WAITING) 类似，只是多了超时时间，比如</span></span><br><span class="line"><span class="comment">     * 调用了有超时时间设置的方法 Object.wait(long timeout) 和 </span></span><br><span class="line"><span class="comment">     * Thread.join(long timeout) 就会进入此状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 终止状态，表示线程已经执行完成</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>线程的工作模式是，首先先要创建线程并指定线程需要执行的业务方法，然后再调用线程的 start()方法，此时线程就从NEW（新建）状态变成了RUNNABLE（就绪）状态，此时线程会判断要执行的方法中有没有synchronized同步代码块，如果有并且其他线程也在使用此锁，那么线程就会变为<br>BLOCKED（阻塞等待）状态，当其他线程使用完此锁之后，线程会继续执行剩余的方法。</p><p>当遇到Object.wait()或Thread.join()方法时，线程会变为WAITING（等待状态）状态，如果是带了超时时间的等待方法，那么线程会进入TIMED WAITING（计时等待）状态，当有其他线程执行了<br>notify()或notifyAll()方法之后，线程被唤醒继续执行剩余的业务方法，直到方法执行完成为止，此时整个线程的流程就执行完了，执行流程如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p><strong>考点分析</strong></p><p>线程一般会作为并发编程的起始问题，用于引出更多的关于并发编程的面试问题。当然对于线程的掌握程度也决定了你对并发编程的掌握程度，通常面试官还会问：</p><ul><li><p>BLOCKED（阻塞等待）和WAITING（等待）有什么区别？</p></li><li><p>start()方法和run()方法有什么区别？</p></li><li><p>线程的优先级有什么用？该如何设置？</p></li><li><p>线程的常用方法有哪些？</p><p>接下来我们一起来看这些问题的答案。</p></li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-BLOCKED和WAITING的区别"><a href="#1-BLOCKED和WAITING的区别" class="headerlink" title="1.BLOCKED和WAITING的区别"></a>1.BLOCKED和WAITING的区别</h3><p>虽然BLOCKED和WAITING都有等待的含义，但二者有着本质的区别，首先它们状态形成的调用方法不同，其次BLOCKED可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；而WAITING则是因为自身调用了Object.wait()或着是Thread.join()又或者是LockSupport.park()而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了Object.wait()而进入WAITING状态之后，则需要等待另一个线程执行<br>Object.notify()或Object.notifyAll()才能被唤醒。</p><h3 id="2-start-和run-的区别"><a href="#2-start-和run-的区别" class="headerlink" title="2.start()和run()的区别"></a>2.start()和run()的区别</h3><p>首先从Thread 源码来看，start()方法属于Thread 自身的方法，并且使用了synchronized来保证线程安全，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态验证，不等于 NEW 的状态会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    <span class="comment">// 通知线程组，此线程即将启动</span></span><br><span class="line">group.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">// 不处理任何异常，如果 start0 抛出异常，则它将被传递到调用堆栈上</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run()方法为Runnable的抽象方法，必须由调用类重写此方法，重写的run()方法其实就是此线程要执行的业务方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 忽略其他方法......</span></span><br><span class="line">  <span class="keyword">private</span> Runnable target;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">          target.run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从执行的效果来说，start()方法可以开启多线程，让线程从NEW状态转换成RUNNABLE状态，而<br>run()方法只是一个普通的方法。</p><p>其次，它们可调用的次数不同，start()方法不能被多次调用，否则会抛出<br>java.lang.llegalStateException；而 run()方法可以进行多次调用，因为它只是一个普通的方法而已。</p><h3 id="3-线程优先级"><a href="#3-线程优先级" class="headerlink" title="3.线程优先级"></a>3.线程优先级</h3><p>在Thread 源码中和线程优先级相关的属性有3个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程可以拥有的最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程可以拥有的最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>线程的优先级可以理解为线程抢占CPU时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。<br>在程序中我们可以通过Thread.setPriority()来设置优先级，setPriority()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="comment">// 先验证优先级的合理性</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优先级如果超过线程组的最高优先级，则把优先级设置为线程组的最高优先级</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-线程的常用方法"><a href="#4-线程的常用方法" class="headerlink" title="4.线程的常用方法"></a>4.线程的常用方法</h3><p>线程的常用方法有以下几个。</p><h4 id="（1）join-）"><a href="#（1）join-）" class="headerlink" title="（1）join(）"></a>（1）join(）</h4><p>在一个线程中调用other.join()，这时候当前线程会让出执行权给other线程，直到other 线程执行完或者过了超时时间之后再继续执行当前线程，join()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 超时时间不能小于 0</span></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等于 0 表示无限等待，直到线程执行完为之</span></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断子线程 (其他线程) 为活跃线程，则一直等待</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 循环判断</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出join()方法底层还是通过wait()方法来实现的。<br>例如，在未使用join()时，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程睡眠："</span> + i + <span class="string">"秒。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start(); <span class="comment">// 开启线程</span></span><br><span class="line">        <span class="comment">// 主线程执行</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">             System.out.println(<span class="string">"主线程睡眠："</span> + i + <span class="string">"秒。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：<br>主线程睡眠：1秒。<br>子线程睡眠：1秒。<br>主线程睡眠：2秒。<br>子线程睡眠：2秒。<br>主线程睡眠：3秒。<br>子线程睡眠：3秒。<br>子线程睡眠：4秒。<br>子线程睡眠：5秒。<br>从结果可以看出，在未使用join()时主子线程会交替执行。<br>然后我们再把join()方法加入到代码中，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程睡眠："</span> + i + <span class="string">"秒。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start(); <span class="comment">// 开启线程</span></span><br><span class="line">        thread.join(<span class="number">2000</span>); <span class="comment">// 等待子线程先执行 2 秒钟</span></span><br><span class="line">        <span class="comment">// 主线程执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"主线程睡眠："</span> + i + <span class="string">"秒。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：<br>子线程睡眠：1秒。<br>子线程睡眠：2秒。<br>主线程睡眠：1秒。/∥thread.join(2000)；等待2秒之后，主线程和子线程再交替执行子线程睡眠：3秒。<br>主线程睡眠：2秒。<br>子线程睡眠：4秒。<br>子线程睡眠：5秒。<br>主线程睡眠：3秒。<br>从执行结果可以看出，添加join()方法之后，主线程会先等子线程执行2秒之后才继续执行。</p><h4 id="（2）yield"><a href="#（2）yield" class="headerlink" title="（2）yield()"></a>（2）yield()</h4><p>看Thread的源码可以知道 yield()为本地方法，也就是说yield()是由C或C++实现的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>yield()方法表示给线程调度器一个当前线程愿意出让CPU使用权的暗示，但是线程调度器可能会忽略这个暗示。<br>比如我们执行这段包含了yield()方法的代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程："</span> +</span><br><span class="line">                        Thread.currentThread().getName() + <span class="string">" I："</span> + i);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(runnable, <span class="string">"T1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(runnable, <span class="string">"T2"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把这段代码执行多次之后会发现，每次执行的结果都不相同，这是因为yield()执行非常不稳定，线程调度器不一定会采纳 yield()出让CPU使用权的建议，从而导致了这样的结果。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-队列</title>
      <link href="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/"/>
      <url>/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="数组模拟队列思路"><a href="#数组模拟队列思路" class="headerlink" title="数组模拟队列思路"></a>数组模拟队列思路</h2><p><img data-src="1.png" alt="1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQArrayQueueDemoueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试一把</span></span><br><span class="line"><span class="comment">// 创建一个队列</span></span><br><span class="line">ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">// 接收用户输入</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line"><span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 输出一个菜单</span></span><br><span class="line"><span class="keyword">while</span> (loop) &#123;</span><br><span class="line">System.out.println(<span class="string">"s(show): 显示队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"e(exit): 退出程序"</span>);</span><br><span class="line">System.out.println(<span class="string">"a(add): 添加数据到队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"g(get): 从队列取出数据"</span>);</span><br><span class="line">System.out.println(<span class="string">"h(head): 查看队列头的数据"</span>);</span><br><span class="line">key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">// 接收一个字符</span></span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">queue.showQueue();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">System.out.println(<span class="string">"输出一个数"</span>);</span><br><span class="line"><span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">queue.addQueue(value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'g'</span>: <span class="comment">// 取出数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">// 查看队列头的数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>: <span class="comment">// 退出</span></span><br><span class="line">scanner.close();</span><br><span class="line">loop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front; <span class="comment">// 队列头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"><span class="comment">// 创建队列的构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSize = maxsize;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">front = -<span class="number">1</span>;<span class="comment">// 指向队列头部，分析出front是指向队列头的前一个位置.</span></span><br><span class="line">rear = -<span class="number">1</span>;<span class="comment">// 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据到队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列已满，不能加入数据"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">rear++;</span><br><span class="line">arr[rear] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列的数据，出队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 通过抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，不能取数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line">front++;</span><br><span class="line"><span class="keyword">return</span> arr[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议和三次握手四次挥手</title>
      <link href="/2020/03/18/TCPIP%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2020/03/18/TCPIP%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>在计算机网络的基本概念中，分层次的体系结构是最基本的。计算机网络体系结构的抽象概念较多，在学习时要多思考。这些概念对后面的学习很有帮助。</p><h3 id="网络协议是什么？"><a href="#网络协议是什么？" class="headerlink" title="网络协议是什么？"></a>网络协议是什么？</h3><p>在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p><h3 id="为什么要对网络协议分层？"><a href="#为什么要对网络协议分层？" class="headerlink" title="为什么要对网络协议分层？"></a>为什么要对网络协议分层？</h3><ul><li>简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。</li><li>灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。</li><li>易于实现和维护。</li><li>促进标准化工作。分开后，每层功能可以相对简单地被描述。</li></ul><p>网络协议分层的缺点： 功能可能出现在多个层里，产生了额外开销。</p><p>为了使不同体系结构的计算机网络都能互联，国际标准化组织 ISO 于1977年提出了一个试图使各种计算机在世界范围内互联成网的标准框架，即著名的开放系统互联基本参考模型 OSI/RM，简称为OSI。</p><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用，TCP/IP 体系结构则不同，但它现在却得到了非常广泛的应用。TCP/IP 是一个四层体系结构，它包含应用层，运输层，网际层和网络接口层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题），不过从实质上讲，TCP/IP 只有最上面的三层，因为最下面的网络接口层并没有什么具体内容，因此在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚，有时为了方便，也可把最底下两层称为网络接口层。</p><p>四层协议，五层协议和七层协议的关系如下：</p><ul><li>TCP/IP是一个四层的体系结构，主要包括：应用层、运输层、网际层和网络接口层。</li><li>五层协议的体系结构主要包括：应用层、运输层、网络层，数据链路层和物理层。</li><li>OSI七层协议模型主要包括是：应用层（Application）、表示层（Presentation）、会话层（Session）、运输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</li></ul><p><img data-src="1.png" alt="1.png"></p><p>注：五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p><h2 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p><p>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的<strong>数据传输服务</strong>。应用进程利用该服务传送应用层报文。</p><p>运输层主要使用一下两种协议</p><ol><li>传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。</li><li>用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li></ol><table><thead><tr><th align="center"></th><th align="center"><strong>UDP</strong></th><th align="center"><strong>TCP</strong></th></tr></thead><tbody><tr><td align="center">是否连接</td><td align="center">无连接</td><td align="center">面向连接</td></tr><tr><td align="center">是否可靠</td><td align="center">不可靠传输，不使用流量控制和拥塞控制</td><td align="center">可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="center">连接对象个数</td><td align="center">支持一对一，一对多，多对一和多对多交互通信</td><td align="center">只能是一对一通信</td></tr><tr><td align="center">传输方式</td><td align="center">面向报文</td><td align="center">面向字节流</td></tr><tr><td align="center">首部开销</td><td align="center">首部开销小，仅8字节</td><td align="center">首部最小20字节，最大60字节</td></tr><tr><td align="center">场景</td><td align="center">适用于实时应用（IP电话、视频会议、直播等）</td><td align="center">适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><p><strong>每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</strong></p><p>运行在<code>TCP协议</code>上的协议:</p><ul><li><code>HTTP（Hypertext Transfer Protocol，超文本传输协议)</code>，主要用于普通浏览。</li><li><code>HTTPS（HTTP over SSL，安全超文本传输协议）</code>,HTTP协议的安全版本。</li><li><code>FTP（File Transfer Protocol，文件传输协议）</code>，用于文件传输。</li><li><code>POP3（Post Office Protocol, version 3，邮局协议</code>），收邮件用。</li><li><code>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</code>，用来发送电子邮件。</li><li><code>TELNET（Teletype over the Network，网络电传</code>），通过一个终端（terminal）登陆到网络。</li><li><code>SSH（Secure Shell，用于替代安全性差的TELNET）</code>，用于加密安全登陆用。</li></ul><p>运行在<code>UDP协议</code>上的协议：</p><ul><li><code>BOOTP（Boot Protocol，启动协议）</code>，应用于无盘设备。</li><li><code>NTP（Network Time Protocol，网络时间协议）</code>，用于网络同步。</li><li><code>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）</code>，动态配置IP地址。</li></ul><p>运行在<code>TCP</code>和<code>UDP</code>协议上：</p><ul><li><code>DNS（Domain Name Service，域名服务）</code>，用于完成地址查找，邮件转发等工作。</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p><p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。</p><p>一般的web应用的通信传输流是这样的：</p><p><img data-src="2.jpg" alt="2.jpg"></p><p>发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><h3 id="TCP-IP-协议族-1"><a href="#TCP-IP-协议族-1" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h3><p>在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族。</p><p><img data-src="3.jpg" alt="3.jpg"></p><p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。因为该协定家族的两个核心协定：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。</p><p>划重点：</p><p><code>TCP（传输控制协议）和IP（网际协议）</code> 是最先定义的两个核心协议，所以才统称为<code>TCP/IP协议族</code></p><h2 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h2><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。</p><p><strong>通过三次握手建立一个链接，通过四次挥手来关闭一个连接</strong>。</p><p><strong>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据</strong>。</p><h3 id="TCP报文的头部结构"><a href="#TCP报文的头部结构" class="headerlink" title="TCP报文的头部结构"></a>TCP报文的头部结构</h3><p>在了解TCP连接之前先来了解一下TCP报文的头部结构。</p><p><img data-src="4.jpg" alt="4.jpg"></p><p>上图中有几个字段需要重点介绍下：</p><p>（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p><p>（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。</p><p>（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p><ul><li>ACK：确认序号有效。</li><li>FIN：释放一个连接。</li><li>PSH：接收方应该尽快将这个报文交给应用层。</li><li>RST：重置连接。</li><li>SYN：发起一个新连接。</li><li>URG：紧急指针（urgent pointer）有效。</li></ul><p>需要注意的是：</p><ul><li>不要将确认序号ack与标志位中的ACK搞混了。</li><li>确认方ack=发起方seq+1，两端配对。</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><code>三次握手的本质是确认通信双方收发数据的能力</code></p><p>首先，我让信使运输一份信件给对方，<strong>对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的</strong>。</p><p>于是他给我回信，<strong>我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以</strong>。</p><p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，<strong>他若收到了，他便清楚了他的发件能力和我的收件能力是可以的</strong>。</p><p>这，就是三次握手，这样说，你理解了吗？</p><p><img data-src="5.jpg" alt="5.jpg"></p><ul><li><code>第一次握手</code>：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。</li><li><code>第二次握手</code>：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</li><li><code>第三次握手</code>：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><code>四次挥手的目的是关闭一个连接</code></p><p><img data-src="6.jpg" alt="6.jpg"></p><p>比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p><ul><li><code>第一次挥手</code>：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</li><li><code>第二次挥手</code>：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</li><li><code>第三次挥手</code>：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。</li><li><code>第四次挥手</code>：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</li></ul><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="为什么TCP连接的时候是3次？2次不可以吗？"><a href="#为什么TCP连接的时候是3次？2次不可以吗？" class="headerlink" title="为什么TCP连接的时候是3次？2次不可以吗？"></a>为什么TCP连接的时候是3次？2次不可以吗？</h3><p>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p><p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p><h3 id="为什么TCP连接的时候是3次，关闭的时候却是4次？"><a href="#为什么TCP连接的时候是3次，关闭的时候却是4次？" class="headerlink" title="为什么TCP连接的时候是3次，关闭的时候却是4次？"></a>为什么TCP连接的时候是3次，关闭的时候却是4次？</h3><p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p><h3 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h3><p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h3 id="什么是HTTP，HTTP-与-HTTPS-的区别"><a href="#什么是HTTP，HTTP-与-HTTPS-的区别" class="headerlink" title="什么是HTTP，HTTP 与 HTTPS 的区别"></a>什么是HTTP，HTTP 与 HTTPS 的区别</h3><p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</p><table><thead><tr><th>·······</th><th align="center">HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>协议</td><td align="center">运行在 TCP 之上，明文传输，<strong>客户端与服务器端都无法验证对方的身份</strong></td><td>身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， <strong>是添加了加密和认证机制的 HTTP</strong>。</td></tr><tr><td>端口</td><td align="center">80</td><td>443</td></tr><tr><td>资源消耗</td><td align="center">较少</td><td>由于加解密处理，会消耗更多的 CPU 和内存资源</td></tr><tr><td>开销</td><td align="center">无需证书</td><td>需要证书，而证书一般需要向认证机构购买</td></tr><tr><td>加密机制</td><td align="center">无</td><td>共享密钥加密和公开密钥加密并用的混合加密机制</td></tr><tr><td>安全性</td><td align="center">弱</td><td>由于加密机制，安全性强</td></tr></tbody></table><h3 id="常用HTTP状态码"><a href="#常用HTTP状态码" class="headerlink" title="常用HTTP状态码"></a>常用HTTP状态码</h3><p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</p><p>状态码的类别：</p><table><thead><tr><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码） 接受的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码） 请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码） 需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码） 服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码） 服务器处理请求出错</td></tr></tbody></table><p>常用HTTP状态码：</p><table><thead><tr><th>2XX</th><th>成功（这系列表明请求被正常处理了）</th></tr></thead><tbody><tr><td>200</td><td>OK，表示从客户端发来的请求在服务器端被正确处理</td></tr><tr><td>204</td><td>No content，表示请求成功，但响应报文不含实体的主体部分</td></tr><tr><td>206</td><td>Partial Content，进行范围请求成功</td></tr></tbody></table><table><thead><tr><th>3XX</th><th>重定向（表明浏览器要执行特殊处理）</th></tr></thead><tbody><tr><td>301</td><td>moved permanently，永久性重定向，表示资源已被分配了新的 URL</td></tr><tr><td>302</td><td>found，临时性重定向，表示资源临时被分配了新的 URL</td></tr><tr><td>303</td><td>see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求）</td></tr><tr><td>304</td><td>not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）</td></tr><tr><td>307</td><td>temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</td></tr></tbody></table><table><thead><tr><th>4XX</th><th>客户端错误</th></tr></thead><tbody><tr><td>400</td><td>bad request，请求报文存在语法错误</td></tr><tr><td>401</td><td>unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</td></tr><tr><td>403</td><td>forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述</td></tr><tr><td>404</td><td>not found，表示在服务器上没有找到请求的资源</td></tr></tbody></table><table><thead><tr><th>5XX</th><th>服务器错误</th></tr></thead><tbody><tr><td>500</td><td>internal sever error，表示服务器端在执行请求时发生了错误</td></tr><tr><td>501</td><td>Not Implemented，表示服务器不支持当前请求所需要的某个功能</td></tr><tr><td>503</td><td>service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</td></tr></tbody></table><h3 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h3><p>说道GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。</p><p>HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。</p><p>HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理解为，对服务器资源的查，改，增，删。</p><ul><li>GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。</li><li>POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。</li><li>PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。</li><li>DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。</li></ul><p><strong>GET和POST区别</strong></p><ol><li><p>Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。</p></li><li><p>Get请求提交的url中的数据最多只能是2048字节，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。</p></li><li><p>Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。</p></li><li><p>Get执行效率却比Post方法好。Get是form提交的默认方法。</p></li><li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p></li></ol><h3 id="什么是对称加密与非对称加密"><a href="#什么是对称加密与非对称加密" class="headerlink" title="什么是对称加密与非对称加密"></a>什么是对称加密与非对称加密</h3><p>对称密钥加密是指加密和解密使用同一个密钥的方式，<strong>这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</strong></p><p>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。<br>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢。</p><h3 id="什么是HTTP2"><a href="#什么是HTTP2" class="headerlink" title="什么是HTTP2"></a>什么是HTTP2</h3><p>HTTP2 可以提高了网页的性能。</p><p>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六个），当在请求很多资源的时候，由于队头阻塞当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。</p><p>HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。</p><h3 id="Session、Cookie和Token的主要区别"><a href="#Session、Cookie和Token的主要区别" class="headerlink" title="Session、Cookie和Token的主要区别"></a>Session、Cookie和Token的主要区别</h3><p>HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。</p><p><strong>什么是cookie</strong></p><p>cookie是由Web服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。</p><p><strong>什么是session</strong></p><p>session是依赖Cookie实现的。session是服务器端对象</p><p>session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认为浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输 cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p><p><strong>cookie与session区别</strong></p><ul><li>存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；</li><li>存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制</li><li>占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li></ul><p><strong>什么是Token</strong></p><p>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p><p>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p><p>使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p><p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</p><p><strong>session与token区别</strong></p><ul><li>session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；</li><li>session存储在服务器端，token存储在客户端</li><li>token提供认证和授权功能，作为身份认证，token安全性比session好；</li><li>session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</li></ul><h3 id="Servlet是线程安全的吗"><a href="#Servlet是线程安全的吗" class="headerlink" title="Servlet是线程安全的吗"></a>Servlet是线程安全的吗</h3><p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong></p><p>解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。</p><p>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p><h3 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h3><p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求<strong>HttpServletRequest</strong>，在<strong>doGet()</strong>，<strong>doPost()中做相应的处理，并将回应HttpServletResponse</strong>反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。</p><p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p><ul><li><p><strong>void init(ServletConfig config) throws ServletException</strong></p></li><li><p><strong>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</strong></p></li><li><p><strong>void destory()</strong></p></li><li><p>java.lang.String getServletInfo()</p></li><li><p>ServletConfig getServletConfig()</p></li></ul><p><strong>生命周期：</strong></p><p><strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；</p><p>请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；</p><p>当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。</p><p><strong>init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p><h3 id="如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="如果客户端禁止 cookie 能实现 session 还能用吗？"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h3><p>Cookie 与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。</p><p>但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</p><p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p><ol><li>手动通过URL传值、隐藏表单传递Session ID。</li><li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】的CRUD操作</title>
      <link href="/2020/03/18/MyBatis%E7%9A%84CRUD%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/03/18/MyBatis%E7%9A%84CRUD%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="动态代理机制"><a href="#动态代理机制" class="headerlink" title="动态代理机制"></a>动态代理机制</h3><h4 id="MyBatis和数据库的交互有两种方式："><a href="#MyBatis和数据库的交互有两种方式：" class="headerlink" title="MyBatis和数据库的交互有两种方式："></a>MyBatis和数据库的交互有两种方式：</h4><h5 id="使用传统的MyBatis提供的API"><a href="#使用传统的MyBatis提供的API" class="headerlink" title="使用传统的MyBatis提供的API"></a>使用传统的MyBatis提供的API</h5><p>使用传统的MyBatis提供的API ，需要传递Statement Id 和查询参数给 SqlSession 对象，MyBatis 提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作</p><h5 id="使用Mapper接口"><a href="#使用Mapper接口" class="headerlink" title="使用Mapper接口"></a>使用Mapper接口</h5><p>使用Mapper接口，MyBatis 将配置文件中的每一个&lt;mapper&gt; 元素抽象为一个 Mapper 接口，而这个接口中声明的方法和&lt;mapper&gt; 元素中的&lt;select|update|delete|insert&gt; 子元素相对应</p><h4 id="为什么Mapper接口中的抽象方法，没有自己定义实现类却能被正常调用呢？"><a href="#为什么Mapper接口中的抽象方法，没有自己定义实现类却能被正常调用呢？" class="headerlink" title="为什么Mapper接口中的抽象方法，没有自己定义实现类却能被正常调用呢？"></a>为什么Mapper接口中的抽象方法，没有自己定义实现类却能被正常调用呢？</h4><ul><li>MyBatis在Mapper接口上使用了动态代理</li><li>代理机制是Java中常用的设计模式，分为静态代理和动态代理。</li></ul><p><strong>静态代理</strong>：在程序编译时已经将接口、代理类和被代理类等确定下来</p><p><strong>动态代理</strong>：代理类在程序运行期间动态创建</p><h4 id="Java中动态代理的实现"><a href="#Java中动态代理的实现" class="headerlink" title="Java中动态代理的实现"></a>Java中动态代理的实现</h4><p>在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p><p><img data-src="1.png" alt="1.png"></p><ul><li>通过sqlSession.getMapper(XXXMapper.class) 方法，MyBatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个Mapper 实例</li><li>使用Mapper 接口的某一个方法时，MyBatis 会调用MapperProxy类的invoke()方法</li><li>底层还是通过SqlSession的select、update、delete、insert等方法来实现对数据库的操作</li></ul><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><h4 id="单条插入"><a href="#单条插入" class="headerlink" title="单条插入"></a>单条插入</h4><p>在映射器接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>在映射文件中添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">    insert into USER(id,user_name,password) </span><br><span class="line">    values(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;) </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>insert元素，用于映射插入语句</strong></p><ul><li>id属性：命名空间中的唯一标识符，为Mapper接口中的方法名</li><li>parameterType：指定了方法的参数类型，为可选项可以省略</li><li>元素的内容为插入的SQL语句</li><li>#{id}：MyBatis SQL中使用预编译参数的一种方式，当实际参数为JavaBean对象时，大括号中的id是其属性名</li></ul><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">User u = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"张三"</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">int</span> num = userMapper.insert(u);</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><p><strong>insert方法的返回值num是执行插入语句所影响的行数</strong></p><h4 id="使用JDBC方式返回主键自增的值"><a href="#使用JDBC方式返回主键自增的值" class="headerlink" title="使用JDBC方式返回主键自增的值"></a>使用JDBC方式返回主键自增的值</h4><ul><li>如果数据库设计时，主键字段为自动增长，那么需要插入的User对象的id属性值可以为null</li><li>如果想在执行插入操作以后返回表中的主键值，需要在映射文件中insert元素中加上如下两个属性</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    insert into USER(id,user_name,password) </span><br><span class="line">    values(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;) </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>useGeneratedKeys属性仅对 insert 和 update 有用，这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键</li><li>keyProperty  属性仅对 insert 和 update 有用，唯一标记一个属性，获得的主键值将会赋值给该属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = userMapper.insert(u);</span><br><span class="line">System.out.println(u.getId());</span><br></pre></td></tr></table></figure><h4 id="使用selectKey返回主键的值"><a href="#使用selectKey返回主键的值" class="headerlink" title="使用selectKey返回主键的值"></a>使用selectKey返回主键的值</h4><p>对于一些不提供主键自增功能的数据库，如Oracle，需要使用selectKey标签来获取主键的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    insert into USER(id,user_name,password) </span><br><span class="line">    values(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;) </span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">order</span>=<span class="string">"AFTER"</span>&gt;</span></span><br><span class="line">        SELECT LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>keyProperty属性表示主键所对应的属性名</p></li><li><p>resultType属性用于设置返回值类型</p></li><li><p>在MySQL中order属性设置为after，表示当前记录的主键值在insert语句执行成功后才能获取到，Oracle中设置为before</p></li><li><p>selectKey元素中的内容是一个独立的SQL语句，在MySQL中SELECT LAST_INSERT_ID()用于获取数据库中最后插入的数据的主键值</p></li><li><p>在Oracle中应该使用SELECT SEQ_ID.nextval from dual 用来获取序列中的一个值</p></li></ul><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><h4 id="普通查询"><a href="#普通查询" class="headerlink" title="普通查询"></a>普通查询</h4><p>根据用户id查询单条记录，在映射器接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>当实体类的属性名与数据库表的字段名一一对应时，映射代码如下所示：select元素用于映射查询语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">resultType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">    select * from USER where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">User u = userMapper.selectById(<span class="number">10</span>);</span><br><span class="line">System.out.println(u);</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><p>当实体类属性名与表字段不一致时，可以使用resultMap元素映射其对应关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.User"</span> <span class="attr">id</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    select * from USER where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>resultMap是一种很重要的配置结果映射的方法</strong></p><ul><li>id属性：必填，是结果映射的唯一标识，与select元素中resultMap属性的值一致</li><li>type属性：必填，用于指定查询结果所映射到的Java对象类型</li><li>id子元素：配置id对应的column（字段名）和property（属性名）</li><li>result子元素：配置普通结果对应的字段名和属性名</li></ul><p>当实体类属性与表字段不一致时，也可以通过设置别名进行映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAllUsers"</span> <span class="attr">resultType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">    select id,</span><br><span class="line">        user_name userName,</span><br><span class="line">        password</span><br><span class="line">    from USER</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="模糊查询like"><a href="#模糊查询like" class="headerlink" title="模糊查询like"></a>模糊查询like</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findLike"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    select * from user where user_name like "%"#&#123;name&#125;"%"</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表达式: user_name like”%”#{name}”%” #起到<strong>占位符</strong>的作用</p><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>在映射器接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateById</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>在映射文件中添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateById"</span>&gt;</span></span><br><span class="line">    update user </span><br><span class="line">    set user_name = #&#123;userName&#125;,</span><br><span class="line">        password = #&#123;password&#125;</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line">User u = <span class="keyword">new</span> User();</span><br><span class="line">u.setId(<span class="number">10</span>);</span><br><span class="line">u.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">u.setPassword(<span class="string">"123456"</span>);</span><br><span class="line"><span class="keyword">int</span> num = userMapper.updateById(u);</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除同更新操作类似，在映射器接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>在映射文件中添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteById"</span>&gt;</span></span><br><span class="line">    delete from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line"><span class="keyword">int</span> num = userMapper.deleteById(<span class="number">10</span>);</span><br><span class="line">System.out.println(num);</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】框架概述</title>
      <link href="/2020/03/17/MyBatis%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/03/17/MyBatis%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="MyBatis使用流程"><a href="#MyBatis使用流程" class="headerlink" title="MyBatis使用流程"></a>MyBatis使用流程</h3><ol><li>创建一个Java Project</li><li>导入MyBatis需要的jar包(mybatis-xxx.jar)</li><li>创建MyBatis的主配置文件mybatis.xml</li><li>创建实体类和映射器接口</li><li>创建MyBatis的SQL映射XML文件</li><li>将SQL映射文件与主配置文件进行关联</li><li>编写代码进行测试</li></ol><h3 id="GitHub源码"><a href="#GitHub源码" class="headerlink" title="GitHub源码"></a>GitHub源码</h3><p><a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">https</a><a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">://</a><a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">github.com/mybatis/mybatis-3</a></p><h3 id="MyBatis中文手册："><a href="#MyBatis中文手册：" class="headerlink" title="MyBatis中文手册："></a>MyBatis中文手册：</h3><p><a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">http</a><a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">://www.mybatis.org/mybatis-3/zh/index.html</a></p><h3 id="MyBatis核心XML配置文件"><a href="#MyBatis核心XML配置文件" class="headerlink" title="MyBatis核心XML配置文件"></a>MyBatis核心XML配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>  <span class="attr">resource</span>=<span class="string">"dbinfo.properties"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打印SQL语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 配置数据库信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.connectUrl&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.user&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.pwd&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>settings</strong>是 MyBatis 中极为重要的调整设置，可以用来配置全局参数，它们会改变 MyBatis 的运行时行为</p><ul><li>logImpl设置用来指定MyBatis 所用日志的具体实现，未指定时将自动查找。如果设置为<strong>STDOUT_LOGGING</strong>则表示在控制台显示SQL语句</li><li><a href="https://blog.csdn.net/u014231523/article/details/53056032" target="_blank" rel="noopener">https://blog.csdn.net/u014231523/article/details/53056032</a></li></ul><p>配置环境（<strong>environments</strong>）</p><ul><li>MyBatis 可以配置成适应多种环境，也就是配置多个environment子元素，这种机制有助于将<br>SQL<br>映射应用于多种数据库之中</li><li><strong>注意：</strong>environments的default属性取值要和其中一个environment的id属性取值一致</li></ul><p><strong>transactionManager</strong> 元素的type属性表示事务管理器类型，在MyBatis中有两种类型：</p><ul><li><strong>JDBC</strong> 这种方式是直接使用了JDBC的事务提交和回滚设置</li><li>MANAGED(托管)这种方式从来不提交或回滚一个连接。而是让容器来管理事务的整个生命周期(比如<br>Spring) </li></ul><p><strong>dataSource</strong>元素中主要配置了 JDBC 连接对象的资源，它的type属性表示数据源类型，内建的数据源类型有三种：</p><ul><li>UNPOOLED:每次被请求时简单打开和关闭连接</li><li><strong>POOLED</strong>：这是JDBC连接对象的数据库连接池的实现,用来避免创建新的连接实例 </li><li>JNDI：这个数据源的实现是为了使用如Spring或应用服务器这类的容器</li></ul><h3 id="MyBatis主要的类层次结构"><a href="#MyBatis主要的类层次结构" class="headerlink" title="MyBatis主要的类层次结构"></a>MyBatis主要的类层次结构</h3><p><img data-src="1.png" alt="1.png"></p><ul><li>每一个MyBatis的应用程序都以一个SqlSessionFactory 对象的实例为核心 。 </li><li>SqlSessionFactory对象的实例可以通过SqlSessionFactoryBuilder对象来获得 。</li><li>SqlSessionFactoryBuilder对象可以从 XML 配置文件中构建 SqlSessionFactory对象。 </li><li>通过SqlSessionFactory对象，可以获得SqlSession的实例。</li><li>SqlSession 对象完全包含以数据库为背景的所有执行 SQL 操作的方法。你可以用 SqlSession 实例来直接执行已映射的 SQL 语句 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is =     </span><br><span class="line">                Resources.getResourceAsStream(<span class="string">"mybatis.xml"</span>);</span><br><span class="line">            factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">openSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>dbinfo.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">db.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">db.connectUrl</span>=<span class="string">jdbc:mysql://localhost:3306/mybatisdemo_db?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.pwd</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>mybatis.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"dbinfo.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打印SQL语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置数据库信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driver&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.connectUrl&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.user&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.pwd&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"top/hiasenna/mapper/userMapper.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtil</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sessionFactory;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream is = Resources.getResourceAsStream(<span class="string">"mybatis.xml"</span>);</span><br><span class="line">sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">is.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">openSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sessionFactory.openSession();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User [id="</span> + id + <span class="string">", username="</span> + username + <span class="string">", password="</span> + password + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>userMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.hiasenna.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAll"</span> <span class="attr">resultType</span>=<span class="string">"top.hiasenna.entity.User"</span>&gt;</span></span><br><span class="line">select * from user </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">queryUser();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queryUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//List&lt;User&gt; users = session.selectList("top.hiasenna.mapper.UserMapper.selectAll");</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line"><span class="keyword">for</span>(User u : users) &#123;</span><br><span class="line">    System.out.println(u);</span><br><span class="line">&#125;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】检索方式与检索策略</title>
      <link href="/2020/03/17/hibernate%E6%A3%80%E7%B4%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5/"/>
      <url>/2020/03/17/hibernate%E6%A3%80%E7%B4%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>Hibernate的Session在加载Java对象时，一般都会把这个对象相关联的其他Java对象也都加载到缓存中，以方便程序的调用。但很多情况下，我们不需要加载太多无用的对象到缓存中，一来会占用大量的内存，二来会增加数据库的访问次数，使得程序的运行效率降低。为了合理的使用缓存，Hibernate提供了不同的检索策略来解决这些问题。</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h1><p>在说检索策略之前，先了解一下检索策略的作用域，它分为：类级别和关联级别。类级别的作用域在检索数据时，检索的数据只包含一个类对象，不涉及与该类关联的其他对象。关联级别的作用域检索的数据包含相关联的多个类的对象，例如，Customer对象与Orders对象存在关系，检索到一个Customer对象后，还会涉及与之关联的Orders对象。</p><p><img data-src="1.png" alt="1"></p><h1 id="检索策略"><a href="#检索策略" class="headerlink" title="检索策略"></a><strong>检索策略</strong></h1><p>Hibernate的检索策略分为三种，立即检索、延迟检索、左外连接检索。</p><h3 id="立即检索"><a href="#立即检索" class="headerlink" title="立即检索"></a><strong>立即检索</strong></h3><p> 采用立即检索策略，会把被检索的对象，以及和这个对象关联的一对多对象都加载到缓存中。Session的get方法就使用的立即检索策略。这种策略的优点在于，频繁使用的对象会被加载到缓存中，程序调用很方便，也很及时。缺点就是，占用的内存过多，而且数据库访问的次数也会很频繁，效率低下。</p><h3 id="延迟检索"><a href="#延迟检索" class="headerlink" title="延迟检索"></a><strong>延迟检索</strong></h3><p>采用延迟检索策略，就不会加载关联对象的内容。直到第一次调用关联对象时，才去加载关联对象。在不涉及关联类操作时，延迟检索策略只适用于Session的load方法。涉及关联类操作时，延迟检索策略也能够适用于get，list等操作。</p><p>在类级别操作时， 延迟检索策略，只加载类的OID不加载类的其他属性，只用当第一次访问其他属性时，才回访问数据库去加载内容。（这里使用了CGLIB生成了类的代理类）</p><p>在关联级别操作时，延迟检索策略，只加载类本身，不加载关联类，直到第一次调用关联对象时，才去加载关联对象。</p><p>程序模式都是用延迟加载策略。如果需要指定使用延迟加载策略。在配置文件中设置&lt;class&gt;的lazy=true，、&lt;set&gt;的lazy=true或extra（增强延迟）&lt;many-to-one&gt;的lazy=proxy和no-proxy。</p><p>  这种策略的优点在于，由程序决定加载哪些类和内容，而不必全部都加载，避免了内存的大量占用和数据库的频繁访问。缺点就是在Session关闭后，就不能访问关联类对象了。 需要确保Session一直处于打开状态，调用关联对象，最后在关闭Session对象。</p><h3 id="左外连接检索"><a href="#左外连接检索" class="headerlink" title="左外连接检索"></a><strong>左外连接检索</strong></h3><p>采用左外连接检索，能够使用sql的外连接查询，将需要加载的关联对象加载在缓存中。&lt;set&gt;fetch设置为join，&lt;many-to-one&gt;的fetch设置为join。</p><p>这种策略的优点在于，对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象。使用了外连接，select语句数目少。缺点就是可能会加载应用程序不需要访问的对象，白白浪费许多内存空间。复杂的数据库表连接也会影响检索性能。</p><p><img data-src="2.png" alt="2"></p><h1 id="检索方式"><a href="#检索方式" class="headerlink" title="检索方式"></a><strong>检索方式</strong></h1><p> Hibernate提供的检索方式为5种，分为导航对象图检索方式、OID检索方式、HQL检索方式、QBC检索方式、本地SQL检索方式。</p><h3 id="导航对象图检索方式"><a href="#导航对象图检索方式" class="headerlink" title="导航对象图检索方式"></a><strong>导航对象图检索方式</strong></h3><p>利用类与类之间的关系来检索对象。譬如我们要查找一份订单，就可以由订单对象自动导航找到订单所属的客户对象。当然，前提是必须在对象-关系映射文件上配置了它们的多对一的关系。</p><h3 id="OID检索方式"><a href="#OID检索方式" class="headerlink" title="OID检索方式"></a><strong>OID检索方式</strong></h3><p>主要指用Session的get()和load()方法加载某条记录对应的对象。</p><h3 id="HQL检索方式"><a href="#HQL检索方式" class="headerlink" title="HQL检索方式"></a><strong>HQL检索方式</strong></h3><p> HQL（Hibernate Query Language）是面向对象的查询语言，它和SQL查询语言有些相似。在Hibernate提供的各种检索方式中，HQL是使用最广的一种检索方式。它具有以下功能：</p><p>&emsp;    在查询语句中设定各种查询条件。</p><p>&emsp;    支持投影查询，即仅检索出对象的部分属性。<br>&emsp;    支持分页查询。<br>&emsp;    支持分组查询，允许使用group by和having关键字。<br>&emsp;    提供内置聚集函数，如sum()、min()和max()。<br>&emsp;    能够调用用户定义的SQL函数。<br>&emsp;    支持子查询，即嵌套查询。<br>&emsp;    支持动态绑定参数。</p><p>   Session类的Qurey接口支持HQL检索方式，它提供了以上列出的各种查询功能。</p><p><strong>注:</strong>Qurey接口支持方法链编程风格，它的set方法都返回自身实例，而不是返回void类型。方法链编程风格能使程序代码更加简洁。</p><p><strong>例：</strong></p><p>检索USER 表的所有记录</p><p>—-HQL语句中关键字大小写无关，但习惯将关键字小写。</p><p>—-from 关键字后面是类名不是数据库表名，类名需区分大小写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Query query = session.createQuery(<span class="string">"from User"</span>);</span><br><span class="line">List userList = query.list();</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"select u from User u"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">List userList = query.list();</span><br></pre></td></tr></table></figure><p>where 子句</p><p>—where子句中给出的是类的属性名而不是数据库表字段名，其中属性名必须区分大小写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from User where userName='张三'"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">List userList = query.list();</span><br></pre></td></tr></table></figure><p>HQL支持的各种运算符</p><table><thead><tr><th align="center"><strong>程序中指定的连接类型</strong></th><th align="center"><strong>HQL**</strong>运算符**</th></tr></thead><tbody><tr><td align="center">比较运算符</td><td align="center">=、&lt;&gt;、&gt;=、&lt;=、&gt;、&lt;、is null、is not null</td></tr><tr><td align="center">范围运算符</td><td align="center">in、not in、between…and、not between…and</td></tr><tr><td align="center">字符串模式匹配运算符</td><td align="center">like</td></tr><tr><td align="center">逻辑运算符</td><td align="center">and、or、not</td></tr></tbody></table><h4 id="HQL检索单个对象"><a href="#HQL检索单个对象" class="headerlink" title="HQL检索单个对象"></a>HQL检索单个对象</h4><p>list()：返回List类型的查询结果，返回所有满足条件的对象。</p><p>uniqueResult()：返回单个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Query query = session.createQuery(<span class="string">"from User u</span></span><br><span class="line"><span class="string">                      where u.userName='张三'"</span>);</span><br><span class="line">User user = (User)query.uniqueResult();</span><br></pre></td></tr></table></figure><h4 id="HQL参数绑定"><a href="#HQL参数绑定" class="headerlink" title="HQL参数绑定"></a>HQL参数绑定</h4><h5 id="在HQL查询语句中按照参数位置绑定参数"><a href="#在HQL查询语句中按照参数位置绑定参数" class="headerlink" title="在HQL查询语句中按照参数位置绑定参数"></a>在HQL查询语句中按照参数位置绑定参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from User u where u.userName=?"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">query.setParameter(<span class="number">0</span>, <span class="string">"张三"</span>);</span><br><span class="line">List&lt;User&gt; userList = query.list();</span><br></pre></td></tr></table></figure><h5 id="在HQL查询语句中按参数名称绑定参数。"><a href="#在HQL查询语句中按参数名称绑定参数。" class="headerlink" title="在HQL查询语句中按参数名称绑定参数。"></a>在HQL查询语句中按参数名称绑定参数。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from User u </span></span><br><span class="line"><span class="string">        where u.userName=:name"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">query.setParameter(<span class="string">"name"</span>, <span class="string">"张三"</span>);</span><br><span class="line">List&lt;User&gt; userList = query.list();</span><br></pre></td></tr></table></figure><h5 id="HQL的绑定参数方法"><a href="#HQL的绑定参数方法" class="headerlink" title="HQL的绑定参数方法"></a>HQL的绑定参数方法</h5><p>setParamter() 绑定任意类型的参数。</p><p>setProperties(Object bean) 用于把命名参数与一个对象的属性值绑定，并且参数名称要与对象属性名称一致。</p><p>setProperties(Map bean)用于把命名参数与一个Map类型的对象的value值绑定，并且参数名称要与Map类型的对象的key值一致。</p><h4 id="HQL实体更新"><a href="#HQL实体更新" class="headerlink" title="HQL实体更新"></a>HQL实体更新</h4><h5 id="不使用HQL的实体更新。"><a href="#不使用HQL的实体更新。" class="headerlink" title="不使用HQL的实体更新。"></a>不使用HQL的实体更新。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">User user = (User) session.get(User<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line">user.setUserName(<span class="string">"Tom"</span>);</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><h5 id="HQL实现实体更新的方式"><a href="#HQL实现实体更新的方式" class="headerlink" title="HQL实现实体更新的方式"></a>HQL实现实体更新的方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">String hql = <span class="string">"update User set userName='Tom' </span></span><br><span class="line"><span class="string">        where id=2"</span>; </span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line"><span class="keyword">int</span> ret = query.executeUpdate();</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><h4 id="HQL实体删除"><a href="#HQL实体删除" class="headerlink" title="HQL实体删除"></a>HQL实体删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">String hql = <span class="string">"delete from User where id = 1"</span>;</span><br><span class="line">Query query  = session.createQuery(hql);</span><br><span class="line"><span class="keyword">int</span> ret = query.executeUpdate();</span><br><span class="line">tx .commit();</span><br></pre></td></tr></table></figure><h4 id="HQL子查询"><a href="#HQL子查询" class="headerlink" title="HQL子查询"></a>HQL子查询</h4><p>HQL支持在 where 子句中嵌入子查询语句，并且子查询语句必须放在括号内。</p><p>查询订单数量大于0的所有用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> u </span><br><span class="line"><span class="keyword">where</span> <span class="number">0</span>&lt;(<span class="keyword">select</span> <span class="keyword">count</span>(o) <span class="keyword">from</span> orders o </span><br><span class="line">         <span class="keyword">where</span> u.id=o.userId )</span><br></pre></td></tr></table></figure><p>如果HQL子查询的是集合，HQL提供了一组操作集合的函数:</p><p>size()，获得集合中元素的个数；</p><p>maxIndex()，对于建立索引的集合，获得最大索引值；</p><p>minIndex()，对于建立索引的集合，获得最小索引值；</p><p>elements()，获得集合中所有元素。</p><h3 id="QBC检索方式"><a href="#QBC检索方式" class="headerlink" title="QBC检索方式"></a><strong>QBC检索方式</strong></h3><p>采用HQL检索方式时，在应用程序中需要定义基于字符串形式的HQL查询语句。QBC API提供了检索对象的另一种方式，它主要由Criteria接口、Criterion接口和Expression类组成，它支持在运行时动态生成查询语句。</p><p>检索姓名为张三 的所有用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria=session.createCriteria(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Criterion c1= Restrictions.eq(<span class="string">"userName"</span>, <span class="string">"张三"</span>);</span><br><span class="line">criteria.add(c1);</span><br><span class="line">List result = criteria.list();</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>运算类型</strong></th><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>范围运算符</td><td>Restrictions.in</td><td>等于列表中的某个值</td></tr><tr><td></td><td>Restrictions.not(Restrictions.in)</td><td>不等于列表中的任意值</td></tr><tr><td></td><td>Restrictions.between</td><td>大于等于值1小于等于值2</td></tr><tr><td>字符串模糊匹配</td><td>Restrictions.like</td><td>字符串模糊匹配   like</td></tr><tr><td>逻辑运算符</td><td>Restrictions.and</td><td>逻辑与</td></tr><tr><td></td><td>Restrictions.or</td><td>逻辑或</td></tr><tr><td></td><td>Restrictions.not</td><td>逻辑非</td></tr><tr><td>比较运算符</td><td>Restrictions.eq</td><td>等于</td></tr><tr><td></td><td>Restrictions.ne</td><td>不等于</td></tr><tr><td></td><td>Restrictions.gt</td><td>大于</td></tr><tr><td></td><td>Restrictions.ge</td><td>大于等于</td></tr><tr><td></td><td>Restrictions.lt</td><td>小于</td></tr><tr><td></td><td>Restrictions.le</td><td>小于等于</td></tr><tr><td></td><td>Restrictions.isNull</td><td>等于空值</td></tr><tr><td></td><td>Restrictions.isNotNull</td><td>非空值</td></tr></tbody></table><h3 id="本地SQL检索方式"><a href="#本地SQL检索方式" class="headerlink" title="本地SQL检索方式"></a><strong>本地SQL检索方式</strong></h3><p>采用HQL或QBC检索方式时，Hibernate生成标准的SQL查询语句，使用于所有的数据库平台，因此这两种检索方式都是跨平台的。有的应用程序可能需要根据底层数据库的SQL方言，来生成一些特殊的查询语句。在这种情况下，可以利用Hibernate提供的SQL检索方式。</p><p>查询所有的用户信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from  user"</span>;</span><br><span class="line">NativeQuery query = session.createNativeQuery(sql, </span><br><span class="line">    User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">List list = query.list();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-稀疏数组</title>
      <link href="/2020/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2020/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。<br>稀疏数组的处理方法是:</p><p>1) 记录数组 一共有几行几列，有多少个不同的值<br>2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而 缩小程序的规模</p><p><img data-src="1.png" alt="1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line"><span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表示蓝子</span></span><br><span class="line"><span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 输出原始的二维数组</span></span><br><span class="line">System.out.println(<span class="string">"原始的二维数组~~"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将二维数组 转 稀疏数组</span></span><br><span class="line"><span class="comment">// 1. 先遍历二维数组 得到非0数据的个数</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line"><span class="keyword">if</span> (data != <span class="number">0</span>) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line"><span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二维数组，将非0的值存放到 sparseArr中</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"得到稀疏数组为~~~~"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int [11][11] 2.</span></span><br><span class="line"><span class="comment"> * 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"><span class="keyword">int</span> chessRow = sparseArr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> chessCol = sparseArr[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[chessRow][chessCol];</span><br><span class="line"><span class="comment">// 2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]]=sparseArr[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img data-src="2.png" alt="2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】操作持久化对象</title>
      <link href="/2020/03/16/hibernate%E6%93%8D%E4%BD%9C%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/16/hibernate%E6%93%8D%E4%BD%9C%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="一-Session缓存"><a href="#一-Session缓存" class="headerlink" title="一.Session缓存"></a>一.Session缓存</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li>缓存介于应用程序和永久性存储源之间，其作用是降低应用程序直接读写永久性存储源的频率，从而提高应用的运行效率。</li><li>缓存内的数据是永久性存储源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件同步缓存和永久性存储源的数据。</li></ul><p><img data-src="1.png" alt="1.png"></p><h4 id="Session缓存"><a href="#Session缓存" class="headerlink" title="Session缓存"></a>Session缓存</h4><p>Session 接口的实现类 SessionImpl 中定义了一系列的 Java 集合，这些集合构成了 Session 的缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Session session = sessionFactory.openSession(); </span><br><span class="line">......</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><h4 id="Session缓存的工作过程"><a href="#Session缓存的工作过程" class="headerlink" title="Session缓存的工作过程"></a>Session缓存的工作过程</h4><p>当 Session 执行查询方法时，先从 Session 缓存中读取据，如果缓存中有则直接读取，如果缓存中没有，从数据库中查询并加载到 Session 缓存中，再从缓存中读取。</p><p>当 Session 执行 save()、update() 方法时，将对象持久化到数据库中并将对象加载到 Session 缓存中。</p><p><img data-src="2.png" alt="2.png"></p><h4 id="Session实现缓存"><a href="#Session实现缓存" class="headerlink" title="Session实现缓存"></a>Session实现缓存</h4><p><img data-src="3.gif" alt="3.gif"></p><h4 id="Session清理缓存"><a href="#Session清理缓存" class="headerlink" title="Session清理缓存"></a>Session清理缓存</h4><p>Session在某一时间点按照缓存中对象的属性变化来同步更新数据库的这一过程被称为 <strong>Session</strong> <strong>清理缓存</strong>。</p><p><strong>缓存清理的时间点：</strong></p><ul><li>当调用 transaction.commit() 方法时，会先清理缓存，再向数据库提交事务；</li><li>当显式调用 Session.flush() 方法时，会清理缓存；</li><li>当调用 Session 的查询（不包括 load() 和 get() )方法时，如果缓存中对象的属性有变化则清理缓存。</li></ul><h4 id="Session对象快照"><a href="#Session对象快照" class="headerlink" title="Session对象快照"></a>Session对象快照</h4><p><img data-src="4.gif" alt="4.gif"></p><h4 id="Session清理缓存的模式"><a href="#Session清理缓存的模式" class="headerlink" title="Session清理缓存的模式"></a>Session清理缓存的模式</h4><p>setHibernateFlushMode() 用于设定 Session 清理缓存的模式。</p><table><thead><tr><th align="center"><strong>清理缓存模式</strong></th><th align="center"><strong>Session的查询方法</strong></th><th align="center"><strong>commit()</strong></th><th align="center"><strong>flush()</strong></th></tr></thead><tbody><tr><td align="center">FlushMode.ALWAYS</td><td align="center">清理</td><td align="center">清理</td><td align="center">清理</td></tr><tr><td align="center">FlushMode.AUTO</td><td align="center">缓存中对象的属性有变化时清理，没变化不清理</td><td align="center">清理</td><td align="center">清理</td></tr><tr><td align="center">FlushMode.COMMIT</td><td align="center">不清理</td><td align="center">清理</td><td align="center">清理</td></tr><tr><td align="center">FlushMode.MANUAL</td><td align="center">不清理</td><td align="center">不清理</td><td align="center">清理</td></tr><tr><td align="center">FlushMode.NEVER</td><td align="center">已过时，被MANUAL取代</td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="Session缓存有三大作用"><a href="#Session缓存有三大作用" class="headerlink" title="Session缓存有三大作用:"></a>Session缓存有三大作用:</h4><ul><li>减少数据库访问次数，提高数据访问的效率；</li><li>保证缓存中的对象与数据库中相关的记录同步；</li><li>当缓存中的持久化对象存在循环关联关系时，Session会保证不出现死循环，以及由死循环引起的堆栈溢出异常。</li></ul><h3 id="二-Hibernate对象的生命周期"><a href="#二-Hibernate对象的生命周期" class="headerlink" title="二.Hibernate对象的生命周期"></a>二.Hibernate对象的生命周期</h3><h4 id="实体对象的4种状态"><a href="#实体对象的4种状态" class="headerlink" title="实体对象的4种状态"></a>实体对象的4种状态</h4><ul><li>Transient(临时状态) ： 刚刚被 new 关键字创建，还没有被持久化，不在Session的缓存中。</li><li>Persistent(持久化状态) ： 已经被持久化，并加入到 Session 缓存中。</li><li>Detached(游离状态) ： 已经被持久化，但不再处于 Session 缓存中。</li><li>Removed(删除状态) ： Session 已经计划将其从数据库删除，并且不再处于 Session 缓存中。</li></ul><p><img data-src="5.png" alt="5.png"></p><h4 id="实体对象的生命周期（lifecycle）"><a href="#实体对象的生命周期（lifecycle）" class="headerlink" title="实体对象的生命周期（lifecycle）"></a>实体对象的生命周期（lifecycle）</h4><p><img data-src="6.png" alt="6.png"></p><h3 id="三-Hibernate操作持久化对象"><a href="#三-Hibernate操作持久化对象" class="headerlink" title="三.Hibernate操作持久化对象"></a>三.Hibernate操作持久化对象</h3><h4 id="Session的save-方法"><a href="#Session的save-方法" class="headerlink" title="Session的save()方法"></a>Session的save()方法</h4><p>•1. 把对象加入缓存中，使其变成持久化对象；</p><p>•2. 根据映射文件配置的标识符生成器为对象分配一个<br>OID；</p><p>•3. 计划执行一个 insert，把对象当前属性值组装到<br>insert 语句中；</p><p>•4. 事务提交后（transaction.commit()）永久的将数据保存到数据库。</p><h4 id="Session的update-方法"><a href="#Session的update-方法" class="headerlink" title="Session的update()方法"></a>Session的update()方法</h4><p>•1. 把游离对象重新加入 Session 缓存中，使其变为持久化对象；</p><p>•2. 计划执行一个 update，将对象当前属性组装到 update 语句，执行 update 语句；</p><p>•3. 事务提交后（transaction.commit()）永久的将数据保存到数据库；</p><p>•4. 不管对象属性有没有改变都会执行update （通过设置<class>的select-before-update=true改变）。</class></p><h4 id="Session的saveOrUpdate-方法"><a href="#Session的saveOrUpdate-方法" class="headerlink" title="Session的saveOrUpdate()方法"></a>Session的saveOrUpdate()方法</h4><ul><li>如果参数是临时对象–save()</li><li>如果参数是游离对象–update()</li><li>如果参数是持久化对象–返回</li></ul><p>Hibernate 如何区分临时对象：</p><ul><li>对象的 OID 为 null；</li><li>如果映射文件中设置了 <id> 的 unsaved-value 属性，并且对象的 id 值与 unsaved-value 设置的值相等。</id></li></ul><h4 id="Session的delete-方法"><a href="#Session的delete-方法" class="headerlink" title="Session的delete()方法"></a>Session的delete()方法</h4><p>•1. 检查传入的参数是否是持久化对象，如果是持久化对象将其移出 Session 缓存；</p><p>•2. 计划执行一个 delete，但是并不立即执行；</p><p>•3. 当 Session 清理缓存时才执行 delete，比如执行 Session.flush()。</p><h4 id="Session的load-和get-方法"><a href="#Session的load-和get-方法" class="headerlink" title="Session的load()和get()方法"></a>Session的load()和get()方法</h4><p>load() 与 get() 方法都是根据 OID 加载持久化对象。</p><p>load() 与 get() 方法的不同点：</p><ul><li>如果数据库中不存在与 OID 对应的记录：</li></ul><ol><li>load() 会抛出 ObjectNotFoundException 异常；</li><li>get() 会返回 null。</li></ol><ul><li>默认加载策略：</li></ul><ol><li>load() 使用类的延迟加载策略；</li><li>get() 使用类的立即加载策略。</li></ol>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】多对多关联映射</title>
      <link href="/2020/03/16/hibernate%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/16/hibernate%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在某高校选课系统中，一个学生可以同时选修多门课程，一门课程可以被若干个学生选修，像这样的多对多关联关系，应该如何实现？</p><p><img data-src="1.png" alt="1.png"></p><p><img data-src="2.png" alt="2.png"></p><h3 id="Hibernate多对多关联映射"><a href="#Hibernate多对多关联映射" class="headerlink" title="Hibernate多对多关联映射"></a>Hibernate多对多关联映射</h3><p>Student.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String studentNo;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Course&gt; courses = <span class="keyword">new</span> HashSet&lt;Course&gt;();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Course.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> credit;  <span class="comment">// 学分</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"courses"</span> <span class="attr">table</span>=<span class="string">"studentcourse"</span> <span class="attr">inverse</span>=<span class="string">"false"</span> <span class="attr">cascade</span>=<span class="string">"all"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"student_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"Course"</span> <span class="attr">column</span>=<span class="string">"course_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Course.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"students"</span> <span class="attr">table</span>=<span class="string">"studentcourse"</span> <span class="attr">inverse</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"course_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"Student"</span> <span class="attr">column</span>=<span class="string">"student_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="4.png" alt="4.png"></p><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">addStudent();</span><br><span class="line">delStudent();</span><br><span class="line">query();</span><br><span class="line">addCourse();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setName(<span class="string">"zs"</span>);</span><br><span class="line">Course course = session.get(Course<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Integer</span>(1))</span>;</span><br><span class="line">Course course2 = session.get(Course<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Integer</span>(2))</span>;</span><br><span class="line">student.getCourses().add(course);</span><br><span class="line">student.getCourses().add(course2);</span><br><span class="line"></span><br><span class="line">session.save(student);</span><br><span class="line"></span><br><span class="line">Student student2 = <span class="keyword">new</span> Student();</span><br><span class="line">student2.setName(<span class="string">"ls"</span>);</span><br><span class="line">student2.getCourses().add(course);</span><br><span class="line">student2.getCourses().add(course2);</span><br><span class="line"></span><br><span class="line">session.save(student2);</span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createCourse</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">Course course = <span class="keyword">new</span> Course();</span><br><span class="line">course.setName(<span class="string">"Java"</span>);</span><br><span class="line">session.save(course);</span><br><span class="line">Course course2 = <span class="keyword">new</span> Course();</span><br><span class="line">course2.setName(<span class="string">"H5"</span>);</span><br><span class="line">session.save(course2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">Student student =session.get(Student<span class="class">.<span class="keyword">class</span>, <span class="title">i</span>)</span>;</span><br><span class="line">session.delete(student);</span><br><span class="line">&#125;</span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addCourse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">createCourse(session);</span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">Student student = session.get(Student<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Integer</span>(1))</span>;</span><br><span class="line">Set&lt;Course&gt; courses = student.getCourses();</span><br><span class="line"><span class="keyword">for</span>(Course course:courses)&#123;</span><br><span class="line">System.out.println(course.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Course course = session.get(Course<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Integer</span>(1))</span>;</span><br><span class="line"><span class="keyword">for</span>(Student student2:course.getStudents())&#123;</span><br><span class="line">System.out.println(student2.getName());</span><br><span class="line">&#125;</span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@ManyToMany</span></span><br><span class="line"><span class="meta">@JoinTable</span>(name=<span class="string">"studentcourse"</span>,</span><br><span class="line">joinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"student_id"</span>),</span><br><span class="line">inverseJoinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"course_id"</span>))</span><br><span class="line"><span class="keyword">private</span> Set&lt;Course&gt; courses = <span class="keyword">new</span> HashSet&lt;Course&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Course&gt; <span class="title">getCourses</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> courses;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourses</span><span class="params">(Set&lt;Course&gt; courses)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.courses = courses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"course"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@ManyToMany</span>(mappedBy=<span class="string">"courses"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> students;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudents</span><span class="params">(Set&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.students = students;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="3.png" alt="3.png"></p>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap集合(高级)</title>
      <link href="/2020/03/15/HashMap%E9%9B%86%E5%90%88-%E9%AB%98%E7%BA%A7/"/>
      <url>/2020/03/15/HashMap%E9%9B%86%E5%90%88-%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap集合-高级"><a href="#HashMap集合-高级" class="headerlink" title="HashMap集合(高级)"></a>HashMap集合(高级)</h1><h2 id="1-HashMap集合简介"><a href="#1-HashMap集合简介" class="headerlink" title="1.HashMap集合简介"></a>1.HashMap集合简介</h2><p>​    HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><p>​    JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突<strong>(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)</strong>而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</strong></p><p>补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。</p><p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 <code>treeifyBin</code>方法。</p><p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。 </p><p>小结：</p><p>特点：</p><p>1.存取无序的</p><p>2.键和值位置都可以是null，但是键位置只能是一个null</p><p>3.键位置是唯一的，底层的数据结构控制键的</p><p>4.jdk1.8前数据结构是：链表 + 数组  jdk1.8之后是 ： 链表 + 数组  + 红黑树</p><p>5.阈值(边界值) &gt; 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</p><h2 id="2-HashMap集合底层的数据结构"><a href="#2-HashMap集合底层的数据结构" class="headerlink" title="2.HashMap集合底层的数据结构"></a>2.HashMap集合底层的数据结构</h2><h3 id="2-1数据结构概念"><a href="#2-1数据结构概念" class="headerlink" title="2.1数据结构概念"></a>2.1数据结构概念</h3><p> 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 </p><p>数据结构：就是存储数据的一种方式。ArrayList LinkedList</p><p>在JDK1.8 之前 HashMap 由 <strong>数组+链表</strong> 数据结构组成的。</p><p>在JDK1.8 之后 HashMap 由 <strong>数组+链表 +红黑树</strong>数据结构组成的。</p><h3 id="2-2HashMap底层的数据结构存储数据的过程"><a href="#2-2HashMap底层的数据结构存储数据的过程" class="headerlink" title="2.2HashMap底层的数据结构存储数据的过程"></a>2.2HashMap底层的数据结构存储数据的过程</h3><p>存储过程如下所示：</p><p>使用的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"刘德华"</span>, <span class="number">53</span>);</span><br><span class="line">        map.put(<span class="string">"柳岩"</span>, <span class="number">35</span>);</span><br><span class="line">        map.put(<span class="string">"张学友"</span>, <span class="number">55</span>);</span><br><span class="line">        map.put(<span class="string">"郭富城"</span>, <span class="number">52</span>);</span><br><span class="line">        map.put(<span class="string">"黎明"</span>, <span class="number">51</span>);</span><br><span class="line">        map.put(<span class="string">"林青霞"</span>, <span class="number">55</span>);</span><br><span class="line">        map.put(<span class="string">"刘德华"</span>, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" alt="哈希表存储过程.png"></p><p>说明：</p><p>1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于key的hashCode做hash操作，无符号右移16位然后做异或运算。</span><br><span class="line">还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移16位异或运算效率是最高的。至于底层是如何计算的我们下面看源码时给大家讲解。</span><br></pre></td></tr></table></figure><p>2.面试题：当两个对象的hashCode相等时会怎么样？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">会产生哈希碰撞，若key值内容相同则替换旧的value.不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储。</span><br></pre></td></tr></table></figure><p>3.面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</span><br></pre></td></tr></table></figure><p>4.面试题：如果两个键的hashcode相同，如何存储键值对？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashcode相同，通过equals比较内容是否相同。</span><br><span class="line">相同：则新的value覆盖之前的value</span><br><span class="line">不相同：则将新的键值对添加到哈希表中</span><br></pre></td></tr></table></figure><p>5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p><p>6.通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次查找的效率较低。而<strong>JDK1.8</strong>中，哈希表存储采用数组+链表+红黑树实现，当链表长度(阀值)超过 8 时且当前数组的长度 &gt; 64时，将链表转换为红黑树，这样大大减少了查找时间。jdk8在哈希表中引入红黑树的原因只是为了查找效率更高。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示。</p><p><img data-src="%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="哈希表.png"></p><p> <strong>但是这样的话问题来了，传统hashMap的缺点，1.8为什么引入红黑树？这样结构的话不是更麻烦了吗，为何阈值大于8换成红黑树？</strong></p><p> JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。 当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。</p><p>至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。 下面我们在分析源码的时候会介绍。</p><p><strong>7.总结：</strong></p><p>上述我们大概阐述了HashMap底层存储数据的方式。为了方便大家更好的理解，我们结合一个存储流程图来进一步说明一下：(jdk8存储过程)</p><p><img data-src="1.png" alt="1.png"></p><p>说明：</p><p>1.size表示 HashMap中K-V的实时数量 ， 注意这个不等于数组的长度 。 </p><p>2.threshold( 临界值)  =capacity(容量) * loadFactor( 加载因子 )。这个值是当前已占用数组长度的最大值。size超过这个临界值就重新resize(扩容)，扩容后的 HashMap 容量是之前容量的两倍 。</p><h2 id="3-HashMap继承关系"><a href="#3-HashMap继承关系" class="headerlink" title="3.HashMap继承关系"></a>3.HashMap继承关系</h2><p>HashMap继承关系如下图所示：</p><p><img data-src="1.bmp" alt="1.bmp"></p><p>说明：</p><ul><li>Cloneable 空接口，表示可以克隆。 创建并返回HashMap对象的一个副本。</li><li>Serializable 序列化接口。属于标记性接口。HashMap对象可以被序列化和反序列化。</li><li>AbstractMap 父类提供了Map实现接口。以最大限度地减少实现此接口所需的工作。</li></ul><p>补充：通过上述继承关系我们发现一个很奇怪的现象， 就是HashMap已经继承了AbstractMap而AbstractMap类实现了Map接口，那为什么HashMap还要在实现Map接口呢？同样在ArrayList中LinkedList中都是这种结构。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">据 java 集合框架的创始人Josh Bloch描述，这样的写法是一个失误。在java集合框架中，类似这样的写法很多，最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改，所以就这样存在下来了。</span><br></pre></td></tr></table></figure><h2 id="4-HashMap集合类的成员"><a href="#4-HashMap集合类的成员" class="headerlink" title="4.HashMap集合类的成员"></a>4.HashMap集合类的成员</h2><h3 id="4-1成员变量"><a href="#4-1成员变量" class="headerlink" title="4.1成员变量"></a>4.1成员变量</h3><p>1.序列化版本号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure><p>2.集合的初始化容量( <strong>必须是二的n次幂</strong> )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>问题： <strong>为什么必须是2的n次幂？如果输入值不是2的幂比如10会怎么样？</strong> </p><p>HashMap构造方法还可以指定集合的初始化容量大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap(<span class="keyword">int</span> initialCapacity) 构造一个带指定初始容量和默认加载因子 (<span class="number">0.75</span>) 的空 HashMap。</span><br></pre></td></tr></table></figure><p> 根据上述讲解我们已经知道，当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。 HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。</p><p>这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算(这点上述已经讲解)。所以源码中做了优化,使用 hash&amp;(length-1)，而实际上hash%length等于hash&amp;(length-1)的前提是length是2的n次幂。</p><p>为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；</p><p>举例：</p><p><strong>说明：按位与运算：相同的二进制数位上，都是1的时候，结果为1，否则为零。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例如长度为<span class="number">8</span>时候，<span class="number">3</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">3</span>  <span class="number">2</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">2</span> ，不同位置上，不碰撞；</span><br><span class="line">例如长度length为<span class="number">8</span>时候，<span class="number">8</span>是<span class="number">2</span>的<span class="number">3</span>次幂。二进制是：<span class="number">1000</span></span><br><span class="line">length-<span class="number">1</span> 二进制运算：</span><br><span class="line"><span class="number">1000</span></span><br><span class="line">-   <span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line">     <span class="number">111</span></span><br><span class="line">如下所示：</span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>   &amp;(<span class="number">8</span>    - <span class="number">1</span>)=<span class="number">3</span>  </span><br><span class="line"><span class="number">00000011</span>  <span class="number">3</span> hash</span><br><span class="line">&amp;   <span class="number">00000111</span>  <span class="number">7</span> length-<span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000011</span>-----》<span class="number">3</span> 数组下标</span><br><span class="line"></span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> &amp;  (<span class="number">8</span> -    <span class="number">1</span>) = <span class="number">2</span>  </span><br><span class="line"><span class="number">00000010</span>  <span class="number">2</span> hash</span><br><span class="line">&amp;   <span class="number">00000111</span>  <span class="number">7</span> length-<span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000010</span>-----》<span class="number">2</span>  数组下标</span><br><span class="line">说明：上述计算结果是不同位置上，不碰撞；</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例如长度为<span class="number">9</span>时候，<span class="number">3</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span>  <span class="number">2</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span> ，都在<span class="number">0</span>上，碰撞了；</span><br><span class="line">例如长度length为<span class="number">9</span>时候，<span class="number">9</span>不是<span class="number">2</span>的n次幂。二进制是：<span class="number">00001001</span></span><br><span class="line">length-<span class="number">1</span> 二进制运算：</span><br><span class="line"><span class="number">1001</span></span><br><span class="line">-   <span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">如下所示：</span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>   &amp;(<span class="number">9</span>    - <span class="number">1</span>)=<span class="number">0</span>  </span><br><span class="line"><span class="number">00000011</span>  <span class="number">3</span> hash</span><br><span class="line">&amp;   <span class="number">00001000</span>  <span class="number">8</span> length-<span class="number">1</span> </span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000000</span>-----》<span class="number">0</span>  数组下标</span><br><span class="line"></span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> &amp;  (<span class="number">9</span> -    <span class="number">1</span>) = <span class="number">2</span>  </span><br><span class="line"><span class="number">00000010</span> <span class="number">2</span> hash</span><br><span class="line">&amp;   <span class="number">00001000</span> <span class="number">8</span> length-<span class="number">1</span> </span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000000</span>-----》<span class="number">0</span>  数组下标</span><br><span class="line">说明：上述计算结果都在<span class="number">0</span>上，碰撞了；</span><br></pre></td></tr></table></figure><p><strong>注意： 当然如果不考虑效率直接求余即可（就不需要要求长度必须是2的n次方了）</strong> </p><p>小结：</p><p>​    1.由上面可以看出，当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，可以保证数据的均匀插入，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突。</p><p>​    2.另一方面，一般我们可能会想通过 % 求余来确定位置，这样也可以，只不过性能不如 &amp; 运算。而且当n是2的幂次方时：hash &amp; (length - 1) == hash % length</p><p>​    3.因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突，毕竟hash冲突越大，代表数组中一个链的长度越大，这样的话会降低hashmap的性能</p><p>​    <strong>4.如果创建HashMap对象时，输入的数组长度是10，不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字。</strong></p><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建HashMap集合的对象，指定数组长度是10，不是2的幂</span></span><br><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//initialCapacity=10</span></span><br><span class="line">   <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;<span class="comment">//initialCapacity=10</span></span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//initialCapacity=10</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;<span class="comment">//int cap = 10</span></span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>由此可以看到，当在实例化HashMap实例时，如果给定了initialCapacity(假设是10)，由于HashMap的capacity必须都是2的幂，因此这个方法用于找到大于等于initialCapacity(假设是10)的最小的2的幂（initialCapacity如果就是2的幂，则返回的还是这个数）。 下面分析这个算法： 1)、首先，为什么要对cap做减1操作。int n = cap - 1; 这是为了防止，cap已经是2的幂。如果cap已经是2的幂， 又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。如果不懂，要看完后面的几个无符号右移之后再回来看看。 下面看看这几个无符号右移操作： 2）、如果n这时为0了（经过了cap-1之后），则经过后面的几次无符号右移依然是0，最后返回的capacity是        1（最后有个n+1的操作）。 这里只讨论n不等于0的情况。</p><p>3）、注意：<strong>|（按位或运算）：运算规则：相同的二进制数位上，都是0的时候，结果为0，否则为1。</strong></p><p>​     <strong>第一次右移</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = cap - <span class="number">1</span>;<span class="comment">//cap=10  n=9</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001001</span> <span class="comment">//9</span></span><br><span class="line">|</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span> <span class="comment">//9右移之后变为4</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span> <span class="comment">//按位异或之后是13</span></span><br></pre></td></tr></table></figure><p> 由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span></span><br></pre></td></tr></table></figure><p> <strong>第二次右移</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> n |= n &gt;&gt;&gt; <span class="number">2</span>;<span class="comment">//n通过第一次右移变为了：n=13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span>  <span class="comment">// 13</span></span><br><span class="line">|</span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>  <span class="comment">//13右移之后变为3</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span> <span class="comment">//按位异或之后是15</span></span><br></pre></td></tr></table></figure><p> 注意，这个n已经经过了<code>n |= n &gt;&gt;&gt; 1;</code> 操作。假设此时n为00000000 00000000 00000000 00001101 ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 00001111 &#x2F;&#x2F;按位异或之后是15</span><br></pre></td></tr></table></figure><p> <strong>第三次右移</strong> :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n |&#x3D; n &gt;&gt;&gt; 4;&#x2F;&#x2F;n通过第一、二次右移变为了：n&#x3D;15</span><br><span class="line">00000000 00000000 00000000 00001111  &#x2F;&#x2F; 15</span><br><span class="line">|</span><br><span class="line">    00000000 00000000 00000000 00000000  &#x2F;&#x2F;15右移之后变为0</span><br><span class="line">-------------------------------------------------</span><br><span class="line">00000000 00000000 00000000 00001111 &#x2F;&#x2F;按位异或之后是15</span><br></pre></td></tr></table></figure><p>这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中正常会有8个连续的1。如00001111 1111xxxxxx 。 以此类推 注意，容量最大也就是32bit的正数，因此最后n |= n &gt;&gt;&gt; 16; ，最多也就32个1（但是这已经是负数了。在执行tableSizeFor之前，对initialCapacity做了判断，如果大于MAXIMUM_CAPACITY(2 ^ 30)，则取MAXIMUM_CAPACITY。如果等于MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作。所以这里面的移位操作之后，最大30个1，不会大于等于MAXIMUM_CAPACITY。30个1，加1之后得2 ^ 30） 。 请看下面的一个完整例子：</p><p><img data-src="image-20191115151657917.png" alt="image-20191115151657917.png"></p><p>  注意，得到的这个capacity却被赋值给了threshold。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.threshold &#x3D; tableSizeFor(initialCapacity);&#x2F;&#x2F;initialCapacity&#x3D;10</span><br></pre></td></tr></table></figure><p>3.默认的负载因子，默认值是0.75 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br></pre></td></tr></table></figure><p>4.集合最大容量 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;集合最大容量的上限是：2的30次幂</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br></pre></td></tr></table></figure><p>5.当链表的值超过8则会转红黑树(<strong>1.8新增</strong>) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当桶(bucket)上的结点数大于这个值时会转成红黑树</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br></pre></td></tr></table></figure><p><strong>问题：为什么Map桶中节点个数超过8才转为红黑树？</strong></p><p>8这个阈值定义在HashMap中，针对这个成员变量，在源码的注释中只说明了8是bin（bin就是bucket(桶)）从链表转成树的阈值，但是并没有说明为什么是8： </p><p> 在HashMap中有一段注释说明： 我们继续往下看 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Because TreeNodes are about twice the size of regular nodes, <span class="function">we use them only when bins contain enough nodes to warrant <span class="title">use</span> <span class="params">(see TREEIFY_THRESHOLD)</span>. And when they become too <span class="title">small</span> <span class="params">(due to removal or resizing)</span> they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="function"><span class="params">(http://en.wikipedia.org/wiki/Poisson_distribution)</span> with a parameter of about 0.5 on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k <span class="title">are</span> <span class="params">(exp(<span class="number">-0.5</span>)</span>*<span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span>/<span class="title">factorial</span><span class="params">(k)</span>).</span></span><br><span class="line"><span class="function">The first values are:</span></span><br><span class="line"><span class="function">因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点<span class="params">(参见TREEIFY_THRESHOLD)</span>。当它们变得太小<span class="params">(由于删除或调整大小)</span>时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从泊松分布</span></span><br><span class="line"><span class="function"><span class="params">(http://en.wikipedia.org/wiki/Poisson_distribution)</span>，默认调整阈值为0.75，平均参数约为0.5，尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是<span class="params">(exp(<span class="number">-0.5</span>)</span>*<span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span>/<span class="title">factorial</span><span class="params">(k)</span>)。</span></span><br><span class="line"><span class="function">第一个值是:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">0:    0.60653066</span></span><br><span class="line"><span class="function">1:    0.30326533</span></span><br><span class="line"><span class="function">2:    0.07581633</span></span><br><span class="line"><span class="function">3:    0.01263606</span></span><br><span class="line"><span class="function">4:    0.00157952</span></span><br><span class="line"><span class="function">5:    0.00015795</span></span><br><span class="line"><span class="function">6:    0.00001316</span></span><br><span class="line"><span class="function">7:    0.00000094</span></span><br><span class="line"><span class="function">8:    0.00000006</span></span><br><span class="line"><span class="function">more: less than 1 in ten million</span></span><br></pre></td></tr></table></figure><p>TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点时才会转成TreeNodes，而是否足够多就是由TREEIFY_THRESHOLD的值决定的。当bin中节点数变少时，又会转成普通的bin。并且我们查看源码的时候发现，链表长度达到8就转成红黑树，当长度降到6就转成普通bin。</p><p>这样就解释了为什么不是一开始就将其转换为TreeNodes，而是需要一定节点数才转为TreeNodes，说白了就是权衡，空间和时间的权衡。</p><p> 这段内容还说到：当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是随便决定的，而是根据概率统计决定的。由此可见，发展将近30年的Java每一项改动和优化都是非常严谨和科学的。 </p><p>也就是说：选择8因为符合泊松分布，超过8的时候，概率已经非常小了，所以我们选择8这个数字。</p><p>补充：</p><p>1）.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Poisson分布(泊松分布)，是一种统计与概率学里常见到的离散[概率分布]。</span><br><span class="line">泊松分布的概率函数为：</span><br></pre></td></tr></table></figure><p><img data-src="image-20191115161055901.png" alt="image-20191115161055901.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泊松分布的参数λ是单位时间(或单位面积)内随机事件的平均发生次数。 泊松分布适合于描述单位时间内随机事件发生的次数。</span><br></pre></td></tr></table></figure><p>2）.以下是我在研究这个问题时，在一些资料上面翻看的解释：供大家参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">红黑树的平均查找长度是log(n)，如果长度为8，平均查找长度为log(8)&#x3D;3，链表的平均查找长度为n&#x2F;2，当长度为8时，平均查找长度为8&#x2F;2&#x3D;4，这才有转换成树的必要；链表长度如果是小于等于6，6&#x2F;2&#x3D;3，而log(6)&#x3D;2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</span><br></pre></td></tr></table></figure><p><strong>6.当链表的值小于6则会从红黑树转回链表</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>7.当Map里面的数量超过这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶中结构转化为红黑树对应的数组长度最小的值 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p><strong>8、table用来初始化(必须是二的n次幂)(重点)</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储元素的数组 </span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p><strong>table</strong>在JDK1.8中我们了解到HashMap是由数组加链表加红黑树来组成的结构其中table就是HashMap中的数组，jdk8之前数组类型是Entry&lt;K,V&gt;类型。从jdk1.8之后是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V&gt;。负责存储键值对数据的。</p><p>9、用来存放缓存 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;存放具体元素的集合</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p><strong>10、 HashMap中存放元素的个数(重点)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p><strong>size</strong>为HashMap中K-V的实时数量，不是数组table的长度。</p><p>11、 用来记录HashMap的修改次数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>12、 用来调整大小下一个容量的值计算方式为(容量*负载因子) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 临界值 当实际大小(容量*负载因子)超过临界值时，会进行扩容</span><br><span class="line">int threshold;</span><br></pre></td></tr></table></figure><p><strong>13、 哈希表的加载因子(重点)</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>1.<strong>loadFactor</strong>加载因子，是用来衡量 HashMap 满的程度，<strong>表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率</strong>，计算HashMap的实时加载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。capacity 是桶的数量，也就是 table 的长度length。</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p><p><strong>当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。，所以开发中尽量减少扩容的次数，可以通过创建HashMap集合对象时指定初始容量来尽量避免。</strong></p><p><strong>同时在HashMap的构造器中可以定制loadFactor。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造方法：</span><br><span class="line">HashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor) 构造一个带指定初始容量和加载因子的空 HashMap。</span><br></pre></td></tr></table></figure><p>2.为什么加载因子设置为0.75,初始化临界值是12？</p><p>loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><img data-src="image-20191115173553375.png" alt="image-20191115173553375.png"></p><p>如果希望链表尽可能少些。要提前扩容，有的数组空间有可能一直没有存储数据。加载因子尽可能小一些。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：加载因子是0.4。 那么16*0.4---&gt;6 如果数组中满6个空间就扩容会造成数组利用率太低了。</span><br><span class="line"> 加载因子是0.9。 那么16*0.9----&gt;14 那么这样就会导致链表有点多了。导致查找元素效率低。</span><br></pre></td></tr></table></figure><p>所以既兼顾数组利用率又考虑链表不要太多，经过大量测试0.75是最佳方案。</p><ul><li><strong>threshold</strong>计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。这个值是当前已占用数组长度的最大值。<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的resize(扩容)，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。 扩容后的 HashMap 容量是之前容量的两倍.</li></ul><h3 id="4-2构造方法"><a href="#4-2构造方法" class="headerlink" title="4.2构造方法"></a>4.2构造方法</h3><p> HashMap 中重要的构造方法，它们分别如下： </p><p>1、构造一个空的 <code>HashMap</code> ，默认初始容量（16）和默认负载因子（0.75）。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// 将默认的加载因子0.75赋值给loadFactor，并没有创建数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 构造一个具有指定的初始容量和默认负载因子（0.75） <code>HashMap</code>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>3、 构造一个具有指定的初始容量和负载因子的 <code>HashMap</code>。我们来分析一下。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"><span class="comment"> initialCapacity: 指定的容量</span></span><br><span class="line"><span class="comment"> loadFactor:指定的加载因子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断初始化容量initialCapacity是否小于0</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果小于0，则抛出非法的参数异常IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    <span class="comment">//判断初始化容量initialCapacity是否大于集合的最大容量MAXIMUM_CAPACITY-》2的30次幂</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="comment">//如果超过MAXIMUM_CAPACITY，会将MAXIMUM_CAPACITY赋值给initialCapacity</span></span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//判断负载因子loadFactor是否小于等于0或者是否是一个非数值</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="comment">//如果满足上述其中之一，则抛出非法的参数异常IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">     <span class="comment">//将指定的加载因子赋值给HashMap成员变量的负载因子loadFactor</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    tableSizeFor(initialCapacity) 判断指定的初始化容量是否是2的n次幂，如果不是那么会变为比指定初始化容量大的最小的2的n次幂。这点上述已经讲解过。</span></span><br><span class="line"><span class="comment">    但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边界值了。有些人会觉得这里是一个bug,应该这样书写：</span></span><br><span class="line"><span class="comment">    this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;</span></span><br><span class="line"><span class="comment">    这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。</span></span><br><span class="line"><span class="comment">但是，请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推 迟到了put方法中，在put方法中会对threshold重新计算，put方法的具体实现我们下面会进行讲解</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">最后调用了tableSizeFor，来看一下方法实现：</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">       返回比指定初始化容量大的最小的2的n次幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>对于 this.threshold = tableSizeFor(initialCapacity); 疑问解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tableSizeFor(initialCapacity) 判断指定的初始化容量是否是<span class="number">2</span>的n次幂，如果不是那么会变为比指定初始化容量大的最小的<span class="number">2</span>的n次幂。这点上述已经讲解过。</span><br><span class="line">但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边界值了。有些人会觉得这里是一个bug,应该这样书写：</span><br><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity) * <span class="keyword">this</span>.loadFactor;</span><br><span class="line">这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。</span><br><span class="line">但是，请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推 迟到了put方法中，在put方法中会对threshold重新计算，put方法的具体实现我们下面会进行讲解</span><br></pre></td></tr></table></figure><p>4、包含另一个“Map”的构造函数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个映射关系与指定 Map 相同的新 HashMap。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//负载因子loadFactor变为默认的负载因子0.75</span></span><br><span class="line">         <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">         putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后调用了putMapEntries，来看一下方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取参数集合的长度</span></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断参数集合的长度是否大于0，说明大于0</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>)  <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p> float ft = ((float)s / loadFactor) + 1.0F;这一行代码中为什么要加1.0F ？</p><p> s/loadFactor的结果是小数，加1.0F与(int)ft相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少resize的调用次数。所以 + 1.0F是为了获取更大的容量。 </p><p>例如：原来集合的元素个数是6个，那么6/0.75是8，是2的n次幂，那么新的数组大小就是8了。然后原来数组的数据就会存储到长度是8的新的数组中了，这样会导致在存储元素的时候，容量不够，还得继续扩容，那么性能降低了，而如果+1呢，数组长度直接变为16了，这样可以减少数组的扩容。</p><h3 id="4-3成员方法"><a href="#4-3成员方法" class="headerlink" title="4.3成员方法"></a>4.3成员方法</h3><h4 id="4-3-1增加方法"><a href="#4-3-1增加方法" class="headerlink" title="4.3.1增加方法"></a>4.3.1增加方法</h4><p>put方法是比较复杂的，实现步骤大致如下：</p><p>1）先通过hash值计算出key映射到哪个桶；</p><p>2）如果桶上没有碰撞冲突，则直接插入；</p><p>3）如果出现碰撞冲突了，则需要处理冲突：</p><p>​    a:如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；</p><p>​    b:否则采用传统的链式方法插入。如果链的长度达到临界值，则把链转变为红黑树；</p><p>4）如果桶中存在重复的键，则为该键替换新值value；</p><p>5）如果size大于阈值threshold，则进行扩容；</p><p>具体的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明： </p><p>​    1）HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。 所以我们重点看putVal方法。</p><pre><code>2）我们可以看到在putVal()方法中key在这里执行了一下hash()方法,来看一下Hash方法是如何实现的。 </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）如果key等于null：</span></span><br><span class="line"><span class="comment">    可以看到当key等于null的时候也是有哈希值的，返回的是0.</span></span><br><span class="line"><span class="comment">    2）如果key不等于null：</span></span><br><span class="line"><span class="comment">    首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的hash值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以得知HashMap是支持Key为空的，而HashTable是直接用Key来获取HashCode所以key为空会抛异常。</p><p>{其实上面就已经解释了为什么HashMap的长度<strong>为什么要是2的幂</strong>因为HashMap 使用的方法很巧妙，它通过 hash &amp; (table.length -1)来得到该对象的保存位，前面说过 HashMap 底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当 length 总是2的n次方时，hash &amp; (length-1)运算等价于对 length 取模，也就是hash%length，但是&amp;比%具有更高的效率。比如 n % 32 = n &amp; (32 -1)。}</p><p><strong>解读上述hash方法：</strong></p><p>我们先研究下key的哈希值是如何计算出来的。key的哈希值是通过上述方法计算出来的。</p><p>这个哈希方法首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的    hash值。计算过程如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）如果key等于null：</span></span><br><span class="line"><span class="comment">    可以看到当key等于null的时候也是有哈希值的，返回的是0.</span></span><br><span class="line"><span class="comment">    2）如果key不等于null：</span></span><br><span class="line"><span class="comment">    首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的hash值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在putVal函数中使用到了上述hash函数计算的哈希值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        。。。。。。。。。。。。。。</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//这里的n表示数组长度16</span></span><br><span class="line">       。。。。。。。。。。。。。。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>计算过程如下所示：</p><p>​    说明：</p><p>​        1）key.hashCode()；返回散列值也就是hashcode。假设随便生成的一个值。</p><p>​        2）n表示数组初始化的长度是16</p><p>​        3）&amp;（按位与运算）：运算规则：相同的二进制数位上，都是1的时候，结果为1，否则为零。</p><p>​        4）^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为0，不同为1。</p><p><img data-src="image-20191114193730911.png" alt="image-2019111419370911.png"></p><p>简单来说就是：</p><ul><li><p>高16 bit 不变，低16 bit 和高16 bit 做了一个异或（得到的 hashcode 转化为32位二进制，前16位和后16位低16 bit和高16 bit做了一个异或）</p><p><strong>问题：为什么要这样操作呢？</strong></p><p>如果当n即数组长度很小，假设是16的话，那么n-1即为  —》1111 ，这样的值和hashCode()直接做按位与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如上述：</span><br><span class="line">hashCode()值：     <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1110</span> <span class="number">1010</span></span><br><span class="line">&amp;</span><br><span class="line">n-<span class="number">1</span>即<span class="number">16</span>-<span class="number">1</span>--》<span class="number">15</span>：  。。。。。。。。。。。。。。。。。。。。。。<span class="number">1111</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">  <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span> ----》<span class="number">10</span>作为索引</span><br><span class="line">其实就是将hashCode值作为数组索引，那么如果下个高位hashCode不一致，低位一致的话，就会造成计算的索引还是<span class="number">10</span>,从而造成了哈希冲突了。降低性能。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>(n-1) &amp; hash = -&gt; 得到下标   (n-1)   n表示数组长度16，n-1就是15</p></li><li><p>取余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低。</p></li></ul><p>现在看putVal()方法，看看它到底做了什么。</p><p>主要参数：</p><ul><li>hash key的hash值</li><li>key 原始Key</li><li>value 要存放的值</li><li>onlyIfAbsent 如果true代表不更改现有的值</li><li>evict 如果为false表示table为创建状态</li></ul><p>putVal()方法源代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）transient Node&lt;K,V&gt;[] table; 表示存储Map集合中元素的数组。</span></span><br><span class="line"><span class="comment">    2）(tab = table) == null 表示将空的table赋值给tab,然后判断tab是否等于null，第一次肯定是null</span></span><br><span class="line"><span class="comment">    3）(n = tab.length) == 0 表示将数组的长度0赋值给n,然后判断n是否等于0，n等于0</span></span><br><span class="line"><span class="comment">    由于if判断使用双或，满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化。</span></span><br><span class="line"><span class="comment">    并将初始化好的数组长度赋值给n.</span></span><br><span class="line"><span class="comment">    4）执行完n = (tab = resize()).length，数组tab每个空间都是null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）i = (n - 1) &amp; hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中</span></span><br><span class="line"><span class="comment">    2）p = tab[i = (n - 1) &amp; hash]表示获取计算出的位置的数据赋值给节点p</span></span><br><span class="line"><span class="comment">    3) (p = tab[i = (n - 1) &amp; hash]) == null 判断节点位置是否等于null，如果为null，则执行代码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的节点放入该位置的桶中</span></span><br><span class="line"><span class="comment">        小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//创建一个新的节点存入到桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 执行else说明tab[i]不等于null，表示这个位置已经有值了。</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较桶中第一个元素(数组中的结点)的hash值和key是否相等</span></span><br><span class="line"><span class="comment">        1）p.hash == hash ：p.hash表示原来存在数据的hash值  hash表示后添加数据的hash值 比较两个 hash值是否相等</span></span><br><span class="line"><span class="comment">                 说明：p表示tab[i]，即 newNode(hash, key, value, null)方法返回的Node对象。</span></span><br><span class="line"><span class="comment">                    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) </span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    而在Node类中具有成员变量hash用来记录着之前数据的hash值的</span></span><br><span class="line"><span class="comment">             2）(k = p.key) == key ：p.key获取原来数据的key赋值给k  key 表示后添加数据的key 比较两个key的地址值是否相等</span></span><br><span class="line"><span class="comment">             3）key != null &amp;&amp; key.equals(k)：能够执行到这里说明两个key的地址值不相等，那么先判断后添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                说明：两个元素哈希值相等，并且key的值也相等</span></span><br><span class="line"><span class="comment">                将旧的元素整体对象赋值给e，用e来记录</span></span><br><span class="line"><span class="comment">                */</span> </span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等或者key不相等；判断p是否为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 说明是链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1)如果是链表的话需要遍历到最后节点然后插入</span></span><br><span class="line"><span class="comment">            2)采用循环遍历的方式，判断链表中是否有重复的key</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                1)e = p.next 获取p的下一个元素赋值给e</span></span><br><span class="line"><span class="comment">                2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键</span></span><br><span class="line"><span class="comment">                将该键值对插入链表中</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    1）创建一个新的节点插入到尾部</span></span><br><span class="line"><span class="comment">                     p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                     Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) </span></span><br><span class="line"><span class="comment">                     &#123;</span></span><br><span class="line"><span class="comment">                                return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                         &#125;</span></span><br><span class="line"><span class="comment">                         注意第四个参数next是null，因为当前元素插入到链表末尾了，那么下一个节点肯定是null</span></span><br><span class="line"><span class="comment">                         2）这种添加方式也满足链表数据结构的特点，每次向后添加新的元素</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    1)节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于</span></span><br><span class="line"><span class="comment">                    则将链表转换为红黑树</span></span><br><span class="line"><span class="comment">                    2）int binCount = 0 ：表示for循环的初始化值。从0开始计数。记录着遍历节点的个数。值是0表示第一个节点，1表示第二个节点。。。。7表示第八个节点，加上数组中的的一个元素，元素个数是9</span></span><br><span class="line"><span class="comment">                    TREEIFY_THRESHOLD - 1 --》8 - 1 ---》7</span></span><br><span class="line"><span class="comment">                    如果binCount的值是7(加上数组中的的一个元素，元素个数是9)</span></span><br><span class="line"><span class="comment">                    TREEIFY_THRESHOLD - 1也是7，此时转换红黑树</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//转换为红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                执行到这里说明e = p.next 不是null，不是最后一个元素。继续判断链表中结点的key值与插  入的元素的key值是否相等</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                要添加的元素和链表中的存在的元素的key相等了，则跳出for循环。不用再继续比较了</span></span><br><span class="line"><span class="comment">                直接执行下面的if语句去替换去 if (e != null) </span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                说明新添加的元素和当前节点不相等，继续查找下一个节点。</span></span><br><span class="line"><span class="comment">                用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line"><span class="comment">        也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，并返回旧值</span></span><br><span class="line"><span class="comment">        这里完成了put方法的修改功能</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                <span class="comment">//e.value 表示旧值  value表示新值 </span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改记录次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 判断实际大小是否大于threshold阈值，如果超过则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2将链表转换为红黑树的treeifyBin方法"><a href="#4-3-2将链表转换为红黑树的treeifyBin方法" class="headerlink" title="4.3.2将链表转换为红黑树的treeifyBin方法"></a>4.3.2将链表转换为红黑树的treeifyBin方法</h4><p>节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树，转换红黑树的方法  treeifyBin，整体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">   &#x2F;&#x2F;转换为红黑树 tab表示数组名  hash表示哈希值</span><br><span class="line">   treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure><p>treeifyBin方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">   替换指定哈希表的索引处桶中的所有链接节点，除非表太小，否则将修改大小。</span></span><br><span class="line"><span class="comment">   Node&lt;K,V&gt;[] tab = tab 数组名</span></span><br><span class="line"><span class="comment">   int hash = hash表示哈希值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64),</span></span><br><span class="line"><span class="comment">      就去扩容。而不是将节点变为红黑树。</span></span><br><span class="line"><span class="comment">      目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，那么重新计算哈希值</span></span><br><span class="line"><span class="comment">      ，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          <span class="comment">//扩容方法</span></span><br><span class="line">          resize();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化</span></span><br><span class="line"><span class="comment">          2）e = tab[index = (n - 1) &amp; hash]表示将数组中的元素取出赋值给e,e是哈希表中指定位置桶里的链表节点，从第一个开始</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="comment">//hd：红黑树的头结点   tl :红黑树的尾结点</span></span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="comment">//新创建一个树的节点，内容和当前链表节点e一致</span></span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                  <span class="comment">//将新创键的p节点赋值给红黑树的头结点</span></span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   p.prev = tl：将上一个节点p赋值给现在的p的前一个节点</span></span><br><span class="line"><span class="comment">                   tl.next = p;将现在节点p作为树的尾结点的下一个节点</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              e = e.next 将当前节点的下一个节点赋值给e,如果下一个节点不等于null</span></span><br><span class="line"><span class="comment">              则回到上面继续取出链表中节点转换为红黑树</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树</span></span><br><span class="line"><span class="comment">          而不是链表数据结构了</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>小结：上述操作一共做了如下几件事：</p><p>1.根据哈希表中元素个数确定是扩容还是树形化</p><p>2.如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</p><p>3.然后让桶中的第一个元素指向新创建的树根节点，替换桶的链表内容为树形化内容</p><h4 id="4-3-3扩容方法-resize"><a href="#4-3-3扩容方法-resize" class="headerlink" title="4.3.3扩容方法_resize"></a>4.3.3扩容方法_resize</h4><h5 id="4-3-3-1扩容机制"><a href="#4-3-3-1扩容机制" class="headerlink" title="4.3.3.1扩容机制"></a>4.3.3.1扩容机制</h5><p>想要了解HashMap的扩容机制你要有这两个问题</p><ul><li>1.什么时候才需要扩容</li><li>2.HashMap的扩容是什么</li></ul><p><strong>1.什么时候才需要扩容</strong></p><p>当HashMap中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75=12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。</p><p><strong>补充：</strong></p><p><strong>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。</strong></p><p><strong>2.HashMap的扩容是什么</strong></p><p> 进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 </p><p>HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n-1)&amp;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到”<strong>原位置+旧容量</strong>“这个位置。</p><p> 怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示： </p><p><img data-src="image-20191117110812839.png" alt="image-20191117110812839.png"></p><p> 因此元素在重新计算hash之后，因为n变为2倍，那么n-1的标记范围在高位多1bit(红色)，因此新的index就会发生这样的变化： </p><p><img data-src="image-20191117110934974.png" alt="image-20191117110934974.png"></p><p>说明：5是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以节点要么就在原来的位置，要么就被分配到”<strong>原位置+旧容量</strong>“这个位置。</p><p> 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就可以了，是0的话索引没变，是1的话索引变成“原索引+oldCap(<strong>原位置+旧容量</strong>)”。可以看看下图为16扩充为32的resize示意图： </p><p><img data-src="image-20191117111211630.png" alt="image-20191117111211630.png"></p><p>正是因为这样巧妙的rehash方式，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，在resize的过程中保证了rehash之后每个桶上的节点数一定小于等于原来桶上的节点数，保证了rehash之后不会出现更严重的hash冲突，均匀的把之前的冲突的节点分散到新的桶中了。</p><h5 id="4-3-3-2源码resize方法的解读"><a href="#4-3-3-2源码resize方法的解读" class="headerlink" title="4.3.3.2源码resize方法的解读"></a>4.3.3.2源码resize方法的解读</h5><p>下面是代码的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//得到当前数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//如果当前数组等于null长度返回0，否则返回当前数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//当前阀值点 默认是12(16*0.75)</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果老的数组长度大于0</span></span><br><span class="line">    <span class="comment">//开始计算扩容后的大小</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//修改阈值为int的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        没超过最大值，就扩充为原来的2倍</span></span><br><span class="line"><span class="comment">        1)(newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量</span></span><br><span class="line"><span class="comment">        2）oldCap &gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//老阈值点大于0 直接赋值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 老阈值赋值给新的数组长度</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 直接使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize最大上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的阀值 默认原来是12 乘以2之后变为24</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//newCap是新的数组长度--》32</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//判断旧数组是否等于空</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="comment">//遍历旧的哈希表的每个桶，重新计算桶里元素的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//原来的数据赋值为null 便于GC回收</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//判断数组是否有下一个引用</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//判断是否是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//说明是红黑树来处理冲突的，则调用相关方法把树分开</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 采用链表处理冲突</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//通过上述讲解的原理来计算节点的新位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                     <span class="comment">//这里来判断如果等于true e这个节点在resize之后不需要移动位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-删除方法-remove"><a href="#4-3-4-删除方法-remove" class="headerlink" title="4.3.4 删除方法(remove)"></a>4.3.4 删除方法(remove)</h4><p> 理解了put方法之后，remove方法已经没什么难度了，所以重复的内容就不再做详细介绍了。</p><p> 删除的话就是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于6的时候要转链表。 </p><p> 删除remove方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove方法的具体实现在removeNode方法中，所以我们重点看下removeNode方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> removeNode方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//根据hash找到位置 </span></span><br><span class="line">    <span class="comment">//如果当前key映射到的桶不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">//如果桶上的节点就是要找的key，则将node指向该节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明节点存在下一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//说明是以红黑树来处理的冲突，则获取红黑树要删除的节点</span></span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//判断是否以链表方式处理hash冲突，是的话则通过遍历链表来寻找要删除的节点</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较找到的key的value和要删除的是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="comment">//通过调用红黑树的方法来删除节点</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    <span class="comment">//链表删除</span></span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                <span class="comment">//记录修改次数</span></span><br><span class="line">                ++modCount;</span><br><span class="line">                <span class="comment">//变动的数量</span></span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-5查找元素方法-get"><a href="#4-3-5查找元素方法-get" class="headerlink" title="4.3.5查找元素方法(get)"></a>4.3.5查找元素方法(get)</h4><p> 查找方法，通过元素的Key找到Value。 </p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法主要调用的是getNode方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果哈希表不为空并且key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        判断数组元素是否相等</span></span><br><span class="line"><span class="comment">        根据索引的位置检查第一个元素</span></span><br><span class="line"><span class="comment">        注意：总是检查第一个元素</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果不是第一个元素，判断是否有后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树，是的话调用红黑树中的getTreeNode方法获取节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 不是红黑树的话，那就是链表结构了，通过循环的方法判断链表中是否存在该key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>1.get方法实现的步骤：</p><p>​    1）通过hash值获取该key映射到的桶</p><p>​    2）桶上的key就是要查找的key,则直接找到并返回</p><p>​    3）桶上的key不是要找的key,则查看后续的节点：</p><p>​            a:如果后续节点是红黑树节点，通过调用红黑树的方法根据key获取value</p><p>​            b:如果后续节点是链表节点，则通过循环遍历链表根据key获取value</p><p>2.上述红黑树节点调用的是getTreeNode方法通过树形节点的find方法进行查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">               TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">               <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                   p = pl;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                   p = pr;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                   <span class="keyword">return</span> p;<span class="comment">//找到之后直接返回</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                   p = pr;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                   p = pl;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                         (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                   p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">               <span class="comment">//递归查找</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> q;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   p = pl;</span><br><span class="line">           &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>3.查找红黑树，由于之前添加时已经保证这个树是有序的了，因此查找时基本就是折半查找，效率更高。</p><p>4.这里和插入时一样，如果对比节点的哈希值和要查找的哈希值相等，就会判断key是否相等，相等就直接返回。不相等就从子树中递归查找。</p><p>5.</p><p>​    若为树，则在树中通过key.equals(k)查找，O(logn) </p><p>​    若为链表，则在链表中通过key.equals(k)查找，O(n)。</p><h4 id="4-3-6遍历HashMap集合几种方式"><a href="#4-3-6遍历HashMap集合几种方式" class="headerlink" title="4.3.6遍历HashMap集合几种方式"></a>4.3.6遍历HashMap集合几种方式</h4><p> 1、分别遍历Key和Values </p><p><img data-src="image-20191117160455507.png" alt="image-2019111760455507.png"></p><p>2.使用迭代器Iterator</p><p><img data-src="image-20191117160627369.png" alt="image-20191117160627369.png"></p><p>3、通过get方式（不建议使用）</p><p><img data-src="image-20191117160733756.png" alt="image-20191117160733756.png"></p><p>说明：根据阿里开发手册，不建议使用这种方式，因为迭代两次。keySet获取Iterator一次，还有通过get又迭代一次。降低性能。</p><p>4.jdk8以后使用Map接口中的默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K,? <span class="keyword">super</span> V&gt; action)</span> </span></span><br><span class="line"><span class="function">BiConsumer接口中的方法：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span> 对给定的参数执行此操作。  </span></span><br><span class="line"><span class="function">参数 </span></span><br><span class="line"><span class="function">            t - 第一个输入参数 </span></span><br><span class="line"><span class="function">            u - 第二个输入参数</span></span><br></pre></td></tr></table></figure><p>遍历代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,String&gt; m1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        m1.put(<span class="string">"001"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">        m1.put(<span class="string">"002"</span>, <span class="string">"lisi"</span>);</span><br><span class="line">        m1.forEach((key,value)-&gt;&#123;</span><br><span class="line">            System.out.println(key+<span class="string">"---"</span>+value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-如何设计多个非重复的键值对要存储HashMap的初始化？"><a href="#5-如何设计多个非重复的键值对要存储HashMap的初始化？" class="headerlink" title="5.如何设计多个非重复的键值对要存储HashMap的初始化？"></a>5.如何设计多个非重复的键值对要存储HashMap的初始化？</h2><h3 id="5-1HashMap的初始化问题描述"><a href="#5-1HashMap的初始化问题描述" class="headerlink" title="5.1HashMap的初始化问题描述"></a>5.1HashMap的初始化问题描述</h3><p>​    如果我们确切的知道我们有多少键值对需要存储，那么我们在初始化HashMap的时候就应该指定它的容量，以防止HashMap自动扩容，影响使用效率。</p><p>​    默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(3-&gt;4、7-&gt;8、9-&gt;16) .这点我们在上述已经进行过讲解。</p><p> 《阿里巴巴Java开发手册》中建议我们设置HashMap的初始化容量。 </p><p><img data-src="2.bmp" alt="2.bmp"></p><p> 那么，为什么要这么建议？你有想过没有。 </p><p>当然，以上建议也是有理论支撑的。我们上面介绍过，HashMap的扩容机制，就是当达到扩容条件时会进行扩容。HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。在HashMap中，threshold = loadFactor * capacity。</p><p>所以，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会有可能发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。</p><p>但是设置初始化容量，设置的数值不同也会影响性能，那么当我们已知HashMap中即将存放的KV个数的时候，容量设置成多少为好呢？</p><h3 id="5-2HashMap中容量的初始化"><a href="#5-2HashMap中容量的初始化" class="headerlink" title="5.2HashMap中容量的初始化"></a>5.2HashMap中容量的初始化</h3><p>当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。那么，是不是我们只需要把已知的HashMap中即将存放的元素个数直接传给initialCapacity就可以了呢？</p><p>关于这个值的设置，在《阿里巴巴Java开发手册》有以下建议：</p><p><img data-src="image-20191117165438726.png" alt="image-20191117165438726.png"></p><p>也就是说，如果我们设置的默认值是7，经过Jdk处理之后，会被设置成8，但是，这个HashMap在元素个数达到 8*0.75 = 6的时候就会进行一次扩容，这明显是我们不希望见到的。我们应该尽量减少扩容。原因也已经分析过。</p><p>如果我们通过<strong>initialCapacity/ 0.75F + 1.0F</strong>计算，7/0.75 + 1 = 10 ,10经过Jdk处理之后，会被设置成16，这就大大的减少了扩容的几率。</p><p>当HashMap内部维护的哈希表的容量达到75%时（默认情况下），会触发rehash，而rehash的过程是比较耗费时间的。所以初始化容量要设置成<strong>initialCapacity/0.75 + 1</strong>的话，可以有效的减少冲突也可以减小误差。</p><p>所以，我可以认为，当我们明确知道HashMap中元素的个数的时候，把默认容量设置成<strong>initialCapacity/ 0.75F + 1.0F</strong>是一个在性能上相对好的选择，但是，同时也会牺牲些内存。</p><p>我们想要在代码中创建一个HashMap的时候，如果我们已知这个Map中即将存放的元素个数，给HashMap设置初始容量可以在一定程度上提升效率。</p><p>但是，JDK并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个2的幂。原因也已经分析过。</p><p>但是，为了最大程度的避免扩容带来的性能消耗，我们建议可以把默认容量的数字设置成<strong>initialCapacity/ 0.75F + 1.0F</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算------按位与、按位或、按位异或、取反、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</title>
      <link href="/2020/03/15/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2020/03/15/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>程序中的所有数在计算机内存中都是以二进制的形式储存的，位运算就是直接对整数在内存中的二进制位进行操作。</p><p><strong>1、原码、反码、补码(以byte的1、-1举例)</strong></p><p>示例                    1                      -1                                   </p><p>原码        0000 0001          1000 0001     ——&gt;第一位是符号位，0是正数，1为负数  </p><p>反码        0000 0001          1111 1110       ——&gt;正数反码是其自身，负数则符号位不变，其他位置全部取反</p><p>补码        0000 0001          1111 1111       ——-&gt;正数补码是其自身，负数则为反码+1</p><p>当然也可以从1通过取反，然后+1的方式得到-1的补码</p><p><strong>2、补码：用于将十进制的负整数转换为二进制数。十进制的正整数可以除以2取余，负整数则需要补码。</strong></p><p>  补码的流程：例如-10</p><p>　　10：0000 0000 0000 1010</p><p>​    取反：1111 1111   1111  0101</p><p>​                          +1</p><p>​    -10：1111  1111  1111  0110</p><p><strong>3、整数在内存中以补码存在。</strong></p><h2 id="一、按位与-amp"><a href="#一、按位与-amp" class="headerlink" title="一、按位与(&amp;)"></a><strong>一、按位与(&amp;)</strong></h2><p><strong>定义：如果两个相应的二进制位都为1，则该位的结果值为1，否则为0.</strong></p><p>示例：</p><h3 id="1、10与-10-amp-运算"><a href="#1、10与-10-amp-运算" class="headerlink" title="1、10与-10 &amp;运算"></a>1、10与-10 &amp;运算</h3><p>10：0000 0000 0000 1010     —–&gt;   十进制转二进制</p><p>-10：1111  1111  1111  0110     —–&gt;   -10就是10取反，然后+1(补码)</p><p>结果: 0000 0000 0000 0010     —–&gt;   结果为2</p><h2 id="二、按位或"><a href="#二、按位或" class="headerlink" title="二、按位或(|)"></a><strong>二、按位或(|)</strong></h2><p><strong>定义：如果两个相应的二进制位有一个为1，则该结果为1，否则为0.</strong></p><p>示例：</p><h3 id="1、10与-10-运算"><a href="#1、10与-10-运算" class="headerlink" title="1、10与-10 |运算"></a>1、10与-10 |运算</h3><p> 10：0000 0000 0000 1010</p><p>-10：1111  1111  1111  0110</p><p>结果: 1111  1111 1111   1110  —–&gt;结果-2</p><p>第一位为符号位，1代表是负数，因此是补码形式存在，补码–&gt;十进制。先-1再取反(符号位不变)，。</p><p>1000 0000 0000 0001</p><p>+1</p><p>1000 0000 0000 0010 ——&gt; -2</p><h2 id="三、按位异或"><a href="#三、按位异或" class="headerlink" title="三、按位异或(^)"></a><strong>三、按位异或(^)</strong></h2><p><strong>定义：如果两个相应的二进制位值不同则为1，否则为0</strong></p><p>示例：</p><h3 id="1、10与-10-运算-1"><a href="#1、10与-10-运算-1" class="headerlink" title="1、10与-10 ^运算"></a>1、10与-10 ^运算</h3><p> 10：0000 0000 0000 1010</p><p>-10：1111  1111  1111  0110</p><p>结果: 1111  1111 1111   1100  ——&gt; 结果-4</p><h2 id="四、取反"><a href="#四、取反" class="headerlink" title="四、取反(~)"></a><strong>四、取反(~)</strong></h2><p><strong>定义：用来对一个二进制按位取反。</strong></p><p>示例：</p><h3 id="1、10取反"><a href="#1、10取反" class="headerlink" title="1、10取反"></a>1、10取反</h3><p>10：0000 0000 0000 1010</p><p>结果: 1111  1111 1111  0101 ——&gt; 结果-11</p><h2 id="五、左移-lt-lt"><a href="#五、左移-lt-lt" class="headerlink" title="五、左移(&lt;&lt;)"></a><strong>五、左移(&lt;&lt;)</strong></h2><p><strong>定义：将一个数的各二进制位全部左移N位，右补0</strong></p><p>示例：</p><h3 id="1、10左移-lt-lt-2"><a href="#1、10左移-lt-lt-2" class="headerlink" title="1、10左移&lt;&lt;2"></a>1、10左移&lt;&lt;2</h3><p>10：0000 0000 0000 1010</p><p>结果: 0000 0000 0010 1000——&gt; 结果40</p><h2 id="六、右移-gt-gt"><a href="#六、右移-gt-gt" class="headerlink" title="六、右移(&gt;&gt;)"></a><strong>六、右移(&gt;&gt;)</strong></h2><p><strong>定义：将一个数的各二进制位全部右移N位，移到右边的低位被舍弃，对于无符号数高位补0，负数高位补1.</strong></p><h3 id="1、10右移-gt-gt-2"><a href="#1、10右移-gt-gt-2" class="headerlink" title="1、10右移&gt;&gt;2"></a>1、10右移&gt;&gt;2</h3><p>10：0000 0000 0000 1010</p><p>结果: 0000 0000 0000 0010——&gt; 结果2</p><h3 id="2、-10右移-gt-gt-2"><a href="#2、-10右移-gt-gt-2" class="headerlink" title="2、-10右移&gt;&gt;2"></a>2、-10右移&gt;&gt;2</h3><p>-10：1111  1111  1111  0110</p><p>结果: 1111  1111 1111   1101</p><p>　　　　　 -1</p><p>​          1111  1111 1111   1100</p><p>​          取反，符号位不变</p><p>​           1000 0000 0000 0011</p><p>结果：-3</p><h2 id="七、-gt-gt-gt-无符号右移"><a href="#七、-gt-gt-gt-无符号右移" class="headerlink" title="七、&gt;&gt;&gt;(无符号右移)"></a><strong>七、&gt;&gt;&gt;(无符号右移)</strong></h2><p><strong>定义：将一个数的各二进制位全部右移N位，移到右边的低位被舍弃，对于无符号数高位补0，只是对32位和64位的值有意义。</strong></p><p>示例：</p><h3 id="1、-10-gt-gt-gt-2"><a href="#1、-10-gt-gt-gt-2" class="headerlink" title="1、-10&gt;&gt;&gt;2"></a>1、-10&gt;&gt;&gt;2</h3><p>-10：1111 1111 1111 1111 1111  1111  1111  0110  ——-&gt;由于&gt;&gt;&gt;只对32和64位有意义，所以把-10定义成32位的</p><p>结果: 0011  1111 1111 1111 1111 1111 1111 1101</p><p>　　　　　　-1</p><p>​          0011  1111 1111 1111 1111 1111 1111 1100</p><p>​             取反码(符号位不变，正数反码是其本身)</p><p>​         0011  1111 1111 1111 1111 1111 1111 1100</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap底层实现原理是什么?jdk8做了哪些优化?</title>
      <link href="/2020/03/13/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-jdk8%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/"/>
      <url>/2020/03/13/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-jdk8%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>HashMap 是使用频率最高的类型之一，同时也是面试经常被问到的问题之一，这是因为HashMap<br>的知识点有很多，同时它又属于Java基础知识的一部分，因此在面试中经常被问到。<br>本课时的面试题是，HashMap底层是如何实现的？在JDK1.8中它都做了哪些优化？<br><strong>典型回答</strong><br>在JDK1.7中HashMap是以数组加链表的形式组成的，JDK1.8之后新增了红黑树的组成结构，当链表大于8时，链表结构会转换成红黑树结构，它的组成结构如下图所示：</p><p><img data-src="1.png" alt="1"></p><p>数组中的元素我们称之为哈希桶，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line"> V value;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="keyword">this</span>.hash = hash;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">V oldValue = value;</span><br><span class="line">value = newValue;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"><span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">Objects.equals(value, e.getValue()))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出每个哈希桶中包含了四个字段：hash、key、value、next，其中next 表示链表的下一个节点。<br>JDK 1.8之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。</p><p><strong>考点分析</strong><br>上面大体介绍了HashMap的组成结构，但面试官想要知道的远远不止这些，和HashMap相关的面试题还有以下几个：</p><ul><li>JDK 1.8 HashMap 扩容时做了哪些优化？</li><li>加载因子为什么是0.75？</li><li>当有哈希冲突时，HashMap是如何查找并确认元素的？</li><li>HashMap 源码中有哪些重要的方法？</li><li>HashMap是如何导致死循环的？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-HashMap源码分析"><a href="#1-HashMap源码分析" class="headerlink" title="1.HashMap源码分析"></a>1.HashMap源码分析</h3><p>声明：本系列课程在未做特殊说明的情况下，都是以目前主流的JDK版本1.8为例来进行源码分析的。</p><p>HashMap源码中包含了以下几个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 初始化长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 最大长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的加载因子 (扩容因子)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换红黑树的临界值，当链表长度大于此值时，会把链表结构转换为红黑树结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换链表的临界值，当元素小于此值时，会将红黑树结构转换成链表结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小树容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY =</span><br></pre></td></tr></table></figure><p><strong>什么是加载因子？加载因子为什么是0.75？</strong><br>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是0.5，HashMap<br>的初始化容量是16，那么当HashMap中有16*0.5=8个元素时，HashMap就会进行扩容。</p><p><strong>那加载因子为什么是0.75而不是0.5或者1.0呢？</strong><br>这其实是出于容量和性能之间平衡的结果：</p><ul><li>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</li><li>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</li></ul><p>所以综合了以上情况就取了一个0.5到1.0的平均数0.75作为加载因子。</p><p>HashMap源码中三个重要方法：<strong>查询</strong>、<strong>新增</strong>和<strong>数据扩容</strong>。<br>先来看查询源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 对 key 进行哈希操作</span></span><br><span class="line"><span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"><span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个元素是否是要查询的元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 下一个节点非空判断</span></span><br><span class="line"><span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果第一节点是树结构，则使用 getTreeNode 直接获取相应的数据</span></span><br><span class="line"><span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// 非树结构，循环节点判断</span></span><br><span class="line">                <span class="comment">// hash 相等并且 key 相同，则返回此节点</span></span><br><span class="line"> <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，当哈希冲突时我们需要通过判断key值是否相等，才能确认此元素是不是我们想要的元素。<br>HashMap第二个重要方法：<strong>新增方法</strong>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对 key 进行哈希操作</span></span><br><span class="line"><span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 哈希表为空则创建表  </span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"> <span class="comment">// 根据 key 的哈希值计算出要插入的数组索引 i    </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line"> <span class="comment">// 如果 table[i] 等于 null，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">// 如果 key 已经存在了，直接覆盖 value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"> <span class="comment">// 如果 key 不存在，判断是否为红黑树     </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="comment">// 红黑树直接插入键值对</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 为链表结构，循环准备插入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 下一个元素为空时</span></span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度大于 8 转换为红黑树进行处理</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> <span class="comment">//  key 已经存在直接覆盖 value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过最大容量，扩容</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增方法的执行流程，如下图所示：</p><p><img data-src="2.png" alt="2"></p><p>HashMap 第三个重要的方法是扩容方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 扩容前的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 扩容前的数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 预定义新数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩大容量为当前容量的两倍，但不能超过 MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 当前数组没有数据，使用初始化的值</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 如果初始化的值为 0，则使用默认的初始化容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的容量等于 0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">     Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 开始扩容，将新的容量赋值给 table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 原数据不为空，将原数据复制到新 table 中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据容量循环数组，复制非空元素到新 table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果链表只有一个，则进行直接赋值</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 红黑树相关的操作</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表复制，JDK 1.8 扩容优化部分</span></span><br><span class="line">                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                         <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                             &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将原索引放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="comment">// 将原索引 + oldCap 放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，JDK1.8在扩容时并没有像JDK1.7那样，重新计算每个元素的哈希值，而是通过高位运算（e.hash&amp;oldCap）来确定元素是否需要移动，比如key1的信息如下：</p><ul><li>key1.hash=10 0000 1010</li><li>oldCap=16 00010000</li></ul><p>使用e.hash&amp;oldCap得到的结果高一位为0，当结果为0时表示元素在扩容时位置不会发生任何变化，而key 2信息如下：</p><ul><li>key2.hash=10 0001 0001</li><li>oldCap=1600010000</li></ul><p>这时候得到的结果高一位为1，当结果为1时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置+原数组长度，如下图所示：</p><p><img data-src="3.png" alt="3"></p><p>其中红色的虚线图代表了扩容时元素移动的位置。</p><h3 id="2-HashMap-死循环分析"><a href="#2-HashMap-死循环分析" class="headerlink" title="2.HashMap 死循环分析"></a>2.HashMap 死循环分析</h3><p>以JDK1.7为例，假设HashMap默认大小为2，原本HashMap中有一个元素key（5），我们再使用两个线程：t1添加元素key（3），t2添加元素key（7），当元素key（3）和key（7）都添加到HashMap<br>中之后，线程t1在执行到Entry&lt;K，V&gt;next=e.next；时，交出了CPU的使用权，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程一执行此处</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此时线程t1中的e指向了key（3），而next 指向了key（7）；之后线程t2重新rehash 之后链表的顺序被反转，链表的位置变成了key（5）→key（7）→key（3），其中“→”用来表示下一个元素。<br>当t1重新获得执行权之后，先执行newTalbe[i]=e把key（3）的next 设置为key（7），而下次循环时查询到key（7）的next 元素为key（3），于是就形成了key（3）和key（7）的循环引用，因此就导致了死循环的发生，如下图所示：</p><p><img data-src="4.png" alt="4"></p><p>当然发生死循环的原因是JDK1.7链表插入方式为首部倒序插入，这个问题在JDK1.8得到了改善，变成了尾部正序插入。<br>有人曾经把这个问题反馈给了Sun公司，但Sun公司认为这不是一个问题，因为HashMap本身就是非线程安全的，如果要在多线程下，建议使用ConcurrentHashMap替代，但这个问题在面试中被问到的几率依然很大，所以在这里需要特别说明一下。</p><p><strong>小结</strong></p><p>本课时介绍了HashMap的底层数据结构，在JDK1.7时HashMap是由数组和链表组成的，而JDK<br>1.8则新增了红黑树结构，当链表的长度大于8时会转换为红黑树存储，以提升元素的操作性能。同时还介绍了HashMap的三个重要方法，查询、添加和扩容，以及JDK1.7 resize0在并发环境下导致死循环的原因。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 美团点评2020校招后台开发方向笔试题 </title>
      <link href="/2020/03/12/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%842020%E6%A0%A1%E6%8B%9B%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2020/03/12/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%842020%E6%A0%A1%E6%8B%9B%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-RESTful调用和-RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service-Mesh，如果了解Service-Mesh是用来解决什么问题的？"><a href="#1-RESTful调用和-RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service-Mesh，如果了解Service-Mesh是用来解决什么问题的？" class="headerlink" title="1.RESTful调用和 RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service Mesh，如果了解Service Mesh是用来解决什么问题的？"></a>1.RESTful调用和 RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service Mesh，如果了解Service Mesh是用来解决什么问题的？</h3><p>1、RESTful<strong>是一种软件架构风格</strong>，<strong>用于约束客户端和服务器交互</strong>，满足这些约束条件和原则的应用程序或设计就是 RESTful。比如HTTP协议使用同一个URL地址，通过GET，POST，PUT，DELETE等方式实现查询、提交、删除数据。</p><p>RPC是<strong>远程过程调用</strong>，是用于<strong>解决分布式系统服务间调用的一种方式</strong>。RPC采用客户端与服务端模式，双方通过约定的接口（常见为通过IDL定义或者是代码定义）以类似本地方法调用的方式来进行交互，客户端根据约定传输调用函数+参数给服务端（一般是网络传输TCP/UDP），服务端处理完按照约定将返回值返回给客户端。</p><p><strong>重点为RESTful HTTP的约束风格，RPC调用模型。</strong></p><p>1、可分为两大部分RPC +服务治理<br>RPC部分 = IDL  +客户端/服务端实现层  +协议层 +数据传输层<br>服务治理 =服务管理（注册中心） +服务监控 +服务容灾 +服务鉴权</p><p>2、 Service Mesh为了解决传统微服务框架”胖客户端”方式，引入的如下问题：<br>与业务无关的服务治理逻辑与业务代码强耦合，框架、SDK的升级与业务代码强绑定，多语言的胖客户端支持起来性价比极低。</p><h3 id="2-请描述避免多线程竞争时有哪些手段？"><a href="#2-请描述避免多线程竞争时有哪些手段？" class="headerlink" title="2.请描述避免多线程竞争时有哪些手段？"></a>2.请描述避免多线程竞争时有哪些手段？</h3><p>1) 不可变对象；</p><p>2) 互斥锁；</p><p>3)  ThreadLocal 对象；</p><p>4) CAS；</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p><strong>给出一个布尔表达式的字符串，比如：true or false and false，表达式只包含true，false，and和or，现在要对这个表达式进行布尔求值，计算结果为真时输出true、为假时输出false，不合法的表达时输出error（比如：true true）。表达式求值是注意and 的优先级比 or 要高，比如：true or false and false，等价于 true or (false and false)，计算结果是 true。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">        String str = cal();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine().trim();</span><br><span class="line"><span class="comment">//        String str = "false&amp;nbs***bsp;true and false";</span></span><br><span class="line">        String[] words = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(words));</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(<span class="string">"true"</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(<span class="string">"false"</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(<span class="string">"and"</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() != <span class="number">2</span> &amp;&amp; i != words.length - <span class="number">1</span></span><br><span class="line">                        &amp;&amp; (words[i + <span class="number">1</span>].equals(<span class="string">"true"</span>) || words[i + <span class="number">1</span>].equals(<span class="string">"false"</span>)))&#123;</span><br><span class="line">                    <span class="keyword">int</span> val = words[i + <span class="number">1</span>].equals(<span class="string">"true"</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                    stack.push(stack.pop() &amp; val);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(<span class="string">"or"</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(last == -<span class="number">1</span>)&#123;</span><br><span class="line">                last = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(last == <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> or = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(or != <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">                <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() != <span class="number">2</span>) val = stack.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">                last = last | val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last == <span class="number">1</span> ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>给出两个字符串，分别是模式串P和目标串T，判断模式串和目标串是否匹配，匹配输出 1，不匹配输出 0。模式串中‘？’可以匹配目标串中的任何字符，模式串中的 ’*’可以匹配目标串中的任何长度的串，模式串的其它字符必须和目标串的字符匹配。例如P=a?b，T=acb，则P 和 T 匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String p = sc.next();</span><br><span class="line">        String s = sc.next();</span><br><span class="line">        <span class="comment">// System.out.println(s + " - " + p);</span></span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; p.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((dp[m][n] ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      <categories>
          
          <category> 牛客真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String的特点是什么？它有哪些重要的方法？</title>
      <link href="/2020/03/11/String%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%20%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/11/String%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%20%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>几乎所有的Java面试都是以String开始的，如果第一个问题没有回答好，则会给面试官留下非常不好的第一印象，而糟糕的第一印象则会直接影响到自己的面试结果，就好像刚破壳的小鹅一样，会把第一眼看到的动物当成自己的母亲，即使它第一眼看到的是一只小狗或小猫，也会默认跟随其后，心理学把这种现象叫做<strong>印刻效应</strong>。印刻效应不仅存在于低等动物之中，同样也适用于人类，所以对于String的知识，我们必须深入的掌握才能为自己赢得更多的筹码。</p><p>本课时的问题是：String 是如何实现的？它有哪些重要的方法？</p><h3 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a><strong>典型回答</strong></h3><p>以主流的JDK版本1.8来说，String内部实际存储结构为char数组，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;，<span class="title">CharSequence</span></span>&#123;</span><br><span class="line">    <span class="comment">//用于存储字符串的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value [];</span><br><span class="line">    <span class="comment">//缓存字符串的 hash code </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;<span class="comment">//Default to 0</span></span><br><span class="line">    <span class="comment">//..其他内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 源码中包含下面几个重要的方法。</p><h3 id="1-多构造方法"><a href="#1-多构造方法" class="headerlink" title="1.多构造方法"></a>1.多构造方法</h3><p>String字符串有以下4个重要的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value =original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash =original.hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char[]为参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value=Arrays.copyof(value，value<span class="number">.1</span>ength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StringBuffer为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(buffer)&#123;</span><br><span class="line"><span class="keyword">this</span>.value=Arrays.copyof（buffer.getValue()，buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stringBuilder为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value =Arrays.copyof(builder.getValue()，builder<span class="number">.1</span>ength());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，比较容易被我们忽略的是以StringBuffer和StringBuilder为参数的构造函数，因为这三种数据类型，我们通常都是单独使用的，所以这个小细节我们需要特别留意一下。</p><h3 id="2-equals（）比较两个字符串是否相等"><a href="#2-equals（）比较两个字符串是否相等" class="headerlink" title="2.equals（）比较两个字符串是否相等"></a>2.equals（）比较两个字符串是否相等</h3><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对象引用相同直接返回 true </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==anObject)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断需要对比的值是否为String类型，如果不是则直接返回false </span></span><br><span class="line">    <span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">        String anotherString=(String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span>(n == anotherString.value.length)&#123;</span><br><span class="line">    <span class="comment">//把两个字符串都转换为char数组对比</span></span><br><span class="line">    <span class="keyword">char</span> vl[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环比对两个字符串的每一个字符</span></span><br><span class="line">    <span class="keyword">while</span>（n-- != <span class="number">0</span>）&#123;</span><br><span class="line">    <span class="comment">//如果其中有一个字符不相等就 true false，否则继续对比</span></span><br><span class="line">                <span class="keyword">if</span>(vl[i] != v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 类型重写了Object中的equals(）方法，equals(）方法需要传递一个Object类型的参数值，在比较时会先通过instanceof 判断是否为String 类型，如果不是则会直接返回false，instanceof的使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object oString=<span class="string">"123"</span>;</span><br><span class="line">Object oInt =<span class="number">123</span>;</span><br><span class="line">System.out.println(oString <span class="keyword">instanceof</span> String);<span class="comment">//返回 true</span></span><br><span class="line">System.out.println(oInt <span class="keyword">instanceof</span> String);<span class="comment">//返回false</span></span><br></pre></td></tr></table></figure><p>当判断参数为String类型之后，会循环对比两个字符串中的每一个字符，当所有字符都相等时返回true，否则则返回false。<br>还有一个和equals0比较类似的方法equalslgnoreCase0，它是用于忽略字符串的大小写之后进行字符串对比。</p><h3 id="3-compareTo（）比较两个字符串"><a href="#3-compareTo（）比较两个字符串" class="headerlink" title="3.compareTo（）比较两个字符串"></a>3.compareTo（）比较两个字符串</h3><p>compareTo0方法用于比较两个字符串，返回的结果为int类型的值，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenl=value.length;</span><br><span class="line">    <span class="keyword">int</span> len2=anotherString.value.length;</span><br><span class="line">    <span class="comment">//获取到两个字符串长度最短的那个int值</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">1</span>im=Math.min(<span class="number">1</span>en1，<span class="number">1</span>en2);</span><br><span class="line">    <span class="keyword">char</span> vl[]=value;</span><br><span class="line">    <span class="keyword">char</span> v2[]=anotherString.value;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对比每一个字符</span></span><br><span class="line">    <span class="keyword">while</span>(k &lt; lim)&#123;</span><br><span class="line"><span class="keyword">char</span> cl=vl[k];</span><br><span class="line"><span class="keyword">char</span> c2=v2[k];</span><br><span class="line"><span class="keyword">if</span>（c1 != c2）&#123;</span><br><span class="line"><span class="comment">//有字符不相等就返回差值</span></span><br><span class="line"><span class="keyword">return</span> c1-c2;</span><br><span class="line">        &#125;</span><br><span class="line">k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>en1 - <span class="number">1</span>en2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，compareTo0方法会循环对比所有的字符，当两个字符串中有任意一个字符不相同时，则return char1-char2。比如，两个字符串分别存储的是1和2，返回的值是-1；如果存储的是1和1，则返回的值是0，如果存储的是2和1，则返回的值是1。<br>还有一个和compareTo0 比较类似的方法compareTolgnoreCase0，用于忽略大小写后比较两个字符串。<br>可以看出compareTo0方法和equals0方法都是用于比较两个字符串的，但它们有两点不同：</p><ul><li>equals0可以接收一个Object 类型的参数，而compareTo0只能接收一个String类型的参数；    </li><li>equals0返回值为Boolean，而compareTo0的返回值则为int。</li></ul><p>它们都可以用于两个字符串的比较，当equals0方法返回true时，或者是compareTo0方法返回0时，则表示两个字符串完全相同。</p><h3 id="4-其他重要方法"><a href="#4-其他重要方法" class="headerlink" title="4.其他重要方法"></a>4.其他重要方法</h3><ul><li>indexOf(）：查询字符串首次出现的下标位置</li><li>lastlndexOf()：查询字符串最后出现的下标位置</li><li>contains()：查询字符串中是否包含另一个字符串</li><li>toLowerCase()：把字符串全部转换成小写</li><li>toUpperCase()：把字符串全部转换成大写</li><li>length()：查询字符串的长度</li><li>trim()：去掉字符串首尾空格</li><li>replace()：替换字符串中的某些字符</li><li>split()：把字符串分割并返回字符串数组</li><li>join()：把字符串数组转为字符串</li></ul><p><strong>考点分析</strong></p><p>这道题目考察的重点是，你对Java 源码的理解，这也从侧面反应了你是否热爱和喜欢专研程序，而这正是一个优秀程序员所必备的特质。<br>String 源码属于所有源码中最基础、最简单的一个，对String源码的理解也反应了你的Java基础功底。<br>String问题如果再延伸一下，会问到一些更多的知识细节，这也是大厂一贯使用的面试策略，从一个知识点入手然后扩充更多的知识细节，对于String也不例外，通常还会关联的询问以下问题：</p><ul><li>为什么String 类型要用final修饰？</li><li>==和equals的区别是什么？</li><li>String和StringBuilder、StringBuffer 有什么区别？</li><li>String的intern()方法有什么含义？</li><li>String 类型在 JVM（Java虚拟机）中是如何存储的？编译器对String做了哪些优化？</li></ul><p>接下来我们一起来看这些问题的答案。</p><h4 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a><strong>知识拓展</strong></h4><h5 id="1-和equals的区别"><a href="#1-和equals的区别" class="headerlink" title="1.==和equals的区别"></a>1.==和equals的区别</h5><p>==对于基本数据类型来说，是用于比较“值”是否相等的；而对于引用类型来说，是用于比较引用地址是否相同的。<br>查看源码我们可以知道Object中也有equals0方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Object中的equals0方法其实就是==，而String重写了equals0方法把它修改成比较两个字符串的值是否相等。<br>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对象引用相同直接返回 true </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==anObject)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断需要对比的值是否为String类型，如果不是则直接返回false </span></span><br><span class="line">    <span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">        String anotherString=(String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span>(n == anotherString.value.length)&#123;</span><br><span class="line">    <span class="comment">//把两个字符串都转换为char数组对比</span></span><br><span class="line">    <span class="keyword">char</span> vl[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环比对两个字符串的每一个字符</span></span><br><span class="line">    <span class="keyword">while</span>（n-- != <span class="number">0</span>）&#123;</span><br><span class="line">    <span class="comment">//如果其中有一个字符不相等就 true false，否则继续对比</span></span><br><span class="line">                <span class="keyword">if</span>(vl[i] != v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-final-修饰的好处"><a href="#2-final-修饰的好处" class="headerlink" title="2.final 修饰的好处"></a>2.final 修饰的好处</h5><p>从String类的源码我们可以看出String是被final修饰的不可继承类，源码如下：</p><p>Java 语言之父James Gosling的回答是，他会更倾向于使用final，因为它能够缓存结果，当你在传参时不需要考虑谁会修改它的值；如果是可变类的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上就会有一定的损失。<br>James Gosling 还说迫使String类设计成不可变的另一个原因是安全，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，它的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题，这是迫使String类设计成不可变类的一个重要原因。<br>总结来说，使用final修饰的第一个好处是安全；第二个好处是高效，以JVM中的字符串常量池来举例，如下两个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"java"</span>;</span><br><span class="line">String s2 = <span class="string">"java"</span>;</span><br></pre></td></tr></table></figure><p>只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如下图所示：</p><p><img data-src="1.png" alt="1"></p><p>试想一下如果String是可变的，那当s1的值修改之后，52的值也跟着改变了，这样就和我们预期的结果不相符了，因此也就没有办法实现字符串常量池的功能了。</p><h5 id="3-String-和StringBuilder、StringBuffer的区别"><a href="#3-String-和StringBuilder、StringBuffer的区别" class="headerlink" title="3.String 和StringBuilder、StringBuffer的区别"></a>3.String 和StringBuilder、StringBuffer的区别</h5><p>因为String类型是不可变的，所以在字符串拼接的时候如果使用String的话性能会很低，因此我们就需要使用另一个数据类型 StringBuffer，它提供了append和insert方法可用于字符串的拼接，它使用synchronized来保证线程安全，如下源码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    toStringCache =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    toStringCache =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为它使用了synchronized来保证线程安全，所以性能不是很高，于是在JDK1.5就有了StringBuilder，它同样提供了append和insert的拼接方法，但它没有使用synchronized来修饰，因此在性能上要优于StringBufer，所以在非并发操作的环境下可使用 StringBuilder来进行字符串拼接。</p><h5 id="4-String-和JVM"><a href="#4-String-和JVM" class="headerlink" title="4.String 和JVM"></a>4.String 和JVM</h5><p>String 常见的创建方式有两种，直接赋值的方式”String s1=”Java”；”和“Strings2=new String（”Java”）；”的方式，但两者在JVM的存储区域却截然不同，在JDK1.8中，变量s1会先去字符串常量池中找字符串“Java”，如果有相同的字符则直接返回常量句柄，如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量s2是直接在堆上创建一个变量，如果调用<br>intern方法才会把此字符串保存到常量池中，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String sl =<span class="keyword">new</span> String(<span class="string">"Java"</span>); </span><br><span class="line">String s2=s1.intern();</span><br><span class="line">String s3=<span class="string">"Java"</span>;</span><br><span class="line">System.out.println(s1 ==s2);<span class="comment">//false </span></span><br><span class="line">System.out.println(s2 ==s3);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>它们在 JVM 存储的位置，如下图所示：</p><p><img data-src="2.png" alt="2"></p><p>注：JDK1.7之后把永生代换成的元空间，把字符串常量池从方法区移到了Java堆上。<br>除此之外编译器还会对String字符串做一些优化，例如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Ja"</span> + <span class="string">"va"</span>;</span><br><span class="line">String s2 = <span class="string">"Java"</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure><p>虽然51拼接了多个字符串，但对比的结果却是true，我们使用反编译工具，看到的结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"StringExample.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">lagou</span>.<span class="title">interview</span>.<span class="title">StringExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> com.lagou.interview.StringExample();</span><br><span class="line">Code:</span><br><span class="line">            <span class="number">0</span>:aload_0</span><br><span class="line">            1:invokespecial #1//Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">            <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">       LineNumberTable:</span><br><span class="line">     line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">0: ldc           #2                  // String Java</span><br><span class="line"><span class="number">2</span>: astore_1</span><br><span class="line">       3: ldc           #2                  // String Java</span><br><span class="line"><span class="number">5</span>:astore_2</span><br><span class="line">        6:getstatic     #3 //Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"><span class="number">9</span>: aload_1</span><br><span class="line"> <span class="number">10</span>: aload_2</span><br><span class="line">        <span class="number">11</span>: if_acmpne     <span class="number">18</span></span><br><span class="line">        <span class="number">14</span>: iconst_1</span><br><span class="line">        <span class="number">15</span>: goto          <span class="number">19</span></span><br><span class="line">        <span class="number">18</span>: iconst_0</span><br><span class="line">      19: invokevirtual #4  </span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">        LineNumberTable:</span><br><span class="line">        <span class="number">1</span>ine <span class="number">5</span>:<span class="number">0</span></span><br><span class="line">        <span class="number">1</span>ine <span class="number">6</span>:<span class="number">3</span></span><br><span class="line">        line <span class="number">7</span>:<span class="number">6</span></span><br><span class="line">        <span class="number">1</span>ine <span class="number">8</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从编译代码#2可以看出，代码“Ja”+”va”被直接编译成了“Java”，因此s1==s2的结果才是<br>true，这就是编译器对字符串优化的结果。<br>小结<br>本课时从String 的源码入手，重点讲了String的构造方法、equals0方法和compareTo())方法，其中equals(）重写了Object的equals())方法，把引用对比改成了字符串值对比，也介绍了final修饰String的好处，可以提高效率和增强安全性，同时我们还介绍了String和JVM的一些执行细节。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】一对一关联映射</title>
      <link href="/2020/03/10/hibernate%E4%B8%80%E5%AF%B9%E4%B8%80%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/10/hibernate%E4%B8%80%E5%AF%B9%E4%B8%80%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p><img data-src="1.png" alt="1"></p><h3 id="一-XML方式"><a href="#一-XML方式" class="headerlink" title="一.XML方式"></a>一.XML方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 标识一个类的xml映射,name为类名,table为表名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"Person"</span> <span class="attr">cascade</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Person.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"foreign"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"property"</span>&gt;</span>user<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idNumber"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">constrained</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过&lt;one-to-one&gt; 元素配置。</p><p>•constrained 属性为 true，表明 PERSON 表 ID 为外键，参照主表（USER）。</p><p>•外键表实体类配置文件中 OID 使用 foreign 生成策略。</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">User user  = <span class="keyword">new</span> User();</span><br><span class="line">user.setUserName(<span class="string">"zs"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"ls"</span>);</span><br><span class="line">person.setIdNumber(<span class="string">"2017011776"</span>);</span><br><span class="line">user.setPerson(person);</span><br><span class="line">person.setUser(user);</span><br><span class="line">session.save(user);</span><br><span class="line">session.save(person);</span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-注解方式"><a href="#二-注解方式" class="headerlink" title="二.注解方式"></a>二.注解方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@OneToOne</span>(cascade=CascadeType.ALL)</span><br><span class="line"><span class="meta">@PrimaryKeyJoinColumn</span>(name=<span class="string">"id"</span>)</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator = <span class="string">"foreign"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name = <span class="string">"foreign"</span>, strategy = <span class="string">"foreign"</span>, parameters = &#123;</span><br><span class="line"><span class="meta">@Parameter</span>(name = <span class="string">"property"</span>, value = <span class="string">"user"</span>) &#125;)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="meta">@OneToOne</span>(mappedBy=<span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-唯一外键关联"><a href="#三-唯一外键关联" class="headerlink" title="三.唯一外键关联"></a>三.唯一外键关联</h3><h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"person"</span> <span class="attr">column</span>=<span class="string">"PERSONID"</span> <span class="attr">cascade</span>=<span class="string">"all"</span> <span class="attr">unique</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Person.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Person"</span> <span class="attr">table</span>=<span class="string">"PERSON"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idNumber"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 外键关联方式映射与User的一对一关系   property-ref:外键列对应的属性名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">property-ref</span>=<span class="string">"person"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">User user  = <span class="keyword">new</span> User();</span><br><span class="line">user.setUserName(<span class="string">"zs"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"ls"</span>);</span><br><span class="line">person.setIdNumber(<span class="string">"2017011776"</span>);</span><br><span class="line">user.setPerson(person);</span><br><span class="line">person.setUser(user);</span><br><span class="line">session.save(user);</span><br><span class="line">session.save(person);</span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@OneToOne</span>(cascade=CascadeType.ALL)</span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"PERSONID"</span>)</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userName = userName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.person = person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="meta">@OneToOne</span>(mappedBy=<span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIdNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> idNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdNumber</span><span class="params">(String idNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.idNumber = idNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.user = user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-组合关系映射"><a href="#四-组合关系映射" class="headerlink" title="四.组合关系映射"></a>四.组合关系映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"contact"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"phoneNum"</span>)</span><br><span class="line"><span class="keyword">private</span> String tel;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"><span class="meta">@Embedded</span></span><br><span class="line"><span class="meta">@AttributeOverrides</span>(value=&#123;</span><br><span class="line">    <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"province"</span>, </span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_province"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"city"</span>,</span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_city"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"district"</span>,</span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_district"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"detail"</span>,</span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_detail"</span>))&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Address homeAddress;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTel</span><span class="params">(String tel)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tel = tel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Address <span class="title">getHomeAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> homeAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHomeAddress</span><span class="params">(Address homeAddress)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.homeAddress = homeAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span><span class="comment">//指明为嵌入式类，不需要单独进行映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String province;</span><br><span class="line"><span class="keyword">private</span> String city;</span><br><span class="line"><span class="keyword">private</span> String district;</span><br><span class="line"><span class="keyword">private</span> String detail;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProvince</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> province;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProvince</span><span class="params">(String province)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.province = province;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> city;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span><span class="params">(String city)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.city = city;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDistrict</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> district;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDistrict</span><span class="params">(String district)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.district = district;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> detail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDetail</span><span class="params">(String detail)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.detail = detail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">Contact contact = <span class="keyword">new</span> Contact();</span><br><span class="line">contact.setEmail(<span class="string">"273903932@qq.com"</span>);</span><br><span class="line">contact.setTel(<span class="string">"12312123451"</span>);</span><br><span class="line">Address address = <span class="keyword">new</span> Address();</span><br><span class="line">address.setProvince(<span class="string">"河北省"</span>);</span><br><span class="line">address.setCity(<span class="string">"秦皇岛市"</span>);</span><br><span class="line">address.setDistrict(<span class="string">"昌黎县"</span>);</span><br><span class="line">address.setDetail(<span class="string">"黎昌尚府小区"</span>);</span><br><span class="line">contact.setHomeAddress(address); </span><br><span class="line">session.save(contact);</span><br><span class="line"></span><br><span class="line">tx.commit();</span><br><span class="line"> </span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】单实体映射</title>
      <link href="/2020/03/10/hibernate%E5%8D%95%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/10/hibernate%E5%8D%95%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="Java程序中区分不同对象。"><a href="#Java程序中区分不同对象。" class="headerlink" title="Java程序中区分不同对象。"></a>Java程序中区分不同对象。</h3><p>​    <strong>1.Java语言中通过内存地址区分不同对象；</strong></p><p>​    <strong>2.两种比较引用变量方法；</strong></p><p>​        a. “==” 比较两个变量引用的内存地址是否相同；</p><p>​        b.  equals可以比较两个变量引用的对象的值是否相同。</p><p>​    <strong>3.用户自定义的类也可以覆盖Object的equals方法实现对象按值进行比较。</strong></p><h3 id="Hibernate-自带了很多种标识符生成器："><a href="#Hibernate-自带了很多种标识符生成器：" class="headerlink" title="Hibernate 自带了很多种标识符生成器："></a>Hibernate 自带了很多种标识符生成器：</h3><p><img data-src="1.png" alt="1"></p><p><strong>increment</strong>  采用 Hibernate 数值递增的方式,该机制是 Hibernate 以递增的方式为OID赋值。</p><p>&emsp;&emsp;&emsp;不依赖于底层数据库系统，适合所有数据库;</p><p>&emsp;&emsp;&emsp;适合单独的 Hibernate 应用使用，不适合在集群情况下使用。</p><p><strong>identity</strong> 采用数据库提供的自增长方式,该机制依赖于底层数据库，需要数据库支持自动增长字段。</p><p>&emsp;&emsp;&emsp;例如：MySQL、MSSQL、DB2、Sybase等。</p><p><strong>assigned</strong> 主键由应用逻辑产生；该机制是由外部程序负责生成OID,Hibernate 不负责维护主键生成，与Hibernate和底层数据库都无关。</p><p>&emsp;&emsp;例如：Student类没有定义 ID，而是以学号studentNo 作为业务主键。&emsp;</p><p><strong>sequence</strong> 采用数据库提供的序列方式；</p><p>hilo 通过hi/lo算法   // Hibernate 5.0 以后不支持；</p><p>seqhilo 通过hi/lo算法；</p><p>native 自动选择合适的标识符生成器；</p><p>uuid.hex 通过uuid算法。</p><h3 id="使用注解映射单实体"><a href="#使用注解映射单实体" class="headerlink" title="使用注解映射单实体"></a><strong>使用注解映射单实体</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"employee"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment_generator"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment_generator"</span>, strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"name"</span>) </span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Entity：声明一个实体类。</p><p>@Table(name=”table_name”)：为实体类指定对应的数据库表。</p><p>@Id：声明实体类的OID属性。</p><p>@GeneratedValue(generator=”increment_generator”)：声明OID的生成策略。</p><p>@GenericGenerator(name=”increment_generator”, strategy=”increment”)：使用Hibernate提供的生成策略。</p><p>@Column(name=”columnName”) ：将属性映射到列。</p><p>@Access(AccessType.PROPERTY)：1.通过 getter 和 setter 方法访问实体类的属性；2.需要在 getter 方法上定义字段的属性。</p><p>@Access(AccessType.FIELD)：1.直接访问实体类的属性，可以不定义 getter 和 setter 方法；2.需要在变量上定义字段的属性。</p>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hibernate】搭建框架</title>
      <link href="/2020/03/10/hibernate%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/03/10/hibernate%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="初始框架搭建"><a href="#初始框架搭建" class="headerlink" title="初始框架搭建"></a>初始框架搭建</h1><h3 id="分层构系结构"><a href="#分层构系结构" class="headerlink" title="分层构系结构"></a>分层构系结构</h3><p>指的是将系统的组件分隔到不同的层中，每一层中的组件应保持内聚性；<br>每一层都应与它下面的各层保持松散耦合。</p><h3 id="三层体系结构"><a href="#三层体系结构" class="headerlink" title="三层体系结构"></a><strong>三层体系结构</strong></h3><p><img data-src="1583851295917.png" alt="1583851295917"></p><h3 id="持久化层是怎么来的"><a href="#持久化层是怎么来的" class="headerlink" title="持久化层是怎么来的"></a><strong>持久化层是怎么来的</strong></h3><p>为了把数据访问细节和业务逻辑分开，可以把数据访问作为单独的持久化层。</p><p><img data-src="1583851385990.png" alt="1583851385990"></p><h3 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h3><p><strong>瞬时状态</strong>：保存在内存的程序数据，程序退出后，数据就消失了，称为瞬时状态。</p><p><strong>持久状态</strong>：保存在数据库（磁盘）的程序数据，程序退出后，数据依然存在，称为程序数据的持久状态。</p><p><strong>持久化</strong>：将程序数据在瞬时状态和持久化状态之间转换的机制。</p><h3 id="MVC设计模式与四层结构的对应关系"><a href="#MVC设计模式与四层结构的对应关系" class="headerlink" title="MVC设计模式与四层结构的对应关系"></a>MVC设计模式与四层结构的对应关系</h3><p><img data-src="1583851508296.png" alt="1583851508296"></p><h3 id="持久化层的设计目标："><a href="#持久化层的设计目标：" class="headerlink" title="持久化层的设计目标："></a>持久化层的设计目标：</h3><p>1.代码可重用性高，能够完成对象持久化操作；</p><p>2.如果需要的话，能够支持多种数据库平台；</p><p>3.具有相对独立性，当持久层发生变化时，不会影响上层实现。</p><h3 id="Hibernate是什么？"><a href="#Hibernate是什么？" class="headerlink" title="Hibernate是什么？"></a>Hibernate是什么？</h3><p>1.在分层体系结构中Hibernate位于持久化层，是完成对象持久化的持久化层框架；</p><p>2.Hibernate是连接Java应用程序和关系型数据库的框架，能够建立对象模型和关系数据模型之间的映射，是一种自动ORM框架；</p><p>3.Hibernate是对JDBC API的封装，是JDBC轻量级封装框架。</p><h2 id="第一个Hibernate程序"><a href="#第一个Hibernate程序" class="headerlink" title="第一个Hibernate程序"></a>第一个Hibernate程序</h2><h4 id="1-引入jar包"><a href="#1-引入jar包" class="headerlink" title="1.引入jar包"></a>1.引入jar包</h4><p><img data-src="1583851888229.png" alt="1583851888229"></p><h4 id="2-项目目录结构"><a href="#2-项目目录结构" class="headerlink" title="2.项目目录结构"></a>2.项目目录结构</h4><p><img data-src="1583851908692.png" alt="1583851908692"></p><h4 id="3-hibernate-cfg-xml"><a href="#3-hibernate-cfg-xml" class="headerlink" title="3.hibernate.cfg.xml"></a>3.hibernate.cfg.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span> <span class="meta-string">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/hibernate_demo_db<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/hibernate/entity/Customer.hbm.xml"</span>/&gt;</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;mapping class="top.hiasenna.entity.User" /&gt;</span></span><br><span class="line"><span class="comment">&lt;mapping class="top.hiasenna.entity.Order" /&gt; </span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-编写持久化类"><a href="#4-编写持久化类" class="headerlink" title="4.编写持久化类"></a>4.编写持久化类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Customer [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-创建持久化类的配置文件"><a href="#5-创建持久化类的配置文件" class="headerlink" title="5.创建持久化类的配置文件"></a>5.创建持久化类的配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.hibernate.entity"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 标识一个类的xml映射,name为类名,table为表名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Customer"</span> <span class="attr">table</span>=<span class="string">"customer"</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 主键的设置,generator标识主键生成方式--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 这里配了该类一个属性街道名称 name属性字段,column,数据库对应列 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">column</span>=<span class="string">"name"</span> /&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 这里同上,写法不同而已 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"age"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="标签说明"><a href="#标签说明" class="headerlink" title="标签说明"></a>标签说明</h5><p>1.<strong>&lt;class&gt;</strong>元素用于指定类和表之间的映射</p><p>​        -name属性设定类名(包含路径)；</p><p>​        -table属性设定表名，默认以类名作表名。</p><p>2.<strong>id</strong> 子元素设定持久化类的OID和表的主键的映射关系</p><p>​        -column – 指定表字段的名称；</p><p>​        -generator – 元素指定OID的生成器。</p><p>3.<strong>property</strong>子元素设定类的其他属性和表的字段的映射关系</p><p>​        -name – 对应类的属性名称；</p><p>​        -type – 指定属性的类型；</p><p>​        -column – 指定表字段的名称；</p><p>​        -not-null – 指定属性是否允许为空。</p><p>6.HibernateUtil工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.MetadataSources;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistry;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtil</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">final</span> StandardServiceRegistry registry=<span class="keyword">new</span> StandardServiceRegistryBuilder().configure().build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sessionFactory=<span class="keyword">new</span> MetadataSources(registry).buildMetadata().buildSessionFactory();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">sessionFactory=<span class="keyword">null</span>;</span><br><span class="line">StandardServiceRegistryBuilder.destroy(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SessionFactory <span class="title">getSessionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sessionFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSessionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sessionFactory.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SSH】初始项目搭建流程</title>
      <link href="/2020/03/10/ssh%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/03/10/ssh%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="初始项目搭建流程"><a href="#初始项目搭建流程" class="headerlink" title="初始项目搭建流程"></a>初始项目搭建流程</h1><p>1.创建一个动态web项目</p><p><img data-src="1.png" alt="1"></p><p>接着点击next，勾选自动生成web.xml选项，最后点击finish。</p><p>2.在WEB-INF的lib文件夹中导入必备的jar包，包括spring、struts以及hibernate的jar包：</p><p>spring相关jar包：</p><p><img data-src="2.png" alt="2"></p><p>struts相关jar包：</p><p><img data-src="3.png" alt="3"></p><p>hibernate相关jar包：</p><p><img data-src="4.png" alt="4"></p><p>3.jar导入后，开始搭建框架，完成配置文件</p><p>（1）首先第一步加载数据库配置文件，配置数据源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载数据库配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 包扫描器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.jiangnan.ssh"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置C3P0数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.username&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driverClass&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.url&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.initialPoolSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.maxPoolSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）第二步创建数据库操作对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建数据库的操作对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate5.LocalSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernateProperties"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库方言 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 显示Hibernate持久化操作生成的预编译的SQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将SQL格式化后再输出 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 是否根据需要每次自动创建数据库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hibernate映射文件的目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappingDirectoryLocations"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com/jiangnan/ssh/pojo<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）第三步配置事务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate5.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）第四步配置通知</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> <span class="attr">id</span> =<span class="string">"txadvice"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（5）第五步配置切面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.jiangnan.ssh.service.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（6）最后配置一下web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.jiangnan.ssh.service.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成</p>]]></content>
      
      
      <categories>
          
          <category> spring框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Guava Cache】基于Guava Cache内存缓存实现的token验证</title>
      <link href="/2020/03/10/%E5%9F%BA%E4%BA%8EGuava%20Cache%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E7%9A%84token%E9%AA%8C%E8%AF%81/"/>
      <url>/2020/03/10/%E5%9F%BA%E4%BA%8EGuava%20Cache%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E7%9A%84token%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Guava-Cache内存缓存实现的token验证"><a href="#基于Guava-Cache内存缓存实现的token验证" class="headerlink" title="基于Guava Cache内存缓存实现的token验证"></a>基于Guava Cache内存缓存实现的token验证</h1><h2 id="理解token机制"><a href="#理解token机制" class="headerlink" title="理解token机制"></a>理解token机制</h2><p> 什么是token</p><p>   token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。</p><p>   身份认证概述</p><p>   由于HTTP是一种没有状态的协议，它并不知道是谁访问了我们的应用。这里把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下次这个客户端再发送请求时候，还得再验证一下。<br>通用的解决方法就是，当用户请求登录的时候，如果没有问题，在服务端生成一条记录，在这个记录里可以说明登录的用户是谁，然后把这条记录的id发送给客户端，客户端收到以后把这个id存储在cookie里，下次该用户再次向服务端发送请求的时候，可以带上这个cookie，这样服务端会验证一下cookie里的信息，看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。<br>以上所描述的过程就是利用session，那个id值就是sessionid。我们需要在服务端存储为用户生成的session，这些session会存储在内存，磁盘，或者数据库。</p><p>   基于token机制的身份认证</p><p>   使用token机制的身份验证方法，在服务器端不需要存储用户的登录记录。大概的流程：</p><p>客户端使用用户名和密码请求登录。服务端收到请求，验证用户名和密码。验证成功后，服务端会生成一个token，然后把这个token发送给客户端。客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。客户端每次向服务端发送请求的时候都需要带上服务端发给的token。服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。</p><h3 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h3><p>Guava Cache是单个应用运行时的本地缓存。它不把数据存放到文件或者外部服务器上。简单、强大、及轻量级。它不需要配置文件，使用起来和ConcurrentHashMap一样简单，而且能覆盖绝大多数使用cache的场景需求</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p> 校验答案正确后，在service层来生成一个唯一token，一般可以使用mac地址，或者sessionId来生成token。因为token是可以被截获的，非常容易泄露，如果不进行加密，很容易被恶意拷贝并用来登录。所以一般会对token进行加密处理。</p><p>一般可以在存储的时候把token进行对称加密存储，用到的时候再解密，或者使用请求URL、时间戳、token三者合并，通过算法进行加密处理。两个一块用更安全。这里就简单利用UUID来实现生成唯一token</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String forgetToken = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure><p>然后再把token存到本地Guava Cache内存缓存中，在响应对象中也把这个token封装起来响应给客户端。到时候用户改密，就可以传入该token实现token机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TokenCache.setKey(<span class="string">"Token_"</span>+username,forgetToken);</span><br></pre></td></tr></table></figure><p>Guava Cache实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheLoader;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.LoadingCache;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author Liang Shan</span></span><br><span class="line"><span class="comment"> * @Description token本地缓存，使用guava缓存实现</span></span><br><span class="line"><span class="comment"> * @Date 2018/6/1 17:28</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    创建logback的logger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TokenCache<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//    声明一个静态的内存块,guava里面的本地缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LoadingCache&lt;String, String&gt; localcache =</span><br><span class="line">        <span class="comment">//构建本地缓存，调用链的方式 ,1000是设置缓存的初始化容量，maximumSize是设置缓存最大容量，当超过了最大容量，guava将使用LRU算法（最少使用算法），来移除缓存项</span></span><br><span class="line">        <span class="comment">//expireAfterAccess(12,TimeUnit.HOURS)设置缓存有效期为12个小时</span></span><br><span class="line">        CacheBuilder.newBuilder().initialCapacity(<span class="number">1000</span>).maximumSize(<span class="number">10000</span>).expireAfterAccess(<span class="number">12</span>,TimeUnit.HOURS)</span><br><span class="line">        <span class="comment">//build里面要实现一个匿名抽象类</span></span><br><span class="line">                .build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line"><span class="comment">//                   这个方法是默认的数据加载实现,get的时候，如果key没有对应的值，就调用这个方法进行加载</span></span><br><span class="line"> </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//                        为什么要把return的null值写成字符串，因为到时候用null去.equal的时候，会报空指针异常</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 添加本地缓存</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        localcache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 得到本地缓存</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value= localcache.get(key);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"null"</span>.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"getKey()方法错误"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Guava-Cache的回收策略"><a href="#Guava-Cache的回收策略" class="headerlink" title="Guava Cache的回收策略"></a>Guava Cache的回收策略</h3><h4 id="有两种回收策略："><a href="#有两种回收策略：" class="headerlink" title="有两种回收策略："></a>有两种回收策略：</h4><p>一种是基于容量的回收CacheBuilder.maximumSize(Long)。设置缓存最大容量，当超过最大容量，缓存将尝试回收最近没有使用或总体上很少使用的缓存项。</p><p>第二种定时回收</p><p>expireAfterAccess(long,TimeUnit):缓存项在给定时间内没有被读写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。</p><p>  expireAfterWrite(long,TimeUnit):缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变的陈旧不可用，这种回收是可取的。</p><p>实例中用的是第一种策略，通过设置缓存最大容量，当超过了最大容量，guava将使用LRU算法来减少缓存项</p><h3 id="LRU算法原理"><a href="#LRU算法原理" class="headerlink" title="LRU算法原理"></a>LRU算法原理</h3><p>LRU（Least recently used，最近最少使用的）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高。</p><p>最常见的实现是使用一个链表保存缓存数据：<br>1 新数据插入到链表头部<br>2 每当缓存命中（即缓存数据被访问），则将数据移到链表头部<br>3 当链表满的时候，将链表尾部的数据丢弃</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava Cache </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
