<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线程的状态有哪些？它是如何工作的？</title>
      <link href="/2020/03/19/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
      <url>/2020/03/19/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>线程（Thread）是并发编程的基础，也是程序执行的最小单元，它依托进程而存在。一个进程中可以包含多个线程，多线程可以共享一块内存空间和一组系统资源，因此线程之间的切换更加节省资源、<br>更加轻量化，也因此被称为轻量级的进程。</p><p>当然，线程也是面试中常被问到的一个知识点，是程序员必备的基础技能，使用它可以有效地提高程序的整体运行速度。</p><p>本课时的面试问题是，线程的状态有哪些？它是如何工作的？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>线程的状态在JDK1.5之后以枚举的方式被定义在Thread的源码中，它总共包含以下6个状态：</p><ul><li>NEW，新建状态，线程被创建出来，但尚未启动时的线程状态；</li><li>RUNNABLE，就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配CPU资源；</li><li>BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行synchronized代码块或者使用synchronized标记的方法；</li><li>WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了Object.wait0方法，那它就在等待另一个线程调用Object.notify0或<br>Object.notifyAll0方法；</li><li>TIMED WAITING，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法Object.wait（long timeout）和Thread.join（long timeout）等这些方法时，它才会进入此状态；</li><li>TERMINATED，终止状态，表示线程已经执行完成。</li></ul><p>线程状态的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建状态，线程被创建出来，但尚未启动时的线程状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 就绪状态，表示可以运行的线程状态，但它在排队等待来自操作系统的 CPU 资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞等待锁的线程状态，表示正在处于阻塞状态的线程</span></span><br><span class="line"><span class="comment">     * 正在等待监视器锁，比如等待执行 synchronized 代码块或者</span></span><br><span class="line"><span class="comment">     * 使用 synchronized 标记的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作。</span></span><br><span class="line"><span class="comment">     * 例如，一个线程调用了 Object.wait() 它在等待另一个线程调用</span></span><br><span class="line"><span class="comment"> * Object.notify() 或 Object.notifyAll()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计时等待状态，和等待状态 (WAITING) 类似，只是多了超时时间，比如</span></span><br><span class="line"><span class="comment">     * 调用了有超时时间设置的方法 Object.wait(long timeout) 和 </span></span><br><span class="line"><span class="comment">     * Thread.join(long timeout) 就会进入此状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 终止状态，表示线程已经执行完成</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>线程的工作模式是，首先先要创建线程并指定线程需要执行的业务方法，然后再调用线程的 start()方法，此时线程就从NEW（新建）状态变成了RUNNABLE（就绪）状态，此时线程会判断要执行的方法中有没有synchronized同步代码块，如果有并且其他线程也在使用此锁，那么线程就会变为<br>BLOCKED（阻塞等待）状态，当其他线程使用完此锁之后，线程会继续执行剩余的方法。</p><p>当遇到Object.wait()或Thread.join()方法时，线程会变为WAITING（等待状态）状态，如果是带了超时时间的等待方法，那么线程会进入TIMED WAITING（计时等待）状态，当有其他线程执行了<br>notify()或notifyAll()方法之后，线程被唤醒继续执行剩余的业务方法，直到方法执行完成为止，此时整个线程的流程就执行完了，执行流程如下图所示：</p><p><img data-src="1.png" alt="1.png"></p><p><strong>考点分析</strong></p><p>线程一般会作为并发编程的起始问题，用于引出更多的关于并发编程的面试问题。当然对于线程的掌握程度也决定了你对并发编程的掌握程度，通常面试官还会问：</p><ul><li><p>BLOCKED（阻塞等待）和WAITING（等待）有什么区别？</p></li><li><p>start()方法和run()方法有什么区别？</p></li><li><p>线程的优先级有什么用？该如何设置？</p></li><li><p>线程的常用方法有哪些？</p><p>接下来我们一起来看这些问题的答案。</p></li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-BLOCKED和WAITING的区别"><a href="#1-BLOCKED和WAITING的区别" class="headerlink" title="1.BLOCKED和WAITING的区别"></a>1.BLOCKED和WAITING的区别</h3><p>虽然BLOCKED和WAITING都有等待的含义，但二者有着本质的区别，首先它们状态形成的调用方法不同，其次BLOCKED可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；而WAITING则是因为自身调用了Object.wait()或着是Thread.join()又或者是LockSupport.park()而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了Object.wait()而进入WAITING状态之后，则需要等待另一个线程执行<br>Object.notify()或Object.notifyAll()才能被唤醒。</p><h3 id="2-start-和run-的区别"><a href="#2-start-和run-的区别" class="headerlink" title="2.start()和run()的区别"></a>2.start()和run()的区别</h3><p>首先从Thread 源码来看，start()方法属于Thread 自身的方法，并且使用了synchronized来保证线程安全，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态验证，不等于 NEW 的状态会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    <span class="comment">// 通知线程组，此线程即将启动</span></span><br><span class="line">group.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">// 不处理任何异常，如果 start0 抛出异常，则它将被传递到调用堆栈上</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run()方法为Runnable的抽象方法，必须由调用类重写此方法，重写的run()方法其实就是此线程要执行的业务方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 忽略其他方法......</span></span><br><span class="line">  <span class="keyword">private</span> Runnable target;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">          target.run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从执行的效果来说，start()方法可以开启多线程，让线程从NEW状态转换成RUNNABLE状态，而<br>run()方法只是一个普通的方法。</p><p>其次，它们可调用的次数不同，start()方法不能被多次调用，否则会抛出<br>java.lang.llegalStateException；而 run()方法可以进行多次调用，因为它只是一个普通的方法而已。</p><h3 id="3-线程优先级"><a href="#3-线程优先级" class="headerlink" title="3.线程优先级"></a>3.线程优先级</h3><p>在Thread 源码中和线程优先级相关的属性有3个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程可以拥有的最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程可以拥有的最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>线程的优先级可以理解为线程抢占CPU时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。<br>在程序中我们可以通过Thread.setPriority()来设置优先级，setPriority()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="comment">// 先验证优先级的合理性</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优先级如果超过线程组的最高优先级，则把优先级设置为线程组的最高优先级</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-线程的常用方法"><a href="#4-线程的常用方法" class="headerlink" title="4.线程的常用方法"></a>4.线程的常用方法</h3><p>线程的常用方法有以下几个。</p><h4 id="（1）join-）"><a href="#（1）join-）" class="headerlink" title="（1）join(）"></a>（1）join(）</h4><p>在一个线程中调用other.join()，这时候当前线程会让出执行权给other线程，直到other 线程执行完或者过了超时时间之后再继续执行当前线程，join()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 超时时间不能小于 0</span></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等于 0 表示无限等待，直到线程执行完为之</span></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断子线程 (其他线程) 为活跃线程，则一直等待</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 循环判断</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出join()方法底层还是通过wait()方法来实现的。<br>例如，在未使用join()时，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程睡眠："</span> + i + <span class="string">"秒。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start(); <span class="comment">// 开启线程</span></span><br><span class="line">        <span class="comment">// 主线程执行</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">             System.out.println(<span class="string">"主线程睡眠："</span> + i + <span class="string">"秒。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：<br>主线程睡眠：1秒。<br>子线程睡眠：1秒。<br>主线程睡眠：2秒。<br>子线程睡眠：2秒。<br>主线程睡眠：3秒。<br>子线程睡眠：3秒。<br>子线程睡眠：4秒。<br>子线程睡眠：5秒。<br>从结果可以看出，在未使用join()时主子线程会交替执行。<br>然后我们再把join()方法加入到代码中，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程睡眠："</span> + i + <span class="string">"秒。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start(); <span class="comment">// 开启线程</span></span><br><span class="line">        thread.join(<span class="number">2000</span>); <span class="comment">// 等待子线程先执行 2 秒钟</span></span><br><span class="line">        <span class="comment">// 主线程执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"主线程睡眠："</span> + i + <span class="string">"秒。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：<br>子线程睡眠：1秒。<br>子线程睡眠：2秒。<br>主线程睡眠：1秒。/∥thread.join(2000)；等待2秒之后，主线程和子线程再交替执行子线程睡眠：3秒。<br>主线程睡眠：2秒。<br>子线程睡眠：4秒。<br>子线程睡眠：5秒。<br>主线程睡眠：3秒。<br>从执行结果可以看出，添加join()方法之后，主线程会先等子线程执行2秒之后才继续执行。</p><h4 id="（2）yield"><a href="#（2）yield" class="headerlink" title="（2）yield()"></a>（2）yield()</h4><p>看Thread的源码可以知道 yield()为本地方法，也就是说yield()是由C或C++实现的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>yield()方法表示给线程调度器一个当前线程愿意出让CPU使用权的暗示，但是线程调度器可能会忽略这个暗示。<br>比如我们执行这段包含了yield()方法的代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程："</span> +</span><br><span class="line">                        Thread.currentThread().getName() + <span class="string">" I："</span> + i);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(runnable, <span class="string">"T1"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(runnable, <span class="string">"T2"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把这段代码执行多次之后会发现，每次执行的结果都不相同，这是因为yield()执行非常不稳定，线程调度器不一定会采纳 yield()出让CPU使用权的建议，从而导致了这样的结果。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-队列</title>
      <link href="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/"/>
      <url>/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="数组模拟队列思路"><a href="#数组模拟队列思路" class="headerlink" title="数组模拟队列思路"></a>数组模拟队列思路</h2><p><img data-src="1.png" alt="1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQArrayQueueDemoueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试一把</span></span><br><span class="line"><span class="comment">// 创建一个队列</span></span><br><span class="line">ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">// 接收用户输入</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line"><span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 输出一个菜单</span></span><br><span class="line"><span class="keyword">while</span> (loop) &#123;</span><br><span class="line">System.out.println(<span class="string">"s(show): 显示队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"e(exit): 退出程序"</span>);</span><br><span class="line">System.out.println(<span class="string">"a(add): 添加数据到队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"g(get): 从队列取出数据"</span>);</span><br><span class="line">System.out.println(<span class="string">"h(head): 查看队列头的数据"</span>);</span><br><span class="line">key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">// 接收一个字符</span></span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">queue.showQueue();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">System.out.println(<span class="string">"输出一个数"</span>);</span><br><span class="line"><span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">queue.addQueue(value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'g'</span>: <span class="comment">// 取出数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">// 查看队列头的数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>: <span class="comment">// 退出</span></span><br><span class="line">scanner.close();</span><br><span class="line">loop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front; <span class="comment">// 队列头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"><span class="comment">// 创建队列的构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSize = maxsize;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">front = -<span class="number">1</span>;<span class="comment">// 指向队列头部，分析出front是指向队列头的前一个位置.</span></span><br><span class="line">rear = -<span class="number">1</span>;<span class="comment">// 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据到队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列已满，不能加入数据"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">rear++;</span><br><span class="line">arr[rear] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列的数据，出队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 通过抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，不能取数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line">front++;</span><br><span class="line"><span class="keyword">return</span> arr[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议和三次握手四次挥手</title>
      <link href="/2020/03/18/TCPIP%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2020/03/18/TCPIP%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>在计算机网络的基本概念中，分层次的体系结构是最基本的。计算机网络体系结构的抽象概念较多，在学习时要多思考。这些概念对后面的学习很有帮助。</p><h3 id="网络协议是什么？"><a href="#网络协议是什么？" class="headerlink" title="网络协议是什么？"></a>网络协议是什么？</h3><p>在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p><h3 id="为什么要对网络协议分层？"><a href="#为什么要对网络协议分层？" class="headerlink" title="为什么要对网络协议分层？"></a>为什么要对网络协议分层？</h3><ul><li>简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。</li><li>灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。</li><li>易于实现和维护。</li><li>促进标准化工作。分开后，每层功能可以相对简单地被描述。</li></ul><p>网络协议分层的缺点： 功能可能出现在多个层里，产生了额外开销。</p><p>为了使不同体系结构的计算机网络都能互联，国际标准化组织 ISO 于1977年提出了一个试图使各种计算机在世界范围内互联成网的标准框架，即著名的开放系统互联基本参考模型 OSI/RM，简称为OSI。</p><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用，TCP/IP 体系结构则不同，但它现在却得到了非常广泛的应用。TCP/IP 是一个四层体系结构，它包含应用层，运输层，网际层和网络接口层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题），不过从实质上讲，TCP/IP 只有最上面的三层，因为最下面的网络接口层并没有什么具体内容，因此在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚，有时为了方便，也可把最底下两层称为网络接口层。</p><p>四层协议，五层协议和七层协议的关系如下：</p><ul><li>TCP/IP是一个四层的体系结构，主要包括：应用层、运输层、网际层和网络接口层。</li><li>五层协议的体系结构主要包括：应用层、运输层、网络层，数据链路层和物理层。</li><li>OSI七层协议模型主要包括是：应用层（Application）、表示层（Presentation）、会话层（Session）、运输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</li></ul><p><img data-src="1.png" alt="1.png"></p><p>注：五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p><h2 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p><p>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的<strong>数据传输服务</strong>。应用进程利用该服务传送应用层报文。</p><p>运输层主要使用一下两种协议</p><ol><li>传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。</li><li>用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li></ol><table><thead><tr><th align="center"></th><th align="center"><strong>UDP</strong></th><th align="center"><strong>TCP</strong></th></tr></thead><tbody><tr><td align="center">是否连接</td><td align="center">无连接</td><td align="center">面向连接</td></tr><tr><td align="center">是否可靠</td><td align="center">不可靠传输，不使用流量控制和拥塞控制</td><td align="center">可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="center">连接对象个数</td><td align="center">支持一对一，一对多，多对一和多对多交互通信</td><td align="center">只能是一对一通信</td></tr><tr><td align="center">传输方式</td><td align="center">面向报文</td><td align="center">面向字节流</td></tr><tr><td align="center">首部开销</td><td align="center">首部开销小，仅8字节</td><td align="center">首部最小20字节，最大60字节</td></tr><tr><td align="center">场景</td><td align="center">适用于实时应用（IP电话、视频会议、直播等）</td><td align="center">适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><p><strong>每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</strong></p><p>运行在<code>TCP协议</code>上的协议:</p><ul><li><code>HTTP（Hypertext Transfer Protocol，超文本传输协议)</code>，主要用于普通浏览。</li><li><code>HTTPS（HTTP over SSL，安全超文本传输协议）</code>,HTTP协议的安全版本。</li><li><code>FTP（File Transfer Protocol，文件传输协议）</code>，用于文件传输。</li><li><code>POP3（Post Office Protocol, version 3，邮局协议</code>），收邮件用。</li><li><code>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</code>，用来发送电子邮件。</li><li><code>TELNET（Teletype over the Network，网络电传</code>），通过一个终端（terminal）登陆到网络。</li><li><code>SSH（Secure Shell，用于替代安全性差的TELNET）</code>，用于加密安全登陆用。</li></ul><p>运行在<code>UDP协议</code>上的协议：</p><ul><li><code>BOOTP（Boot Protocol，启动协议）</code>，应用于无盘设备。</li><li><code>NTP（Network Time Protocol，网络时间协议）</code>，用于网络同步。</li><li><code>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）</code>，动态配置IP地址。</li></ul><p>运行在<code>TCP</code>和<code>UDP</code>协议上：</p><ul><li><code>DNS（Domain Name Service，域名服务）</code>，用于完成地址查找，邮件转发等工作。</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p><p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。</p><p>一般的web应用的通信传输流是这样的：</p><p><img data-src="2.jpg" alt="2.jpg"></p><p>发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><h3 id="TCP-IP-协议族-1"><a href="#TCP-IP-协议族-1" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h3><p>在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族。</p><p><img data-src="3.jpg" alt="3.jpg"></p><p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。因为该协定家族的两个核心协定：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。</p><p>划重点：</p><p><code>TCP（传输控制协议）和IP（网际协议）</code> 是最先定义的两个核心协议，所以才统称为<code>TCP/IP协议族</code></p><h2 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h2><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。</p><p><strong>通过三次握手建立一个链接，通过四次挥手来关闭一个连接</strong>。</p><p><strong>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据</strong>。</p><h3 id="TCP报文的头部结构"><a href="#TCP报文的头部结构" class="headerlink" title="TCP报文的头部结构"></a>TCP报文的头部结构</h3><p>在了解TCP连接之前先来了解一下TCP报文的头部结构。</p><p><img data-src="4.jpg" alt="4.jpg"></p><p>上图中有几个字段需要重点介绍下：</p><p>（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p><p>（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。</p><p>（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p><ul><li>ACK：确认序号有效。</li><li>FIN：释放一个连接。</li><li>PSH：接收方应该尽快将这个报文交给应用层。</li><li>RST：重置连接。</li><li>SYN：发起一个新连接。</li><li>URG：紧急指针（urgent pointer）有效。</li></ul><p>需要注意的是：</p><ul><li>不要将确认序号ack与标志位中的ACK搞混了。</li><li>确认方ack=发起方seq+1，两端配对。</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><code>三次握手的本质是确认通信双方收发数据的能力</code></p><p>首先，我让信使运输一份信件给对方，<strong>对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的</strong>。</p><p>于是他给我回信，<strong>我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以</strong>。</p><p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，<strong>他若收到了，他便清楚了他的发件能力和我的收件能力是可以的</strong>。</p><p>这，就是三次握手，这样说，你理解了吗？</p><p><img data-src="5.jpg" alt="5.jpg"></p><ul><li><code>第一次握手</code>：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。</li><li><code>第二次握手</code>：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</li><li><code>第三次握手</code>：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><code>四次挥手的目的是关闭一个连接</code></p><p><img data-src="6.jpg" alt="6.jpg"></p><p>比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p><ul><li><code>第一次挥手</code>：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</li><li><code>第二次挥手</code>：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</li><li><code>第三次挥手</code>：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。</li><li><code>第四次挥手</code>：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</li></ul><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="为什么TCP连接的时候是3次？2次不可以吗？"><a href="#为什么TCP连接的时候是3次？2次不可以吗？" class="headerlink" title="为什么TCP连接的时候是3次？2次不可以吗？"></a>为什么TCP连接的时候是3次？2次不可以吗？</h3><p>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p><p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p><h3 id="为什么TCP连接的时候是3次，关闭的时候却是4次？"><a href="#为什么TCP连接的时候是3次，关闭的时候却是4次？" class="headerlink" title="为什么TCP连接的时候是3次，关闭的时候却是4次？"></a>为什么TCP连接的时候是3次，关闭的时候却是4次？</h3><p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p><h3 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h3><p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h3 id="什么是HTTP，HTTP-与-HTTPS-的区别"><a href="#什么是HTTP，HTTP-与-HTTPS-的区别" class="headerlink" title="什么是HTTP，HTTP 与 HTTPS 的区别"></a>什么是HTTP，HTTP 与 HTTPS 的区别</h3><p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</p><table><thead><tr><th>·······</th><th align="center">HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>协议</td><td align="center">运行在 TCP 之上，明文传输，<strong>客户端与服务器端都无法验证对方的身份</strong></td><td>身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， <strong>是添加了加密和认证机制的 HTTP</strong>。</td></tr><tr><td>端口</td><td align="center">80</td><td>443</td></tr><tr><td>资源消耗</td><td align="center">较少</td><td>由于加解密处理，会消耗更多的 CPU 和内存资源</td></tr><tr><td>开销</td><td align="center">无需证书</td><td>需要证书，而证书一般需要向认证机构购买</td></tr><tr><td>加密机制</td><td align="center">无</td><td>共享密钥加密和公开密钥加密并用的混合加密机制</td></tr><tr><td>安全性</td><td align="center">弱</td><td>由于加密机制，安全性强</td></tr></tbody></table><h3 id="常用HTTP状态码"><a href="#常用HTTP状态码" class="headerlink" title="常用HTTP状态码"></a>常用HTTP状态码</h3><p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</p><p>状态码的类别：</p><table><thead><tr><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码） 接受的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码） 请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码） 需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码） 服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码） 服务器处理请求出错</td></tr></tbody></table><p>常用HTTP状态码：</p><table><thead><tr><th>2XX</th><th>成功（这系列表明请求被正常处理了）</th></tr></thead><tbody><tr><td>200</td><td>OK，表示从客户端发来的请求在服务器端被正确处理</td></tr><tr><td>204</td><td>No content，表示请求成功，但响应报文不含实体的主体部分</td></tr><tr><td>206</td><td>Partial Content，进行范围请求成功</td></tr></tbody></table><table><thead><tr><th>3XX</th><th>重定向（表明浏览器要执行特殊处理）</th></tr></thead><tbody><tr><td>301</td><td>moved permanently，永久性重定向，表示资源已被分配了新的 URL</td></tr><tr><td>302</td><td>found，临时性重定向，表示资源临时被分配了新的 URL</td></tr><tr><td>303</td><td>see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求）</td></tr><tr><td>304</td><td>not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）</td></tr><tr><td>307</td><td>temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</td></tr></tbody></table><table><thead><tr><th>4XX</th><th>客户端错误</th></tr></thead><tbody><tr><td>400</td><td>bad request，请求报文存在语法错误</td></tr><tr><td>401</td><td>unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</td></tr><tr><td>403</td><td>forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述</td></tr><tr><td>404</td><td>not found，表示在服务器上没有找到请求的资源</td></tr></tbody></table><table><thead><tr><th>5XX</th><th>服务器错误</th></tr></thead><tbody><tr><td>500</td><td>internal sever error，表示服务器端在执行请求时发生了错误</td></tr><tr><td>501</td><td>Not Implemented，表示服务器不支持当前请求所需要的某个功能</td></tr><tr><td>503</td><td>service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</td></tr></tbody></table><h3 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h3><p>说道GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。</p><p>HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。</p><p>HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理解为，对服务器资源的查，改，增，删。</p><ul><li>GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。</li><li>POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。</li><li>PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。</li><li>DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。</li></ul><p><strong>GET和POST区别</strong></p><ol><li><p>Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。</p></li><li><p>Get请求提交的url中的数据最多只能是2048字节，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。</p></li><li><p>Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。</p></li><li><p>Get执行效率却比Post方法好。Get是form提交的默认方法。</p></li><li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p></li></ol><h3 id="什么是对称加密与非对称加密"><a href="#什么是对称加密与非对称加密" class="headerlink" title="什么是对称加密与非对称加密"></a>什么是对称加密与非对称加密</h3><p>对称密钥加密是指加密和解密使用同一个密钥的方式，<strong>这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</strong></p><p>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。<br>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢。</p><h3 id="什么是HTTP2"><a href="#什么是HTTP2" class="headerlink" title="什么是HTTP2"></a>什么是HTTP2</h3><p>HTTP2 可以提高了网页的性能。</p><p>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六个），当在请求很多资源的时候，由于队头阻塞当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。</p><p>HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。</p><h3 id="Session、Cookie和Token的主要区别"><a href="#Session、Cookie和Token的主要区别" class="headerlink" title="Session、Cookie和Token的主要区别"></a>Session、Cookie和Token的主要区别</h3><p>HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。</p><p><strong>什么是cookie</strong></p><p>cookie是由Web服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。</p><p><strong>什么是session</strong></p><p>session是依赖Cookie实现的。session是服务器端对象</p><p>session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认为浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输 cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p><p><strong>cookie与session区别</strong></p><ul><li>存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；</li><li>存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制</li><li>占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li></ul><p><strong>什么是Token</strong></p><p>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p><p>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p><p>使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p><p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</p><p><strong>session与token区别</strong></p><ul><li>session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；</li><li>session存储在服务器端，token存储在客户端</li><li>token提供认证和授权功能，作为身份认证，token安全性比session好；</li><li>session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</li></ul><h3 id="Servlet是线程安全的吗"><a href="#Servlet是线程安全的吗" class="headerlink" title="Servlet是线程安全的吗"></a>Servlet是线程安全的吗</h3><p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong></p><p>解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。</p><p>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p><h3 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h3><p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求<strong>HttpServletRequest</strong>，在<strong>doGet()</strong>，<strong>doPost()中做相应的处理，并将回应HttpServletResponse</strong>反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。</p><p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p><ul><li><p><strong>void init(ServletConfig config) throws ServletException</strong></p></li><li><p><strong>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</strong></p></li><li><p><strong>void destory()</strong></p></li><li><p>java.lang.String getServletInfo()</p></li><li><p>ServletConfig getServletConfig()</p></li></ul><p><strong>生命周期：</strong></p><p><strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；</p><p>请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；</p><p>当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。</p><p><strong>init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p><h3 id="如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="如果客户端禁止 cookie 能实现 session 还能用吗？"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h3><p>Cookie 与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。</p><p>但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</p><p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p><ol><li>手动通过URL传值、隐藏表单传递Session ID。</li><li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】的CRUD操作</title>
      <link href="/2020/03/18/MyBatis%E7%9A%84CRUD%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/03/18/MyBatis%E7%9A%84CRUD%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="动态代理机制"><a href="#动态代理机制" class="headerlink" title="动态代理机制"></a>动态代理机制</h3><h4 id="MyBatis和数据库的交互有两种方式："><a href="#MyBatis和数据库的交互有两种方式：" class="headerlink" title="MyBatis和数据库的交互有两种方式："></a>MyBatis和数据库的交互有两种方式：</h4><h5 id="使用传统的MyBatis提供的API"><a href="#使用传统的MyBatis提供的API" class="headerlink" title="使用传统的MyBatis提供的API"></a>使用传统的MyBatis提供的API</h5><p>使用传统的MyBatis提供的API ，需要传递Statement Id 和查询参数给 SqlSession 对象，MyBatis 提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作</p><h5 id="使用Mapper接口"><a href="#使用Mapper接口" class="headerlink" title="使用Mapper接口"></a>使用Mapper接口</h5><p>使用Mapper接口，MyBatis 将配置文件中的每一个&lt;mapper&gt; 元素抽象为一个 Mapper 接口，而这个接口中声明的方法和&lt;mapper&gt; 元素中的&lt;select|update|delete|insert&gt; 子元素相对应</p><h4 id="为什么Mapper接口中的抽象方法，没有自己定义实现类却能被正常调用呢？"><a href="#为什么Mapper接口中的抽象方法，没有自己定义实现类却能被正常调用呢？" class="headerlink" title="为什么Mapper接口中的抽象方法，没有自己定义实现类却能被正常调用呢？"></a>为什么Mapper接口中的抽象方法，没有自己定义实现类却能被正常调用呢？</h4><ul><li>MyBatis在Mapper接口上使用了动态代理</li><li>代理机制是Java中常用的设计模式，分为静态代理和动态代理。</li></ul><p><strong>静态代理</strong>：在程序编译时已经将接口、代理类和被代理类等确定下来</p><p><strong>动态代理</strong>：代理类在程序运行期间动态创建</p><h4 id="Java中动态代理的实现"><a href="#Java中动态代理的实现" class="headerlink" title="Java中动态代理的实现"></a>Java中动态代理的实现</h4><p>在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p><p><img data-src="1.png" alt="1.png"></p><ul><li>通过sqlSession.getMapper(XXXMapper.class) 方法，MyBatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个Mapper 实例</li><li>使用Mapper 接口的某一个方法时，MyBatis 会调用MapperProxy类的invoke()方法</li><li>底层还是通过SqlSession的select、update、delete、insert等方法来实现对数据库的操作</li></ul><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><h4 id="单条插入"><a href="#单条插入" class="headerlink" title="单条插入"></a>单条插入</h4><p>在映射器接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>在映射文件中添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">    insert into USER(id,user_name,password) </span><br><span class="line">    values(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;) </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>insert元素，用于映射插入语句</strong></p><ul><li>id属性：命名空间中的唯一标识符，为Mapper接口中的方法名</li><li>parameterType：指定了方法的参数类型，为可选项可以省略</li><li>元素的内容为插入的SQL语句</li><li>#{id}：MyBatis SQL中使用预编译参数的一种方式，当实际参数为JavaBean对象时，大括号中的id是其属性名</li></ul><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">User u = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"张三"</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">int</span> num = userMapper.insert(u);</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><p><strong>insert方法的返回值num是执行插入语句所影响的行数</strong></p><h4 id="使用JDBC方式返回主键自增的值"><a href="#使用JDBC方式返回主键自增的值" class="headerlink" title="使用JDBC方式返回主键自增的值"></a>使用JDBC方式返回主键自增的值</h4><ul><li>如果数据库设计时，主键字段为自动增长，那么需要插入的User对象的id属性值可以为null</li><li>如果想在执行插入操作以后返回表中的主键值，需要在映射文件中insert元素中加上如下两个属性</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    insert into USER(id,user_name,password) </span><br><span class="line">    values(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;) </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>useGeneratedKeys属性仅对 insert 和 update 有用，这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键</li><li>keyProperty  属性仅对 insert 和 update 有用，唯一标记一个属性，获得的主键值将会赋值给该属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = userMapper.insert(u);</span><br><span class="line">System.out.println(u.getId());</span><br></pre></td></tr></table></figure><h4 id="使用selectKey返回主键的值"><a href="#使用selectKey返回主键的值" class="headerlink" title="使用selectKey返回主键的值"></a>使用selectKey返回主键的值</h4><p>对于一些不提供主键自增功能的数据库，如Oracle，需要使用selectKey标签来获取主键的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    insert into USER(id,user_name,password) </span><br><span class="line">    values(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;) </span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">order</span>=<span class="string">"AFTER"</span>&gt;</span></span><br><span class="line">        SELECT LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>keyProperty属性表示主键所对应的属性名</p></li><li><p>resultType属性用于设置返回值类型</p></li><li><p>在MySQL中order属性设置为after，表示当前记录的主键值在insert语句执行成功后才能获取到，Oracle中设置为before</p></li><li><p>selectKey元素中的内容是一个独立的SQL语句，在MySQL中SELECT LAST_INSERT_ID()用于获取数据库中最后插入的数据的主键值</p></li><li><p>在Oracle中应该使用SELECT SEQ_ID.nextval from dual 用来获取序列中的一个值</p></li></ul><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><h4 id="普通查询"><a href="#普通查询" class="headerlink" title="普通查询"></a>普通查询</h4><p>根据用户id查询单条记录，在映射器接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>当实体类的属性名与数据库表的字段名一一对应时，映射代码如下所示：select元素用于映射查询语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">resultType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">    select * from USER where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">User u = userMapper.selectById(<span class="number">10</span>);</span><br><span class="line">System.out.println(u);</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><p>当实体类属性名与表字段不一致时，可以使用resultMap元素映射其对应关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.mybatis.entity.User"</span> <span class="attr">id</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    select * from USER where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>resultMap是一种很重要的配置结果映射的方法</strong></p><ul><li>id属性：必填，是结果映射的唯一标识，与select元素中resultMap属性的值一致</li><li>type属性：必填，用于指定查询结果所映射到的Java对象类型</li><li>id子元素：配置id对应的column（字段名）和property（属性名）</li><li>result子元素：配置普通结果对应的字段名和属性名</li></ul><p>当实体类属性与表字段不一致时，也可以通过设置别名进行映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAllUsers"</span> <span class="attr">resultType</span>=<span class="string">"com.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">    select id,</span><br><span class="line">        user_name userName,</span><br><span class="line">        password</span><br><span class="line">    from USER</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="模糊查询like"><a href="#模糊查询like" class="headerlink" title="模糊查询like"></a>模糊查询like</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findLike"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    select * from user where user_name like "%"#&#123;name&#125;"%"</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表达式: user_name like”%”#{name}”%” #起到<strong>占位符</strong>的作用</p><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>在映射器接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateById</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>在映射文件中添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateById"</span>&gt;</span></span><br><span class="line">    update user </span><br><span class="line">    set user_name = #&#123;userName&#125;,</span><br><span class="line">        password = #&#123;password&#125;</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line">User u = <span class="keyword">new</span> User();</span><br><span class="line">u.setId(<span class="number">10</span>);</span><br><span class="line">u.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">u.setPassword(<span class="string">"123456"</span>);</span><br><span class="line"><span class="keyword">int</span> num = userMapper.updateById(u);</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除同更新操作类似，在映射器接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>在映射文件中添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteById"</span>&gt;</span></span><br><span class="line">    delete from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line"><span class="keyword">int</span> num = userMapper.deleteById(<span class="number">10</span>);</span><br><span class="line">System.out.println(num);</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MyBatis】框架概述</title>
      <link href="/2020/03/17/MyBatis%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/03/17/MyBatis%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="MyBatis使用流程"><a href="#MyBatis使用流程" class="headerlink" title="MyBatis使用流程"></a>MyBatis使用流程</h3><ol><li>创建一个Java Project</li><li>导入MyBatis需要的jar包(mybatis-xxx.jar)</li><li>创建MyBatis的主配置文件mybatis.xml</li><li>创建实体类和映射器接口</li><li>创建MyBatis的SQL映射XML文件</li><li>将SQL映射文件与主配置文件进行关联</li><li>编写代码进行测试</li></ol><h3 id="GitHub源码"><a href="#GitHub源码" class="headerlink" title="GitHub源码"></a>GitHub源码</h3><p><a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">https</a><a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">://</a><a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">github.com/mybatis/mybatis-3</a></p><h3 id="MyBatis中文手册："><a href="#MyBatis中文手册：" class="headerlink" title="MyBatis中文手册："></a>MyBatis中文手册：</h3><p><a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">http</a><a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">://www.mybatis.org/mybatis-3/zh/index.html</a></p><h3 id="MyBatis核心XML配置文件"><a href="#MyBatis核心XML配置文件" class="headerlink" title="MyBatis核心XML配置文件"></a>MyBatis核心XML配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>  <span class="attr">resource</span>=<span class="string">"dbinfo.properties"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打印SQL语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 配置数据库信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.connectUrl&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.user&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.pwd&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>settings</strong>是 MyBatis 中极为重要的调整设置，可以用来配置全局参数，它们会改变 MyBatis 的运行时行为</p><ul><li>logImpl设置用来指定MyBatis 所用日志的具体实现，未指定时将自动查找。如果设置为<strong>STDOUT_LOGGING</strong>则表示在控制台显示SQL语句</li><li><a href="https://blog.csdn.net/u014231523/article/details/53056032" target="_blank" rel="noopener">https://blog.csdn.net/u014231523/article/details/53056032</a></li></ul><p>配置环境（<strong>environments</strong>）</p><ul><li>MyBatis 可以配置成适应多种环境，也就是配置多个environment子元素，这种机制有助于将<br>SQL<br>映射应用于多种数据库之中</li><li><strong>注意：</strong>environments的default属性取值要和其中一个environment的id属性取值一致</li></ul><p><strong>transactionManager</strong> 元素的type属性表示事务管理器类型，在MyBatis中有两种类型：</p><ul><li><strong>JDBC</strong> 这种方式是直接使用了JDBC的事务提交和回滚设置</li><li>MANAGED(托管)这种方式从来不提交或回滚一个连接。而是让容器来管理事务的整个生命周期(比如<br>Spring) </li></ul><p><strong>dataSource</strong>元素中主要配置了 JDBC 连接对象的资源，它的type属性表示数据源类型，内建的数据源类型有三种：</p><ul><li>UNPOOLED:每次被请求时简单打开和关闭连接</li><li><strong>POOLED</strong>：这是JDBC连接对象的数据库连接池的实现,用来避免创建新的连接实例 </li><li>JNDI：这个数据源的实现是为了使用如Spring或应用服务器这类的容器</li></ul><h3 id="MyBatis主要的类层次结构"><a href="#MyBatis主要的类层次结构" class="headerlink" title="MyBatis主要的类层次结构"></a>MyBatis主要的类层次结构</h3><p><img data-src="1.png" alt="1.png"></p><ul><li>每一个MyBatis的应用程序都以一个SqlSessionFactory 对象的实例为核心 。 </li><li>SqlSessionFactory对象的实例可以通过SqlSessionFactoryBuilder对象来获得 。</li><li>SqlSessionFactoryBuilder对象可以从 XML 配置文件中构建 SqlSessionFactory对象。 </li><li>通过SqlSessionFactory对象，可以获得SqlSession的实例。</li><li>SqlSession 对象完全包含以数据库为背景的所有执行 SQL 操作的方法。你可以用 SqlSession 实例来直接执行已映射的 SQL 语句 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is =     </span><br><span class="line">                Resources.getResourceAsStream(<span class="string">"mybatis.xml"</span>);</span><br><span class="line">            factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">openSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>dbinfo.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">db.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">db.connectUrl</span>=<span class="string">jdbc:mysql://localhost:3306/mybatisdemo_db?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.pwd</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>mybatis.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"dbinfo.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打印SQL语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置数据库信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driver&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.connectUrl&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.user&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.pwd&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"top/hiasenna/mapper/userMapper.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtil</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sessionFactory;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream is = Resources.getResourceAsStream(<span class="string">"mybatis.xml"</span>);</span><br><span class="line">sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">is.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">openSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sessionFactory.openSession();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User [id="</span> + id + <span class="string">", username="</span> + username + <span class="string">", password="</span> + password + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>userMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.hiasenna.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAll"</span> <span class="attr">resultType</span>=<span class="string">"top.hiasenna.entity.User"</span>&gt;</span></span><br><span class="line">select * from user </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">queryUser();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queryUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqlSession session = MyBatisUtil.openSqlSession();</span><br><span class="line">UserMapper userMapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//List&lt;User&gt; users = session.selectList("top.hiasenna.mapper.UserMapper.selectAll");</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line"><span class="keyword">for</span>(User u : users) &#123;</span><br><span class="line">    System.out.println(u);</span><br><span class="line">&#125;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】检索方式与检索策略</title>
      <link href="/2020/03/17/hibernate%E6%A3%80%E7%B4%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5/"/>
      <url>/2020/03/17/hibernate%E6%A3%80%E7%B4%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>Hibernate的Session在加载Java对象时，一般都会把这个对象相关联的其他Java对象也都加载到缓存中，以方便程序的调用。但很多情况下，我们不需要加载太多无用的对象到缓存中，一来会占用大量的内存，二来会增加数据库的访问次数，使得程序的运行效率降低。为了合理的使用缓存，Hibernate提供了不同的检索策略来解决这些问题。</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h1><p>在说检索策略之前，先了解一下检索策略的作用域，它分为：类级别和关联级别。类级别的作用域在检索数据时，检索的数据只包含一个类对象，不涉及与该类关联的其他对象。关联级别的作用域检索的数据包含相关联的多个类的对象，例如，Customer对象与Orders对象存在关系，检索到一个Customer对象后，还会涉及与之关联的Orders对象。</p><p><img data-src="1.png" alt="1"></p><h1 id="检索策略"><a href="#检索策略" class="headerlink" title="检索策略"></a><strong>检索策略</strong></h1><p>Hibernate的检索策略分为三种，立即检索、延迟检索、左外连接检索。</p><h3 id="立即检索"><a href="#立即检索" class="headerlink" title="立即检索"></a><strong>立即检索</strong></h3><p> 采用立即检索策略，会把被检索的对象，以及和这个对象关联的一对多对象都加载到缓存中。Session的get方法就使用的立即检索策略。这种策略的优点在于，频繁使用的对象会被加载到缓存中，程序调用很方便，也很及时。缺点就是，占用的内存过多，而且数据库访问的次数也会很频繁，效率低下。</p><h3 id="延迟检索"><a href="#延迟检索" class="headerlink" title="延迟检索"></a><strong>延迟检索</strong></h3><p>采用延迟检索策略，就不会加载关联对象的内容。直到第一次调用关联对象时，才去加载关联对象。在不涉及关联类操作时，延迟检索策略只适用于Session的load方法。涉及关联类操作时，延迟检索策略也能够适用于get，list等操作。</p><p>在类级别操作时， 延迟检索策略，只加载类的OID不加载类的其他属性，只用当第一次访问其他属性时，才回访问数据库去加载内容。（这里使用了CGLIB生成了类的代理类）</p><p>在关联级别操作时，延迟检索策略，只加载类本身，不加载关联类，直到第一次调用关联对象时，才去加载关联对象。</p><p>程序模式都是用延迟加载策略。如果需要指定使用延迟加载策略。在配置文件中设置&lt;class&gt;的lazy=true，、&lt;set&gt;的lazy=true或extra（增强延迟）&lt;many-to-one&gt;的lazy=proxy和no-proxy。</p><p>  这种策略的优点在于，由程序决定加载哪些类和内容，而不必全部都加载，避免了内存的大量占用和数据库的频繁访问。缺点就是在Session关闭后，就不能访问关联类对象了。 需要确保Session一直处于打开状态，调用关联对象，最后在关闭Session对象。</p><h3 id="左外连接检索"><a href="#左外连接检索" class="headerlink" title="左外连接检索"></a><strong>左外连接检索</strong></h3><p>采用左外连接检索，能够使用sql的外连接查询，将需要加载的关联对象加载在缓存中。&lt;set&gt;fetch设置为join，&lt;many-to-one&gt;的fetch设置为join。</p><p>这种策略的优点在于，对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象。使用了外连接，select语句数目少。缺点就是可能会加载应用程序不需要访问的对象，白白浪费许多内存空间。复杂的数据库表连接也会影响检索性能。</p><p><img data-src="2.png" alt="2"></p><h1 id="检索方式"><a href="#检索方式" class="headerlink" title="检索方式"></a><strong>检索方式</strong></h1><p> Hibernate提供的检索方式为5种，分为导航对象图检索方式、OID检索方式、HQL检索方式、QBC检索方式、本地SQL检索方式。</p><h3 id="导航对象图检索方式"><a href="#导航对象图检索方式" class="headerlink" title="导航对象图检索方式"></a><strong>导航对象图检索方式</strong></h3><p>利用类与类之间的关系来检索对象。譬如我们要查找一份订单，就可以由订单对象自动导航找到订单所属的客户对象。当然，前提是必须在对象-关系映射文件上配置了它们的多对一的关系。</p><h3 id="OID检索方式"><a href="#OID检索方式" class="headerlink" title="OID检索方式"></a><strong>OID检索方式</strong></h3><p>主要指用Session的get()和load()方法加载某条记录对应的对象。</p><h3 id="HQL检索方式"><a href="#HQL检索方式" class="headerlink" title="HQL检索方式"></a><strong>HQL检索方式</strong></h3><p> HQL（Hibernate Query Language）是面向对象的查询语言，它和SQL查询语言有些相似。在Hibernate提供的各种检索方式中，HQL是使用最广的一种检索方式。它具有以下功能：</p><p>&emsp;    在查询语句中设定各种查询条件。</p><p>&emsp;    支持投影查询，即仅检索出对象的部分属性。<br>&emsp;    支持分页查询。<br>&emsp;    支持分组查询，允许使用group by和having关键字。<br>&emsp;    提供内置聚集函数，如sum()、min()和max()。<br>&emsp;    能够调用用户定义的SQL函数。<br>&emsp;    支持子查询，即嵌套查询。<br>&emsp;    支持动态绑定参数。</p><p>   Session类的Qurey接口支持HQL检索方式，它提供了以上列出的各种查询功能。</p><p><strong>注:</strong>Qurey接口支持方法链编程风格，它的set方法都返回自身实例，而不是返回void类型。方法链编程风格能使程序代码更加简洁。</p><p><strong>例：</strong></p><p>检索USER 表的所有记录</p><p>—-HQL语句中关键字大小写无关，但习惯将关键字小写。</p><p>—-from 关键字后面是类名不是数据库表名，类名需区分大小写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Query query = session.createQuery(<span class="string">"from User"</span>);</span><br><span class="line">List userList = query.list();</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"select u from User u"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">List userList = query.list();</span><br></pre></td></tr></table></figure><p>where 子句</p><p>—where子句中给出的是类的属性名而不是数据库表字段名，其中属性名必须区分大小写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from User where userName='张三'"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">List userList = query.list();</span><br></pre></td></tr></table></figure><p>HQL支持的各种运算符</p><table><thead><tr><th align="center"><strong>程序中指定的连接类型</strong></th><th align="center"><strong>HQL**</strong>运算符**</th></tr></thead><tbody><tr><td align="center">比较运算符</td><td align="center">=、&lt;&gt;、&gt;=、&lt;=、&gt;、&lt;、is null、is not null</td></tr><tr><td align="center">范围运算符</td><td align="center">in、not in、between…and、not between…and</td></tr><tr><td align="center">字符串模式匹配运算符</td><td align="center">like</td></tr><tr><td align="center">逻辑运算符</td><td align="center">and、or、not</td></tr></tbody></table><h4 id="HQL检索单个对象"><a href="#HQL检索单个对象" class="headerlink" title="HQL检索单个对象"></a>HQL检索单个对象</h4><p>list()：返回List类型的查询结果，返回所有满足条件的对象。</p><p>uniqueResult()：返回单个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Query query = session.createQuery(<span class="string">"from User u</span></span><br><span class="line"><span class="string">                      where u.userName='张三'"</span>);</span><br><span class="line">User user = (User)query.uniqueResult();</span><br></pre></td></tr></table></figure><h4 id="HQL参数绑定"><a href="#HQL参数绑定" class="headerlink" title="HQL参数绑定"></a>HQL参数绑定</h4><h5 id="在HQL查询语句中按照参数位置绑定参数"><a href="#在HQL查询语句中按照参数位置绑定参数" class="headerlink" title="在HQL查询语句中按照参数位置绑定参数"></a>在HQL查询语句中按照参数位置绑定参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from User u where u.userName=?"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">query.setParameter(<span class="number">0</span>, <span class="string">"张三"</span>);</span><br><span class="line">List&lt;User&gt; userList = query.list();</span><br></pre></td></tr></table></figure><h5 id="在HQL查询语句中按参数名称绑定参数。"><a href="#在HQL查询语句中按参数名称绑定参数。" class="headerlink" title="在HQL查询语句中按参数名称绑定参数。"></a>在HQL查询语句中按参数名称绑定参数。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from User u </span></span><br><span class="line"><span class="string">        where u.userName=:name"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">query.setParameter(<span class="string">"name"</span>, <span class="string">"张三"</span>);</span><br><span class="line">List&lt;User&gt; userList = query.list();</span><br></pre></td></tr></table></figure><h5 id="HQL的绑定参数方法"><a href="#HQL的绑定参数方法" class="headerlink" title="HQL的绑定参数方法"></a>HQL的绑定参数方法</h5><p>setParamter() 绑定任意类型的参数。</p><p>setProperties(Object bean) 用于把命名参数与一个对象的属性值绑定，并且参数名称要与对象属性名称一致。</p><p>setProperties(Map bean)用于把命名参数与一个Map类型的对象的value值绑定，并且参数名称要与Map类型的对象的key值一致。</p><h4 id="HQL实体更新"><a href="#HQL实体更新" class="headerlink" title="HQL实体更新"></a>HQL实体更新</h4><h5 id="不使用HQL的实体更新。"><a href="#不使用HQL的实体更新。" class="headerlink" title="不使用HQL的实体更新。"></a>不使用HQL的实体更新。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">User user = (User) session.get(User<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line">user.setUserName(<span class="string">"Tom"</span>);</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><h5 id="HQL实现实体更新的方式"><a href="#HQL实现实体更新的方式" class="headerlink" title="HQL实现实体更新的方式"></a>HQL实现实体更新的方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">String hql = <span class="string">"update User set userName='Tom' </span></span><br><span class="line"><span class="string">        where id=2"</span>; </span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line"><span class="keyword">int</span> ret = query.executeUpdate();</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><h4 id="HQL实体删除"><a href="#HQL实体删除" class="headerlink" title="HQL实体删除"></a>HQL实体删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">String hql = <span class="string">"delete from User where id = 1"</span>;</span><br><span class="line">Query query  = session.createQuery(hql);</span><br><span class="line"><span class="keyword">int</span> ret = query.executeUpdate();</span><br><span class="line">tx .commit();</span><br></pre></td></tr></table></figure><h4 id="HQL子查询"><a href="#HQL子查询" class="headerlink" title="HQL子查询"></a>HQL子查询</h4><p>HQL支持在 where 子句中嵌入子查询语句，并且子查询语句必须放在括号内。</p><p>查询订单数量大于0的所有用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> u </span><br><span class="line"><span class="keyword">where</span> <span class="number">0</span>&lt;(<span class="keyword">select</span> <span class="keyword">count</span>(o) <span class="keyword">from</span> orders o </span><br><span class="line">         <span class="keyword">where</span> u.id=o.userId )</span><br></pre></td></tr></table></figure><p>如果HQL子查询的是集合，HQL提供了一组操作集合的函数:</p><p>size()，获得集合中元素的个数；</p><p>maxIndex()，对于建立索引的集合，获得最大索引值；</p><p>minIndex()，对于建立索引的集合，获得最小索引值；</p><p>elements()，获得集合中所有元素。</p><h3 id="QBC检索方式"><a href="#QBC检索方式" class="headerlink" title="QBC检索方式"></a><strong>QBC检索方式</strong></h3><p>采用HQL检索方式时，在应用程序中需要定义基于字符串形式的HQL查询语句。QBC API提供了检索对象的另一种方式，它主要由Criteria接口、Criterion接口和Expression类组成，它支持在运行时动态生成查询语句。</p><p>检索姓名为张三 的所有用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria=session.createCriteria(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Criterion c1= Restrictions.eq(<span class="string">"userName"</span>, <span class="string">"张三"</span>);</span><br><span class="line">criteria.add(c1);</span><br><span class="line">List result = criteria.list();</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>运算类型</strong></th><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>范围运算符</td><td>Restrictions.in</td><td>等于列表中的某个值</td></tr><tr><td></td><td>Restrictions.not(Restrictions.in)</td><td>不等于列表中的任意值</td></tr><tr><td></td><td>Restrictions.between</td><td>大于等于值1小于等于值2</td></tr><tr><td>字符串模糊匹配</td><td>Restrictions.like</td><td>字符串模糊匹配   like</td></tr><tr><td>逻辑运算符</td><td>Restrictions.and</td><td>逻辑与</td></tr><tr><td></td><td>Restrictions.or</td><td>逻辑或</td></tr><tr><td></td><td>Restrictions.not</td><td>逻辑非</td></tr><tr><td>比较运算符</td><td>Restrictions.eq</td><td>等于</td></tr><tr><td></td><td>Restrictions.ne</td><td>不等于</td></tr><tr><td></td><td>Restrictions.gt</td><td>大于</td></tr><tr><td></td><td>Restrictions.ge</td><td>大于等于</td></tr><tr><td></td><td>Restrictions.lt</td><td>小于</td></tr><tr><td></td><td>Restrictions.le</td><td>小于等于</td></tr><tr><td></td><td>Restrictions.isNull</td><td>等于空值</td></tr><tr><td></td><td>Restrictions.isNotNull</td><td>非空值</td></tr></tbody></table><h3 id="本地SQL检索方式"><a href="#本地SQL检索方式" class="headerlink" title="本地SQL检索方式"></a><strong>本地SQL检索方式</strong></h3><p>采用HQL或QBC检索方式时，Hibernate生成标准的SQL查询语句，使用于所有的数据库平台，因此这两种检索方式都是跨平台的。有的应用程序可能需要根据底层数据库的SQL方言，来生成一些特殊的查询语句。在这种情况下，可以利用Hibernate提供的SQL检索方式。</p><p>查询所有的用户信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from  user"</span>;</span><br><span class="line">NativeQuery query = session.createNativeQuery(sql, </span><br><span class="line">    User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">List list = query.list();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-稀疏数组</title>
      <link href="/2020/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2020/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。<br>稀疏数组的处理方法是:</p><p>1) 记录数组 一共有几行几列，有多少个不同的值<br>2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而 缩小程序的规模</p><p><img data-src="1.png" alt="1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line"><span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表示蓝子</span></span><br><span class="line"><span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 输出原始的二维数组</span></span><br><span class="line">System.out.println(<span class="string">"原始的二维数组~~"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将二维数组 转 稀疏数组</span></span><br><span class="line"><span class="comment">// 1. 先遍历二维数组 得到非0数据的个数</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line"><span class="keyword">if</span> (data != <span class="number">0</span>) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line"><span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二维数组，将非0的值存放到 sparseArr中</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"得到稀疏数组为~~~~"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int [11][11] 2.</span></span><br><span class="line"><span class="comment"> * 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"><span class="keyword">int</span> chessRow = sparseArr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> chessCol = sparseArr[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[chessRow][chessCol];</span><br><span class="line"><span class="comment">// 2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]]=sparseArr[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img data-src="2.png" alt="2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】操作持久化对象</title>
      <link href="/2020/03/16/hibernate%E6%93%8D%E4%BD%9C%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/16/hibernate%E6%93%8D%E4%BD%9C%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="一-Session缓存"><a href="#一-Session缓存" class="headerlink" title="一.Session缓存"></a>一.Session缓存</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li>缓存介于应用程序和永久性存储源之间，其作用是降低应用程序直接读写永久性存储源的频率，从而提高应用的运行效率。</li><li>缓存内的数据是永久性存储源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件同步缓存和永久性存储源的数据。</li></ul><p><img data-src="1.png" alt="1.png"></p><h4 id="Session缓存"><a href="#Session缓存" class="headerlink" title="Session缓存"></a>Session缓存</h4><p>Session 接口的实现类 SessionImpl 中定义了一系列的 Java 集合，这些集合构成了 Session 的缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Session session = sessionFactory.openSession(); </span><br><span class="line">......</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><h4 id="Session缓存的工作过程"><a href="#Session缓存的工作过程" class="headerlink" title="Session缓存的工作过程"></a>Session缓存的工作过程</h4><p>当 Session 执行查询方法时，先从 Session 缓存中读取据，如果缓存中有则直接读取，如果缓存中没有，从数据库中查询并加载到 Session 缓存中，再从缓存中读取。</p><p>当 Session 执行 save()、update() 方法时，将对象持久化到数据库中并将对象加载到 Session 缓存中。</p><p><img data-src="2.png" alt="2.png"></p><h4 id="Session实现缓存"><a href="#Session实现缓存" class="headerlink" title="Session实现缓存"></a>Session实现缓存</h4><p><img data-src="3.gif" alt="3.gif"></p><h4 id="Session清理缓存"><a href="#Session清理缓存" class="headerlink" title="Session清理缓存"></a>Session清理缓存</h4><p>Session在某一时间点按照缓存中对象的属性变化来同步更新数据库的这一过程被称为 <strong>Session</strong> <strong>清理缓存</strong>。</p><p><strong>缓存清理的时间点：</strong></p><ul><li>当调用 transaction.commit() 方法时，会先清理缓存，再向数据库提交事务；</li><li>当显式调用 Session.flush() 方法时，会清理缓存；</li><li>当调用 Session 的查询（不包括 load() 和 get() )方法时，如果缓存中对象的属性有变化则清理缓存。</li></ul><h4 id="Session对象快照"><a href="#Session对象快照" class="headerlink" title="Session对象快照"></a>Session对象快照</h4><p><img data-src="4.gif" alt="4.gif"></p><h4 id="Session清理缓存的模式"><a href="#Session清理缓存的模式" class="headerlink" title="Session清理缓存的模式"></a>Session清理缓存的模式</h4><p>setHibernateFlushMode() 用于设定 Session 清理缓存的模式。</p><table><thead><tr><th align="center"><strong>清理缓存模式</strong></th><th align="center"><strong>Session的查询方法</strong></th><th align="center"><strong>commit()</strong></th><th align="center"><strong>flush()</strong></th></tr></thead><tbody><tr><td align="center">FlushMode.ALWAYS</td><td align="center">清理</td><td align="center">清理</td><td align="center">清理</td></tr><tr><td align="center">FlushMode.AUTO</td><td align="center">缓存中对象的属性有变化时清理，没变化不清理</td><td align="center">清理</td><td align="center">清理</td></tr><tr><td align="center">FlushMode.COMMIT</td><td align="center">不清理</td><td align="center">清理</td><td align="center">清理</td></tr><tr><td align="center">FlushMode.MANUAL</td><td align="center">不清理</td><td align="center">不清理</td><td align="center">清理</td></tr><tr><td align="center">FlushMode.NEVER</td><td align="center">已过时，被MANUAL取代</td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="Session缓存有三大作用"><a href="#Session缓存有三大作用" class="headerlink" title="Session缓存有三大作用:"></a>Session缓存有三大作用:</h4><ul><li>减少数据库访问次数，提高数据访问的效率；</li><li>保证缓存中的对象与数据库中相关的记录同步；</li><li>当缓存中的持久化对象存在循环关联关系时，Session会保证不出现死循环，以及由死循环引起的堆栈溢出异常。</li></ul><h3 id="二-Hibernate对象的生命周期"><a href="#二-Hibernate对象的生命周期" class="headerlink" title="二.Hibernate对象的生命周期"></a>二.Hibernate对象的生命周期</h3><h4 id="实体对象的4种状态"><a href="#实体对象的4种状态" class="headerlink" title="实体对象的4种状态"></a>实体对象的4种状态</h4><ul><li>Transient(临时状态) ： 刚刚被 new 关键字创建，还没有被持久化，不在Session的缓存中。</li><li>Persistent(持久化状态) ： 已经被持久化，并加入到 Session 缓存中。</li><li>Detached(游离状态) ： 已经被持久化，但不再处于 Session 缓存中。</li><li>Removed(删除状态) ： Session 已经计划将其从数据库删除，并且不再处于 Session 缓存中。</li></ul><p><img data-src="5.png" alt="5.png"></p><h4 id="实体对象的生命周期（lifecycle）"><a href="#实体对象的生命周期（lifecycle）" class="headerlink" title="实体对象的生命周期（lifecycle）"></a>实体对象的生命周期（lifecycle）</h4><p><img data-src="6.png" alt="6.png"></p><h3 id="三-Hibernate操作持久化对象"><a href="#三-Hibernate操作持久化对象" class="headerlink" title="三.Hibernate操作持久化对象"></a>三.Hibernate操作持久化对象</h3><h4 id="Session的save-方法"><a href="#Session的save-方法" class="headerlink" title="Session的save()方法"></a>Session的save()方法</h4><p>•1. 把对象加入缓存中，使其变成持久化对象；</p><p>•2. 根据映射文件配置的标识符生成器为对象分配一个<br>OID；</p><p>•3. 计划执行一个 insert，把对象当前属性值组装到<br>insert 语句中；</p><p>•4. 事务提交后（transaction.commit()）永久的将数据保存到数据库。</p><h4 id="Session的update-方法"><a href="#Session的update-方法" class="headerlink" title="Session的update()方法"></a>Session的update()方法</h4><p>•1. 把游离对象重新加入 Session 缓存中，使其变为持久化对象；</p><p>•2. 计划执行一个 update，将对象当前属性组装到 update 语句，执行 update 语句；</p><p>•3. 事务提交后（transaction.commit()）永久的将数据保存到数据库；</p><p>•4. 不管对象属性有没有改变都会执行update （通过设置<class>的select-before-update=true改变）。</class></p><h4 id="Session的saveOrUpdate-方法"><a href="#Session的saveOrUpdate-方法" class="headerlink" title="Session的saveOrUpdate()方法"></a>Session的saveOrUpdate()方法</h4><ul><li>如果参数是临时对象–save()</li><li>如果参数是游离对象–update()</li><li>如果参数是持久化对象–返回</li></ul><p>Hibernate 如何区分临时对象：</p><ul><li>对象的 OID 为 null；</li><li>如果映射文件中设置了 <id> 的 unsaved-value 属性，并且对象的 id 值与 unsaved-value 设置的值相等。</id></li></ul><h4 id="Session的delete-方法"><a href="#Session的delete-方法" class="headerlink" title="Session的delete()方法"></a>Session的delete()方法</h4><p>•1. 检查传入的参数是否是持久化对象，如果是持久化对象将其移出 Session 缓存；</p><p>•2. 计划执行一个 delete，但是并不立即执行；</p><p>•3. 当 Session 清理缓存时才执行 delete，比如执行 Session.flush()。</p><h4 id="Session的load-和get-方法"><a href="#Session的load-和get-方法" class="headerlink" title="Session的load()和get()方法"></a>Session的load()和get()方法</h4><p>load() 与 get() 方法都是根据 OID 加载持久化对象。</p><p>load() 与 get() 方法的不同点：</p><ul><li>如果数据库中不存在与 OID 对应的记录：</li></ul><ol><li>load() 会抛出 ObjectNotFoundException 异常；</li><li>get() 会返回 null。</li></ol><ul><li>默认加载策略：</li></ul><ol><li>load() 使用类的延迟加载策略；</li><li>get() 使用类的立即加载策略。</li></ol>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】多对多关联映射</title>
      <link href="/2020/03/16/hibernate%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/16/hibernate%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在某高校选课系统中，一个学生可以同时选修多门课程，一门课程可以被若干个学生选修，像这样的多对多关联关系，应该如何实现？</p><p><img data-src="1.png" alt="1.png"></p><p><img data-src="2.png" alt="2.png"></p><h3 id="Hibernate多对多关联映射"><a href="#Hibernate多对多关联映射" class="headerlink" title="Hibernate多对多关联映射"></a>Hibernate多对多关联映射</h3><p>Student.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String studentNo;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Course&gt; courses = <span class="keyword">new</span> HashSet&lt;Course&gt;();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Course.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> credit;  <span class="comment">// 学分</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"courses"</span> <span class="attr">table</span>=<span class="string">"studentcourse"</span> <span class="attr">inverse</span>=<span class="string">"false"</span> <span class="attr">cascade</span>=<span class="string">"all"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"student_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"Course"</span> <span class="attr">column</span>=<span class="string">"course_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Course.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"students"</span> <span class="attr">table</span>=<span class="string">"studentcourse"</span> <span class="attr">inverse</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"course_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"Student"</span> <span class="attr">column</span>=<span class="string">"student_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="4.png" alt="4.png"></p><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">addStudent();</span><br><span class="line">delStudent();</span><br><span class="line">query();</span><br><span class="line">addCourse();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setName(<span class="string">"zs"</span>);</span><br><span class="line">Course course = session.get(Course<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Integer</span>(1))</span>;</span><br><span class="line">Course course2 = session.get(Course<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Integer</span>(2))</span>;</span><br><span class="line">student.getCourses().add(course);</span><br><span class="line">student.getCourses().add(course2);</span><br><span class="line"></span><br><span class="line">session.save(student);</span><br><span class="line"></span><br><span class="line">Student student2 = <span class="keyword">new</span> Student();</span><br><span class="line">student2.setName(<span class="string">"ls"</span>);</span><br><span class="line">student2.getCourses().add(course);</span><br><span class="line">student2.getCourses().add(course2);</span><br><span class="line"></span><br><span class="line">session.save(student2);</span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createCourse</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">Course course = <span class="keyword">new</span> Course();</span><br><span class="line">course.setName(<span class="string">"Java"</span>);</span><br><span class="line">session.save(course);</span><br><span class="line">Course course2 = <span class="keyword">new</span> Course();</span><br><span class="line">course2.setName(<span class="string">"H5"</span>);</span><br><span class="line">session.save(course2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">Student student =session.get(Student<span class="class">.<span class="keyword">class</span>, <span class="title">i</span>)</span>;</span><br><span class="line">session.delete(student);</span><br><span class="line">&#125;</span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addCourse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">createCourse(session);</span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">Student student = session.get(Student<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Integer</span>(1))</span>;</span><br><span class="line">Set&lt;Course&gt; courses = student.getCourses();</span><br><span class="line"><span class="keyword">for</span>(Course course:courses)&#123;</span><br><span class="line">System.out.println(course.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Course course = session.get(Course<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">Integer</span>(1))</span>;</span><br><span class="line"><span class="keyword">for</span>(Student student2:course.getStudents())&#123;</span><br><span class="line">System.out.println(student2.getName());</span><br><span class="line">&#125;</span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@ManyToMany</span></span><br><span class="line"><span class="meta">@JoinTable</span>(name=<span class="string">"studentcourse"</span>,</span><br><span class="line">joinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"student_id"</span>),</span><br><span class="line">inverseJoinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"course_id"</span>))</span><br><span class="line"><span class="keyword">private</span> Set&lt;Course&gt; courses = <span class="keyword">new</span> HashSet&lt;Course&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Course&gt; <span class="title">getCourses</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> courses;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourses</span><span class="params">(Set&lt;Course&gt; courses)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.courses = courses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"course"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@ManyToMany</span>(mappedBy=<span class="string">"courses"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> students;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudents</span><span class="params">(Set&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.students = students;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="3.png" alt="3.png"></p>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap集合(高级)</title>
      <link href="/2020/03/15/HashMap%E9%9B%86%E5%90%88-%E9%AB%98%E7%BA%A7/"/>
      <url>/2020/03/15/HashMap%E9%9B%86%E5%90%88-%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap集合-高级"><a href="#HashMap集合-高级" class="headerlink" title="HashMap集合(高级)"></a>HashMap集合(高级)</h1><h2 id="1-HashMap集合简介"><a href="#1-HashMap集合简介" class="headerlink" title="1.HashMap集合简介"></a>1.HashMap集合简介</h2><p>​    HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><p>​    JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突<strong>(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)</strong>而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</strong></p><p>补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。</p><p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 <code>treeifyBin</code>方法。</p><p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。 </p><p>小结：</p><p>特点：</p><p>1.存取无序的</p><p>2.键和值位置都可以是null，但是键位置只能是一个null</p><p>3.键位置是唯一的，底层的数据结构控制键的</p><p>4.jdk1.8前数据结构是：链表 + 数组  jdk1.8之后是 ： 链表 + 数组  + 红黑树</p><p>5.阈值(边界值) &gt; 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</p><h2 id="2-HashMap集合底层的数据结构"><a href="#2-HashMap集合底层的数据结构" class="headerlink" title="2.HashMap集合底层的数据结构"></a>2.HashMap集合底层的数据结构</h2><h3 id="2-1数据结构概念"><a href="#2-1数据结构概念" class="headerlink" title="2.1数据结构概念"></a>2.1数据结构概念</h3><p> 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 </p><p>数据结构：就是存储数据的一种方式。ArrayList LinkedList</p><p>在JDK1.8 之前 HashMap 由 <strong>数组+链表</strong> 数据结构组成的。</p><p>在JDK1.8 之后 HashMap 由 <strong>数组+链表 +红黑树</strong>数据结构组成的。</p><h3 id="2-2HashMap底层的数据结构存储数据的过程"><a href="#2-2HashMap底层的数据结构存储数据的过程" class="headerlink" title="2.2HashMap底层的数据结构存储数据的过程"></a>2.2HashMap底层的数据结构存储数据的过程</h3><p>存储过程如下所示：</p><p>使用的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"刘德华"</span>, <span class="number">53</span>);</span><br><span class="line">        map.put(<span class="string">"柳岩"</span>, <span class="number">35</span>);</span><br><span class="line">        map.put(<span class="string">"张学友"</span>, <span class="number">55</span>);</span><br><span class="line">        map.put(<span class="string">"郭富城"</span>, <span class="number">52</span>);</span><br><span class="line">        map.put(<span class="string">"黎明"</span>, <span class="number">51</span>);</span><br><span class="line">        map.put(<span class="string">"林青霞"</span>, <span class="number">55</span>);</span><br><span class="line">        map.put(<span class="string">"刘德华"</span>, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" alt="哈希表存储过程.png"></p><p>说明：</p><p>1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于key的hashCode做hash操作，无符号右移16位然后做异或运算。</span><br><span class="line">还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移16位异或运算效率是最高的。至于底层是如何计算的我们下面看源码时给大家讲解。</span><br></pre></td></tr></table></figure><p>2.面试题：当两个对象的hashCode相等时会怎么样？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">会产生哈希碰撞，若key值内容相同则替换旧的value.不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储。</span><br></pre></td></tr></table></figure><p>3.面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</span><br></pre></td></tr></table></figure><p>4.面试题：如果两个键的hashcode相同，如何存储键值对？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashcode相同，通过equals比较内容是否相同。</span><br><span class="line">相同：则新的value覆盖之前的value</span><br><span class="line">不相同：则将新的键值对添加到哈希表中</span><br></pre></td></tr></table></figure><p>5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p><p>6.通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次查找的效率较低。而<strong>JDK1.8</strong>中，哈希表存储采用数组+链表+红黑树实现，当链表长度(阀值)超过 8 时且当前数组的长度 &gt; 64时，将链表转换为红黑树，这样大大减少了查找时间。jdk8在哈希表中引入红黑树的原因只是为了查找效率更高。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示。</p><p><img data-src="%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="哈希表.png"></p><p> <strong>但是这样的话问题来了，传统hashMap的缺点，1.8为什么引入红黑树？这样结构的话不是更麻烦了吗，为何阈值大于8换成红黑树？</strong></p><p> JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。 当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。</p><p>至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。 下面我们在分析源码的时候会介绍。</p><p><strong>7.总结：</strong></p><p>上述我们大概阐述了HashMap底层存储数据的方式。为了方便大家更好的理解，我们结合一个存储流程图来进一步说明一下：(jdk8存储过程)</p><p><img data-src="1.png" alt="1.png"></p><p>说明：</p><p>1.size表示 HashMap中K-V的实时数量 ， 注意这个不等于数组的长度 。 </p><p>2.threshold( 临界值)  =capacity(容量) * loadFactor( 加载因子 )。这个值是当前已占用数组长度的最大值。size超过这个临界值就重新resize(扩容)，扩容后的 HashMap 容量是之前容量的两倍 。</p><h2 id="3-HashMap继承关系"><a href="#3-HashMap继承关系" class="headerlink" title="3.HashMap继承关系"></a>3.HashMap继承关系</h2><p>HashMap继承关系如下图所示：</p><p><img data-src="1.bmp" alt="1.bmp"></p><p>说明：</p><ul><li>Cloneable 空接口，表示可以克隆。 创建并返回HashMap对象的一个副本。</li><li>Serializable 序列化接口。属于标记性接口。HashMap对象可以被序列化和反序列化。</li><li>AbstractMap 父类提供了Map实现接口。以最大限度地减少实现此接口所需的工作。</li></ul><p>补充：通过上述继承关系我们发现一个很奇怪的现象， 就是HashMap已经继承了AbstractMap而AbstractMap类实现了Map接口，那为什么HashMap还要在实现Map接口呢？同样在ArrayList中LinkedList中都是这种结构。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">据 java 集合框架的创始人Josh Bloch描述，这样的写法是一个失误。在java集合框架中，类似这样的写法很多，最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改，所以就这样存在下来了。</span><br></pre></td></tr></table></figure><h2 id="4-HashMap集合类的成员"><a href="#4-HashMap集合类的成员" class="headerlink" title="4.HashMap集合类的成员"></a>4.HashMap集合类的成员</h2><h3 id="4-1成员变量"><a href="#4-1成员变量" class="headerlink" title="4.1成员变量"></a>4.1成员变量</h3><p>1.序列化版本号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure><p>2.集合的初始化容量( <strong>必须是二的n次幂</strong> )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>问题： <strong>为什么必须是2的n次幂？如果输入值不是2的幂比如10会怎么样？</strong> </p><p>HashMap构造方法还可以指定集合的初始化容量大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap(<span class="keyword">int</span> initialCapacity) 构造一个带指定初始容量和默认加载因子 (<span class="number">0.75</span>) 的空 HashMap。</span><br></pre></td></tr></table></figure><p> 根据上述讲解我们已经知道，当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。 HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。</p><p>这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算(这点上述已经讲解)。所以源码中做了优化,使用 hash&amp;(length-1)，而实际上hash%length等于hash&amp;(length-1)的前提是length是2的n次幂。</p><p>为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；</p><p>举例：</p><p><strong>说明：按位与运算：相同的二进制数位上，都是1的时候，结果为1，否则为零。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例如长度为<span class="number">8</span>时候，<span class="number">3</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">3</span>  <span class="number">2</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">2</span> ，不同位置上，不碰撞；</span><br><span class="line">例如长度length为<span class="number">8</span>时候，<span class="number">8</span>是<span class="number">2</span>的<span class="number">3</span>次幂。二进制是：<span class="number">1000</span></span><br><span class="line">length-<span class="number">1</span> 二进制运算：</span><br><span class="line"><span class="number">1000</span></span><br><span class="line">-   <span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line">     <span class="number">111</span></span><br><span class="line">如下所示：</span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>   &amp;(<span class="number">8</span>    - <span class="number">1</span>)=<span class="number">3</span>  </span><br><span class="line"><span class="number">00000011</span>  <span class="number">3</span> hash</span><br><span class="line">&amp;   <span class="number">00000111</span>  <span class="number">7</span> length-<span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000011</span>-----》<span class="number">3</span> 数组下标</span><br><span class="line"></span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> &amp;  (<span class="number">8</span> -    <span class="number">1</span>) = <span class="number">2</span>  </span><br><span class="line"><span class="number">00000010</span>  <span class="number">2</span> hash</span><br><span class="line">&amp;   <span class="number">00000111</span>  <span class="number">7</span> length-<span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000010</span>-----》<span class="number">2</span>  数组下标</span><br><span class="line">说明：上述计算结果是不同位置上，不碰撞；</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例如长度为<span class="number">9</span>时候，<span class="number">3</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span>  <span class="number">2</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span> ，都在<span class="number">0</span>上，碰撞了；</span><br><span class="line">例如长度length为<span class="number">9</span>时候，<span class="number">9</span>不是<span class="number">2</span>的n次幂。二进制是：<span class="number">00001001</span></span><br><span class="line">length-<span class="number">1</span> 二进制运算：</span><br><span class="line"><span class="number">1001</span></span><br><span class="line">-   <span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">如下所示：</span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>   &amp;(<span class="number">9</span>    - <span class="number">1</span>)=<span class="number">0</span>  </span><br><span class="line"><span class="number">00000011</span>  <span class="number">3</span> hash</span><br><span class="line">&amp;   <span class="number">00001000</span>  <span class="number">8</span> length-<span class="number">1</span> </span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000000</span>-----》<span class="number">0</span>  数组下标</span><br><span class="line"></span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> &amp;  (<span class="number">9</span> -    <span class="number">1</span>) = <span class="number">2</span>  </span><br><span class="line"><span class="number">00000010</span> <span class="number">2</span> hash</span><br><span class="line">&amp;   <span class="number">00001000</span> <span class="number">8</span> length-<span class="number">1</span> </span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000000</span>-----》<span class="number">0</span>  数组下标</span><br><span class="line">说明：上述计算结果都在<span class="number">0</span>上，碰撞了；</span><br></pre></td></tr></table></figure><p><strong>注意： 当然如果不考虑效率直接求余即可（就不需要要求长度必须是2的n次方了）</strong> </p><p>小结：</p><p>​    1.由上面可以看出，当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，可以保证数据的均匀插入，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突。</p><p>​    2.另一方面，一般我们可能会想通过 % 求余来确定位置，这样也可以，只不过性能不如 &amp; 运算。而且当n是2的幂次方时：hash &amp; (length - 1) == hash % length</p><p>​    3.因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突，毕竟hash冲突越大，代表数组中一个链的长度越大，这样的话会降低hashmap的性能</p><p>​    <strong>4.如果创建HashMap对象时，输入的数组长度是10，不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字。</strong></p><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建HashMap集合的对象，指定数组长度是10，不是2的幂</span></span><br><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//initialCapacity=10</span></span><br><span class="line">   <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;<span class="comment">//initialCapacity=10</span></span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//initialCapacity=10</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;<span class="comment">//int cap = 10</span></span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>由此可以看到，当在实例化HashMap实例时，如果给定了initialCapacity(假设是10)，由于HashMap的capacity必须都是2的幂，因此这个方法用于找到大于等于initialCapacity(假设是10)的最小的2的幂（initialCapacity如果就是2的幂，则返回的还是这个数）。 下面分析这个算法： 1)、首先，为什么要对cap做减1操作。int n = cap - 1; 这是为了防止，cap已经是2的幂。如果cap已经是2的幂， 又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。如果不懂，要看完后面的几个无符号右移之后再回来看看。 下面看看这几个无符号右移操作： 2）、如果n这时为0了（经过了cap-1之后），则经过后面的几次无符号右移依然是0，最后返回的capacity是        1（最后有个n+1的操作）。 这里只讨论n不等于0的情况。</p><p>3）、注意：<strong>|（按位或运算）：运算规则：相同的二进制数位上，都是0的时候，结果为0，否则为1。</strong></p><p>​     <strong>第一次右移</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = cap - <span class="number">1</span>;<span class="comment">//cap=10  n=9</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001001</span> <span class="comment">//9</span></span><br><span class="line">|</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span> <span class="comment">//9右移之后变为4</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span> <span class="comment">//按位异或之后是13</span></span><br></pre></td></tr></table></figure><p> 由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span></span><br></pre></td></tr></table></figure><p> <strong>第二次右移</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> n |= n &gt;&gt;&gt; <span class="number">2</span>;<span class="comment">//n通过第一次右移变为了：n=13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span>  <span class="comment">// 13</span></span><br><span class="line">|</span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>  <span class="comment">//13右移之后变为3</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span> <span class="comment">//按位异或之后是15</span></span><br></pre></td></tr></table></figure><p> 注意，这个n已经经过了<code>n |= n &gt;&gt;&gt; 1;</code> 操作。假设此时n为00000000 00000000 00000000 00001101 ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 00001111 &#x2F;&#x2F;按位异或之后是15</span><br></pre></td></tr></table></figure><p> <strong>第三次右移</strong> :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n |&#x3D; n &gt;&gt;&gt; 4;&#x2F;&#x2F;n通过第一、二次右移变为了：n&#x3D;15</span><br><span class="line">00000000 00000000 00000000 00001111  &#x2F;&#x2F; 15</span><br><span class="line">|</span><br><span class="line">    00000000 00000000 00000000 00000000  &#x2F;&#x2F;15右移之后变为0</span><br><span class="line">-------------------------------------------------</span><br><span class="line">00000000 00000000 00000000 00001111 &#x2F;&#x2F;按位异或之后是15</span><br></pre></td></tr></table></figure><p>这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中正常会有8个连续的1。如00001111 1111xxxxxx 。 以此类推 注意，容量最大也就是32bit的正数，因此最后n |= n &gt;&gt;&gt; 16; ，最多也就32个1（但是这已经是负数了。在执行tableSizeFor之前，对initialCapacity做了判断，如果大于MAXIMUM_CAPACITY(2 ^ 30)，则取MAXIMUM_CAPACITY。如果等于MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作。所以这里面的移位操作之后，最大30个1，不会大于等于MAXIMUM_CAPACITY。30个1，加1之后得2 ^ 30） 。 请看下面的一个完整例子：</p><p><img data-src="image-20191115151657917.png" alt="image-20191115151657917.png"></p><p>  注意，得到的这个capacity却被赋值给了threshold。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.threshold &#x3D; tableSizeFor(initialCapacity);&#x2F;&#x2F;initialCapacity&#x3D;10</span><br></pre></td></tr></table></figure><p>3.默认的负载因子，默认值是0.75 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br></pre></td></tr></table></figure><p>4.集合最大容量 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;集合最大容量的上限是：2的30次幂</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br></pre></td></tr></table></figure><p>5.当链表的值超过8则会转红黑树(<strong>1.8新增</strong>) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当桶(bucket)上的结点数大于这个值时会转成红黑树</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br></pre></td></tr></table></figure><p><strong>问题：为什么Map桶中节点个数超过8才转为红黑树？</strong></p><p>8这个阈值定义在HashMap中，针对这个成员变量，在源码的注释中只说明了8是bin（bin就是bucket(桶)）从链表转成树的阈值，但是并没有说明为什么是8： </p><p> 在HashMap中有一段注释说明： 我们继续往下看 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Because TreeNodes are about twice the size of regular nodes, <span class="function">we use them only when bins contain enough nodes to warrant <span class="title">use</span> <span class="params">(see TREEIFY_THRESHOLD)</span>. And when they become too <span class="title">small</span> <span class="params">(due to removal or resizing)</span> they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="function"><span class="params">(http://en.wikipedia.org/wiki/Poisson_distribution)</span> with a parameter of about 0.5 on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k <span class="title">are</span> <span class="params">(exp(<span class="number">-0.5</span>)</span>*<span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span>/<span class="title">factorial</span><span class="params">(k)</span>).</span></span><br><span class="line"><span class="function">The first values are:</span></span><br><span class="line"><span class="function">因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点<span class="params">(参见TREEIFY_THRESHOLD)</span>。当它们变得太小<span class="params">(由于删除或调整大小)</span>时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从泊松分布</span></span><br><span class="line"><span class="function"><span class="params">(http://en.wikipedia.org/wiki/Poisson_distribution)</span>，默认调整阈值为0.75，平均参数约为0.5，尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是<span class="params">(exp(<span class="number">-0.5</span>)</span>*<span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span>/<span class="title">factorial</span><span class="params">(k)</span>)。</span></span><br><span class="line"><span class="function">第一个值是:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">0:    0.60653066</span></span><br><span class="line"><span class="function">1:    0.30326533</span></span><br><span class="line"><span class="function">2:    0.07581633</span></span><br><span class="line"><span class="function">3:    0.01263606</span></span><br><span class="line"><span class="function">4:    0.00157952</span></span><br><span class="line"><span class="function">5:    0.00015795</span></span><br><span class="line"><span class="function">6:    0.00001316</span></span><br><span class="line"><span class="function">7:    0.00000094</span></span><br><span class="line"><span class="function">8:    0.00000006</span></span><br><span class="line"><span class="function">more: less than 1 in ten million</span></span><br></pre></td></tr></table></figure><p>TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点时才会转成TreeNodes，而是否足够多就是由TREEIFY_THRESHOLD的值决定的。当bin中节点数变少时，又会转成普通的bin。并且我们查看源码的时候发现，链表长度达到8就转成红黑树，当长度降到6就转成普通bin。</p><p>这样就解释了为什么不是一开始就将其转换为TreeNodes，而是需要一定节点数才转为TreeNodes，说白了就是权衡，空间和时间的权衡。</p><p> 这段内容还说到：当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是随便决定的，而是根据概率统计决定的。由此可见，发展将近30年的Java每一项改动和优化都是非常严谨和科学的。 </p><p>也就是说：选择8因为符合泊松分布，超过8的时候，概率已经非常小了，所以我们选择8这个数字。</p><p>补充：</p><p>1）.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Poisson分布(泊松分布)，是一种统计与概率学里常见到的离散[概率分布]。</span><br><span class="line">泊松分布的概率函数为：</span><br></pre></td></tr></table></figure><p><img data-src="image-20191115161055901.png" alt="image-20191115161055901.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泊松分布的参数λ是单位时间(或单位面积)内随机事件的平均发生次数。 泊松分布适合于描述单位时间内随机事件发生的次数。</span><br></pre></td></tr></table></figure><p>2）.以下是我在研究这个问题时，在一些资料上面翻看的解释：供大家参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">红黑树的平均查找长度是log(n)，如果长度为8，平均查找长度为log(8)&#x3D;3，链表的平均查找长度为n&#x2F;2，当长度为8时，平均查找长度为8&#x2F;2&#x3D;4，这才有转换成树的必要；链表长度如果是小于等于6，6&#x2F;2&#x3D;3，而log(6)&#x3D;2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</span><br></pre></td></tr></table></figure><p><strong>6.当链表的值小于6则会从红黑树转回链表</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>7.当Map里面的数量超过这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶中结构转化为红黑树对应的数组长度最小的值 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p><strong>8、table用来初始化(必须是二的n次幂)(重点)</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储元素的数组 </span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p><strong>table</strong>在JDK1.8中我们了解到HashMap是由数组加链表加红黑树来组成的结构其中table就是HashMap中的数组，jdk8之前数组类型是Entry&lt;K,V&gt;类型。从jdk1.8之后是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V&gt;。负责存储键值对数据的。</p><p>9、用来存放缓存 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;存放具体元素的集合</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p><strong>10、 HashMap中存放元素的个数(重点)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p><strong>size</strong>为HashMap中K-V的实时数量，不是数组table的长度。</p><p>11、 用来记录HashMap的修改次数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>12、 用来调整大小下一个容量的值计算方式为(容量*负载因子) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 临界值 当实际大小(容量*负载因子)超过临界值时，会进行扩容</span><br><span class="line">int threshold;</span><br></pre></td></tr></table></figure><p><strong>13、 哈希表的加载因子(重点)</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>1.<strong>loadFactor</strong>加载因子，是用来衡量 HashMap 满的程度，<strong>表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率</strong>，计算HashMap的实时加载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。capacity 是桶的数量，也就是 table 的长度length。</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p><p><strong>当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。，所以开发中尽量减少扩容的次数，可以通过创建HashMap集合对象时指定初始容量来尽量避免。</strong></p><p><strong>同时在HashMap的构造器中可以定制loadFactor。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造方法：</span><br><span class="line">HashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor) 构造一个带指定初始容量和加载因子的空 HashMap。</span><br></pre></td></tr></table></figure><p>2.为什么加载因子设置为0.75,初始化临界值是12？</p><p>loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><img data-src="image-20191115173553375.png" alt="image-20191115173553375.png"></p><p>如果希望链表尽可能少些。要提前扩容，有的数组空间有可能一直没有存储数据。加载因子尽可能小一些。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：加载因子是0.4。 那么16*0.4---&gt;6 如果数组中满6个空间就扩容会造成数组利用率太低了。</span><br><span class="line"> 加载因子是0.9。 那么16*0.9----&gt;14 那么这样就会导致链表有点多了。导致查找元素效率低。</span><br></pre></td></tr></table></figure><p>所以既兼顾数组利用率又考虑链表不要太多，经过大量测试0.75是最佳方案。</p><ul><li><strong>threshold</strong>计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。这个值是当前已占用数组长度的最大值。<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的resize(扩容)，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。 扩容后的 HashMap 容量是之前容量的两倍.</li></ul><h3 id="4-2构造方法"><a href="#4-2构造方法" class="headerlink" title="4.2构造方法"></a>4.2构造方法</h3><p> HashMap 中重要的构造方法，它们分别如下： </p><p>1、构造一个空的 <code>HashMap</code> ，默认初始容量（16）和默认负载因子（0.75）。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// 将默认的加载因子0.75赋值给loadFactor，并没有创建数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 构造一个具有指定的初始容量和默认负载因子（0.75） <code>HashMap</code>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>3、 构造一个具有指定的初始容量和负载因子的 <code>HashMap</code>。我们来分析一下。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"><span class="comment"> initialCapacity: 指定的容量</span></span><br><span class="line"><span class="comment"> loadFactor:指定的加载因子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断初始化容量initialCapacity是否小于0</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果小于0，则抛出非法的参数异常IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    <span class="comment">//判断初始化容量initialCapacity是否大于集合的最大容量MAXIMUM_CAPACITY-》2的30次幂</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="comment">//如果超过MAXIMUM_CAPACITY，会将MAXIMUM_CAPACITY赋值给initialCapacity</span></span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//判断负载因子loadFactor是否小于等于0或者是否是一个非数值</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="comment">//如果满足上述其中之一，则抛出非法的参数异常IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">     <span class="comment">//将指定的加载因子赋值给HashMap成员变量的负载因子loadFactor</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    tableSizeFor(initialCapacity) 判断指定的初始化容量是否是2的n次幂，如果不是那么会变为比指定初始化容量大的最小的2的n次幂。这点上述已经讲解过。</span></span><br><span class="line"><span class="comment">    但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边界值了。有些人会觉得这里是一个bug,应该这样书写：</span></span><br><span class="line"><span class="comment">    this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;</span></span><br><span class="line"><span class="comment">    这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。</span></span><br><span class="line"><span class="comment">但是，请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推 迟到了put方法中，在put方法中会对threshold重新计算，put方法的具体实现我们下面会进行讲解</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">最后调用了tableSizeFor，来看一下方法实现：</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">       返回比指定初始化容量大的最小的2的n次幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>对于 this.threshold = tableSizeFor(initialCapacity); 疑问解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tableSizeFor(initialCapacity) 判断指定的初始化容量是否是<span class="number">2</span>的n次幂，如果不是那么会变为比指定初始化容量大的最小的<span class="number">2</span>的n次幂。这点上述已经讲解过。</span><br><span class="line">但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边界值了。有些人会觉得这里是一个bug,应该这样书写：</span><br><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity) * <span class="keyword">this</span>.loadFactor;</span><br><span class="line">这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。</span><br><span class="line">但是，请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推 迟到了put方法中，在put方法中会对threshold重新计算，put方法的具体实现我们下面会进行讲解</span><br></pre></td></tr></table></figure><p>4、包含另一个“Map”的构造函数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个映射关系与指定 Map 相同的新 HashMap。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//负载因子loadFactor变为默认的负载因子0.75</span></span><br><span class="line">         <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">         putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后调用了putMapEntries，来看一下方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取参数集合的长度</span></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断参数集合的长度是否大于0，说明大于0</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>)  <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p> float ft = ((float)s / loadFactor) + 1.0F;这一行代码中为什么要加1.0F ？</p><p> s/loadFactor的结果是小数，加1.0F与(int)ft相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少resize的调用次数。所以 + 1.0F是为了获取更大的容量。 </p><p>例如：原来集合的元素个数是6个，那么6/0.75是8，是2的n次幂，那么新的数组大小就是8了。然后原来数组的数据就会存储到长度是8的新的数组中了，这样会导致在存储元素的时候，容量不够，还得继续扩容，那么性能降低了，而如果+1呢，数组长度直接变为16了，这样可以减少数组的扩容。</p><h3 id="4-3成员方法"><a href="#4-3成员方法" class="headerlink" title="4.3成员方法"></a>4.3成员方法</h3><h4 id="4-3-1增加方法"><a href="#4-3-1增加方法" class="headerlink" title="4.3.1增加方法"></a>4.3.1增加方法</h4><p>put方法是比较复杂的，实现步骤大致如下：</p><p>1）先通过hash值计算出key映射到哪个桶；</p><p>2）如果桶上没有碰撞冲突，则直接插入；</p><p>3）如果出现碰撞冲突了，则需要处理冲突：</p><p>​    a:如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；</p><p>​    b:否则采用传统的链式方法插入。如果链的长度达到临界值，则把链转变为红黑树；</p><p>4）如果桶中存在重复的键，则为该键替换新值value；</p><p>5）如果size大于阈值threshold，则进行扩容；</p><p>具体的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明： </p><p>​    1）HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。 所以我们重点看putVal方法。</p><pre><code>2）我们可以看到在putVal()方法中key在这里执行了一下hash()方法,来看一下Hash方法是如何实现的。 </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）如果key等于null：</span></span><br><span class="line"><span class="comment">    可以看到当key等于null的时候也是有哈希值的，返回的是0.</span></span><br><span class="line"><span class="comment">    2）如果key不等于null：</span></span><br><span class="line"><span class="comment">    首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的hash值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以得知HashMap是支持Key为空的，而HashTable是直接用Key来获取HashCode所以key为空会抛异常。</p><p>{其实上面就已经解释了为什么HashMap的长度<strong>为什么要是2的幂</strong>因为HashMap 使用的方法很巧妙，它通过 hash &amp; (table.length -1)来得到该对象的保存位，前面说过 HashMap 底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当 length 总是2的n次方时，hash &amp; (length-1)运算等价于对 length 取模，也就是hash%length，但是&amp;比%具有更高的效率。比如 n % 32 = n &amp; (32 -1)。}</p><p><strong>解读上述hash方法：</strong></p><p>我们先研究下key的哈希值是如何计算出来的。key的哈希值是通过上述方法计算出来的。</p><p>这个哈希方法首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的    hash值。计算过程如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）如果key等于null：</span></span><br><span class="line"><span class="comment">    可以看到当key等于null的时候也是有哈希值的，返回的是0.</span></span><br><span class="line"><span class="comment">    2）如果key不等于null：</span></span><br><span class="line"><span class="comment">    首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的hash值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在putVal函数中使用到了上述hash函数计算的哈希值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        。。。。。。。。。。。。。。</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//这里的n表示数组长度16</span></span><br><span class="line">       。。。。。。。。。。。。。。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>计算过程如下所示：</p><p>​    说明：</p><p>​        1）key.hashCode()；返回散列值也就是hashcode。假设随便生成的一个值。</p><p>​        2）n表示数组初始化的长度是16</p><p>​        3）&amp;（按位与运算）：运算规则：相同的二进制数位上，都是1的时候，结果为1，否则为零。</p><p>​        4）^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为0，不同为1。</p><p><img data-src="image-20191114193730911.png" alt="image-2019111419370911.png"></p><p>简单来说就是：</p><ul><li><p>高16 bit 不变，低16 bit 和高16 bit 做了一个异或（得到的 hashcode 转化为32位二进制，前16位和后16位低16 bit和高16 bit做了一个异或）</p><p><strong>问题：为什么要这样操作呢？</strong></p><p>如果当n即数组长度很小，假设是16的话，那么n-1即为  —》1111 ，这样的值和hashCode()直接做按位与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如上述：</span><br><span class="line">hashCode()值：     <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1110</span> <span class="number">1010</span></span><br><span class="line">&amp;</span><br><span class="line">n-<span class="number">1</span>即<span class="number">16</span>-<span class="number">1</span>--》<span class="number">15</span>：  。。。。。。。。。。。。。。。。。。。。。。<span class="number">1111</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">  <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span> ----》<span class="number">10</span>作为索引</span><br><span class="line">其实就是将hashCode值作为数组索引，那么如果下个高位hashCode不一致，低位一致的话，就会造成计算的索引还是<span class="number">10</span>,从而造成了哈希冲突了。降低性能。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>(n-1) &amp; hash = -&gt; 得到下标   (n-1)   n表示数组长度16，n-1就是15</p></li><li><p>取余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低。</p></li></ul><p>现在看putVal()方法，看看它到底做了什么。</p><p>主要参数：</p><ul><li>hash key的hash值</li><li>key 原始Key</li><li>value 要存放的值</li><li>onlyIfAbsent 如果true代表不更改现有的值</li><li>evict 如果为false表示table为创建状态</li></ul><p>putVal()方法源代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）transient Node&lt;K,V&gt;[] table; 表示存储Map集合中元素的数组。</span></span><br><span class="line"><span class="comment">    2）(tab = table) == null 表示将空的table赋值给tab,然后判断tab是否等于null，第一次肯定是null</span></span><br><span class="line"><span class="comment">    3）(n = tab.length) == 0 表示将数组的长度0赋值给n,然后判断n是否等于0，n等于0</span></span><br><span class="line"><span class="comment">    由于if判断使用双或，满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化。</span></span><br><span class="line"><span class="comment">    并将初始化好的数组长度赋值给n.</span></span><br><span class="line"><span class="comment">    4）执行完n = (tab = resize()).length，数组tab每个空间都是null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）i = (n - 1) &amp; hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中</span></span><br><span class="line"><span class="comment">    2）p = tab[i = (n - 1) &amp; hash]表示获取计算出的位置的数据赋值给节点p</span></span><br><span class="line"><span class="comment">    3) (p = tab[i = (n - 1) &amp; hash]) == null 判断节点位置是否等于null，如果为null，则执行代码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的节点放入该位置的桶中</span></span><br><span class="line"><span class="comment">        小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//创建一个新的节点存入到桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 执行else说明tab[i]不等于null，表示这个位置已经有值了。</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较桶中第一个元素(数组中的结点)的hash值和key是否相等</span></span><br><span class="line"><span class="comment">        1）p.hash == hash ：p.hash表示原来存在数据的hash值  hash表示后添加数据的hash值 比较两个 hash值是否相等</span></span><br><span class="line"><span class="comment">                 说明：p表示tab[i]，即 newNode(hash, key, value, null)方法返回的Node对象。</span></span><br><span class="line"><span class="comment">                    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) </span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    而在Node类中具有成员变量hash用来记录着之前数据的hash值的</span></span><br><span class="line"><span class="comment">             2）(k = p.key) == key ：p.key获取原来数据的key赋值给k  key 表示后添加数据的key 比较两个key的地址值是否相等</span></span><br><span class="line"><span class="comment">             3）key != null &amp;&amp; key.equals(k)：能够执行到这里说明两个key的地址值不相等，那么先判断后添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                说明：两个元素哈希值相等，并且key的值也相等</span></span><br><span class="line"><span class="comment">                将旧的元素整体对象赋值给e，用e来记录</span></span><br><span class="line"><span class="comment">                */</span> </span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等或者key不相等；判断p是否为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 说明是链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1)如果是链表的话需要遍历到最后节点然后插入</span></span><br><span class="line"><span class="comment">            2)采用循环遍历的方式，判断链表中是否有重复的key</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                1)e = p.next 获取p的下一个元素赋值给e</span></span><br><span class="line"><span class="comment">                2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键</span></span><br><span class="line"><span class="comment">                将该键值对插入链表中</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    1）创建一个新的节点插入到尾部</span></span><br><span class="line"><span class="comment">                     p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                     Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) </span></span><br><span class="line"><span class="comment">                     &#123;</span></span><br><span class="line"><span class="comment">                                return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                         &#125;</span></span><br><span class="line"><span class="comment">                         注意第四个参数next是null，因为当前元素插入到链表末尾了，那么下一个节点肯定是null</span></span><br><span class="line"><span class="comment">                         2）这种添加方式也满足链表数据结构的特点，每次向后添加新的元素</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    1)节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于</span></span><br><span class="line"><span class="comment">                    则将链表转换为红黑树</span></span><br><span class="line"><span class="comment">                    2）int binCount = 0 ：表示for循环的初始化值。从0开始计数。记录着遍历节点的个数。值是0表示第一个节点，1表示第二个节点。。。。7表示第八个节点，加上数组中的的一个元素，元素个数是9</span></span><br><span class="line"><span class="comment">                    TREEIFY_THRESHOLD - 1 --》8 - 1 ---》7</span></span><br><span class="line"><span class="comment">                    如果binCount的值是7(加上数组中的的一个元素，元素个数是9)</span></span><br><span class="line"><span class="comment">                    TREEIFY_THRESHOLD - 1也是7，此时转换红黑树</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//转换为红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                执行到这里说明e = p.next 不是null，不是最后一个元素。继续判断链表中结点的key值与插  入的元素的key值是否相等</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                要添加的元素和链表中的存在的元素的key相等了，则跳出for循环。不用再继续比较了</span></span><br><span class="line"><span class="comment">                直接执行下面的if语句去替换去 if (e != null) </span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                说明新添加的元素和当前节点不相等，继续查找下一个节点。</span></span><br><span class="line"><span class="comment">                用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line"><span class="comment">        也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，并返回旧值</span></span><br><span class="line"><span class="comment">        这里完成了put方法的修改功能</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                <span class="comment">//e.value 表示旧值  value表示新值 </span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改记录次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 判断实际大小是否大于threshold阈值，如果超过则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2将链表转换为红黑树的treeifyBin方法"><a href="#4-3-2将链表转换为红黑树的treeifyBin方法" class="headerlink" title="4.3.2将链表转换为红黑树的treeifyBin方法"></a>4.3.2将链表转换为红黑树的treeifyBin方法</h4><p>节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树，转换红黑树的方法  treeifyBin，整体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">   &#x2F;&#x2F;转换为红黑树 tab表示数组名  hash表示哈希值</span><br><span class="line">   treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure><p>treeifyBin方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">   替换指定哈希表的索引处桶中的所有链接节点，除非表太小，否则将修改大小。</span></span><br><span class="line"><span class="comment">   Node&lt;K,V&gt;[] tab = tab 数组名</span></span><br><span class="line"><span class="comment">   int hash = hash表示哈希值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64),</span></span><br><span class="line"><span class="comment">      就去扩容。而不是将节点变为红黑树。</span></span><br><span class="line"><span class="comment">      目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，那么重新计算哈希值</span></span><br><span class="line"><span class="comment">      ，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          <span class="comment">//扩容方法</span></span><br><span class="line">          resize();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化</span></span><br><span class="line"><span class="comment">          2）e = tab[index = (n - 1) &amp; hash]表示将数组中的元素取出赋值给e,e是哈希表中指定位置桶里的链表节点，从第一个开始</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="comment">//hd：红黑树的头结点   tl :红黑树的尾结点</span></span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="comment">//新创建一个树的节点，内容和当前链表节点e一致</span></span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                  <span class="comment">//将新创键的p节点赋值给红黑树的头结点</span></span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   p.prev = tl：将上一个节点p赋值给现在的p的前一个节点</span></span><br><span class="line"><span class="comment">                   tl.next = p;将现在节点p作为树的尾结点的下一个节点</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              e = e.next 将当前节点的下一个节点赋值给e,如果下一个节点不等于null</span></span><br><span class="line"><span class="comment">              则回到上面继续取出链表中节点转换为红黑树</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树</span></span><br><span class="line"><span class="comment">          而不是链表数据结构了</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>小结：上述操作一共做了如下几件事：</p><p>1.根据哈希表中元素个数确定是扩容还是树形化</p><p>2.如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</p><p>3.然后让桶中的第一个元素指向新创建的树根节点，替换桶的链表内容为树形化内容</p><h4 id="4-3-3扩容方法-resize"><a href="#4-3-3扩容方法-resize" class="headerlink" title="4.3.3扩容方法_resize"></a>4.3.3扩容方法_resize</h4><h5 id="4-3-3-1扩容机制"><a href="#4-3-3-1扩容机制" class="headerlink" title="4.3.3.1扩容机制"></a>4.3.3.1扩容机制</h5><p>想要了解HashMap的扩容机制你要有这两个问题</p><ul><li>1.什么时候才需要扩容</li><li>2.HashMap的扩容是什么</li></ul><p><strong>1.什么时候才需要扩容</strong></p><p>当HashMap中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75=12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。</p><p><strong>补充：</strong></p><p><strong>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。</strong></p><p><strong>2.HashMap的扩容是什么</strong></p><p> 进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 </p><p>HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n-1)&amp;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到”<strong>原位置+旧容量</strong>“这个位置。</p><p> 怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示： </p><p><img data-src="image-20191117110812839.png" alt="image-20191117110812839.png"></p><p> 因此元素在重新计算hash之后，因为n变为2倍，那么n-1的标记范围在高位多1bit(红色)，因此新的index就会发生这样的变化： </p><p><img data-src="image-20191117110934974.png" alt="image-20191117110934974.png"></p><p>说明：5是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以节点要么就在原来的位置，要么就被分配到”<strong>原位置+旧容量</strong>“这个位置。</p><p> 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就可以了，是0的话索引没变，是1的话索引变成“原索引+oldCap(<strong>原位置+旧容量</strong>)”。可以看看下图为16扩充为32的resize示意图： </p><p><img data-src="image-20191117111211630.png" alt="image-20191117111211630.png"></p><p>正是因为这样巧妙的rehash方式，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，在resize的过程中保证了rehash之后每个桶上的节点数一定小于等于原来桶上的节点数，保证了rehash之后不会出现更严重的hash冲突，均匀的把之前的冲突的节点分散到新的桶中了。</p><h5 id="4-3-3-2源码resize方法的解读"><a href="#4-3-3-2源码resize方法的解读" class="headerlink" title="4.3.3.2源码resize方法的解读"></a>4.3.3.2源码resize方法的解读</h5><p>下面是代码的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//得到当前数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//如果当前数组等于null长度返回0，否则返回当前数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//当前阀值点 默认是12(16*0.75)</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果老的数组长度大于0</span></span><br><span class="line">    <span class="comment">//开始计算扩容后的大小</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//修改阈值为int的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        没超过最大值，就扩充为原来的2倍</span></span><br><span class="line"><span class="comment">        1)(newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量</span></span><br><span class="line"><span class="comment">        2）oldCap &gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//老阈值点大于0 直接赋值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 老阈值赋值给新的数组长度</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 直接使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize最大上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的阀值 默认原来是12 乘以2之后变为24</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//newCap是新的数组长度--》32</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//判断旧数组是否等于空</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="comment">//遍历旧的哈希表的每个桶，重新计算桶里元素的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//原来的数据赋值为null 便于GC回收</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//判断数组是否有下一个引用</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//判断是否是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//说明是红黑树来处理冲突的，则调用相关方法把树分开</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 采用链表处理冲突</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//通过上述讲解的原理来计算节点的新位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                     <span class="comment">//这里来判断如果等于true e这个节点在resize之后不需要移动位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-删除方法-remove"><a href="#4-3-4-删除方法-remove" class="headerlink" title="4.3.4 删除方法(remove)"></a>4.3.4 删除方法(remove)</h4><p> 理解了put方法之后，remove方法已经没什么难度了，所以重复的内容就不再做详细介绍了。</p><p> 删除的话就是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于6的时候要转链表。 </p><p> 删除remove方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove方法的具体实现在removeNode方法中，所以我们重点看下removeNode方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> removeNode方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//根据hash找到位置 </span></span><br><span class="line">    <span class="comment">//如果当前key映射到的桶不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">//如果桶上的节点就是要找的key，则将node指向该节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明节点存在下一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//说明是以红黑树来处理的冲突，则获取红黑树要删除的节点</span></span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//判断是否以链表方式处理hash冲突，是的话则通过遍历链表来寻找要删除的节点</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较找到的key的value和要删除的是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="comment">//通过调用红黑树的方法来删除节点</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    <span class="comment">//链表删除</span></span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                <span class="comment">//记录修改次数</span></span><br><span class="line">                ++modCount;</span><br><span class="line">                <span class="comment">//变动的数量</span></span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-5查找元素方法-get"><a href="#4-3-5查找元素方法-get" class="headerlink" title="4.3.5查找元素方法(get)"></a>4.3.5查找元素方法(get)</h4><p> 查找方法，通过元素的Key找到Value。 </p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法主要调用的是getNode方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果哈希表不为空并且key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        判断数组元素是否相等</span></span><br><span class="line"><span class="comment">        根据索引的位置检查第一个元素</span></span><br><span class="line"><span class="comment">        注意：总是检查第一个元素</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果不是第一个元素，判断是否有后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树，是的话调用红黑树中的getTreeNode方法获取节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 不是红黑树的话，那就是链表结构了，通过循环的方法判断链表中是否存在该key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>1.get方法实现的步骤：</p><p>​    1）通过hash值获取该key映射到的桶</p><p>​    2）桶上的key就是要查找的key,则直接找到并返回</p><p>​    3）桶上的key不是要找的key,则查看后续的节点：</p><p>​            a:如果后续节点是红黑树节点，通过调用红黑树的方法根据key获取value</p><p>​            b:如果后续节点是链表节点，则通过循环遍历链表根据key获取value</p><p>2.上述红黑树节点调用的是getTreeNode方法通过树形节点的find方法进行查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">               TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">               <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                   p = pl;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                   p = pr;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                   <span class="keyword">return</span> p;<span class="comment">//找到之后直接返回</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                   p = pr;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                   p = pl;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                         (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                   p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">               <span class="comment">//递归查找</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> q;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   p = pl;</span><br><span class="line">           &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>3.查找红黑树，由于之前添加时已经保证这个树是有序的了，因此查找时基本就是折半查找，效率更高。</p><p>4.这里和插入时一样，如果对比节点的哈希值和要查找的哈希值相等，就会判断key是否相等，相等就直接返回。不相等就从子树中递归查找。</p><p>5.</p><p>​    若为树，则在树中通过key.equals(k)查找，O(logn) </p><p>​    若为链表，则在链表中通过key.equals(k)查找，O(n)。</p><h4 id="4-3-6遍历HashMap集合几种方式"><a href="#4-3-6遍历HashMap集合几种方式" class="headerlink" title="4.3.6遍历HashMap集合几种方式"></a>4.3.6遍历HashMap集合几种方式</h4><p> 1、分别遍历Key和Values </p><p><img data-src="image-20191117160455507.png" alt="image-2019111760455507.png"></p><p>2.使用迭代器Iterator</p><p><img data-src="image-20191117160627369.png" alt="image-20191117160627369.png"></p><p>3、通过get方式（不建议使用）</p><p><img data-src="image-20191117160733756.png" alt="image-20191117160733756.png"></p><p>说明：根据阿里开发手册，不建议使用这种方式，因为迭代两次。keySet获取Iterator一次，还有通过get又迭代一次。降低性能。</p><p>4.jdk8以后使用Map接口中的默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K,? <span class="keyword">super</span> V&gt; action)</span> </span></span><br><span class="line"><span class="function">BiConsumer接口中的方法：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span> 对给定的参数执行此操作。  </span></span><br><span class="line"><span class="function">参数 </span></span><br><span class="line"><span class="function">            t - 第一个输入参数 </span></span><br><span class="line"><span class="function">            u - 第二个输入参数</span></span><br></pre></td></tr></table></figure><p>遍历代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,String&gt; m1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        m1.put(<span class="string">"001"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">        m1.put(<span class="string">"002"</span>, <span class="string">"lisi"</span>);</span><br><span class="line">        m1.forEach((key,value)-&gt;&#123;</span><br><span class="line">            System.out.println(key+<span class="string">"---"</span>+value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-如何设计多个非重复的键值对要存储HashMap的初始化？"><a href="#5-如何设计多个非重复的键值对要存储HashMap的初始化？" class="headerlink" title="5.如何设计多个非重复的键值对要存储HashMap的初始化？"></a>5.如何设计多个非重复的键值对要存储HashMap的初始化？</h2><h3 id="5-1HashMap的初始化问题描述"><a href="#5-1HashMap的初始化问题描述" class="headerlink" title="5.1HashMap的初始化问题描述"></a>5.1HashMap的初始化问题描述</h3><p>​    如果我们确切的知道我们有多少键值对需要存储，那么我们在初始化HashMap的时候就应该指定它的容量，以防止HashMap自动扩容，影响使用效率。</p><p>​    默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(3-&gt;4、7-&gt;8、9-&gt;16) .这点我们在上述已经进行过讲解。</p><p> 《阿里巴巴Java开发手册》中建议我们设置HashMap的初始化容量。 </p><p><img data-src="2.bmp" alt="2.bmp"></p><p> 那么，为什么要这么建议？你有想过没有。 </p><p>当然，以上建议也是有理论支撑的。我们上面介绍过，HashMap的扩容机制，就是当达到扩容条件时会进行扩容。HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。在HashMap中，threshold = loadFactor * capacity。</p><p>所以，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会有可能发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。</p><p>但是设置初始化容量，设置的数值不同也会影响性能，那么当我们已知HashMap中即将存放的KV个数的时候，容量设置成多少为好呢？</p><h3 id="5-2HashMap中容量的初始化"><a href="#5-2HashMap中容量的初始化" class="headerlink" title="5.2HashMap中容量的初始化"></a>5.2HashMap中容量的初始化</h3><p>当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。那么，是不是我们只需要把已知的HashMap中即将存放的元素个数直接传给initialCapacity就可以了呢？</p><p>关于这个值的设置，在《阿里巴巴Java开发手册》有以下建议：</p><p><img data-src="image-20191117165438726.png" alt="image-20191117165438726.png"></p><p>也就是说，如果我们设置的默认值是7，经过Jdk处理之后，会被设置成8，但是，这个HashMap在元素个数达到 8*0.75 = 6的时候就会进行一次扩容，这明显是我们不希望见到的。我们应该尽量减少扩容。原因也已经分析过。</p><p>如果我们通过<strong>initialCapacity/ 0.75F + 1.0F</strong>计算，7/0.75 + 1 = 10 ,10经过Jdk处理之后，会被设置成16，这就大大的减少了扩容的几率。</p><p>当HashMap内部维护的哈希表的容量达到75%时（默认情况下），会触发rehash，而rehash的过程是比较耗费时间的。所以初始化容量要设置成<strong>initialCapacity/0.75 + 1</strong>的话，可以有效的减少冲突也可以减小误差。</p><p>所以，我可以认为，当我们明确知道HashMap中元素的个数的时候，把默认容量设置成<strong>initialCapacity/ 0.75F + 1.0F</strong>是一个在性能上相对好的选择，但是，同时也会牺牲些内存。</p><p>我们想要在代码中创建一个HashMap的时候，如果我们已知这个Map中即将存放的元素个数，给HashMap设置初始容量可以在一定程度上提升效率。</p><p>但是，JDK并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个2的幂。原因也已经分析过。</p><p>但是，为了最大程度的避免扩容带来的性能消耗，我们建议可以把默认容量的数字设置成<strong>initialCapacity/ 0.75F + 1.0F</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算------按位与、按位或、按位异或、取反、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</title>
      <link href="/2020/03/15/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2020/03/15/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>程序中的所有数在计算机内存中都是以二进制的形式储存的，位运算就是直接对整数在内存中的二进制位进行操作。</p><p><strong>1、原码、反码、补码(以byte的1、-1举例)</strong></p><p>示例                    1                      -1                                   </p><p>原码        0000 0001          1000 0001     ——&gt;第一位是符号位，0是正数，1为负数  </p><p>反码        0000 0001          1111 1110       ——&gt;正数反码是其自身，负数则符号位不变，其他位置全部取反</p><p>补码        0000 0001          1111 1111       ——-&gt;正数补码是其自身，负数则为反码+1</p><p>当然也可以从1通过取反，然后+1的方式得到-1的补码</p><p><strong>2、补码：用于将十进制的负整数转换为二进制数。十进制的正整数可以除以2取余，负整数则需要补码。</strong></p><p>  补码的流程：例如-10</p><p>　　10：0000 0000 0000 1010</p><p>​    取反：1111 1111   1111  0101</p><p>​                          +1</p><p>​    -10：1111  1111  1111  0110</p><p><strong>3、整数在内存中以补码存在。</strong></p><h2 id="一、按位与-amp"><a href="#一、按位与-amp" class="headerlink" title="一、按位与(&amp;)"></a><strong>一、按位与(&amp;)</strong></h2><p><strong>定义：如果两个相应的二进制位都为1，则该位的结果值为1，否则为0.</strong></p><p>示例：</p><h3 id="1、10与-10-amp-运算"><a href="#1、10与-10-amp-运算" class="headerlink" title="1、10与-10 &amp;运算"></a>1、10与-10 &amp;运算</h3><p>10：0000 0000 0000 1010     —–&gt;   十进制转二进制</p><p>-10：1111  1111  1111  0110     —–&gt;   -10就是10取反，然后+1(补码)</p><p>结果: 0000 0000 0000 0010     —–&gt;   结果为2</p><h2 id="二、按位或"><a href="#二、按位或" class="headerlink" title="二、按位或(|)"></a><strong>二、按位或(|)</strong></h2><p><strong>定义：如果两个相应的二进制位有一个为1，则该结果为1，否则为0.</strong></p><p>示例：</p><h3 id="1、10与-10-运算"><a href="#1、10与-10-运算" class="headerlink" title="1、10与-10 |运算"></a>1、10与-10 |运算</h3><p> 10：0000 0000 0000 1010</p><p>-10：1111  1111  1111  0110</p><p>结果: 1111  1111 1111   1110  —–&gt;结果-2</p><p>第一位为符号位，1代表是负数，因此是补码形式存在，补码–&gt;十进制。先-1再取反(符号位不变)，。</p><p>1000 0000 0000 0001</p><p>+1</p><p>1000 0000 0000 0010 ——&gt; -2</p><h2 id="三、按位异或"><a href="#三、按位异或" class="headerlink" title="三、按位异或(^)"></a><strong>三、按位异或(^)</strong></h2><p><strong>定义：如果两个相应的二进制位值不同则为1，否则为0</strong></p><p>示例：</p><h3 id="1、10与-10-运算-1"><a href="#1、10与-10-运算-1" class="headerlink" title="1、10与-10 ^运算"></a>1、10与-10 ^运算</h3><p> 10：0000 0000 0000 1010</p><p>-10：1111  1111  1111  0110</p><p>结果: 1111  1111 1111   1100  ——&gt; 结果-4</p><h2 id="四、取反"><a href="#四、取反" class="headerlink" title="四、取反(~)"></a><strong>四、取反(~)</strong></h2><p><strong>定义：用来对一个二进制按位取反。</strong></p><p>示例：</p><h3 id="1、10取反"><a href="#1、10取反" class="headerlink" title="1、10取反"></a>1、10取反</h3><p>10：0000 0000 0000 1010</p><p>结果: 1111  1111 1111  0101 ——&gt; 结果-11</p><h2 id="五、左移-lt-lt"><a href="#五、左移-lt-lt" class="headerlink" title="五、左移(&lt;&lt;)"></a><strong>五、左移(&lt;&lt;)</strong></h2><p><strong>定义：将一个数的各二进制位全部左移N位，右补0</strong></p><p>示例：</p><h3 id="1、10左移-lt-lt-2"><a href="#1、10左移-lt-lt-2" class="headerlink" title="1、10左移&lt;&lt;2"></a>1、10左移&lt;&lt;2</h3><p>10：0000 0000 0000 1010</p><p>结果: 0000 0000 0010 1000——&gt; 结果40</p><h2 id="六、右移-gt-gt"><a href="#六、右移-gt-gt" class="headerlink" title="六、右移(&gt;&gt;)"></a><strong>六、右移(&gt;&gt;)</strong></h2><p><strong>定义：将一个数的各二进制位全部右移N位，移到右边的低位被舍弃，对于无符号数高位补0，负数高位补1.</strong></p><h3 id="1、10右移-gt-gt-2"><a href="#1、10右移-gt-gt-2" class="headerlink" title="1、10右移&gt;&gt;2"></a>1、10右移&gt;&gt;2</h3><p>10：0000 0000 0000 1010</p><p>结果: 0000 0000 0000 0010——&gt; 结果2</p><h3 id="2、-10右移-gt-gt-2"><a href="#2、-10右移-gt-gt-2" class="headerlink" title="2、-10右移&gt;&gt;2"></a>2、-10右移&gt;&gt;2</h3><p>-10：1111  1111  1111  0110</p><p>结果: 1111  1111 1111   1101</p><p>　　　　　 -1</p><p>​          1111  1111 1111   1100</p><p>​          取反，符号位不变</p><p>​           1000 0000 0000 0011</p><p>结果：-3</p><h2 id="七、-gt-gt-gt-无符号右移"><a href="#七、-gt-gt-gt-无符号右移" class="headerlink" title="七、&gt;&gt;&gt;(无符号右移)"></a><strong>七、&gt;&gt;&gt;(无符号右移)</strong></h2><p><strong>定义：将一个数的各二进制位全部右移N位，移到右边的低位被舍弃，对于无符号数高位补0，只是对32位和64位的值有意义。</strong></p><p>示例：</p><h3 id="1、-10-gt-gt-gt-2"><a href="#1、-10-gt-gt-gt-2" class="headerlink" title="1、-10&gt;&gt;&gt;2"></a>1、-10&gt;&gt;&gt;2</h3><p>-10：1111 1111 1111 1111 1111  1111  1111  0110  ——-&gt;由于&gt;&gt;&gt;只对32和64位有意义，所以把-10定义成32位的</p><p>结果: 0011  1111 1111 1111 1111 1111 1111 1101</p><p>　　　　　　-1</p><p>​          0011  1111 1111 1111 1111 1111 1111 1100</p><p>​             取反码(符号位不变，正数反码是其本身)</p><p>​         0011  1111 1111 1111 1111 1111 1111 1100</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap底层实现原理是什么?jdk8做了哪些优化?</title>
      <link href="/2020/03/13/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-jdk8%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/"/>
      <url>/2020/03/13/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-jdk8%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>HashMap 是使用频率最高的类型之一，同时也是面试经常被问到的问题之一，这是因为HashMap<br>的知识点有很多，同时它又属于Java基础知识的一部分，因此在面试中经常被问到。<br>本课时的面试题是，HashMap底层是如何实现的？在JDK1.8中它都做了哪些优化？<br><strong>典型回答</strong><br>在JDK1.7中HashMap是以数组加链表的形式组成的，JDK1.8之后新增了红黑树的组成结构，当链表大于8时，链表结构会转换成红黑树结构，它的组成结构如下图所示：</p><p><img data-src="1.png" alt="1"></p><p>数组中的元素我们称之为哈希桶，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line"> V value;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="keyword">this</span>.hash = hash;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">V oldValue = value;</span><br><span class="line">value = newValue;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"><span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">Objects.equals(value, e.getValue()))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出每个哈希桶中包含了四个字段：hash、key、value、next，其中next 表示链表的下一个节点。<br>JDK 1.8之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。</p><p><strong>考点分析</strong><br>上面大体介绍了HashMap的组成结构，但面试官想要知道的远远不止这些，和HashMap相关的面试题还有以下几个：</p><ul><li>JDK 1.8 HashMap 扩容时做了哪些优化？</li><li>加载因子为什么是0.75？</li><li>当有哈希冲突时，HashMap是如何查找并确认元素的？</li><li>HashMap 源码中有哪些重要的方法？</li><li>HashMap是如何导致死循环的？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-HashMap源码分析"><a href="#1-HashMap源码分析" class="headerlink" title="1.HashMap源码分析"></a>1.HashMap源码分析</h3><p>声明：本系列课程在未做特殊说明的情况下，都是以目前主流的JDK版本1.8为例来进行源码分析的。</p><p>HashMap源码中包含了以下几个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 初始化长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 最大长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的加载因子 (扩容因子)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换红黑树的临界值，当链表长度大于此值时，会把链表结构转换为红黑树结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换链表的临界值，当元素小于此值时，会将红黑树结构转换成链表结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小树容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY =</span><br></pre></td></tr></table></figure><p><strong>什么是加载因子？加载因子为什么是0.75？</strong><br>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是0.5，HashMap<br>的初始化容量是16，那么当HashMap中有16*0.5=8个元素时，HashMap就会进行扩容。</p><p><strong>那加载因子为什么是0.75而不是0.5或者1.0呢？</strong><br>这其实是出于容量和性能之间平衡的结果：</p><ul><li>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</li><li>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</li></ul><p>所以综合了以上情况就取了一个0.5到1.0的平均数0.75作为加载因子。</p><p>HashMap源码中三个重要方法：<strong>查询</strong>、<strong>新增</strong>和<strong>数据扩容</strong>。<br>先来看查询源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 对 key 进行哈希操作</span></span><br><span class="line"><span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"><span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个元素是否是要查询的元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 下一个节点非空判断</span></span><br><span class="line"><span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果第一节点是树结构，则使用 getTreeNode 直接获取相应的数据</span></span><br><span class="line"><span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// 非树结构，循环节点判断</span></span><br><span class="line">                <span class="comment">// hash 相等并且 key 相同，则返回此节点</span></span><br><span class="line"> <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，当哈希冲突时我们需要通过判断key值是否相等，才能确认此元素是不是我们想要的元素。<br>HashMap第二个重要方法：<strong>新增方法</strong>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对 key 进行哈希操作</span></span><br><span class="line"><span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 哈希表为空则创建表  </span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"> <span class="comment">// 根据 key 的哈希值计算出要插入的数组索引 i    </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line"> <span class="comment">// 如果 table[i] 等于 null，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">// 如果 key 已经存在了，直接覆盖 value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"> <span class="comment">// 如果 key 不存在，判断是否为红黑树     </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="comment">// 红黑树直接插入键值对</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 为链表结构，循环准备插入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 下一个元素为空时</span></span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度大于 8 转换为红黑树进行处理</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> <span class="comment">//  key 已经存在直接覆盖 value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过最大容量，扩容</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增方法的执行流程，如下图所示：</p><p><img data-src="2.png" alt="2"></p><p>HashMap 第三个重要的方法是扩容方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 扩容前的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 扩容前的数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 预定义新数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩大容量为当前容量的两倍，但不能超过 MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 当前数组没有数据，使用初始化的值</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 如果初始化的值为 0，则使用默认的初始化容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的容量等于 0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">     Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 开始扩容，将新的容量赋值给 table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 原数据不为空，将原数据复制到新 table 中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据容量循环数组，复制非空元素到新 table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果链表只有一个，则进行直接赋值</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 红黑树相关的操作</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表复制，JDK 1.8 扩容优化部分</span></span><br><span class="line">                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                         <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                             &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将原索引放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="comment">// 将原索引 + oldCap 放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，JDK1.8在扩容时并没有像JDK1.7那样，重新计算每个元素的哈希值，而是通过高位运算（e.hash&amp;oldCap）来确定元素是否需要移动，比如key1的信息如下：</p><ul><li>key1.hash=10 0000 1010</li><li>oldCap=16 00010000</li></ul><p>使用e.hash&amp;oldCap得到的结果高一位为0，当结果为0时表示元素在扩容时位置不会发生任何变化，而key 2信息如下：</p><ul><li>key2.hash=10 0001 0001</li><li>oldCap=1600010000</li></ul><p>这时候得到的结果高一位为1，当结果为1时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置+原数组长度，如下图所示：</p><p><img data-src="3.png" alt="3"></p><p>其中红色的虚线图代表了扩容时元素移动的位置。</p><h3 id="2-HashMap-死循环分析"><a href="#2-HashMap-死循环分析" class="headerlink" title="2.HashMap 死循环分析"></a>2.HashMap 死循环分析</h3><p>以JDK1.7为例，假设HashMap默认大小为2，原本HashMap中有一个元素key（5），我们再使用两个线程：t1添加元素key（3），t2添加元素key（7），当元素key（3）和key（7）都添加到HashMap<br>中之后，线程t1在执行到Entry&lt;K，V&gt;next=e.next；时，交出了CPU的使用权，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程一执行此处</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此时线程t1中的e指向了key（3），而next 指向了key（7）；之后线程t2重新rehash 之后链表的顺序被反转，链表的位置变成了key（5）→key（7）→key（3），其中“→”用来表示下一个元素。<br>当t1重新获得执行权之后，先执行newTalbe[i]=e把key（3）的next 设置为key（7），而下次循环时查询到key（7）的next 元素为key（3），于是就形成了key（3）和key（7）的循环引用，因此就导致了死循环的发生，如下图所示：</p><p><img data-src="4.png" alt="4"></p><p>当然发生死循环的原因是JDK1.7链表插入方式为首部倒序插入，这个问题在JDK1.8得到了改善，变成了尾部正序插入。<br>有人曾经把这个问题反馈给了Sun公司，但Sun公司认为这不是一个问题，因为HashMap本身就是非线程安全的，如果要在多线程下，建议使用ConcurrentHashMap替代，但这个问题在面试中被问到的几率依然很大，所以在这里需要特别说明一下。</p><p><strong>小结</strong></p><p>本课时介绍了HashMap的底层数据结构，在JDK1.7时HashMap是由数组和链表组成的，而JDK<br>1.8则新增了红黑树结构，当链表的长度大于8时会转换为红黑树存储，以提升元素的操作性能。同时还介绍了HashMap的三个重要方法，查询、添加和扩容，以及JDK1.7 resize0在并发环境下导致死循环的原因。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 美团点评2020校招后台开发方向笔试题 </title>
      <link href="/2020/03/12/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%842020%E6%A0%A1%E6%8B%9B%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2020/03/12/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%842020%E6%A0%A1%E6%8B%9B%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-RESTful调用和-RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service-Mesh，如果了解Service-Mesh是用来解决什么问题的？"><a href="#1-RESTful调用和-RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service-Mesh，如果了解Service-Mesh是用来解决什么问题的？" class="headerlink" title="1.RESTful调用和 RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service Mesh，如果了解Service Mesh是用来解决什么问题的？"></a>1.RESTful调用和 RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service Mesh，如果了解Service Mesh是用来解决什么问题的？</h3><p>1、RESTful<strong>是一种软件架构风格</strong>，<strong>用于约束客户端和服务器交互</strong>，满足这些约束条件和原则的应用程序或设计就是 RESTful。比如HTTP协议使用同一个URL地址，通过GET，POST，PUT，DELETE等方式实现查询、提交、删除数据。</p><p>RPC是<strong>远程过程调用</strong>，是用于<strong>解决分布式系统服务间调用的一种方式</strong>。RPC采用客户端与服务端模式，双方通过约定的接口（常见为通过IDL定义或者是代码定义）以类似本地方法调用的方式来进行交互，客户端根据约定传输调用函数+参数给服务端（一般是网络传输TCP/UDP），服务端处理完按照约定将返回值返回给客户端。</p><p><strong>重点为RESTful HTTP的约束风格，RPC调用模型。</strong></p><p>1、可分为两大部分RPC +服务治理<br>RPC部分 = IDL  +客户端/服务端实现层  +协议层 +数据传输层<br>服务治理 =服务管理（注册中心） +服务监控 +服务容灾 +服务鉴权</p><p>2、 Service Mesh为了解决传统微服务框架”胖客户端”方式，引入的如下问题：<br>与业务无关的服务治理逻辑与业务代码强耦合，框架、SDK的升级与业务代码强绑定，多语言的胖客户端支持起来性价比极低。</p><h3 id="2-请描述避免多线程竞争时有哪些手段？"><a href="#2-请描述避免多线程竞争时有哪些手段？" class="headerlink" title="2.请描述避免多线程竞争时有哪些手段？"></a>2.请描述避免多线程竞争时有哪些手段？</h3><p>1) 不可变对象；</p><p>2) 互斥锁；</p><p>3)  ThreadLocal 对象；</p><p>4) CAS；</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p><strong>给出一个布尔表达式的字符串，比如：true or false and false，表达式只包含true，false，and和or，现在要对这个表达式进行布尔求值，计算结果为真时输出true、为假时输出false，不合法的表达时输出error（比如：true true）。表达式求值是注意and 的优先级比 or 要高，比如：true or false and false，等价于 true or (false and false)，计算结果是 true。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">        String str = cal();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine().trim();</span><br><span class="line"><span class="comment">//        String str = "false&amp;nbs***bsp;true and false";</span></span><br><span class="line">        String[] words = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(words));</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(<span class="string">"true"</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(<span class="string">"false"</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(<span class="string">"and"</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() != <span class="number">2</span> &amp;&amp; i != words.length - <span class="number">1</span></span><br><span class="line">                        &amp;&amp; (words[i + <span class="number">1</span>].equals(<span class="string">"true"</span>) || words[i + <span class="number">1</span>].equals(<span class="string">"false"</span>)))&#123;</span><br><span class="line">                    <span class="keyword">int</span> val = words[i + <span class="number">1</span>].equals(<span class="string">"true"</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                    stack.push(stack.pop() &amp; val);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(<span class="string">"or"</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(last == -<span class="number">1</span>)&#123;</span><br><span class="line">                last = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(last == <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> or = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(or != <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">                <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() != <span class="number">2</span>) val = stack.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">                last = last | val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last == <span class="number">1</span> ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>给出两个字符串，分别是模式串P和目标串T，判断模式串和目标串是否匹配，匹配输出 1，不匹配输出 0。模式串中‘？’可以匹配目标串中的任何字符，模式串中的 ’*’可以匹配目标串中的任何长度的串，模式串的其它字符必须和目标串的字符匹配。例如P=a?b，T=acb，则P 和 T 匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String p = sc.next();</span><br><span class="line">        String s = sc.next();</span><br><span class="line">        <span class="comment">// System.out.println(s + " - " + p);</span></span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; p.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((dp[m][n] ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      <categories>
          
          <category> 牛客真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String的特点是什么？它有哪些重要的方法？</title>
      <link href="/2020/03/11/String%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%20%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/11/String%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%20%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>几乎所有的Java面试都是以String开始的，如果第一个问题没有回答好，则会给面试官留下非常不好的第一印象，而糟糕的第一印象则会直接影响到自己的面试结果，就好像刚破壳的小鹅一样，会把第一眼看到的动物当成自己的母亲，即使它第一眼看到的是一只小狗或小猫，也会默认跟随其后，心理学把这种现象叫做<strong>印刻效应</strong>。印刻效应不仅存在于低等动物之中，同样也适用于人类，所以对于String的知识，我们必须深入的掌握才能为自己赢得更多的筹码。</p><p>本课时的问题是：String 是如何实现的？它有哪些重要的方法？</p><h3 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a><strong>典型回答</strong></h3><p>以主流的JDK版本1.8来说，String内部实际存储结构为char数组，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;，<span class="title">CharSequence</span></span>&#123;</span><br><span class="line">    <span class="comment">//用于存储字符串的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value [];</span><br><span class="line">    <span class="comment">//缓存字符串的 hash code </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;<span class="comment">//Default to 0</span></span><br><span class="line">    <span class="comment">//..其他内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 源码中包含下面几个重要的方法。</p><h3 id="1-多构造方法"><a href="#1-多构造方法" class="headerlink" title="1.多构造方法"></a>1.多构造方法</h3><p>String字符串有以下4个重要的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value =original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash =original.hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char[]为参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value=Arrays.copyof(value，value<span class="number">.1</span>ength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StringBuffer为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(buffer)&#123;</span><br><span class="line"><span class="keyword">this</span>.value=Arrays.copyof（buffer.getValue()，buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stringBuilder为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value =Arrays.copyof(builder.getValue()，builder<span class="number">.1</span>ength());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，比较容易被我们忽略的是以StringBuffer和StringBuilder为参数的构造函数，因为这三种数据类型，我们通常都是单独使用的，所以这个小细节我们需要特别留意一下。</p><h3 id="2-equals（）比较两个字符串是否相等"><a href="#2-equals（）比较两个字符串是否相等" class="headerlink" title="2.equals（）比较两个字符串是否相等"></a>2.equals（）比较两个字符串是否相等</h3><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对象引用相同直接返回 true </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==anObject)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断需要对比的值是否为String类型，如果不是则直接返回false </span></span><br><span class="line">    <span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">        String anotherString=(String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span>(n == anotherString.value.length)&#123;</span><br><span class="line">    <span class="comment">//把两个字符串都转换为char数组对比</span></span><br><span class="line">    <span class="keyword">char</span> vl[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环比对两个字符串的每一个字符</span></span><br><span class="line">    <span class="keyword">while</span>（n-- != <span class="number">0</span>）&#123;</span><br><span class="line">    <span class="comment">//如果其中有一个字符不相等就 true false，否则继续对比</span></span><br><span class="line">                <span class="keyword">if</span>(vl[i] != v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 类型重写了Object中的equals(）方法，equals(）方法需要传递一个Object类型的参数值，在比较时会先通过instanceof 判断是否为String 类型，如果不是则会直接返回false，instanceof的使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object oString=<span class="string">"123"</span>;</span><br><span class="line">Object oInt =<span class="number">123</span>;</span><br><span class="line">System.out.println(oString <span class="keyword">instanceof</span> String);<span class="comment">//返回 true</span></span><br><span class="line">System.out.println(oInt <span class="keyword">instanceof</span> String);<span class="comment">//返回false</span></span><br></pre></td></tr></table></figure><p>当判断参数为String类型之后，会循环对比两个字符串中的每一个字符，当所有字符都相等时返回true，否则则返回false。<br>还有一个和equals0比较类似的方法equalslgnoreCase0，它是用于忽略字符串的大小写之后进行字符串对比。</p><h3 id="3-compareTo（）比较两个字符串"><a href="#3-compareTo（）比较两个字符串" class="headerlink" title="3.compareTo（）比较两个字符串"></a>3.compareTo（）比较两个字符串</h3><p>compareTo0方法用于比较两个字符串，返回的结果为int类型的值，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenl=value.length;</span><br><span class="line">    <span class="keyword">int</span> len2=anotherString.value.length;</span><br><span class="line">    <span class="comment">//获取到两个字符串长度最短的那个int值</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">1</span>im=Math.min(<span class="number">1</span>en1，<span class="number">1</span>en2);</span><br><span class="line">    <span class="keyword">char</span> vl[]=value;</span><br><span class="line">    <span class="keyword">char</span> v2[]=anotherString.value;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对比每一个字符</span></span><br><span class="line">    <span class="keyword">while</span>(k &lt; lim)&#123;</span><br><span class="line"><span class="keyword">char</span> cl=vl[k];</span><br><span class="line"><span class="keyword">char</span> c2=v2[k];</span><br><span class="line"><span class="keyword">if</span>（c1 != c2）&#123;</span><br><span class="line"><span class="comment">//有字符不相等就返回差值</span></span><br><span class="line"><span class="keyword">return</span> c1-c2;</span><br><span class="line">        &#125;</span><br><span class="line">k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>en1 - <span class="number">1</span>en2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，compareTo0方法会循环对比所有的字符，当两个字符串中有任意一个字符不相同时，则return char1-char2。比如，两个字符串分别存储的是1和2，返回的值是-1；如果存储的是1和1，则返回的值是0，如果存储的是2和1，则返回的值是1。<br>还有一个和compareTo0 比较类似的方法compareTolgnoreCase0，用于忽略大小写后比较两个字符串。<br>可以看出compareTo0方法和equals0方法都是用于比较两个字符串的，但它们有两点不同：</p><ul><li>equals0可以接收一个Object 类型的参数，而compareTo0只能接收一个String类型的参数；    </li><li>equals0返回值为Boolean，而compareTo0的返回值则为int。</li></ul><p>它们都可以用于两个字符串的比较，当equals0方法返回true时，或者是compareTo0方法返回0时，则表示两个字符串完全相同。</p><h3 id="4-其他重要方法"><a href="#4-其他重要方法" class="headerlink" title="4.其他重要方法"></a>4.其他重要方法</h3><ul><li>indexOf(）：查询字符串首次出现的下标位置</li><li>lastlndexOf()：查询字符串最后出现的下标位置</li><li>contains()：查询字符串中是否包含另一个字符串</li><li>toLowerCase()：把字符串全部转换成小写</li><li>toUpperCase()：把字符串全部转换成大写</li><li>length()：查询字符串的长度</li><li>trim()：去掉字符串首尾空格</li><li>replace()：替换字符串中的某些字符</li><li>split()：把字符串分割并返回字符串数组</li><li>join()：把字符串数组转为字符串</li></ul><p><strong>考点分析</strong></p><p>这道题目考察的重点是，你对Java 源码的理解，这也从侧面反应了你是否热爱和喜欢专研程序，而这正是一个优秀程序员所必备的特质。<br>String 源码属于所有源码中最基础、最简单的一个，对String源码的理解也反应了你的Java基础功底。<br>String问题如果再延伸一下，会问到一些更多的知识细节，这也是大厂一贯使用的面试策略，从一个知识点入手然后扩充更多的知识细节，对于String也不例外，通常还会关联的询问以下问题：</p><ul><li>为什么String 类型要用final修饰？</li><li>==和equals的区别是什么？</li><li>String和StringBuilder、StringBuffer 有什么区别？</li><li>String的intern()方法有什么含义？</li><li>String 类型在 JVM（Java虚拟机）中是如何存储的？编译器对String做了哪些优化？</li></ul><p>接下来我们一起来看这些问题的答案。</p><h4 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a><strong>知识拓展</strong></h4><h5 id="1-和equals的区别"><a href="#1-和equals的区别" class="headerlink" title="1.==和equals的区别"></a>1.==和equals的区别</h5><p>==对于基本数据类型来说，是用于比较“值”是否相等的；而对于引用类型来说，是用于比较引用地址是否相同的。<br>查看源码我们可以知道Object中也有equals0方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Object中的equals0方法其实就是==，而String重写了equals0方法把它修改成比较两个字符串的值是否相等。<br>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对象引用相同直接返回 true </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==anObject)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断需要对比的值是否为String类型，如果不是则直接返回false </span></span><br><span class="line">    <span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">        String anotherString=(String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span>(n == anotherString.value.length)&#123;</span><br><span class="line">    <span class="comment">//把两个字符串都转换为char数组对比</span></span><br><span class="line">    <span class="keyword">char</span> vl[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环比对两个字符串的每一个字符</span></span><br><span class="line">    <span class="keyword">while</span>（n-- != <span class="number">0</span>）&#123;</span><br><span class="line">    <span class="comment">//如果其中有一个字符不相等就 true false，否则继续对比</span></span><br><span class="line">                <span class="keyword">if</span>(vl[i] != v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-final-修饰的好处"><a href="#2-final-修饰的好处" class="headerlink" title="2.final 修饰的好处"></a>2.final 修饰的好处</h5><p>从String类的源码我们可以看出String是被final修饰的不可继承类，源码如下：</p><p>Java 语言之父James Gosling的回答是，他会更倾向于使用final，因为它能够缓存结果，当你在传参时不需要考虑谁会修改它的值；如果是可变类的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上就会有一定的损失。<br>James Gosling 还说迫使String类设计成不可变的另一个原因是安全，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，它的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题，这是迫使String类设计成不可变类的一个重要原因。<br>总结来说，使用final修饰的第一个好处是安全；第二个好处是高效，以JVM中的字符串常量池来举例，如下两个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"java"</span>;</span><br><span class="line">String s2 = <span class="string">"java"</span>;</span><br></pre></td></tr></table></figure><p>只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如下图所示：</p><p><img data-src="1.png" alt="1"></p><p>试想一下如果String是可变的，那当s1的值修改之后，52的值也跟着改变了，这样就和我们预期的结果不相符了，因此也就没有办法实现字符串常量池的功能了。</p><h5 id="3-String-和StringBuilder、StringBuffer的区别"><a href="#3-String-和StringBuilder、StringBuffer的区别" class="headerlink" title="3.String 和StringBuilder、StringBuffer的区别"></a>3.String 和StringBuilder、StringBuffer的区别</h5><p>因为String类型是不可变的，所以在字符串拼接的时候如果使用String的话性能会很低，因此我们就需要使用另一个数据类型 StringBuffer，它提供了append和insert方法可用于字符串的拼接，它使用synchronized来保证线程安全，如下源码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    toStringCache =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    toStringCache =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为它使用了synchronized来保证线程安全，所以性能不是很高，于是在JDK1.5就有了StringBuilder，它同样提供了append和insert的拼接方法，但它没有使用synchronized来修饰，因此在性能上要优于StringBufer，所以在非并发操作的环境下可使用 StringBuilder来进行字符串拼接。</p><h5 id="4-String-和JVM"><a href="#4-String-和JVM" class="headerlink" title="4.String 和JVM"></a>4.String 和JVM</h5><p>String 常见的创建方式有两种，直接赋值的方式”String s1=”Java”；”和“Strings2=new String（”Java”）；”的方式，但两者在JVM的存储区域却截然不同，在JDK1.8中，变量s1会先去字符串常量池中找字符串“Java”，如果有相同的字符则直接返回常量句柄，如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量s2是直接在堆上创建一个变量，如果调用<br>intern方法才会把此字符串保存到常量池中，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String sl =<span class="keyword">new</span> String(<span class="string">"Java"</span>); </span><br><span class="line">String s2=s1.intern();</span><br><span class="line">String s3=<span class="string">"Java"</span>;</span><br><span class="line">System.out.println(s1 ==s2);<span class="comment">//false </span></span><br><span class="line">System.out.println(s2 ==s3);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>它们在 JVM 存储的位置，如下图所示：</p><p><img data-src="2.png" alt="2"></p><p>注：JDK1.7之后把永生代换成的元空间，把字符串常量池从方法区移到了Java堆上。<br>除此之外编译器还会对String字符串做一些优化，例如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Ja"</span> + <span class="string">"va"</span>;</span><br><span class="line">String s2 = <span class="string">"Java"</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure><p>虽然51拼接了多个字符串，但对比的结果却是true，我们使用反编译工具，看到的结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"StringExample.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">lagou</span>.<span class="title">interview</span>.<span class="title">StringExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> com.lagou.interview.StringExample();</span><br><span class="line">Code:</span><br><span class="line">            <span class="number">0</span>:aload_0</span><br><span class="line">            1:invokespecial #1//Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">            <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">       LineNumberTable:</span><br><span class="line">     line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">0: ldc           #2                  // String Java</span><br><span class="line"><span class="number">2</span>: astore_1</span><br><span class="line">       3: ldc           #2                  // String Java</span><br><span class="line"><span class="number">5</span>:astore_2</span><br><span class="line">        6:getstatic     #3 //Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"><span class="number">9</span>: aload_1</span><br><span class="line"> <span class="number">10</span>: aload_2</span><br><span class="line">        <span class="number">11</span>: if_acmpne     <span class="number">18</span></span><br><span class="line">        <span class="number">14</span>: iconst_1</span><br><span class="line">        <span class="number">15</span>: goto          <span class="number">19</span></span><br><span class="line">        <span class="number">18</span>: iconst_0</span><br><span class="line">      19: invokevirtual #4  </span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">        LineNumberTable:</span><br><span class="line">        <span class="number">1</span>ine <span class="number">5</span>:<span class="number">0</span></span><br><span class="line">        <span class="number">1</span>ine <span class="number">6</span>:<span class="number">3</span></span><br><span class="line">        line <span class="number">7</span>:<span class="number">6</span></span><br><span class="line">        <span class="number">1</span>ine <span class="number">8</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从编译代码#2可以看出，代码“Ja”+”va”被直接编译成了“Java”，因此s1==s2的结果才是<br>true，这就是编译器对字符串优化的结果。<br>小结<br>本课时从String 的源码入手，重点讲了String的构造方法、equals0方法和compareTo())方法，其中equals(）重写了Object的equals())方法，把引用对比改成了字符串值对比，也介绍了final修饰String的好处，可以提高效率和增强安全性，同时我们还介绍了String和JVM的一些执行细节。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】一对一关联映射</title>
      <link href="/2020/03/10/hibernate%E4%B8%80%E5%AF%B9%E4%B8%80%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/10/hibernate%E4%B8%80%E5%AF%B9%E4%B8%80%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p><img data-src="1.png" alt="1"></p><h3 id="一-XML方式"><a href="#一-XML方式" class="headerlink" title="一.XML方式"></a>一.XML方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 标识一个类的xml映射,name为类名,table为表名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"Person"</span> <span class="attr">cascade</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Person.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"foreign"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"property"</span>&gt;</span>user<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idNumber"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">constrained</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过&lt;one-to-one&gt; 元素配置。</p><p>•constrained 属性为 true，表明 PERSON 表 ID 为外键，参照主表（USER）。</p><p>•外键表实体类配置文件中 OID 使用 foreign 生成策略。</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">User user  = <span class="keyword">new</span> User();</span><br><span class="line">user.setUserName(<span class="string">"zs"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"ls"</span>);</span><br><span class="line">person.setIdNumber(<span class="string">"2017011776"</span>);</span><br><span class="line">user.setPerson(person);</span><br><span class="line">person.setUser(user);</span><br><span class="line">session.save(user);</span><br><span class="line">session.save(person);</span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-注解方式"><a href="#二-注解方式" class="headerlink" title="二.注解方式"></a>二.注解方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@OneToOne</span>(cascade=CascadeType.ALL)</span><br><span class="line"><span class="meta">@PrimaryKeyJoinColumn</span>(name=<span class="string">"id"</span>)</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator = <span class="string">"foreign"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name = <span class="string">"foreign"</span>, strategy = <span class="string">"foreign"</span>, parameters = &#123;</span><br><span class="line"><span class="meta">@Parameter</span>(name = <span class="string">"property"</span>, value = <span class="string">"user"</span>) &#125;)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="meta">@OneToOne</span>(mappedBy=<span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-唯一外键关联"><a href="#三-唯一外键关联" class="headerlink" title="三.唯一外键关联"></a>三.唯一外键关联</h3><h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"person"</span> <span class="attr">column</span>=<span class="string">"PERSONID"</span> <span class="attr">cascade</span>=<span class="string">"all"</span> <span class="attr">unique</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Person.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Person"</span> <span class="attr">table</span>=<span class="string">"PERSON"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idNumber"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 外键关联方式映射与User的一对一关系   property-ref:外键列对应的属性名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">property-ref</span>=<span class="string">"person"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">User user  = <span class="keyword">new</span> User();</span><br><span class="line">user.setUserName(<span class="string">"zs"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"ls"</span>);</span><br><span class="line">person.setIdNumber(<span class="string">"2017011776"</span>);</span><br><span class="line">user.setPerson(person);</span><br><span class="line">person.setUser(user);</span><br><span class="line">session.save(user);</span><br><span class="line">session.save(person);</span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@OneToOne</span>(cascade=CascadeType.ALL)</span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"PERSONID"</span>)</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userName = userName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.person = person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="meta">@OneToOne</span>(mappedBy=<span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIdNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> idNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdNumber</span><span class="params">(String idNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.idNumber = idNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.user = user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-组合关系映射"><a href="#四-组合关系映射" class="headerlink" title="四.组合关系映射"></a>四.组合关系映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"contact"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"phoneNum"</span>)</span><br><span class="line"><span class="keyword">private</span> String tel;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"><span class="meta">@Embedded</span></span><br><span class="line"><span class="meta">@AttributeOverrides</span>(value=&#123;</span><br><span class="line">    <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"province"</span>, </span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_province"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"city"</span>,</span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_city"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"district"</span>,</span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_district"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"detail"</span>,</span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_detail"</span>))&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Address homeAddress;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTel</span><span class="params">(String tel)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tel = tel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Address <span class="title">getHomeAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> homeAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHomeAddress</span><span class="params">(Address homeAddress)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.homeAddress = homeAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span><span class="comment">//指明为嵌入式类，不需要单独进行映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String province;</span><br><span class="line"><span class="keyword">private</span> String city;</span><br><span class="line"><span class="keyword">private</span> String district;</span><br><span class="line"><span class="keyword">private</span> String detail;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProvince</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> province;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProvince</span><span class="params">(String province)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.province = province;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> city;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span><span class="params">(String city)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.city = city;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDistrict</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> district;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDistrict</span><span class="params">(String district)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.district = district;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> detail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDetail</span><span class="params">(String detail)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.detail = detail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">Contact contact = <span class="keyword">new</span> Contact();</span><br><span class="line">contact.setEmail(<span class="string">"273903932@qq.com"</span>);</span><br><span class="line">contact.setTel(<span class="string">"12312123451"</span>);</span><br><span class="line">Address address = <span class="keyword">new</span> Address();</span><br><span class="line">address.setProvince(<span class="string">"河北省"</span>);</span><br><span class="line">address.setCity(<span class="string">"秦皇岛市"</span>);</span><br><span class="line">address.setDistrict(<span class="string">"昌黎县"</span>);</span><br><span class="line">address.setDetail(<span class="string">"黎昌尚府小区"</span>);</span><br><span class="line">contact.setHomeAddress(address); </span><br><span class="line">session.save(contact);</span><br><span class="line"></span><br><span class="line">tx.commit();</span><br><span class="line"> </span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】单实体映射</title>
      <link href="/2020/03/10/hibernate%E5%8D%95%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/10/hibernate%E5%8D%95%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="Java程序中区分不同对象。"><a href="#Java程序中区分不同对象。" class="headerlink" title="Java程序中区分不同对象。"></a>Java程序中区分不同对象。</h3><p>​    <strong>1.Java语言中通过内存地址区分不同对象；</strong></p><p>​    <strong>2.两种比较引用变量方法；</strong></p><p>​        a. “==” 比较两个变量引用的内存地址是否相同；</p><p>​        b.  equals可以比较两个变量引用的对象的值是否相同。</p><p>​    <strong>3.用户自定义的类也可以覆盖Object的equals方法实现对象按值进行比较。</strong></p><h3 id="Hibernate-自带了很多种标识符生成器："><a href="#Hibernate-自带了很多种标识符生成器：" class="headerlink" title="Hibernate 自带了很多种标识符生成器："></a>Hibernate 自带了很多种标识符生成器：</h3><p><img data-src="1.png" alt="1"></p><p><strong>increment</strong>  采用 Hibernate 数值递增的方式,该机制是 Hibernate 以递增的方式为OID赋值。</p><p>&emsp;&emsp;&emsp;不依赖于底层数据库系统，适合所有数据库;</p><p>&emsp;&emsp;&emsp;适合单独的 Hibernate 应用使用，不适合在集群情况下使用。</p><p><strong>identity</strong> 采用数据库提供的自增长方式,该机制依赖于底层数据库，需要数据库支持自动增长字段。</p><p>&emsp;&emsp;&emsp;例如：MySQL、MSSQL、DB2、Sybase等。</p><p><strong>assigned</strong> 主键由应用逻辑产生；该机制是由外部程序负责生成OID,Hibernate 不负责维护主键生成，与Hibernate和底层数据库都无关。</p><p>&emsp;&emsp;例如：Student类没有定义 ID，而是以学号studentNo 作为业务主键。&emsp;</p><p><strong>sequence</strong> 采用数据库提供的序列方式；</p><p>hilo 通过hi/lo算法   // Hibernate 5.0 以后不支持；</p><p>seqhilo 通过hi/lo算法；</p><p>native 自动选择合适的标识符生成器；</p><p>uuid.hex 通过uuid算法。</p><h3 id="使用注解映射单实体"><a href="#使用注解映射单实体" class="headerlink" title="使用注解映射单实体"></a><strong>使用注解映射单实体</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"employee"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment_generator"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment_generator"</span>, strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"name"</span>) </span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Entity：声明一个实体类。</p><p>@Table(name=”table_name”)：为实体类指定对应的数据库表。</p><p>@Id：声明实体类的OID属性。</p><p>@GeneratedValue(generator=”increment_generator”)：声明OID的生成策略。</p><p>@GenericGenerator(name=”increment_generator”, strategy=”increment”)：使用Hibernate提供的生成策略。</p><p>@Column(name=”columnName”) ：将属性映射到列。</p><p>@Access(AccessType.PROPERTY)：1.通过 getter 和 setter 方法访问实体类的属性；2.需要在 getter 方法上定义字段的属性。</p><p>@Access(AccessType.FIELD)：1.直接访问实体类的属性，可以不定义 getter 和 setter 方法；2.需要在变量上定义字段的属性。</p>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hibernate】搭建框架</title>
      <link href="/2020/03/10/hibernate%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/03/10/hibernate%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="初始框架搭建"><a href="#初始框架搭建" class="headerlink" title="初始框架搭建"></a>初始框架搭建</h1><h3 id="分层构系结构"><a href="#分层构系结构" class="headerlink" title="分层构系结构"></a>分层构系结构</h3><p>指的是将系统的组件分隔到不同的层中，每一层中的组件应保持内聚性；<br>每一层都应与它下面的各层保持松散耦合。</p><h3 id="三层体系结构"><a href="#三层体系结构" class="headerlink" title="三层体系结构"></a><strong>三层体系结构</strong></h3><p><img data-src="1583851295917.png" alt="1583851295917"></p><h3 id="持久化层是怎么来的"><a href="#持久化层是怎么来的" class="headerlink" title="持久化层是怎么来的"></a><strong>持久化层是怎么来的</strong></h3><p>为了把数据访问细节和业务逻辑分开，可以把数据访问作为单独的持久化层。</p><p><img data-src="1583851385990.png" alt="1583851385990"></p><h3 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h3><p><strong>瞬时状态</strong>：保存在内存的程序数据，程序退出后，数据就消失了，称为瞬时状态。</p><p><strong>持久状态</strong>：保存在数据库（磁盘）的程序数据，程序退出后，数据依然存在，称为程序数据的持久状态。</p><p><strong>持久化</strong>：将程序数据在瞬时状态和持久化状态之间转换的机制。</p><h3 id="MVC设计模式与四层结构的对应关系"><a href="#MVC设计模式与四层结构的对应关系" class="headerlink" title="MVC设计模式与四层结构的对应关系"></a>MVC设计模式与四层结构的对应关系</h3><p><img data-src="1583851508296.png" alt="1583851508296"></p><h3 id="持久化层的设计目标："><a href="#持久化层的设计目标：" class="headerlink" title="持久化层的设计目标："></a>持久化层的设计目标：</h3><p>1.代码可重用性高，能够完成对象持久化操作；</p><p>2.如果需要的话，能够支持多种数据库平台；</p><p>3.具有相对独立性，当持久层发生变化时，不会影响上层实现。</p><h3 id="Hibernate是什么？"><a href="#Hibernate是什么？" class="headerlink" title="Hibernate是什么？"></a>Hibernate是什么？</h3><p>1.在分层体系结构中Hibernate位于持久化层，是完成对象持久化的持久化层框架；</p><p>2.Hibernate是连接Java应用程序和关系型数据库的框架，能够建立对象模型和关系数据模型之间的映射，是一种自动ORM框架；</p><p>3.Hibernate是对JDBC API的封装，是JDBC轻量级封装框架。</p><h2 id="第一个Hibernate程序"><a href="#第一个Hibernate程序" class="headerlink" title="第一个Hibernate程序"></a>第一个Hibernate程序</h2><h4 id="1-引入jar包"><a href="#1-引入jar包" class="headerlink" title="1.引入jar包"></a>1.引入jar包</h4><p><img data-src="1583851888229.png" alt="1583851888229"></p><h4 id="2-项目目录结构"><a href="#2-项目目录结构" class="headerlink" title="2.项目目录结构"></a>2.项目目录结构</h4><p><img data-src="1583851908692.png" alt="1583851908692"></p><h4 id="3-hibernate-cfg-xml"><a href="#3-hibernate-cfg-xml" class="headerlink" title="3.hibernate.cfg.xml"></a>3.hibernate.cfg.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span> <span class="meta-string">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/hibernate_demo_db<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/hibernate/entity/Customer.hbm.xml"</span>/&gt;</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;mapping class="top.hiasenna.entity.User" /&gt;</span></span><br><span class="line"><span class="comment">&lt;mapping class="top.hiasenna.entity.Order" /&gt; </span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-编写持久化类"><a href="#4-编写持久化类" class="headerlink" title="4.编写持久化类"></a>4.编写持久化类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Customer [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-创建持久化类的配置文件"><a href="#5-创建持久化类的配置文件" class="headerlink" title="5.创建持久化类的配置文件"></a>5.创建持久化类的配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.hibernate.entity"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 标识一个类的xml映射,name为类名,table为表名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Customer"</span> <span class="attr">table</span>=<span class="string">"customer"</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 主键的设置,generator标识主键生成方式--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 这里配了该类一个属性街道名称 name属性字段,column,数据库对应列 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">column</span>=<span class="string">"name"</span> /&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 这里同上,写法不同而已 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"age"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="标签说明"><a href="#标签说明" class="headerlink" title="标签说明"></a>标签说明</h5><p>1.<strong>&lt;class&gt;</strong>元素用于指定类和表之间的映射</p><p>​        -name属性设定类名(包含路径)；</p><p>​        -table属性设定表名，默认以类名作表名。</p><p>2.<strong>id</strong> 子元素设定持久化类的OID和表的主键的映射关系</p><p>​        -column – 指定表字段的名称；</p><p>​        -generator – 元素指定OID的生成器。</p><p>3.<strong>property</strong>子元素设定类的其他属性和表的字段的映射关系</p><p>​        -name – 对应类的属性名称；</p><p>​        -type – 指定属性的类型；</p><p>​        -column – 指定表字段的名称；</p><p>​        -not-null – 指定属性是否允许为空。</p><p>6.HibernateUtil工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.MetadataSources;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistry;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtil</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">final</span> StandardServiceRegistry registry=<span class="keyword">new</span> StandardServiceRegistryBuilder().configure().build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sessionFactory=<span class="keyword">new</span> MetadataSources(registry).buildMetadata().buildSessionFactory();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">sessionFactory=<span class="keyword">null</span>;</span><br><span class="line">StandardServiceRegistryBuilder.destroy(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SessionFactory <span class="title">getSessionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sessionFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSessionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sessionFactory.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SSH】初始项目搭建流程</title>
      <link href="/2020/03/10/ssh%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/03/10/ssh%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="初始项目搭建流程"><a href="#初始项目搭建流程" class="headerlink" title="初始项目搭建流程"></a>初始项目搭建流程</h1><p>1.创建一个动态web项目</p><p><img data-src="1.png" alt="1"></p><p>接着点击next，勾选自动生成web.xml选项，最后点击finish。</p><p>2.在WEB-INF的lib文件夹中导入必备的jar包，包括spring、struts以及hibernate的jar包：</p><p>spring相关jar包：</p><p><img data-src="2.png" alt="2"></p><p>struts相关jar包：</p><p><img data-src="3.png" alt="3"></p><p>hibernate相关jar包：</p><p><img data-src="4.png" alt="4"></p><p>3.jar导入后，开始搭建框架，完成配置文件</p><p>（1）首先第一步加载数据库配置文件，配置数据源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载数据库配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 包扫描器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.jiangnan.ssh"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置C3P0数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.username&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driverClass&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.url&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.initialPoolSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.maxPoolSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）第二步创建数据库操作对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建数据库的操作对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate5.LocalSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernateProperties"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库方言 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 显示Hibernate持久化操作生成的预编译的SQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将SQL格式化后再输出 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 是否根据需要每次自动创建数据库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hibernate映射文件的目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappingDirectoryLocations"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com/jiangnan/ssh/pojo<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）第三步配置事务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate5.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）第四步配置通知</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> <span class="attr">id</span> =<span class="string">"txadvice"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（5）第五步配置切面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.jiangnan.ssh.service.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（6）最后配置一下web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.jiangnan.ssh.service.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成</p>]]></content>
      
      
      <categories>
          
          <category> spring框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Guava Cache】基于Guava Cache内存缓存实现的token验证</title>
      <link href="/2020/03/10/%E5%9F%BA%E4%BA%8EGuava%20Cache%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E7%9A%84token%E9%AA%8C%E8%AF%81/"/>
      <url>/2020/03/10/%E5%9F%BA%E4%BA%8EGuava%20Cache%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E7%9A%84token%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Guava-Cache内存缓存实现的token验证"><a href="#基于Guava-Cache内存缓存实现的token验证" class="headerlink" title="基于Guava Cache内存缓存实现的token验证"></a>基于Guava Cache内存缓存实现的token验证</h1><h2 id="理解token机制"><a href="#理解token机制" class="headerlink" title="理解token机制"></a>理解token机制</h2><p> 什么是token</p><p>   token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。</p><p>   身份认证概述</p><p>   由于HTTP是一种没有状态的协议，它并不知道是谁访问了我们的应用。这里把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下次这个客户端再发送请求时候，还得再验证一下。<br>通用的解决方法就是，当用户请求登录的时候，如果没有问题，在服务端生成一条记录，在这个记录里可以说明登录的用户是谁，然后把这条记录的id发送给客户端，客户端收到以后把这个id存储在cookie里，下次该用户再次向服务端发送请求的时候，可以带上这个cookie，这样服务端会验证一下cookie里的信息，看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。<br>以上所描述的过程就是利用session，那个id值就是sessionid。我们需要在服务端存储为用户生成的session，这些session会存储在内存，磁盘，或者数据库。</p><p>   基于token机制的身份认证</p><p>   使用token机制的身份验证方法，在服务器端不需要存储用户的登录记录。大概的流程：</p><p>客户端使用用户名和密码请求登录。服务端收到请求，验证用户名和密码。验证成功后，服务端会生成一个token，然后把这个token发送给客户端。客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。客户端每次向服务端发送请求的时候都需要带上服务端发给的token。服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。</p><h3 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h3><p>Guava Cache是单个应用运行时的本地缓存。它不把数据存放到文件或者外部服务器上。简单、强大、及轻量级。它不需要配置文件，使用起来和ConcurrentHashMap一样简单，而且能覆盖绝大多数使用cache的场景需求</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p> 校验答案正确后，在service层来生成一个唯一token，一般可以使用mac地址，或者sessionId来生成token。因为token是可以被截获的，非常容易泄露，如果不进行加密，很容易被恶意拷贝并用来登录。所以一般会对token进行加密处理。</p><p>一般可以在存储的时候把token进行对称加密存储，用到的时候再解密，或者使用请求URL、时间戳、token三者合并，通过算法进行加密处理。两个一块用更安全。这里就简单利用UUID来实现生成唯一token</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String forgetToken = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure><p>然后再把token存到本地Guava Cache内存缓存中，在响应对象中也把这个token封装起来响应给客户端。到时候用户改密，就可以传入该token实现token机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TokenCache.setKey(<span class="string">"Token_"</span>+username,forgetToken);</span><br></pre></td></tr></table></figure><p>Guava Cache实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheLoader;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.LoadingCache;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author Liang Shan</span></span><br><span class="line"><span class="comment"> * @Description token本地缓存，使用guava缓存实现</span></span><br><span class="line"><span class="comment"> * @Date 2018/6/1 17:28</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    创建logback的logger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TokenCache<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//    声明一个静态的内存块,guava里面的本地缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LoadingCache&lt;String, String&gt; localcache =</span><br><span class="line">        <span class="comment">//构建本地缓存，调用链的方式 ,1000是设置缓存的初始化容量，maximumSize是设置缓存最大容量，当超过了最大容量，guava将使用LRU算法（最少使用算法），来移除缓存项</span></span><br><span class="line">        <span class="comment">//expireAfterAccess(12,TimeUnit.HOURS)设置缓存有效期为12个小时</span></span><br><span class="line">        CacheBuilder.newBuilder().initialCapacity(<span class="number">1000</span>).maximumSize(<span class="number">10000</span>).expireAfterAccess(<span class="number">12</span>,TimeUnit.HOURS)</span><br><span class="line">        <span class="comment">//build里面要实现一个匿名抽象类</span></span><br><span class="line">                .build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line"><span class="comment">//                   这个方法是默认的数据加载实现,get的时候，如果key没有对应的值，就调用这个方法进行加载</span></span><br><span class="line"> </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//                        为什么要把return的null值写成字符串，因为到时候用null去.equal的时候，会报空指针异常</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 添加本地缓存</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        localcache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 得到本地缓存</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value= localcache.get(key);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"null"</span>.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"getKey()方法错误"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Guava-Cache的回收策略"><a href="#Guava-Cache的回收策略" class="headerlink" title="Guava Cache的回收策略"></a>Guava Cache的回收策略</h3><h4 id="有两种回收策略："><a href="#有两种回收策略：" class="headerlink" title="有两种回收策略："></a>有两种回收策略：</h4><p>一种是基于容量的回收CacheBuilder.maximumSize(Long)。设置缓存最大容量，当超过最大容量，缓存将尝试回收最近没有使用或总体上很少使用的缓存项。</p><p>第二种定时回收</p><p>expireAfterAccess(long,TimeUnit):缓存项在给定时间内没有被读写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。</p><p>  expireAfterWrite(long,TimeUnit):缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变的陈旧不可用，这种回收是可取的。</p><p>实例中用的是第一种策略，通过设置缓存最大容量，当超过了最大容量，guava将使用LRU算法来减少缓存项</p><h3 id="LRU算法原理"><a href="#LRU算法原理" class="headerlink" title="LRU算法原理"></a>LRU算法原理</h3><p>LRU（Least recently used，最近最少使用的）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高。</p><p>最常见的实现是使用一个链表保存缓存数据：<br>1 新数据插入到链表头部<br>2 每当缓存命中（即缓存数据被访问），则将数据移到链表头部<br>3 当链表满的时候，将链表尾部的数据丢弃</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava Cache </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
