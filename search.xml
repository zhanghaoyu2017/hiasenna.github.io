<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>位运算------按位与、按位或、按位异或、取反、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</title>
      <link href="/2020/03/15/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2020/03/15/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>程序中的所有数在计算机内存中都是以二进制的形式储存的，位运算就是直接对整数在内存中的二进制位进行操作。</p><h3 id="1、原码、反码、补码-以byte的1、-1举例"><a href="#1、原码、反码、补码-以byte的1、-1举例" class="headerlink" title="1、原码、反码、补码(以byte的1、-1举例)"></a>1、原码、反码、补码(以byte的1、-1举例)</h3><p>示例                    1                      -1                                   </p><p>原码        0000 0001          1000 0001     ——&gt;第一位是符号位，0是正数，1为负数  </p><p>反码        0000 0001          1111 1110       ——&gt;正数反码是其自身，负数则符号位不变，其他位置全部取反</p><p>补码        0000 0001          1111 1111       ——-&gt;正数补码是其自身，负数则为反码+1</p><p>当然也可以从1通过取反，然后+1的方式得到-1的补码</p><h3 id="2、补码：用于将十进制的负整数转换为二进制数。十进制的正整数可以除以2取余，负整数则需要补码。"><a href="#2、补码：用于将十进制的负整数转换为二进制数。十进制的正整数可以除以2取余，负整数则需要补码。" class="headerlink" title="2、补码：用于将十进制的负整数转换为二进制数。十进制的正整数可以除以2取余，负整数则需要补码。"></a>2、补码：用于将十进制的负整数转换为二进制数。十进制的正整数可以除以2取余，负整数则需要补码。</h3><p>  补码的流程：例如-10</p><p>　　10：0000 0000 0000 1010</p><p>​    取反：1111 1111   1111  0101</p><p>​                          +1</p><p>​    -10：1111  1111  1111  0110</p><h3 id="3、整数在内存中以补码存在。"><a href="#3、整数在内存中以补码存在。" class="headerlink" title="3、整数在内存中以补码存在。"></a>3、整数在内存中以补码存在。</h3><h2 id="一、按位与-amp"><a href="#一、按位与-amp" class="headerlink" title="一、按位与(&amp;)"></a><strong>一、按位与(&amp;)</strong></h2><p><strong>定义：如果两个相应的二进制位都为1，则该位的结果值为1，否则为0.</strong></p><p>示例：</p><h3 id="1、10与-10-amp-运算"><a href="#1、10与-10-amp-运算" class="headerlink" title="1、10与-10 &amp;运算"></a>1、10与-10 &amp;运算</h3><p>10：0000 0000 0000 1010     —–&gt;   十进制转二进制</p><p>-10：1111  1111  1111  0110     —–&gt;   -10就是10取反，然后+1(补码)</p><p>结果: 0000 0000 0000 0010     —–&gt;   结果为2</p><h2 id="二、按位或"><a href="#二、按位或" class="headerlink" title="二、按位或(|)"></a><strong>二、按位或(|)</strong></h2><p><strong>定义：如果两个相应的二进制位有一个为1，则该结果为1，否则为0.</strong></p><p>示例：</p><h3 id="1、10与-10-运算"><a href="#1、10与-10-运算" class="headerlink" title="1、10与-10 |运算"></a>1、10与-10 |运算</h3><p> 10：0000 0000 0000 1010</p><p>-10：1111  1111  1111  0110</p><p>结果: 1111  1111 1111   1110  —–&gt;结果-2</p><p>第一位为符号位，1代表是负数，因此是补码形式存在，补码–&gt;十进制。先-1再取反(符号位不变)，。</p><p>1000 0000 0000 0001</p><p>+1</p><p>1000 0000 0000 0010 ——&gt; -2</p><h2 id="三、按位异或"><a href="#三、按位异或" class="headerlink" title="三、按位异或(^)"></a><strong>三、按位异或(^)</strong></h2><p><strong>定义：如果两个相应的二进制位值不同则为1，否则为0</strong></p><p>示例：</p><h3 id="1、10与-10-运算-1"><a href="#1、10与-10-运算-1" class="headerlink" title="1、10与-10 ^运算"></a>1、10与-10 ^运算</h3><p> 10：0000 0000 0000 1010</p><p>-10：1111  1111  1111  0110</p><p>结果: 1111  1111 1111   1100  ——&gt; 结果-4</p><h2 id="四、取反"><a href="#四、取反" class="headerlink" title="四、取反(~)"></a><strong>四、取反(~)</strong></h2><p><strong>定义：用来对一个二进制按位取反。</strong></p><p>示例：</p><h3 id="1、10取反"><a href="#1、10取反" class="headerlink" title="1、10取反"></a>1、10取反</h3><p>10：0000 0000 0000 1010</p><p>结果: 1111  1111 1111  0101 ——&gt; 结果-11</p><h2 id="五、左移-lt-lt"><a href="#五、左移-lt-lt" class="headerlink" title="五、左移(&lt;&lt;)"></a><strong>五、左移(&lt;&lt;)</strong></h2><p><strong>定义：将一个数的各二进制位全部左移N位，右补0</strong></p><p>示例：</p><h3 id="1、10左移-lt-lt-2"><a href="#1、10左移-lt-lt-2" class="headerlink" title="1、10左移&lt;&lt;2"></a>1、10左移&lt;&lt;2</h3><p>10：0000 0000 0000 1010</p><p>结果: 0000 0000 0010 1000——&gt; 结果40</p><h2 id="六、右移-gt-gt"><a href="#六、右移-gt-gt" class="headerlink" title="六、右移(&gt;&gt;)"></a><strong>六、右移(&gt;&gt;)</strong></h2><p><strong>定义：将一个数的各二进制位全部右移N位，移到右边的低位被舍弃，对于无符号数高位补0，负数高位补1.</strong></p><h3 id="1、10右移-gt-gt-2"><a href="#1、10右移-gt-gt-2" class="headerlink" title="1、10右移&gt;&gt;2"></a>1、10右移&gt;&gt;2</h3><p>10：0000 0000 0000 1010</p><p>结果: 0000 0000 0000 0010——&gt; 结果2</p><h3 id="2、-10右移-gt-gt-2"><a href="#2、-10右移-gt-gt-2" class="headerlink" title="2、-10右移&gt;&gt;2"></a>2、-10右移&gt;&gt;2</h3><p>-10：1111  1111  1111  0110</p><p>结果: 1111  1111 1111   1101</p><p>　　　　　 -1</p><p>​          1111  1111 1111   1100</p><p>​          取反，符号位不变</p><p>​           1000 0000 0000 0011</p><p>结果：-3</p><h2 id="七、-gt-gt-gt-无符号右移"><a href="#七、-gt-gt-gt-无符号右移" class="headerlink" title="七、&gt;&gt;&gt;(无符号右移)"></a><strong>七、&gt;&gt;&gt;(无符号右移)</strong></h2><p><strong>定义：将一个数的各二进制位全部右移N位，移到右边的低位被舍弃，对于无符号数高位补0，只是对32位和64位的值有意义。</strong></p><p>示例：</p><h3 id="1、-10-gt-gt-gt-2"><a href="#1、-10-gt-gt-gt-2" class="headerlink" title="1、-10&gt;&gt;&gt;2"></a>1、-10&gt;&gt;&gt;2</h3><p>-10：1111 1111 1111 1111 1111  1111  1111  0110  ——-&gt;由于&gt;&gt;&gt;只对32和64位有意义，所以把-10定义成32位的</p><p>结果: 0011  1111 1111 1111 1111 1111 1111 1101</p><p>　　　　　　-1</p><p>​          0011  1111 1111 1111 1111 1111 1111 1100</p><p>​             取反码(符号位不变，正数反码是其本身)</p><p>​         0011  1111 1111 1111 1111 1111 1111 1100</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap底层实现原理是什么?jdk8做了哪些优化?</title>
      <link href="/2020/03/13/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-jdk8%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/"/>
      <url>/2020/03/13/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-jdk8%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>HashMap 是使用频率最高的类型之一，同时也是面试经常被问到的问题之一，这是因为HashMap<br>的知识点有很多，同时它又属于Java基础知识的一部分，因此在面试中经常被问到。<br>本课时的面试题是，HashMap底层是如何实现的？在JDK1.8中它都做了哪些优化？<br><strong>典型回答</strong><br>在JDK1.7中HashMap是以数组加链表的形式组成的，JDK1.8之后新增了红黑树的组成结构，当链表大于8时，链表结构会转换成红黑树结构，它的组成结构如下图所示：</p><p><img data-src="1.png" alt="1"></p><p>数组中的元素我们称之为哈希桶，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line"> V value;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="keyword">this</span>.hash = hash;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">V oldValue = value;</span><br><span class="line">value = newValue;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"><span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">Objects.equals(value, e.getValue()))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出每个哈希桶中包含了四个字段：hash、key、value、next，其中next 表示链表的下一个节点。<br>JDK 1.8之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。</p><p><strong>考点分析</strong><br>上面大体介绍了HashMap的组成结构，但面试官想要知道的远远不止这些，和HashMap相关的面试题还有以下几个：</p><ul><li>JDK 1.8 HashMap 扩容时做了哪些优化？</li><li>加载因子为什么是0.75？</li><li>当有哈希冲突时，HashMap是如何查找并确认元素的？</li><li>HashMap 源码中有哪些重要的方法？</li><li>HashMap是如何导致死循环的？</li></ul><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="1-HashMap源码分析"><a href="#1-HashMap源码分析" class="headerlink" title="1.HashMap源码分析"></a>1.HashMap源码分析</h3><p>声明：本系列课程在未做特殊说明的情况下，都是以目前主流的JDK版本1.8为例来进行源码分析的。</p><p>HashMap源码中包含了以下几个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 初始化长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 最大长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的加载因子 (扩容因子)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换红黑树的临界值，当链表长度大于此值时，会把链表结构转换为红黑树结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换链表的临界值，当元素小于此值时，会将红黑树结构转换成链表结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小树容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY =</span><br></pre></td></tr></table></figure><p><strong>什么是加载因子？加载因子为什么是0.75？</strong><br>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是0.5，HashMap<br>的初始化容量是16，那么当HashMap中有16*0.5=8个元素时，HashMap就会进行扩容。</p><p><strong>那加载因子为什么是0.75而不是0.5或者1.0呢？</strong><br>这其实是出于容量和性能之间平衡的结果：</p><ul><li>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</li><li>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</li></ul><p>所以综合了以上情况就取了一个0.5到1.0的平均数0.75作为加载因子。</p><p>HashMap源码中三个重要方法：<strong>查询</strong>、<strong>新增</strong>和<strong>数据扩容</strong>。<br>先来看查询源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 对 key 进行哈希操作</span></span><br><span class="line"><span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"><span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个元素是否是要查询的元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 下一个节点非空判断</span></span><br><span class="line"><span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果第一节点是树结构，则使用 getTreeNode 直接获取相应的数据</span></span><br><span class="line"><span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// 非树结构，循环节点判断</span></span><br><span class="line">                <span class="comment">// hash 相等并且 key 相同，则返回此节点</span></span><br><span class="line"> <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，当哈希冲突时我们需要通过判断key值是否相等，才能确认此元素是不是我们想要的元素。<br>HashMap第二个重要方法：<strong>新增方法</strong>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对 key 进行哈希操作</span></span><br><span class="line"><span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 哈希表为空则创建表  </span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"> <span class="comment">// 根据 key 的哈希值计算出要插入的数组索引 i    </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line"> <span class="comment">// 如果 table[i] 等于 null，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">// 如果 key 已经存在了，直接覆盖 value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"> <span class="comment">// 如果 key 不存在，判断是否为红黑树     </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="comment">// 红黑树直接插入键值对</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 为链表结构，循环准备插入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 下一个元素为空时</span></span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度大于 8 转换为红黑树进行处理</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> <span class="comment">//  key 已经存在直接覆盖 value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过最大容量，扩容</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增方法的执行流程，如下图所示：</p><p><img data-src="2.png" alt="2"></p><p>HashMap 第三个重要的方法是扩容方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 扩容前的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 扩容前的数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 预定义新数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩大容量为当前容量的两倍，但不能超过 MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 当前数组没有数据，使用初始化的值</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 如果初始化的值为 0，则使用默认的初始化容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的容量等于 0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">     Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 开始扩容，将新的容量赋值给 table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 原数据不为空，将原数据复制到新 table 中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据容量循环数组，复制非空元素到新 table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果链表只有一个，则进行直接赋值</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 红黑树相关的操作</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表复制，JDK 1.8 扩容优化部分</span></span><br><span class="line">                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                         <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                             &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将原索引放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="comment">// 将原索引 + oldCap 放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，JDK1.8在扩容时并没有像JDK1.7那样，重新计算每个元素的哈希值，而是通过高位运算（e.hash&amp;oldCap）来确定元素是否需要移动，比如key1的信息如下：</p><ul><li>key1.hash=10 0000 1010</li><li>oldCap=16 00010000</li></ul><p>使用e.hash&amp;oldCap得到的结果高一位为0，当结果为0时表示元素在扩容时位置不会发生任何变化，而key 2信息如下：</p><ul><li>key2.hash=10 0001 0001</li><li>oldCap=1600010000</li></ul><p>这时候得到的结果高一位为1，当结果为1时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置+原数组长度，如下图所示：</p><p><img data-src="3.png" alt="3"></p><p>其中红色的虚线图代表了扩容时元素移动的位置。</p><h3 id="2-HashMap-死循环分析"><a href="#2-HashMap-死循环分析" class="headerlink" title="2.HashMap 死循环分析"></a>2.HashMap 死循环分析</h3><p>以JDK1.7为例，假设HashMap默认大小为2，原本HashMap中有一个元素key（5），我们再使用两个线程：t1添加元素key（3），t2添加元素key（7），当元素key（3）和key（7）都添加到HashMap<br>中之后，线程t1在执行到Entry&lt;K，V&gt;next=e.next；时，交出了CPU的使用权，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程一执行此处</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此时线程t1中的e指向了key（3），而next 指向了key（7）；之后线程t2重新rehash 之后链表的顺序被反转，链表的位置变成了key（5）→key（7）→key（3），其中“→”用来表示下一个元素。<br>当t1重新获得执行权之后，先执行newTalbe[i]=e把key（3）的next 设置为key（7），而下次循环时查询到key（7）的next 元素为key（3），于是就形成了key（3）和key（7）的循环引用，因此就导致了死循环的发生，如下图所示：</p><p><img data-src="4.png" alt="4"></p><p>当然发生死循环的原因是JDK1.7链表插入方式为首部倒序插入，这个问题在JDK1.8得到了改善，变成了尾部正序插入。<br>有人曾经把这个问题反馈给了Sun公司，但Sun公司认为这不是一个问题，因为HashMap本身就是非线程安全的，如果要在多线程下，建议使用ConcurrentHashMap替代，但这个问题在面试中被问到的几率依然很大，所以在这里需要特别说明一下。</p><p><strong>小结</strong></p><p>本课时介绍了HashMap的底层数据结构，在JDK1.7时HashMap是由数组和链表组成的，而JDK<br>1.8则新增了红黑树结构，当链表的长度大于8时会转换为红黑树存储，以提升元素的操作性能。同时还介绍了HashMap的三个重要方法，查询、添加和扩容，以及JDK1.7 resize0在并发环境下导致死循环的原因。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 美团点评2020校招后台开发方向笔试题 </title>
      <link href="/2020/03/12/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%842020%E6%A0%A1%E6%8B%9B%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2020/03/12/%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%842020%E6%A0%A1%E6%8B%9B%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-RESTful调用和-RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service-Mesh，如果了解Service-Mesh是用来解决什么问题的？"><a href="#1-RESTful调用和-RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service-Mesh，如果了解Service-Mesh是用来解决什么问题的？" class="headerlink" title="1.RESTful调用和 RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service Mesh，如果了解Service Mesh是用来解决什么问题的？"></a>1.RESTful调用和 RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service Mesh，如果了解Service Mesh是用来解决什么问题的？</h3><p>1、RESTful<strong>是一种软件架构风格</strong>，<strong>用于约束客户端和服务器交互</strong>，满足这些约束条件和原则的应用程序或设计就是 RESTful。比如HTTP协议使用同一个URL地址，通过GET，POST，PUT，DELETE等方式实现查询、提交、删除数据。</p><p>RPC是<strong>远程过程调用</strong>，是用于<strong>解决分布式系统服务间调用的一种方式</strong>。RPC采用客户端与服务端模式，双方通过约定的接口（常见为通过IDL定义或者是代码定义）以类似本地方法调用的方式来进行交互，客户端根据约定传输调用函数+参数给服务端（一般是网络传输TCP/UDP），服务端处理完按照约定将返回值返回给客户端。</p><p><strong>重点为RESTful HTTP的约束风格，RPC调用模型。</strong></p><p>1、可分为两大部分RPC +服务治理<br>RPC部分 = IDL  +客户端/服务端实现层  +协议层 +数据传输层<br>服务治理 =服务管理（注册中心） +服务监控 +服务容灾 +服务鉴权</p><p>2、 Service Mesh为了解决传统微服务框架”胖客户端”方式，引入的如下问题：<br>与业务无关的服务治理逻辑与业务代码强耦合，框架、SDK的升级与业务代码强绑定，多语言的胖客户端支持起来性价比极低。</p><h3 id="2-请描述避免多线程竞争时有哪些手段？"><a href="#2-请描述避免多线程竞争时有哪些手段？" class="headerlink" title="2.请描述避免多线程竞争时有哪些手段？"></a>2.请描述避免多线程竞争时有哪些手段？</h3><p>1) 不可变对象；</p><p>2) 互斥锁；</p><p>3)  ThreadLocal 对象；</p><p>4) CAS；</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p><strong>给出一个布尔表达式的字符串，比如：true or false and false，表达式只包含true，false，and和or，现在要对这个表达式进行布尔求值，计算结果为真时输出true、为假时输出false，不合法的表达时输出error（比如：true true）。表达式求值是注意and 的优先级比 or 要高，比如：true or false and false，等价于 true or (false and false)，计算结果是 true。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">        String str = cal();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine().trim();</span><br><span class="line"><span class="comment">//        String str = "false&amp;nbs***bsp;true and false";</span></span><br><span class="line">        String[] words = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(words));</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].equals(<span class="string">"true"</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(<span class="string">"false"</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(<span class="string">"and"</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() != <span class="number">2</span> &amp;&amp; i != words.length - <span class="number">1</span></span><br><span class="line">                        &amp;&amp; (words[i + <span class="number">1</span>].equals(<span class="string">"true"</span>) || words[i + <span class="number">1</span>].equals(<span class="string">"false"</span>)))&#123;</span><br><span class="line">                    <span class="keyword">int</span> val = words[i + <span class="number">1</span>].equals(<span class="string">"true"</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                    stack.push(stack.pop() &amp; val);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(words[i].equals(<span class="string">"or"</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(last == -<span class="number">1</span>)&#123;</span><br><span class="line">                last = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(last == <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> or = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(or != <span class="number">2</span>) <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">                <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() != <span class="number">2</span>) val = stack.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">                last = last | val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last == <span class="number">1</span> ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>给出两个字符串，分别是模式串P和目标串T，判断模式串和目标串是否匹配，匹配输出 1，不匹配输出 0。模式串中‘？’可以匹配目标串中的任何字符，模式串中的 ’*’可以匹配目标串中的任何长度的串，模式串的其它字符必须和目标串的字符匹配。例如P=a?b，T=acb，则P 和 T 匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String p = sc.next();</span><br><span class="line">        String s = sc.next();</span><br><span class="line">        <span class="comment">// System.out.println(s + " - " + p);</span></span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; p.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((dp[m][n] ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      <categories>
          
          <category> 牛客真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String的特点是什么？它有哪些重要的方法？</title>
      <link href="/2020/03/11/String%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%20%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/11/String%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%20%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>几乎所有的Java面试都是以String开始的，如果第一个问题没有回答好，则会给面试官留下非常不好的第一印象，而糟糕的第一印象则会直接影响到自己的面试结果，就好像刚破壳的小鹅一样，会把第一眼看到的动物当成自己的母亲，即使它第一眼看到的是一只小狗或小猫，也会默认跟随其后，心理学把这种现象叫做<strong>印刻效应</strong>。印刻效应不仅存在于低等动物之中，同样也适用于人类，所以对于String的知识，我们必须深入的掌握才能为自己赢得更多的筹码。</p><p>本课时的问题是：String 是如何实现的？它有哪些重要的方法？</p><h3 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a><strong>典型回答</strong></h3><p>以主流的JDK版本1.8来说，String内部实际存储结构为char数组，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;，<span class="title">CharSequence</span></span>&#123;</span><br><span class="line">    <span class="comment">//用于存储字符串的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value [];</span><br><span class="line">    <span class="comment">//缓存字符串的 hash code </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;<span class="comment">//Default to 0</span></span><br><span class="line">    <span class="comment">//..其他内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 源码中包含下面几个重要的方法。</p><h3 id="1-多构造方法"><a href="#1-多构造方法" class="headerlink" title="1.多构造方法"></a>1.多构造方法</h3><p>String字符串有以下4个重要的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value =original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash =original.hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char[]为参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value=Arrays.copyof(value，value<span class="number">.1</span>ength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StringBuffer为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(buffer)&#123;</span><br><span class="line"><span class="keyword">this</span>.value=Arrays.copyof（buffer.getValue()，buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stringBuilder为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value =Arrays.copyof(builder.getValue()，builder<span class="number">.1</span>ength());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，比较容易被我们忽略的是以StringBuffer和StringBuilder为参数的构造函数，因为这三种数据类型，我们通常都是单独使用的，所以这个小细节我们需要特别留意一下。</p><h3 id="2-equals（）比较两个字符串是否相等"><a href="#2-equals（）比较两个字符串是否相等" class="headerlink" title="2.equals（）比较两个字符串是否相等"></a>2.equals（）比较两个字符串是否相等</h3><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对象引用相同直接返回 true </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==anObject)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断需要对比的值是否为String类型，如果不是则直接返回false </span></span><br><span class="line">    <span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">        String anotherString=(String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span>(n == anotherString.value.length)&#123;</span><br><span class="line">    <span class="comment">//把两个字符串都转换为char数组对比</span></span><br><span class="line">    <span class="keyword">char</span> vl[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环比对两个字符串的每一个字符</span></span><br><span class="line">    <span class="keyword">while</span>（n-- != <span class="number">0</span>）&#123;</span><br><span class="line">    <span class="comment">//如果其中有一个字符不相等就 true false，否则继续对比</span></span><br><span class="line">                <span class="keyword">if</span>(vl[i] != v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 类型重写了Object中的equals(）方法，equals(）方法需要传递一个Object类型的参数值，在比较时会先通过instanceof 判断是否为String 类型，如果不是则会直接返回false，instanceof的使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object oString=<span class="string">"123"</span>;</span><br><span class="line">Object oInt =<span class="number">123</span>;</span><br><span class="line">System.out.println(oString <span class="keyword">instanceof</span> String);<span class="comment">//返回 true</span></span><br><span class="line">System.out.println(oInt <span class="keyword">instanceof</span> String);<span class="comment">//返回false</span></span><br></pre></td></tr></table></figure><p>当判断参数为String类型之后，会循环对比两个字符串中的每一个字符，当所有字符都相等时返回true，否则则返回false。<br>还有一个和equals0比较类似的方法equalslgnoreCase0，它是用于忽略字符串的大小写之后进行字符串对比。</p><h3 id="3-compareTo（）比较两个字符串"><a href="#3-compareTo（）比较两个字符串" class="headerlink" title="3.compareTo（）比较两个字符串"></a>3.compareTo（）比较两个字符串</h3><p>compareTo0方法用于比较两个字符串，返回的结果为int类型的值，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenl=value.length;</span><br><span class="line">    <span class="keyword">int</span> len2=anotherString.value.length;</span><br><span class="line">    <span class="comment">//获取到两个字符串长度最短的那个int值</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">1</span>im=Math.min(<span class="number">1</span>en1，<span class="number">1</span>en2);</span><br><span class="line">    <span class="keyword">char</span> vl[]=value;</span><br><span class="line">    <span class="keyword">char</span> v2[]=anotherString.value;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对比每一个字符</span></span><br><span class="line">    <span class="keyword">while</span>(k &lt; lim)&#123;</span><br><span class="line"><span class="keyword">char</span> cl=vl[k];</span><br><span class="line"><span class="keyword">char</span> c2=v2[k];</span><br><span class="line"><span class="keyword">if</span>（c1 != c2）&#123;</span><br><span class="line"><span class="comment">//有字符不相等就返回差值</span></span><br><span class="line"><span class="keyword">return</span> c1-c2;</span><br><span class="line">        &#125;</span><br><span class="line">k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>en1 - <span class="number">1</span>en2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，compareTo0方法会循环对比所有的字符，当两个字符串中有任意一个字符不相同时，则return char1-char2。比如，两个字符串分别存储的是1和2，返回的值是-1；如果存储的是1和1，则返回的值是0，如果存储的是2和1，则返回的值是1。<br>还有一个和compareTo0 比较类似的方法compareTolgnoreCase0，用于忽略大小写后比较两个字符串。<br>可以看出compareTo0方法和equals0方法都是用于比较两个字符串的，但它们有两点不同：</p><ul><li>equals0可以接收一个Object 类型的参数，而compareTo0只能接收一个String类型的参数；    </li><li>equals0返回值为Boolean，而compareTo0的返回值则为int。</li></ul><p>它们都可以用于两个字符串的比较，当equals0方法返回true时，或者是compareTo0方法返回0时，则表示两个字符串完全相同。</p><h3 id="4-其他重要方法"><a href="#4-其他重要方法" class="headerlink" title="4.其他重要方法"></a>4.其他重要方法</h3><ul><li>indexOf(）：查询字符串首次出现的下标位置</li><li>lastlndexOf()：查询字符串最后出现的下标位置</li><li>contains()：查询字符串中是否包含另一个字符串</li><li>toLowerCase()：把字符串全部转换成小写</li><li>toUpperCase()：把字符串全部转换成大写</li><li>length()：查询字符串的长度</li><li>trim()：去掉字符串首尾空格</li><li>replace()：替换字符串中的某些字符</li><li>split()：把字符串分割并返回字符串数组</li><li>join()：把字符串数组转为字符串</li></ul><p><strong>考点分析</strong></p><p>这道题目考察的重点是，你对Java 源码的理解，这也从侧面反应了你是否热爱和喜欢专研程序，而这正是一个优秀程序员所必备的特质。<br>String 源码属于所有源码中最基础、最简单的一个，对String源码的理解也反应了你的Java基础功底。<br>String问题如果再延伸一下，会问到一些更多的知识细节，这也是大厂一贯使用的面试策略，从一个知识点入手然后扩充更多的知识细节，对于String也不例外，通常还会关联的询问以下问题：</p><ul><li>为什么String 类型要用final修饰？</li><li>==和equals的区别是什么？</li><li>String和StringBuilder、StringBuffer 有什么区别？</li><li>String的intern()方法有什么含义？</li><li>String 类型在 JVM（Java虚拟机）中是如何存储的？编译器对String做了哪些优化？</li></ul><p>接下来我们一起来看这些问题的答案。</p><h4 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a><strong>知识拓展</strong></h4><h5 id="1-和equals的区别"><a href="#1-和equals的区别" class="headerlink" title="1.==和equals的区别"></a>1.==和equals的区别</h5><p>==对于基本数据类型来说，是用于比较“值”是否相等的；而对于引用类型来说，是用于比较引用地址是否相同的。<br>查看源码我们可以知道Object中也有equals0方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Object中的equals0方法其实就是==，而String重写了equals0方法把它修改成比较两个字符串的值是否相等。<br>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对象引用相同直接返回 true </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==anObject)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断需要对比的值是否为String类型，如果不是则直接返回false </span></span><br><span class="line">    <span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">        String anotherString=(String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span>(n == anotherString.value.length)&#123;</span><br><span class="line">    <span class="comment">//把两个字符串都转换为char数组对比</span></span><br><span class="line">    <span class="keyword">char</span> vl[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环比对两个字符串的每一个字符</span></span><br><span class="line">    <span class="keyword">while</span>（n-- != <span class="number">0</span>）&#123;</span><br><span class="line">    <span class="comment">//如果其中有一个字符不相等就 true false，否则继续对比</span></span><br><span class="line">                <span class="keyword">if</span>(vl[i] != v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-final-修饰的好处"><a href="#2-final-修饰的好处" class="headerlink" title="2.final 修饰的好处"></a>2.final 修饰的好处</h5><p>从String类的源码我们可以看出String是被final修饰的不可继承类，源码如下：</p><p>Java 语言之父James Gosling的回答是，他会更倾向于使用final，因为它能够缓存结果，当你在传参时不需要考虑谁会修改它的值；如果是可变类的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上就会有一定的损失。<br>James Gosling 还说迫使String类设计成不可变的另一个原因是安全，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，它的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题，这是迫使String类设计成不可变类的一个重要原因。<br>总结来说，使用final修饰的第一个好处是安全；第二个好处是高效，以JVM中的字符串常量池来举例，如下两个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"java"</span>;</span><br><span class="line">String s2 = <span class="string">"java"</span>;</span><br></pre></td></tr></table></figure><p>只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如下图所示：</p><p><img data-src="1.png" alt="1"></p><p>试想一下如果String是可变的，那当s1的值修改之后，52的值也跟着改变了，这样就和我们预期的结果不相符了，因此也就没有办法实现字符串常量池的功能了。</p><h5 id="3-String-和StringBuilder、StringBuffer的区别"><a href="#3-String-和StringBuilder、StringBuffer的区别" class="headerlink" title="3.String 和StringBuilder、StringBuffer的区别"></a>3.String 和StringBuilder、StringBuffer的区别</h5><p>因为String类型是不可变的，所以在字符串拼接的时候如果使用String的话性能会很低，因此我们就需要使用另一个数据类型 StringBuffer，它提供了append和insert方法可用于字符串的拼接，它使用synchronized来保证线程安全，如下源码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    toStringCache =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    toStringCache =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为它使用了synchronized来保证线程安全，所以性能不是很高，于是在JDK1.5就有了StringBuilder，它同样提供了append和insert的拼接方法，但它没有使用synchronized来修饰，因此在性能上要优于StringBufer，所以在非并发操作的环境下可使用 StringBuilder来进行字符串拼接。</p><h5 id="4-String-和JVM"><a href="#4-String-和JVM" class="headerlink" title="4.String 和JVM"></a>4.String 和JVM</h5><p>String 常见的创建方式有两种，直接赋值的方式”String s1=”Java”；”和“Strings2=new String（”Java”）；”的方式，但两者在JVM的存储区域却截然不同，在JDK1.8中，变量s1会先去字符串常量池中找字符串“Java”，如果有相同的字符则直接返回常量句柄，如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量s2是直接在堆上创建一个变量，如果调用<br>intern方法才会把此字符串保存到常量池中，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String sl =<span class="keyword">new</span> String(<span class="string">"Java"</span>); </span><br><span class="line">String s2=s1.intern();</span><br><span class="line">String s3=<span class="string">"Java"</span>;</span><br><span class="line">System.out.println(s1 ==s2);<span class="comment">//false </span></span><br><span class="line">System.out.println(s2 ==s3);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>它们在 JVM 存储的位置，如下图所示：</p><p><img data-src="2.png" alt="2"></p><p>注：JDK1.7之后把永生代换成的元空间，把字符串常量池从方法区移到了Java堆上。<br>除此之外编译器还会对String字符串做一些优化，例如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Ja"</span> + <span class="string">"va"</span>;</span><br><span class="line">String s2 = <span class="string">"Java"</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure><p>虽然51拼接了多个字符串，但对比的结果却是true，我们使用反编译工具，看到的结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"StringExample.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">lagou</span>.<span class="title">interview</span>.<span class="title">StringExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> com.lagou.interview.StringExample();</span><br><span class="line">Code:</span><br><span class="line">            <span class="number">0</span>:aload_0</span><br><span class="line">            1:invokespecial #1//Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">            <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">       LineNumberTable:</span><br><span class="line">     line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">0: ldc           #2                  // String Java</span><br><span class="line"><span class="number">2</span>: astore_1</span><br><span class="line">       3: ldc           #2                  // String Java</span><br><span class="line"><span class="number">5</span>:astore_2</span><br><span class="line">        6:getstatic     #3 //Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"><span class="number">9</span>: aload_1</span><br><span class="line"> <span class="number">10</span>: aload_2</span><br><span class="line">        <span class="number">11</span>: if_acmpne     <span class="number">18</span></span><br><span class="line">        <span class="number">14</span>: iconst_1</span><br><span class="line">        <span class="number">15</span>: goto          <span class="number">19</span></span><br><span class="line">        <span class="number">18</span>: iconst_0</span><br><span class="line">      19: invokevirtual #4  </span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">        LineNumberTable:</span><br><span class="line">        <span class="number">1</span>ine <span class="number">5</span>:<span class="number">0</span></span><br><span class="line">        <span class="number">1</span>ine <span class="number">6</span>:<span class="number">3</span></span><br><span class="line">        line <span class="number">7</span>:<span class="number">6</span></span><br><span class="line">        <span class="number">1</span>ine <span class="number">8</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从编译代码#2可以看出，代码“Ja”+”va”被直接编译成了“Java”，因此s1==s2的结果才是<br>true，这就是编译器对字符串优化的结果。<br>小结<br>本课时从String 的源码入手，重点讲了String的构造方法、equals0方法和compareTo())方法，其中equals(）重写了Object的equals())方法，把引用对比改成了字符串值对比，也介绍了final修饰String的好处，可以提高效率和增强安全性，同时我们还介绍了String和JVM的一些执行细节。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】检索方式与检索策略</title>
      <link href="/2020/03/11/hibernate%E6%A3%80%E7%B4%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5/"/>
      <url>/2020/03/11/hibernate%E6%A3%80%E7%B4%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>Hibernate的Session在加载Java对象时，一般都会把这个对象相关联的其他Java对象也都加载到缓存中，以方便程序的调用。但很多情况下，我们不需要加载太多无用的对象到缓存中，一来会占用大量的内存，二来会增加数据库的访问次数，使得程序的运行效率降低。为了合理的使用缓存，Hibernate提供了不同的检索策略来解决这些问题。</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h1><p>在说检索策略之前，先了解一下检索策略的作用域，它分为：类级别和关联级别。类级别的作用域在检索数据时，检索的数据只包含一个类对象，不涉及与该类关联的其他对象。关联级别的作用域检索的数据包含相关联的多个类的对象，例如，Customer对象与Orders对象存在关系，检索到一个Customer对象后，还会涉及与之关联的Orders对象。</p><p><img data-src="1.png" alt="1"></p><h1 id="检索策略"><a href="#检索策略" class="headerlink" title="检索策略"></a><strong>检索策略</strong></h1><p>Hibernate的检索策略分为三种，立即检索、延迟检索、左外连接检索。</p><h3 id="立即检索"><a href="#立即检索" class="headerlink" title="立即检索"></a><strong>立即检索</strong></h3><p> 采用立即检索策略，会把被检索的对象，以及和这个对象关联的一对多对象都加载到缓存中。Session的get方法就使用的立即检索策略。这种策略的优点在于，频繁使用的对象会被加载到缓存中，程序调用很方便，也很及时。缺点就是，占用的内存过多，而且数据库访问的次数也会很频繁，效率低下。</p><h3 id="延迟检索"><a href="#延迟检索" class="headerlink" title="延迟检索"></a><strong>延迟检索</strong></h3><p>采用延迟检索策略，就不会加载关联对象的内容。直到第一次调用关联对象时，才去加载关联对象。在不涉及关联类操作时，延迟检索策略只适用于Session的load方法。涉及关联类操作时，延迟检索策略也能够适用于get，list等操作。</p><p>在类级别操作时， 延迟检索策略，只加载类的OID不加载类的其他属性，只用当第一次访问其他属性时，才回访问数据库去加载内容。（这里使用了CGLIB生成了类的代理类）</p><p>在关联级别操作时，延迟检索策略，只加载类本身，不加载关联类，直到第一次调用关联对象时，才去加载关联对象。</p><p>程序模式都是用延迟加载策略。如果需要指定使用延迟加载策略。在配置文件中设置&lt;class&gt;的lazy=true，、&lt;set&gt;的lazy=true或extra（增强延迟）&lt;many-to-one&gt;的lazy=proxy和no-proxy。</p><p>  这种策略的优点在于，由程序决定加载哪些类和内容，而不必全部都加载，避免了内存的大量占用和数据库的频繁访问。缺点就是在Session关闭后，就不能访问关联类对象了。 需要确保Session一直处于打开状态，调用关联对象，最后在关闭Session对象。</p><h3 id="左外连接检索"><a href="#左外连接检索" class="headerlink" title="左外连接检索"></a><strong>左外连接检索</strong></h3><p>采用左外连接检索，能够使用sql的外连接查询，将需要加载的关联对象加载在缓存中。&lt;set&gt;fetch设置为join，&lt;many-to-one&gt;的fetch设置为join。</p><p>这种策略的优点在于，对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象。使用了外连接，select语句数目少。缺点就是可能会加载应用程序不需要访问的对象，白白浪费许多内存空间。复杂的数据库表连接也会影响检索性能。</p><p><img data-src="2.png" alt="2"></p><h1 id="检索方式"><a href="#检索方式" class="headerlink" title="检索方式"></a><strong>检索方式</strong></h1><p> Hibernate提供的检索方式为5种，分为导航对象图检索方式、OID检索方式、HQL检索方式、QBC检索方式、本地SQL检索方式。</p><h3 id="导航对象图检索方式"><a href="#导航对象图检索方式" class="headerlink" title="导航对象图检索方式"></a><strong>导航对象图检索方式</strong></h3><p>利用类与类之间的关系来检索对象。譬如我们要查找一份订单，就可以由订单对象自动导航找到订单所属的客户对象。当然，前提是必须在对象-关系映射文件上配置了它们的多对一的关系。</p><h3 id="OID检索方式"><a href="#OID检索方式" class="headerlink" title="OID检索方式"></a><strong>OID检索方式</strong></h3><p>主要指用Session的get()和load()方法加载某条记录对应的对象。</p><h3 id="HQL检索方式"><a href="#HQL检索方式" class="headerlink" title="HQL检索方式"></a><strong>HQL检索方式</strong></h3><p> HQL（Hibernate Query Language）是面向对象的查询语言，它和SQL查询语言有些相似。在Hibernate提供的各种检索方式中，HQL是使用最广的一种检索方式。它具有以下功能：</p><p>&emsp;    在查询语句中设定各种查询条件。</p><p>&emsp;    支持投影查询，即仅检索出对象的部分属性。<br>&emsp;    支持分页查询。<br>&emsp;    支持分组查询，允许使用group by和having关键字。<br>&emsp;    提供内置聚集函数，如sum()、min()和max()。<br>&emsp;    能够调用用户定义的SQL函数。<br>&emsp;    支持子查询，即嵌套查询。<br>&emsp;    支持动态绑定参数。</p><p>   Session类的Qurey接口支持HQL检索方式，它提供了以上列出的各种查询功能。</p><p><strong>注:</strong>Qurey接口支持方法链编程风格，它的set方法都返回自身实例，而不是返回void类型。方法链编程风格能使程序代码更加简洁。</p><p><strong>例：</strong></p><p>检索USER 表的所有记录</p><p>—-HQL语句中关键字大小写无关，但习惯将关键字小写。</p><p>—-from 关键字后面是类名不是数据库表名，类名需区分大小写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Query query = session.createQuery(<span class="string">"from User"</span>);</span><br><span class="line">List userList = query.list();</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"select u from User u"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">List userList = query.list();</span><br></pre></td></tr></table></figure><p>where 子句</p><p>—where子句中给出的是类的属性名而不是数据库表字段名，其中属性名必须区分大小写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from User where userName='张三'"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">List userList = query.list();</span><br></pre></td></tr></table></figure><p>HQL支持的各种运算符</p><table><thead><tr><th align="center"><strong>程序中指定的连接类型</strong></th><th align="center"><strong>HQL**</strong>运算符**</th></tr></thead><tbody><tr><td align="center">比较运算符</td><td align="center">=、&lt;&gt;、&gt;=、&lt;=、&gt;、&lt;、is null、is not null</td></tr><tr><td align="center">范围运算符</td><td align="center">in、not in、between…and、not between…and</td></tr><tr><td align="center">字符串模式匹配运算符</td><td align="center">like</td></tr><tr><td align="center">逻辑运算符</td><td align="center">and、or、not</td></tr></tbody></table><h4 id="HQL检索单个对象"><a href="#HQL检索单个对象" class="headerlink" title="HQL检索单个对象"></a>HQL检索单个对象</h4><p>list()：返回List类型的查询结果，返回所有满足条件的对象。</p><p>uniqueResult()：返回单个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Query query = session.createQuery(<span class="string">"from User u</span></span><br><span class="line"><span class="string">                      where u.userName='张三'"</span>);</span><br><span class="line">User user = (User)query.uniqueResult();</span><br></pre></td></tr></table></figure><h4 id="HQL参数绑定"><a href="#HQL参数绑定" class="headerlink" title="HQL参数绑定"></a>HQL参数绑定</h4><h5 id="在HQL查询语句中按照参数位置绑定参数"><a href="#在HQL查询语句中按照参数位置绑定参数" class="headerlink" title="在HQL查询语句中按照参数位置绑定参数"></a>在HQL查询语句中按照参数位置绑定参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from User u where u.userName=?"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">query.setParameter(<span class="number">0</span>, <span class="string">"张三"</span>);</span><br><span class="line">List&lt;User&gt; userList = query.list();</span><br></pre></td></tr></table></figure><h5 id="在HQL查询语句中按参数名称绑定参数。"><a href="#在HQL查询语句中按参数名称绑定参数。" class="headerlink" title="在HQL查询语句中按参数名称绑定参数。"></a>在HQL查询语句中按参数名称绑定参数。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String hql = <span class="string">"from User u </span></span><br><span class="line"><span class="string">        where u.userName=:name"</span>;</span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">query.setParameter(<span class="string">"name"</span>, <span class="string">"张三"</span>);</span><br><span class="line">List&lt;User&gt; userList = query.list();</span><br></pre></td></tr></table></figure><h5 id="HQL的绑定参数方法"><a href="#HQL的绑定参数方法" class="headerlink" title="HQL的绑定参数方法"></a>HQL的绑定参数方法</h5><p>setParamter() 绑定任意类型的参数。</p><p>setProperties(Object bean) 用于把命名参数与一个对象的属性值绑定，并且参数名称要与对象属性名称一致。</p><p>setProperties(Map bean)用于把命名参数与一个Map类型的对象的value值绑定，并且参数名称要与Map类型的对象的key值一致。</p><h4 id="HQL实体更新"><a href="#HQL实体更新" class="headerlink" title="HQL实体更新"></a>HQL实体更新</h4><h5 id="不使用HQL的实体更新。"><a href="#不使用HQL的实体更新。" class="headerlink" title="不使用HQL的实体更新。"></a>不使用HQL的实体更新。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">User user = (User) session.get(User<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line">user.setUserName(<span class="string">"Tom"</span>);</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><h5 id="HQL实现实体更新的方式"><a href="#HQL实现实体更新的方式" class="headerlink" title="HQL实现实体更新的方式"></a>HQL实现实体更新的方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">String hql = <span class="string">"update User set userName='Tom' </span></span><br><span class="line"><span class="string">        where id=2"</span>; </span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line"><span class="keyword">int</span> ret = query.executeUpdate();</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><h4 id="HQL实体删除"><a href="#HQL实体删除" class="headerlink" title="HQL实体删除"></a>HQL实体删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">String hql = <span class="string">"delete from User where id = 1"</span>;</span><br><span class="line">Query query  = session.createQuery(hql);</span><br><span class="line"><span class="keyword">int</span> ret = query.executeUpdate();</span><br><span class="line">tx .commit();</span><br></pre></td></tr></table></figure><h4 id="HQL子查询"><a href="#HQL子查询" class="headerlink" title="HQL子查询"></a>HQL子查询</h4><p>HQL支持在 where 子句中嵌入子查询语句，并且子查询语句必须放在括号内。</p><p>查询订单数量大于0的所有用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> u </span><br><span class="line"><span class="keyword">where</span> <span class="number">0</span>&lt;(<span class="keyword">select</span> <span class="keyword">count</span>(o) <span class="keyword">from</span> orders o </span><br><span class="line">         <span class="keyword">where</span> u.id=o.userId )</span><br></pre></td></tr></table></figure><p>如果HQL子查询的是集合，HQL提供了一组操作集合的函数:</p><p>size()，获得集合中元素的个数；</p><p>maxIndex()，对于建立索引的集合，获得最大索引值；</p><p>minIndex()，对于建立索引的集合，获得最小索引值；</p><p>elements()，获得集合中所有元素。</p><h3 id="QBC检索方式"><a href="#QBC检索方式" class="headerlink" title="QBC检索方式"></a><strong>QBC检索方式</strong></h3><p>采用HQL检索方式时，在应用程序中需要定义基于字符串形式的HQL查询语句。QBC API提供了检索对象的另一种方式，它主要由Criteria接口、Criterion接口和Expression类组成，它支持在运行时动态生成查询语句。</p><p>检索姓名为张三 的所有用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria=session.createCriteria(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Criterion c1= Restrictions.eq(<span class="string">"userName"</span>, <span class="string">"张三"</span>);</span><br><span class="line">criteria.add(c1);</span><br><span class="line">List result = criteria.list();</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>运算类型</strong></th><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>范围运算符</td><td>Restrictions.in</td><td>等于列表中的某个值</td></tr><tr><td></td><td>Restrictions.not(Restrictions.in)</td><td>不等于列表中的任意值</td></tr><tr><td></td><td>Restrictions.between</td><td>大于等于值1小于等于值2</td></tr><tr><td>字符串模糊匹配</td><td>Restrictions.like</td><td>字符串模糊匹配   like</td></tr><tr><td>逻辑运算符</td><td>Restrictions.and</td><td>逻辑与</td></tr><tr><td></td><td>Restrictions.or</td><td>逻辑或</td></tr><tr><td></td><td>Restrictions.not</td><td>逻辑非</td></tr><tr><td>比较运算符</td><td>Restrictions.eq</td><td>等于</td></tr><tr><td></td><td>Restrictions.ne</td><td>不等于</td></tr><tr><td></td><td>Restrictions.gt</td><td>大于</td></tr><tr><td></td><td>Restrictions.ge</td><td>大于等于</td></tr><tr><td></td><td>Restrictions.lt</td><td>小于</td></tr><tr><td></td><td>Restrictions.le</td><td>小于等于</td></tr><tr><td></td><td>Restrictions.isNull</td><td>等于空值</td></tr><tr><td></td><td>Restrictions.isNotNull</td><td>非空值</td></tr></tbody></table><h3 id="本地SQL检索方式"><a href="#本地SQL检索方式" class="headerlink" title="本地SQL检索方式"></a><strong>本地SQL检索方式</strong></h3><p>采用HQL或QBC检索方式时，Hibernate生成标准的SQL查询语句，使用于所有的数据库平台，因此这两种检索方式都是跨平台的。有的应用程序可能需要根据底层数据库的SQL方言，来生成一些特殊的查询语句。在这种情况下，可以利用Hibernate提供的SQL检索方式。</p><p>查询所有的用户信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from  user"</span>;</span><br><span class="line">NativeQuery query = session.createNativeQuery(sql, </span><br><span class="line">    User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">List list = query.list();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】一对一关联映射</title>
      <link href="/2020/03/10/hibernate%E4%B8%80%E5%AF%B9%E4%B8%80%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/10/hibernate%E4%B8%80%E5%AF%B9%E4%B8%80%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p><img data-src="1.png" alt="1"></p><h3 id="一-XML方式"><a href="#一-XML方式" class="headerlink" title="一.XML方式"></a>一.XML方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 标识一个类的xml映射,name为类名,table为表名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"Person"</span> <span class="attr">cascade</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Person.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"foreign"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"property"</span>&gt;</span>user<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idNumber"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">constrained</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过&lt;one-to-one&gt; 元素配置。</p><p>•constrained 属性为 true，表明 PERSON 表 ID 为外键，参照主表（USER）。</p><p>•外键表实体类配置文件中 OID 使用 foreign 生成策略。</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">User user  = <span class="keyword">new</span> User();</span><br><span class="line">user.setUserName(<span class="string">"zs"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"ls"</span>);</span><br><span class="line">person.setIdNumber(<span class="string">"2017011776"</span>);</span><br><span class="line">user.setPerson(person);</span><br><span class="line">person.setUser(user);</span><br><span class="line">session.save(user);</span><br><span class="line">session.save(person);</span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-注解方式"><a href="#二-注解方式" class="headerlink" title="二.注解方式"></a>二.注解方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@OneToOne</span>(cascade=CascadeType.ALL)</span><br><span class="line"><span class="meta">@PrimaryKeyJoinColumn</span>(name=<span class="string">"id"</span>)</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator = <span class="string">"foreign"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name = <span class="string">"foreign"</span>, strategy = <span class="string">"foreign"</span>, parameters = &#123;</span><br><span class="line"><span class="meta">@Parameter</span>(name = <span class="string">"property"</span>, value = <span class="string">"user"</span>) &#125;)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="meta">@OneToOne</span>(mappedBy=<span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-唯一外键关联"><a href="#三-唯一外键关联" class="headerlink" title="三.唯一外键关联"></a>三.唯一外键关联</h3><h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"person"</span> <span class="attr">column</span>=<span class="string">"PERSONID"</span> <span class="attr">cascade</span>=<span class="string">"all"</span> <span class="attr">unique</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Person.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"top.hiasenna.entity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Person"</span> <span class="attr">table</span>=<span class="string">"PERSON"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idNumber"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 外键关联方式映射与User的一对一关系   property-ref:外键列对应的属性名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">property-ref</span>=<span class="string">"person"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">User user  = <span class="keyword">new</span> User();</span><br><span class="line">user.setUserName(<span class="string">"zs"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"ls"</span>);</span><br><span class="line">person.setIdNumber(<span class="string">"2017011776"</span>);</span><br><span class="line">user.setPerson(person);</span><br><span class="line">person.setUser(user);</span><br><span class="line">session.save(user);</span><br><span class="line">session.save(person);</span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@OneToOne</span>(cascade=CascadeType.ALL)</span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"PERSONID"</span>)</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userName = userName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.person = person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br><span class="line"><span class="meta">@OneToOne</span>(mappedBy=<span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIdNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> idNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdNumber</span><span class="params">(String idNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.idNumber = idNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.user = user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-组合关系映射"><a href="#四-组合关系映射" class="headerlink" title="四.组合关系映射"></a>四.组合关系映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"contact"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment"</span>,strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"phoneNum"</span>)</span><br><span class="line"><span class="keyword">private</span> String tel;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"><span class="meta">@Embedded</span></span><br><span class="line"><span class="meta">@AttributeOverrides</span>(value=&#123;</span><br><span class="line">    <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"province"</span>, </span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_province"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"city"</span>,</span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_city"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"district"</span>,</span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_district"</span>)),</span><br><span class="line">        <span class="meta">@AttributeOverride</span>(</span><br><span class="line">            name = <span class="string">"detail"</span>,</span><br><span class="line">            column = <span class="meta">@Column</span>(name=<span class="string">"home_detail"</span>))&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Address homeAddress;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTel</span><span class="params">(String tel)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tel = tel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Address <span class="title">getHomeAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> homeAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHomeAddress</span><span class="params">(Address homeAddress)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.homeAddress = homeAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span><span class="comment">//指明为嵌入式类，不需要单独进行映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String province;</span><br><span class="line"><span class="keyword">private</span> String city;</span><br><span class="line"><span class="keyword">private</span> String district;</span><br><span class="line"><span class="keyword">private</span> String detail;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProvince</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> province;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProvince</span><span class="params">(String province)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.province = province;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> city;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCity</span><span class="params">(String city)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.city = city;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDistrict</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> district;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDistrict</span><span class="params">(String district)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.district = district;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> detail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDetail</span><span class="params">(String detail)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.detail = detail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Session session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line">Contact contact = <span class="keyword">new</span> Contact();</span><br><span class="line">contact.setEmail(<span class="string">"273903932@qq.com"</span>);</span><br><span class="line">contact.setTel(<span class="string">"12312123451"</span>);</span><br><span class="line">Address address = <span class="keyword">new</span> Address();</span><br><span class="line">address.setProvince(<span class="string">"河北省"</span>);</span><br><span class="line">address.setCity(<span class="string">"秦皇岛市"</span>);</span><br><span class="line">address.setDistrict(<span class="string">"昌黎县"</span>);</span><br><span class="line">address.setDetail(<span class="string">"黎昌尚府小区"</span>);</span><br><span class="line">contact.setHomeAddress(address); </span><br><span class="line">session.save(contact);</span><br><span class="line"></span><br><span class="line">tx.commit();</span><br><span class="line"> </span><br><span class="line">session.close();</span><br><span class="line">HibernateUtil.closeSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【hibernate】单实体映射</title>
      <link href="/2020/03/10/hibernate%E5%8D%95%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84/"/>
      <url>/2020/03/10/hibernate%E5%8D%95%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="Java程序中区分不同对象。"><a href="#Java程序中区分不同对象。" class="headerlink" title="Java程序中区分不同对象。"></a>Java程序中区分不同对象。</h3><p>​    <strong>1.Java语言中通过内存地址区分不同对象；</strong></p><p>​    <strong>2.两种比较引用变量方法；</strong></p><p>​        a. “==” 比较两个变量引用的内存地址是否相同；</p><p>​        b.  equals可以比较两个变量引用的对象的值是否相同。</p><p>​    <strong>3.用户自定义的类也可以覆盖Object的equals方法实现对象按值进行比较。</strong></p><h3 id="Hibernate-自带了很多种标识符生成器："><a href="#Hibernate-自带了很多种标识符生成器：" class="headerlink" title="Hibernate 自带了很多种标识符生成器："></a>Hibernate 自带了很多种标识符生成器：</h3><p><img data-src="1.png" alt="1"></p><p><strong>increment</strong>  采用 Hibernate 数值递增的方式,该机制是 Hibernate 以递增的方式为OID赋值。</p><p>&emsp;&emsp;&emsp;不依赖于底层数据库系统，适合所有数据库;</p><p>&emsp;&emsp;&emsp;适合单独的 Hibernate 应用使用，不适合在集群情况下使用。</p><p><strong>identity</strong> 采用数据库提供的自增长方式,该机制依赖于底层数据库，需要数据库支持自动增长字段。</p><p>&emsp;&emsp;&emsp;例如：MySQL、MSSQL、DB2、Sybase等。</p><p><strong>assigned</strong> 主键由应用逻辑产生；该机制是由外部程序负责生成OID,Hibernate 不负责维护主键生成，与Hibernate和底层数据库都无关。</p><p>&emsp;&emsp;例如：Student类没有定义 ID，而是以学号studentNo 作为业务主键。&emsp;</p><p><strong>sequence</strong> 采用数据库提供的序列方式；</p><p>hilo 通过hi/lo算法   // Hibernate 5.0 以后不支持；</p><p>seqhilo 通过hi/lo算法；</p><p>native 自动选择合适的标识符生成器；</p><p>uuid.hex 通过uuid算法。</p><h3 id="使用注解映射单实体"><a href="#使用注解映射单实体" class="headerlink" title="使用注解映射单实体"></a><strong>使用注解映射单实体</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"employee"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"increment_generator"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"increment_generator"</span>, strategy=<span class="string">"increment"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"name"</span>) </span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Entity：声明一个实体类。</p><p>@Table(name=”table_name”)：为实体类指定对应的数据库表。</p><p>@Id：声明实体类的OID属性。</p><p>@GeneratedValue(generator=”increment_generator”)：声明OID的生成策略。</p><p>@GenericGenerator(name=”increment_generator”, strategy=”increment”)：使用Hibernate提供的生成策略。</p><p>@Column(name=”columnName”) ：将属性映射到列。</p><p>@Access(AccessType.PROPERTY)：1.通过 getter 和 setter 方法访问实体类的属性；2.需要在 getter 方法上定义字段的属性。</p><p>@Access(AccessType.FIELD)：1.直接访问实体类的属性，可以不定义 getter 和 setter 方法；2.需要在变量上定义字段的属性。</p>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hibernate】搭建框架</title>
      <link href="/2020/03/10/hibernate%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/03/10/hibernate%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="初始框架搭建"><a href="#初始框架搭建" class="headerlink" title="初始框架搭建"></a>初始框架搭建</h1><h3 id="分层构系结构"><a href="#分层构系结构" class="headerlink" title="分层构系结构"></a>分层构系结构</h3><p>指的是将系统的组件分隔到不同的层中，每一层中的组件应保持内聚性；<br>每一层都应与它下面的各层保持松散耦合。</p><h3 id="三层体系结构"><a href="#三层体系结构" class="headerlink" title="三层体系结构"></a><strong>三层体系结构</strong></h3><p><img data-src="1583851295917.png" alt="1583851295917"></p><h3 id="持久化层是怎么来的"><a href="#持久化层是怎么来的" class="headerlink" title="持久化层是怎么来的"></a><strong>持久化层是怎么来的</strong></h3><p>为了把数据访问细节和业务逻辑分开，可以把数据访问作为单独的持久化层。</p><p><img data-src="1583851385990.png" alt="1583851385990"></p><h3 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h3><p><strong>瞬时状态</strong>：保存在内存的程序数据，程序退出后，数据就消失了，称为瞬时状态。</p><p><strong>持久状态</strong>：保存在数据库（磁盘）的程序数据，程序退出后，数据依然存在，称为程序数据的持久状态。</p><p><strong>持久化</strong>：将程序数据在瞬时状态和持久化状态之间转换的机制。</p><h3 id="MVC设计模式与四层结构的对应关系"><a href="#MVC设计模式与四层结构的对应关系" class="headerlink" title="MVC设计模式与四层结构的对应关系"></a>MVC设计模式与四层结构的对应关系</h3><p><img data-src="1583851508296.png" alt="1583851508296"></p><h3 id="持久化层的设计目标："><a href="#持久化层的设计目标：" class="headerlink" title="持久化层的设计目标："></a>持久化层的设计目标：</h3><p>1.代码可重用性高，能够完成对象持久化操作；</p><p>2.如果需要的话，能够支持多种数据库平台；</p><p>3.具有相对独立性，当持久层发生变化时，不会影响上层实现。</p><h3 id="Hibernate是什么？"><a href="#Hibernate是什么？" class="headerlink" title="Hibernate是什么？"></a>Hibernate是什么？</h3><p>1.在分层体系结构中Hibernate位于持久化层，是完成对象持久化的持久化层框架；</p><p>2.Hibernate是连接Java应用程序和关系型数据库的框架，能够建立对象模型和关系数据模型之间的映射，是一种自动ORM框架；</p><p>3.Hibernate是对JDBC API的封装，是JDBC轻量级封装框架。</p><h2 id="第一个Hibernate程序"><a href="#第一个Hibernate程序" class="headerlink" title="第一个Hibernate程序"></a>第一个Hibernate程序</h2><h4 id="1-引入jar包"><a href="#1-引入jar包" class="headerlink" title="1.引入jar包"></a>1.引入jar包</h4><p><img data-src="1583851888229.png" alt="1583851888229"></p><h4 id="2-项目目录结构"><a href="#2-项目目录结构" class="headerlink" title="2.项目目录结构"></a>2.项目目录结构</h4><p><img data-src="1583851908692.png" alt="1583851908692"></p><h4 id="3-hibernate-cfg-xml"><a href="#3-hibernate-cfg-xml" class="headerlink" title="3.hibernate.cfg.xml"></a>3.hibernate.cfg.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span> <span class="meta-string">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/hibernate_demo_db<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/hibernate/entity/Customer.hbm.xml"</span>/&gt;</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;mapping class="top.hiasenna.entity.User" /&gt;</span></span><br><span class="line"><span class="comment">&lt;mapping class="top.hiasenna.entity.Order" /&gt; </span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-编写持久化类"><a href="#4-编写持久化类" class="headerlink" title="4.编写持久化类"></a>4.编写持久化类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Customer [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-创建持久化类的配置文件"><a href="#5-创建持久化类的配置文件" class="headerlink" title="5.创建持久化类的配置文件"></a>5.创建持久化类的配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span> <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.hibernate.entity"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 标识一个类的xml映射,name为类名,table为表名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Customer"</span> <span class="attr">table</span>=<span class="string">"customer"</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 主键的设置,generator标识主键生成方式--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 这里配了该类一个属性街道名称 name属性字段,column,数据库对应列 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">column</span>=<span class="string">"name"</span> /&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 这里同上,写法不同而已 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"age"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="标签说明"><a href="#标签说明" class="headerlink" title="标签说明"></a>标签说明</h5><p>1.<strong>&lt;class&gt;</strong>元素用于指定类和表之间的映射</p><p>​        -name属性设定类名(包含路径)；</p><p>​        -table属性设定表名，默认以类名作表名。</p><p>2.<strong>id</strong> 子元素设定持久化类的OID和表的主键的映射关系</p><p>​        -column – 指定表字段的名称；</p><p>​        -generator – 元素指定OID的生成器。</p><p>3.<strong>property</strong>子元素设定类的其他属性和表的字段的映射关系</p><p>​        -name – 对应类的属性名称；</p><p>​        -type – 指定属性的类型；</p><p>​        -column – 指定表字段的名称；</p><p>​        -not-null – 指定属性是否允许为空。</p><p>6.HibernateUtil工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.MetadataSources;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistry;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtil</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">final</span> StandardServiceRegistry registry=<span class="keyword">new</span> StandardServiceRegistryBuilder().configure().build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sessionFactory=<span class="keyword">new</span> MetadataSources(registry).buildMetadata().buildSessionFactory();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">sessionFactory=<span class="keyword">null</span>;</span><br><span class="line">StandardServiceRegistryBuilder.destroy(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SessionFactory <span class="title">getSessionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sessionFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSessionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sessionFactory.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SSH】初始项目搭建流程</title>
      <link href="/2020/03/10/ssh%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/03/10/ssh%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="初始项目搭建流程"><a href="#初始项目搭建流程" class="headerlink" title="初始项目搭建流程"></a>初始项目搭建流程</h1><p>1.创建一个动态web项目</p><p><img data-src="1.png" alt="1"></p><p>接着点击next，勾选自动生成web.xml选项，最后点击finish。</p><p>2.在WEB-INF的lib文件夹中导入必备的jar包，包括spring、struts以及hibernate的jar包：</p><p>spring相关jar包：</p><p><img data-src="2.png" alt="2"></p><p>struts相关jar包：</p><p><img data-src="3.png" alt="3"></p><p>hibernate相关jar包：</p><p><img data-src="4.png" alt="4"></p><p>3.jar导入后，开始搭建框架，完成配置文件</p><p>（1）首先第一步加载数据库配置文件，配置数据源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载数据库配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 包扫描器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.jiangnan.ssh"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置C3P0数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.username&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driverClass&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.url&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.initialPoolSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.maxPoolSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）第二步创建数据库操作对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建数据库的操作对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate5.LocalSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernateProperties"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库方言 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 显示Hibernate持久化操作生成的预编译的SQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将SQL格式化后再输出 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 是否根据需要每次自动创建数据库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hibernate映射文件的目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappingDirectoryLocations"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com/jiangnan/ssh/pojo<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）第三步配置事务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate5.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）第四步配置通知</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> <span class="attr">id</span> =<span class="string">"txadvice"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（5）第五步配置切面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.jiangnan.ssh.service.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（6）最后配置一下web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.jiangnan.ssh.service.*.*(..))"</span> <span class="attr">id</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txpoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成</p>]]></content>
      
      
      <categories>
          
          <category> spring框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Guava Cache】基于Guava Cache内存缓存实现的token验证</title>
      <link href="/2020/03/10/%E5%9F%BA%E4%BA%8EGuava%20Cache%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E7%9A%84token%E9%AA%8C%E8%AF%81/"/>
      <url>/2020/03/10/%E5%9F%BA%E4%BA%8EGuava%20Cache%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E7%9A%84token%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Guava-Cache内存缓存实现的token验证"><a href="#基于Guava-Cache内存缓存实现的token验证" class="headerlink" title="基于Guava Cache内存缓存实现的token验证"></a>基于Guava Cache内存缓存实现的token验证</h1><h2 id="理解token机制"><a href="#理解token机制" class="headerlink" title="理解token机制"></a>理解token机制</h2><p> 什么是token</p><p>   token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。</p><p>   身份认证概述</p><p>   由于HTTP是一种没有状态的协议，它并不知道是谁访问了我们的应用。这里把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下次这个客户端再发送请求时候，还得再验证一下。<br>通用的解决方法就是，当用户请求登录的时候，如果没有问题，在服务端生成一条记录，在这个记录里可以说明登录的用户是谁，然后把这条记录的id发送给客户端，客户端收到以后把这个id存储在cookie里，下次该用户再次向服务端发送请求的时候，可以带上这个cookie，这样服务端会验证一下cookie里的信息，看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。<br>以上所描述的过程就是利用session，那个id值就是sessionid。我们需要在服务端存储为用户生成的session，这些session会存储在内存，磁盘，或者数据库。</p><p>   基于token机制的身份认证</p><p>   使用token机制的身份验证方法，在服务器端不需要存储用户的登录记录。大概的流程：</p><p>客户端使用用户名和密码请求登录。服务端收到请求，验证用户名和密码。验证成功后，服务端会生成一个token，然后把这个token发送给客户端。客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。客户端每次向服务端发送请求的时候都需要带上服务端发给的token。服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。</p><h3 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h3><p>Guava Cache是单个应用运行时的本地缓存。它不把数据存放到文件或者外部服务器上。简单、强大、及轻量级。它不需要配置文件，使用起来和ConcurrentHashMap一样简单，而且能覆盖绝大多数使用cache的场景需求</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p> 校验答案正确后，在service层来生成一个唯一token，一般可以使用mac地址，或者sessionId来生成token。因为token是可以被截获的，非常容易泄露，如果不进行加密，很容易被恶意拷贝并用来登录。所以一般会对token进行加密处理。</p><p>一般可以在存储的时候把token进行对称加密存储，用到的时候再解密，或者使用请求URL、时间戳、token三者合并，通过算法进行加密处理。两个一块用更安全。这里就简单利用UUID来实现生成唯一token</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String forgetToken = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure><p>然后再把token存到本地Guava Cache内存缓存中，在响应对象中也把这个token封装起来响应给客户端。到时候用户改密，就可以传入该token实现token机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TokenCache.setKey(<span class="string">"Token_"</span>+username,forgetToken);</span><br></pre></td></tr></table></figure><p>Guava Cache实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheLoader;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.LoadingCache;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author Liang Shan</span></span><br><span class="line"><span class="comment"> * @Description token本地缓存，使用guava缓存实现</span></span><br><span class="line"><span class="comment"> * @Date 2018/6/1 17:28</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    创建logback的logger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TokenCache<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//    声明一个静态的内存块,guava里面的本地缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LoadingCache&lt;String, String&gt; localcache =</span><br><span class="line">        <span class="comment">//构建本地缓存，调用链的方式 ,1000是设置缓存的初始化容量，maximumSize是设置缓存最大容量，当超过了最大容量，guava将使用LRU算法（最少使用算法），来移除缓存项</span></span><br><span class="line">        <span class="comment">//expireAfterAccess(12,TimeUnit.HOURS)设置缓存有效期为12个小时</span></span><br><span class="line">        CacheBuilder.newBuilder().initialCapacity(<span class="number">1000</span>).maximumSize(<span class="number">10000</span>).expireAfterAccess(<span class="number">12</span>,TimeUnit.HOURS)</span><br><span class="line">        <span class="comment">//build里面要实现一个匿名抽象类</span></span><br><span class="line">                .build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line"><span class="comment">//                   这个方法是默认的数据加载实现,get的时候，如果key没有对应的值，就调用这个方法进行加载</span></span><br><span class="line"> </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//                        为什么要把return的null值写成字符串，因为到时候用null去.equal的时候，会报空指针异常</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 添加本地缓存</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        localcache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 得到本地缓存</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value= localcache.get(key);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"null"</span>.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"getKey()方法错误"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Guava-Cache的回收策略"><a href="#Guava-Cache的回收策略" class="headerlink" title="Guava Cache的回收策略"></a>Guava Cache的回收策略</h3><h4 id="有两种回收策略："><a href="#有两种回收策略：" class="headerlink" title="有两种回收策略："></a>有两种回收策略：</h4><p>一种是基于容量的回收CacheBuilder.maximumSize(Long)。设置缓存最大容量，当超过最大容量，缓存将尝试回收最近没有使用或总体上很少使用的缓存项。</p><p>第二种定时回收</p><p>expireAfterAccess(long,TimeUnit):缓存项在给定时间内没有被读写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。</p><p>  expireAfterWrite(long,TimeUnit):缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变的陈旧不可用，这种回收是可取的。</p><p>实例中用的是第一种策略，通过设置缓存最大容量，当超过了最大容量，guava将使用LRU算法来减少缓存项</p><h3 id="LRU算法原理"><a href="#LRU算法原理" class="headerlink" title="LRU算法原理"></a>LRU算法原理</h3><p>LRU（Least recently used，最近最少使用的）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高。</p><p>最常见的实现是使用一个链表保存缓存数据：<br>1 新数据插入到链表头部<br>2 每当缓存命中（即缓存数据被访问），则将数据移到链表头部<br>3 当链表满的时候，将链表尾部的数据丢弃</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava Cache </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
