<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#836FFF","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="基础面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="基础面试题">
<meta property="og:url" content="http://yoursite.com/2020/07/20/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="MyNotes">
<meta property="og:description" content="基础面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/07/20/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/1.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/838837/201905/838837-20190521092648019-983754481.png">
<meta property="og:image" content="http://yoursite.com/2020/07/20/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/2.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180808171104824?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA5Mzg2MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="article:published_time" content="2020-07-20T15:31:07.000Z">
<meta property="article:modified_time" content="2020-07-21T14:36:21.901Z">
<meta property="article:author" content="Hiasenna">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/07/20/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/1.png">

<link rel="canonical" href="http://yoursite.com/2020/07/20/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>基础面试题 | MyNotes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MyNotes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-top">

    <a href="/top/" rel="section"><i class="fa fa-fw fa-signal"></i>阅读排行</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/zhanghaoyu2017" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/20/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hiasenna">
      <meta itemprop="description" content="自律 稳健">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyNotes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基础面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-20 23:31:07" itemprop="dateCreated datePublished" datetime="2020-07-20T23:31:07+08:00">2020-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-21 22:36:21" itemprop="dateModified" datetime="2020-07-21T22:36:21+08:00">2020-07-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>
            <div class="post-description">基础面试题</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1、List和Set的区别"><a href="#1、List和Set的区别" class="headerlink" title="1、List和Set的区别"></a>1、List和Set的区别</h3><p>Java中的集合共包含三大类，它们分别是Set（集），List（列表）以及Map（映射）。它们都处在java.util中并且都为接口。它们各自都有各自的实现类。Set的实现类主要有HashSet和TreeSet，List的实现类主要有ArrayList</p>
<p><strong>（1）重复对象</strong></p>
<p>list方法可以允许重复的对象，而set方法不允许重复对象</p>
<p><strong>（2）null元素</strong></p>
<p>list可以插入多个null元素，而set只允许插入一个null元素</p>
<p><strong>（3）容器是否有序</strong></p>
<p>list是一个有序的容器，保持了每个元素的插入顺序。即输出顺序就是输入顺序，而set方法是无序容器，无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序</p>
<p><strong>（4）常用的实现类</strong></p>
<p>list方法常用的实现类有ArrayList、LinkedList 和 Vector。其中ArrayList 最为流行，它提供了使用索引的随意访问，而LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适，Vector 表示底层数组，线程安全</p>
<p>Set方法中最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和compareTo() 的定义进行排序的有序容器</p>
<h3 id="2、List常用的实现类"><a href="#2、List常用的实现类" class="headerlink" title="2、List常用的实现类"></a>2、List常用的实现类</h3><h4 id="1、ArrayList"><a href="#1、ArrayList" class="headerlink" title="1、ArrayList"></a>1、ArrayList</h4><p><strong>非线程安全</strong><br>基于对象数组<br>get(int index)不需要遍历数组，速度快；<br>iterator()方法中调用了get(int index)，所以速度也快<br>set(int index, E e)不需要遍历数组，速度快<br>add方法需要考虑扩容与数组复制问题，速度慢<br>remove(Object o)需要遍历数组，并复制数组元素，速度慢<br>remove(int index)不需要遍历数组，需要复制数组元素，但不常用<br>contain(E)需要遍历数组</p>
<h4 id="2、LinkedList"><a href="#2、LinkedList" class="headerlink" title="2、LinkedList"></a>2、LinkedList</h4><p><strong>非线程安全</strong><br>基于环形双向链表<br>get(int index)需要遍历链表，速度慢；<br>iterator()方法中调用了get(int index)，所以速度也慢<br>set(int index, E e)方法中调用了get(int index)，所以速度也慢<br>add方法不需要考虑扩容与数组复制问题，只需创建新对象，再将新对象的前后节点的指针指向重新分配一下就好，速度快<br>remove(Object o)需要遍历链表，但不需要复制元素，只需将所要删除的对象的前后节点的指针指向重新分配一下以及将所要删除的对象的三个属性置空即可，速度快<br>remove(int index)需要遍历链表，但不需要复制元素，只需将所要删除的对象的前后节点的指针指向重新分配一下以及将所要删除的对象的三个属性置空即可，但不常用<br>contain(E)需要遍历链表</p>
<h4 id="3、Vector（线程安全的ArrayList）"><a href="#3、Vector（线程安全的ArrayList）" class="headerlink" title="3、Vector（线程安全的ArrayList）"></a>3、Vector（线程安全的ArrayList）</h4><p>线程安全<br>扩容机制与ArrayList不同</p>
<h4 id="4、Stack（继承于Vector）"><a href="#4、Stack（继承于Vector）" class="headerlink" title="4、Stack（继承于Vector）"></a>4、Stack（继承于Vector）</h4><p>线程安全<br>效率低下，可采用双端队列Deque或LinkedList来实现，Deque用的较多<br>总结：<br>在查询（get）、遍历（iterator）、修改（set）使用的比较多的情况下，用ArrayList<br>在增加（add）、删除（remove）使用比较多的情况下，用LinkedList<br>在需要线程安全而且对效率要求比较低的情况下，使用Vector，当然，实现ArrayList线程安全的方法也有很多，以后再说<br>在需要使用栈结构的情况下，使用Deque，Stack废弃就行了</p>
<h3 id="3、ArrayList和LinkedList的区别"><a href="#3、ArrayList和LinkedList的区别" class="headerlink" title="3、ArrayList和LinkedList的区别"></a>3、ArrayList和LinkedList的区别</h3><h4 id="1-Array"><a href="#1-Array" class="headerlink" title="1. Array"></a>1. Array</h4><p><strong>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。</strong></p>
<p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据, (因为删除数据以后, 需要把后面所有的数据前移)</p>
<p><strong>缺点:</strong> 数组初始化必须指定初始化的长度, 否则报错</p>
<p>例如:</p>
<p>int[] a = new int[4];//推介使用int[] 这种方式初始化</p>
<p>int c[] = {23,43,56,78};//长度：4，索引范围：[0,3]</p>
<h4 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h4><p><strong>List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。</strong></p>
<p><strong>List有两个重要的实现类：ArrayList和LinkedList</strong></p>
<p>List是一个接口，不可以实例化, 不能写成如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> List&lt;Integer&gt;();<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类继承关系</li>
</ul>
<p><img data-src="1.png" alt="1.png"></p>
<p><img data-src="https://img2018.cnblogs.com/blog/838837/201905/838837-20190521092648019-983754481.png" alt="img"></p>
<h4 id="3-ArrayList"><a href="#3-ArrayList" class="headerlink" title="3. ArrayList"></a>3. ArrayList</h4><p><strong>ArrayList: 可以看作是能够自动增长容量的数组</strong></p>
<p><strong>ArrayList的toArray方法返回一个数组</strong></p>
<p><strong>ArrayList的asList方法返回一个列表</strong></p>
<p>ArrayList底层的实现是Array, 数组扩容实现</p>
<p>ArrayList扩容的核心方法grow()</p>
<ul>
<li><p>新增数据空间判断</p>
<p>新增数据的时候需要判断当前是否有空闲空间存储</p>
</li>
<li><p>扩容需要申请新的连续空间</p>
</li>
<li><p>把老的数组复制过去</p>
</li>
<li><p>新加的内容</p>
</li>
<li><p>回收老的数组空间</p>
</li>
</ul>
<h4 id="4-LinkList"><a href="#4-LinkList" class="headerlink" title="4. LinkList"></a>4. LinkList</h4><p><strong>LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。</strong></p>
<p>链表不需要连续的空间, 大小不确定</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><ul>
<li><p>同样查找, 时间复杂度都是O(N), 但是数组要比链表快</p>
<p>因为数组的连续内存, 会有一部分或者全部数据一起进入到CPU缓存, 而链表还需要在去内存中根据上下游标查找, CPU缓存比内存块太多</p>
</li>
<li><p>数据大小固定, 不适合动态存储, 动态添加, 内存为一连续的地址, 可随机访问, 查询速度快</p>
</li>
<li><p>链表代销可变, 扩展性强, 只能顺着指针的方向查询, 速度较慢</p>
</li>
</ul>
<h3 id="4、Set常用的实现类"><a href="#4、Set常用的实现类" class="headerlink" title="4、Set常用的实现类"></a>4、Set常用的实现类</h3><p>一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。常用的实现类有HashSet、LinkedHashSet、TreeSet</p>
<h4 id="HashSet定义及特点"><a href="#HashSet定义及特点" class="headerlink" title="HashSet定义及特点"></a>HashSet定义及特点</h4><p>public class HashSet extends AbstractSet implements Set, Cloneable, Serializable</p>
<ol>
<li>实现原理，基于哈希表（HashMap）实现</li>
<li>不允许重复，最多可以有一个null元素</li>
<li>不保证顺序恒久不变</li>
<li>添加元素时把元素作为HashMap的key保存，HashMap的value使用一个固定的Object对象</li>
<li>排除重复是通过equals方法来检查对象是否相等</li>
<li>判断两个对象是否相同，先判断两个对象的hashCode是否相同（两个对象的hashCode相等不一定是同一个对象，但如果不同，一定不是同一个对象），若不同，则两个对象不是同一个对象；若相同，还要进行equals判断。equals方法返回true则为同一个对象，返回false则不是同一个对象。</li>
<li>自定义类存入HashSet时，建议重写类的hashCode和equals方法</li>
</ol>
<p>哈希表的存储结构：数组+链表，数组里的每个元素以链表的形式存储<br>如何把对象存储到哈希表中？先计算对象的hashCode值再对数组的长度求余数，来决定对象要存储在数组中的哪个位置。</p>
<h4 id="TreeSet定义及特点"><a href="#TreeSet定义及特点" class="headerlink" title="TreeSet定义及特点"></a>TreeSet定义及特点</h4><p>public class TreeSet extends AbstractSet implements NavigableSet, Cloneable, Serializable</p>
<ul>
<li>基于 TreeMap 的 NavigableSet 实现。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。</li>
<li>有序的，基于TreeMap(二叉树数据结构)实现，对象需要比较大小，通过对象比较器来实现。对象比较器还可以用来去除重复元素，若自定义的类没有实现比较器（Comparable）接口，将无法添加到TreeSet中。</li>
</ul>
<h4 id="LinkedHashSet定义及特点"><a href="#LinkedHashSet定义及特点" class="headerlink" title="LinkedHashSet定义及特点"></a>LinkedHashSet定义及特点</h4><p>public class LinkedHashSet extends HashSet implements Set, Cloneable, Serializable</p>
<p>具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。此实现与 HashSet 的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，即按照将元素插入到set 中的顺序（插入顺序）进行迭代。注意，插入顺序不 受在 set 中重新插入的 元素的影响。如果在 s.contains(e) 返回 true 后立即调用 s.add(e)，则元素 e 会被重新插入到 set s 中。）</p>
<p>如何选择Set接口的具体实现？</p>
<ul>
<li>如果要排序，选TreeSet</li>
<li>如果不用排序，也不用保证顺序，选HashSet</li>
<li>如果不用排序，要保证顺序，选LinkedHashSet</li>
</ul>
<h3 id="5、HashSet和LinkedHashSet的区别"><a href="#5、HashSet和LinkedHashSet的区别" class="headerlink" title="5、HashSet和LinkedHashSet的区别"></a>5、HashSet和LinkedHashSet的区别</h3><p>HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。</p>
<p>TreeSet是采用树结构实现(红黑树算法)。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first(), last(), headSet(), tailSet()等等。</p>
<p>LinkedHashSet介于HashSet和TreeSet之间。它也是一个hash表，但是同时维护了一个双链表来记录插入的顺序。基本方法的复杂度为O(1)。</p>
<h3 id="6、int和Integer的区别"><a href="#6、int和Integer的区别" class="headerlink" title="6、int和Integer的区别"></a>6、int和Integer的区别</h3><ol>
<li>int是基本数据类型，Integer是int包装类。</li>
<li>Integer变量必须实例化后才能使用，int可以直接使用</li>
<li>Integer的默认值是null，int默认值是0</li>
<li>Integer变量实际上是对象的引用，指向new的Integer对象，int是直接存储数据</li>
</ol>
<h4 id="深入对比"><a href="#深入对比" class="headerlink" title="深入对比"></a>深入对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(a.equals(b));</span><br></pre></td></tr></table></figure>

<p>结果前false，后true。<br>因为Integer变量是对Integer对象的引用，new了两个对象，显然内存地址不一样，引用不一样。<br>而Integer重写了equals方法，数值一样就返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">10</span>;</span><br><span class="line">    Integer b = <span class="number">10</span>;</span><br><span class="line">    System.out.println(a == b);</span><br><span class="line">    Integer c = <span class="number">128</span>;</span><br><span class="line">    Integer d = <span class="number">128</span>;</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果前true，后false<br>因为Integer自动装箱时对数值在-128到127的对象放入缓存中，第二次就直接取缓存中的数据而不会new。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    System.out.println(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为true<br>因为Integer类型和int比较时，会自动拆箱，化为基本类型数据比较。</p>
<h3 id="7、-和equals的区别"><a href="#7、-和equals的区别" class="headerlink" title="7、==和equals的区别"></a>7、==和equals的区别</h3><p><strong>==:</strong>判断两个字符串在内存中首地址是否相同,即判断两者是否是同一个字符串对象</p>
<p><strong>equles():</strong>如果没有重写equals()方法比较的是对象的地址,因为对Object来说对象没有什么属性可以比较,只能比较最底层的地址.</p>
<p>而如果重写equals()方法时,该方法的对象因为是Object的子类,所以调用时会调用子类对象里面的方法.所以只有重写equals()方法后,两者比较的才是内容.或者说重写可以使自己定义比较的规则,不想按照地址去比较.</p>
<h3 id="8、final关键字"><a href="#8、final关键字" class="headerlink" title="8、final关键字"></a>8、final关键字</h3><p>在java的关键字中，static和final是两个我们必须掌握的关键字。不同于其他关键字，他们都有多种用法，而且在一定环境下使用，可以提高程序的运行性能，优化程序的结构。下面我们来了解一下final关键字及其用法。</p>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>在java中，final的含义在不同的场景下有细微的差别，但总体上来说，它指的是“这是不可变的”。下面，我们来讲final的四种主要用法。</p>
<h4 id="1-修饰数据"><a href="#1-修饰数据" class="headerlink" title="1.修饰数据"></a>1.修饰数据</h4><p>在编写程序时，我们经常需要说明一个数据是不可变的，我们成为常量。在java中，用final关键字修饰的变量，只能进行一次赋值操作，并且在生存期内不可以改变它的值。更重要的是，final会告诉编译器，这个数据是不会修改的，那么编译器就可能会在编译时期就对该数据进行替换甚至执行计算，这样可以对我们的程序起到一点优化。不过在针对基本类型和引用类型时，final关键字的效果存在细微差别。我们来看下面的例子：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> v;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.v = v;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> f2;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         f2 = <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> value1 = <span class="number">1</span>;</span><br><span class="line">         <span class="comment">// value1 = 4;</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">double</span> value2;</span><br><span class="line">         value2 = <span class="number">2.0</span>;</span><br><span class="line">         <span class="keyword">final</span> Value value3 = <span class="keyword">new</span> Value(<span class="number">1</span>);</span><br><span class="line">         value3.v = <span class="number">4</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>上面的例子中，我们先来看一下main方法中的几个final修饰的数据，在给value1赋初始值之后，我们无法再对value1的值进行修改，final关键字起到了常量的作用。从value2我们可以看到，final修饰的变量可以不在声明时赋值，即可以先声明，后赋值。value3时一个引用变量，这里我们可以看到final修饰引用变量时，只是限定了引用变量的引用不可改变，即不能将value3再次引用另一个Value对象，但是引用的对象的值是可以改变的，从内存模型中我们看的更加清晰：</p>
<p><img data-src="2.png" alt="2.png"></p>
<p><img data-src="https://img-blog.csdn.net/20180808171104824?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA5Mzg2MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>上图中，final修饰的值用粗线条的边框表示它的值是不可改变的，我们知道引用变量的值实际上是它所引用的对象的地址，也就是说该地址的值是不可改变的，从而说明了为什么引用变量不可以改变引用对象。而实际引用的对象实际上是不受final关键字的影响的，所以它的值是可以改变的。</p>
<p>另一方面，我们看到了用final修饰成员变量时的细微差别，因为final修饰的数据的值是不可改变的，所以我们必须确保在使用前就已经对成员变量赋值了。因此对于final修饰的成员变量，我们有且只有两个地方可以给它赋值，一个是声明该成员时赋值，另一个是在构造方法中赋值，在这两个地方我们必须给它们赋初始值。</p>
<p>最后我们需要注意的一点是，同时使用static和final修饰的成员在内存中只占据一段不能改变的存储空间。</p>
<p>2.修饰方法参数<br>前面我们可以看到，如果变量是我们自己创建的，那么使用final修饰表示我们只会给它赋值一次且不会改变变量的值。那么如果变量是作为参数传入的，我们怎么保证它的值不会改变呢？这就用到了final的第二种用法，即在我们编写方法时，可以在参数前面添加final关键字，它表示在整个方法中，我们不会（实际上是不能）改变参数的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalFunc</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i, <span class="keyword">final</span> Value value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i = 5; 不能改变i的值</span></span><br><span class="line">    <span class="comment">// v = new Value(); 不能改变v的值</span></span><br><span class="line">    value.v = <span class="number">5</span>; <span class="comment">// 可以改变引用对象的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="3-修饰方法"><a href="#3-修饰方法" class="headerlink" title="3.修饰方法"></a>3.修饰方法</h4><p>第三种方式，即用final关键字修饰方法，它表示该方法不能被覆盖。这种使用方式主要是从设计的角度考虑，即明确告诉其他可能会继承该类的程序员，不希望他们去覆盖这个方法。这种方式我们很容易理解，然而，关于private和final关键字还有一点联系，这就是类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它。</p>
<h4 id="4-修饰类"><a href="#4-修饰类" class="headerlink" title="4.修饰类"></a>4.修饰类</h4><p>了解了final关键字的其他用法，我们很容易可以想到使用final关键字修饰类的作用，那就是用final修饰的类是无法被继承的。</p>
<p>上面我们讲解了final的四种用法，然而，对于第三种和第四种用法，我们却甚少使用。这不是没有道理的，从final的设计来讲，这两种用法甚至可以说是鸡肋，因为对于开发人员来讲，如果我们写的类被继承的越多，就说明我们写的类越有价值，越成功。即使是从设计的角度来讲，也没有必要将一个类设计为不可继承的。Java标准库就是一个很好的反例，特别是Java 1.0/1.1中Vector类被如此广泛的运用，如果所有的方法均未被指定为final的话，它可能会更加有用。如此有用的类，我们很容易想到去继承和重写他们，然而，由于final的作用，导致我们对Vector类的扩展受到了一些阻碍，导致了Vector并没有完全发挥它应有的全部价值。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>final关键字是我们经常使用的关键字之一，它的用法有很多，但是并不是每一种用法都值得我们去广泛使用。它的主要用法有以下四种：</p>
<p>用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；<br>用来修饰方法参数，表示在变量的生存期中它的值不能被改变；<br>修饰方法，表示该方法无法被重写；<br>修饰类，表示该类无法被继承。<br>上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。</p>
<h3 id="9、接口和抽象类的区别"><a href="#9、接口和抽象类的区别" class="headerlink" title="9、接口和抽象类的区别"></a>9、接口和抽象类的区别</h3><h4 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h4><p>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。<br>接口中的实例变量默认是 final 类型的，而抽象类中则不一定。<br>一个类可以实现多个接口，但最多只能实现一个抽象类。<br>一个类实现接口的话要实现接口的所有方法，而抽象类不一定。<br>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象。从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。<br><code>备注:
在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</code></p>
<h4 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a>抽象类必须要有抽象方法吗？</h4><p>抽象类中不一定包含抽象方法，但是包含抽象方法的类一定要被声明为抽象类。</p>
<h4 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h4><p>抽象类不能用 final 来修饰。当用 final 修饰一个类时，表明这个类不能被继承。 final 类中的所有成员方法都会被隐式地指定为 final 方法，这明显违背了抽象类存在的意义了。</p>
<h3 id="10、原子操作，CAS存在的问题，如何解决"><a href="#10、原子操作，CAS存在的问题，如何解决" class="headerlink" title="10、原子操作，CAS存在的问题，如何解决"></a>10、原子操作，CAS存在的问题，如何解决</h3><h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h4><p>CAS,compare and swap的缩写，中文翻译成<strong>比较并交换</strong>。</p>
<p>我们都知道，在java语言之前，并发就已经广泛存在并在服务器领域得到了大量的应用。所以硬件厂商老早就在芯片中加入了大量直至并发操作的原语，从而在硬件层面提升效率。在intel的CPU中，使用cmpxchg指令。</p>
<p>在Java发展初期，java语言是不能够利用硬件提供的这些便利来提升系统的性能的。而随着java不断的发展,Java本地方法(JNI)的出现，使得java程序越过JVM直接调用本地方法提供了一种便捷的方式，因而java在并发的手段上也多了起来。而在Doug Lea提供的cucurenct包中，CAS理论是它实现整个java包的基石。</p>
<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”</p>
<p>通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。</p>
<p>类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。</p>
<h4 id="CAS的目的"><a href="#CAS的目的" class="headerlink" title="CAS的目的"></a>CAS的目的</h4><p>利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。</p>
<h3 id="11、-和–操作是否为原子操作，为什么"><a href="#11、-和–操作是否为原子操作，为什么" class="headerlink" title="11、++和–操作是否为原子操作，为什么"></a>11、++和–操作是否为原子操作，为什么</h3><p>不是原子操作。理由：</p>
<p><strong>1.i++分为三个阶段：</strong></p>
<p>内存到寄存器<br>寄存器自增<br>写回内存<br>这三个阶段中间都可以被中断分离开.</p>
<p> <strong>2.++i首先要看编译器是怎么编译的</strong>，</p>
<p>某些编译器比如VC在非优化版本中会编译为以下汇编代码：</p>
<p>__asm<br>{<br>        moveax,  dword ptr[i]<br>        inc eax<br>        mov dwordptr[i], eax<br>}<br>这种情况下，必定不是原子操作，不加锁互斥是不行的。<br>假设加了优化参数，那么是否一定会编译为“inc dword ptr[i]”呢？答案是否定的，这要看编译器心情，如果++i的结果还要被使用的话，那么一定不会被编译为“inc dword ptr[i]”的形式。<br>那么假设如果编译成了“inc dword ptr[i]”，这是原子操作，是否就不需要加锁了呢？如果在单核机器上，不加锁不会有问题，但到了多核机器上，这个不加锁同样会带来严重后果，两个CPU可以同时执行inc指令，但是两个执行以后，却可能出现只自加了一次。<br>真正可以确保不“额外”加锁的汇编指令是“lock inc dword ptr[i]”，lock前缀可以暂时锁住总线，这时候其他CPU是无法访问相应数据的。但是目前没有任何一个编译器会将++int编译为这种形式。</p>
<h3 id="12、Java的异常处理机制，Error和Exception的区别"><a href="#12、Java的异常处理机制，Error和Exception的区别" class="headerlink" title="12、Java的异常处理机制，Error和Exception的区别"></a>12、Java的异常处理机制，Error和Exception的区别</h3><h4 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h4><p>异常的英文单词是exception，字面翻译就是“意外、例外”的意思，也就是非正常情况。事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用空的引用、数组下标越界、内存溢出错误等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果。因此，如何对运行期间出现的错误进行处理和补救呢？<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java</a>提供了异常机制来进行处理，通过异常机制来处理程序运行期间出现的错误。通过异常机制，我们可以更好地提升程序的健壮性。</p>
<h4 id="unchecked-exception（非检查异常）"><a href="#unchecked-exception（非检查异常）" class="headerlink" title="unchecked exception（非检查异常）"></a>unchecked exception（非检查异常）</h4><p>也称运行时异常（RuntimeException），比如常见的NullPointerException、IndexOutOfBoundsException。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。</p>
<h4 id="checked-exception（检查异常，编译异常）"><a href="#checked-exception（检查异常，编译异常）" class="headerlink" title="checked exception（检查异常，编译异常）"></a>checked exception（检查异常，编译异常）</h4><p>也称非运行时异常（运行时异常以外的异常就是非运行时异常），java编译器强制程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</p>
<h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><p>有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<h4 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h4><p>是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p>
<h4 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h4><p>是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。<br>可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。<br>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p>
<h4 id="应该catch什么"><a href="#应该catch什么" class="headerlink" title="应该catch什么"></a>应该catch什么</h4><p>其实只要是Throwable和其子类都是可以throw和catch的，那么如果在需要统一处理异常的地方，我们应该catch (Throwable th) 还是 catch (Exception)呢？<br>这两种处理的区别在于，catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception极其子类，捕捉的范围更小。先不考虑有其他的类继承了Throwable的情况下，第一种catch相当于比第二种catch多捕捉了把Error和其子类。<br>那么究竟Error是否需要捕捉呢？JDK中Error类的的注释（如下）里提到过，Error是一种严重的问题，应用程序不应该捕捉它。<br>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. The ThreadDeath error, though a “normal” condition, is also a subclass of Error because most applications should not try to catch it.<br>A method is not required to declare in its throws clause any subclasses of Error that might be thrown during the execution of the method but not caught, since these errors are abnormal conditions that should never occur.<br><a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java </a>Lanuage Spec 7 中也提到：Error继承自Throwable而不是继承自Exception，是为了方便程序可以使用 “catch (Exception)“来捕捉异常而不会把Error也捕捉在内，因为Exception发生后可以进行一些恢复工作的，但是Error发生后一般是不可恢复的。<br>The class Error is a separate subclass ofThrowable, distinct from Exception in the class<br>hierarchy, to allow programs to use the idiom “} catch (Exception e) { ” (§11.2.3)<br>to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible.<br>已经不难看出，Java本身设计思路就是希望大家catch Exception就足够了，如果有Error发生，catch了也不会有什么作用。</p>
<h4 id="Error可以catch吗？-可以catch了后做些其他处理吗？"><a href="#Error可以catch吗？-可以catch了后做些其他处理吗？" class="headerlink" title="Error可以catch吗？ 可以catch了后做些其他处理吗？"></a>Error可以catch吗？ 可以catch了后做些其他处理吗？</h4><p>Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。</p>
<h3 id="13、IOException需要捕获吗？"><a href="#13、IOException需要捕获吗？" class="headerlink" title="13、IOException需要捕获吗？"></a>13、IOException需要捕获吗？</h3><p>如果你不想捕捉，就需要把异常往上一级继续抛出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">//方法声明的时候带有异常抛出</span></span><br><span class="line">         System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"test"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; <span class="comment">//方法声明的时候不带异常抛出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"2"</span>);</span><br><span class="line">            test(); <span class="comment">//那么调用带有异常抛出的方法的时候，就必须捕捉异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> satatic <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        test(); <span class="comment">//如果不想捕捉异常，那么就在方法声明的时候继续向上级抛出异常</span></span><br><span class="line">         test2();<span class="comment">//这样，方法异常的时候，程序就中止，由上级继续处理异常，直到JVM级别为止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14、synchronized和Lock的区别"><a href="#14、synchronized和Lock的区别" class="headerlink" title="14、synchronized和Lock的区别"></a>14、synchronized和Lock的区别</h3><p>两者区别：</p>
<p>1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</p>
<p>2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</p>
<p>3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</p>
<p>4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</p>
<p>5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</p>
<p>6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</p>
<h3 id="15、线程池：创建、核心参数、拒绝策略"><a href="#15、线程池：创建、核心参数、拒绝策略" class="headerlink" title="15、线程池：创建、核心参数、拒绝策略"></a>15、线程池：创建、核心参数、拒绝策略</h3><h3 id="16、Spring依赖注入的方式"><a href="#16、Spring依赖注入的方式" class="headerlink" title="16、Spring依赖注入的方式"></a>16、Spring依赖注入的方式</h3><ul>
<li><strong>set方法注入</strong></li>
<li><strong>构造器注入</strong></li>
<li><strong>静态工厂注入</strong></li>
<li><strong>实例工厂注入</strong></li>
</ul>
<h4 id="1-set方法注入"><a href="#1-set方法注入" class="headerlink" title="1.set方法注入"></a>1.set方法注入</h4><ul>
<li> 在演示前，我们需要准备几个类，我使用下面两个类来进行注入的演示，这两个类分别是<code>User</code>和<code>Car</code>类：</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只包含基本数据类型的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> speed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">int</span> speed, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.speed = speed;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpeed</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Car&#123;"</span> +</span><br><span class="line">                <span class="string">"speed="</span> + speed +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 除了上面两个基本数据类型的属性，User还依赖Car</span></span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age, Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", car="</span> + car +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    有了上面两个类，我们就可以演示<code>set</code>注入了。需要注意一点，如果我们需要使用<code>set</code>注入，那么必须要为属性提供<code>set</code>方法，<code>Spring</code>容器就是通过调用<code>bean</code>的<code>set</code>方法为属性注入值的。而在<code>xml</code>文件中，使用<code>set</code>注入的方式就是通过<code>property</code>标签，如下所示：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义car这个bean，id为myCar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCar"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.Car"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        为car的属性注入值，因为speed和price都是基本数据类型，所以使用value为属性设置值；</span></span><br><span class="line"><span class="comment">        注意，这里的name为speed和price，不是因为属性名就是speed和price，</span></span><br><span class="line"><span class="comment">        而是set方法分别为setSpeed和setPrice，名称是通过将set删除，然后将第一个字母变小写得出；</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"speed"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"99999.9"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义user这个bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"aaa"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- car是引用类型，所以这里使用ref为其注入值，注入的就是上面定义的myCar </span></span><br><span class="line"><span class="comment">         基本数据类型或Java包装类型使用value，</span></span><br><span class="line"><span class="comment">         而引用类型使用ref，引用另外一个bean的id </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"myCar"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>    通过上面的配置，就可以为<code>Car</code>和<code>User</code>这两个类型的<code>bean</code>注入值了。需要注意的是，<strong>property的name属性，填写的不是属性的名称，而是set方法去除set，然后将第一个字符小写后的结果。对于基本数据类型，或者是Java的包装类型（比如String），使用value注入值，而对于引用类型，则使用ref，传入其他bean的id。</strong>接下来我们就可以测试效果了：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context =</span><br><span class="line">        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">// 获取user这个bean</span></span><br><span class="line">    User user = context.getBean(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 输出产看结果</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    由于<code>user</code>包含<code>car</code>的引用，所以我们直接输出<code>user</code>，也能够看到<code>car</code>的情况，输入结果如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User&#123;name&#x3D;&#39;aaa&#39;, age&#x3D;123, car&#x3D;Car&#123;speed&#x3D;100, price&#x3D;99999.9&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-构造器注入"><a href="#2-构造器注入" class="headerlink" title="2.构造器注入"></a>2.构造器注入</h4><p>    下面我们来说第二种方式——构造器注入。听名字就可以知道，这种注入值的方式，就是通过调用<code>bean</code>所属类的带参构造器为<code>bean</code>的属性注入值。这也就意味着，<strong>我们如果需要使用构造器注入，就得为类提供包含参数的构造方法</strong>。构造器注入，实际上有多种匹配属性值的方式，下面我们就来一一列举。我们这里依然使用<code>2.2</code>中定义的<code>Car</code>和<code>User</code>这两个类，测试方法以及类的定义都不需要变，需要改变的仅仅是<code>xml</code>配置文件。</p>
<p>  <strong>（一）匹配构造器的参数名称</strong></p>
<p>    我们需要通过<code>constructor-arg</code>标签为构造器传入参数值，但是每个<code>constructor-arg</code>标签对应哪一个参数值呢？这就有多种方式指定了。第一种就是直接匹配参数名，配置如下：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCar"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.Car"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过constructor-arg的name属性，指定构造器参数的名称，为参数赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"speed"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"99999.9"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"aaa"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">         和之前一样，基本数据类型或Java包装类型使用value，</span></span><br><span class="line"><span class="comment">         而引用类型使用ref，引用另外一个bean的id </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"myCar"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>    这样就完成了，测试代码和之前一样，运行结果也一样，我这里就不贴出来了。有人看完之后，可能会觉得这里的配置和<code>set</code>注入时的配置几乎一样，除了一个使用<code>property</code>，一个使用<code>constructor-arg</code>。确实，写法上一样，但是表示的含义却完全不同。<strong>property的name属性，是通过set方法的名称得来；而constructor-arg的name，则是构造器参数的名称</strong>。</p>
<p>  <strong>（二）匹配构造器的参数下标</strong></p>
<p>    上面是通过构造器参数的名称，匹配需要传入的值，那种方式最为直观，而<code>Spring</code>还提供另外两种方式匹配参数，这里就来说说通过参数在参数列表中的下标进行匹配的方式。下面的配置，请结合<code>2.2</code>节中<code>User</code>和<code>Car</code>的构造方法一起阅读，配置方式如下：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.Car"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 下标编号从0开始，构造器的第一个参数是speed，为它赋值100 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构造器的第二个参数是price，为它赋值99999.9 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"99999.9"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 与上面car的配置同理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"aaa"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span> <span class="attr">ref</span>=<span class="string">"car"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>    上面就是通过参数的下标为构造器的参数赋值，需要注意的是，<strong>参实的下标从0开始</strong>。使用上面的方式配置，若赋值的类型与参数的类型不一致，将会在容器初始化<code>bean</code>的时候抛出异常。如果<code>bean</code>存在多个参数数量一样的构造器，<code>Spring</code>容器会自动找到类型匹配的那个进行调用。比如说，<code>Car</code>有如下两个构造器，<code>Spring</code>容器将会调用第二个，因为上面的配置中，<code>index = 1</code>对应的<code>value</code>是<code>double</code>类型，与第二个构造器匹配，而第一个不匹配：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将使用匹配这个构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">int</span> speed, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    还存在另外一种特殊情况，那就是多个构造器都满足<code>bean</code>的配置，此时选择哪一个？假设当前<code>car</code>的配置是这样的：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.Car"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 两个下标的value值都是整数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"999"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>    假设<code>Car</code>还是有上面两个构造器，两个构造器都是一个<code>int</code>类型一个<code>double</code>类型的参数，只是位置不同。而配置中，指定的两个值都是<code>int</code>类型。但是，<code>int</code>类型也可以使用<code>double</code>类型存储，所以上面两个构造器都是匹配的，此时调用哪一个呢？结论就是调用第二个。自己去尝试就会发现，<strong>若存在多个构造器匹配bean的定义，Spring容器总是使用最后一个满足条件的构造器</strong>。</p>
<p>  <strong>（三）匹配构造器的参数类型</strong></p>
<p>    下面说最后一种匹配方式——匹配构造器的参数类型。直接看配置文件吧：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.Car"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用type属性匹配类型，car的构造器包含两个参数，一个是int类型，一个是double类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"double"</span> <span class="attr">value</span>=<span class="string">"99999.9"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对于引用类型，需要使用限定类名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"aaa"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"cn.tewuyiang.pojo.Car"</span> <span class="attr">ref</span>=<span class="string">"car"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>    上面应该不难理解，直接通过匹配构造器的参数类型，从而选择一个能够完全匹配的构造器，调用这个构造器完成<code>bean</code>的创建和属性注入。需要注意的是，上面的配置中，类型并不需要按构造器中声明的顺序编写，<code>Spring</code>也能进行匹配。这也就意味着可能出现多个能够匹配的构造器，和上一个例子中一样。比如说，<code>Car</code>还是有下面两个构造器：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出一句话，看是否调用这个构造器</span></span><br><span class="line">    System.out.println(<span class="number">111</span>);</span><br><span class="line">    <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将使用匹配这个构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">int</span> speed, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出一句话，看是否调用这个构造器</span></span><br><span class="line">    System.out.println(<span class="number">222</span>);</span><br><span class="line">    <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    上面两个构造器都是一个<code>int</code>，一个<code>double</code>类型的参数，都符合xml文件中，<code>car</code>这个<code>bean</code>的配置。通过测试发现，<strong>Spring容器使用的永远都是最后一个符合条件的构造器</strong>，这和上面通过下标匹配是一致的。<strong>需要说明的一点是，这三种使用构造器注入的方式，可以混用</strong>。</p>
<h4 id="3-静态工厂注入"><a href="#3-静态工厂注入" class="headerlink" title="3.静态工厂注入"></a>3.静态工厂注入</h4><p>    静态工厂注入就是我们编写一个静态的工厂方法，这个工厂方法会返回一个我们需要的值，然后在配置文件中，我们指定使用这个工厂方法创建<code>bean</code>。首先我们需要一个静态工厂，如下所示：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态工厂，返回一个Car的实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car(<span class="number">12345</span>, <span class="number">5.4321</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    下面我们需要在<code>xml</code>中配置car这个bean，并指定它由工厂方法进行创建。配置如下：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	注意，这里的配置并不是创建一个SimpleFactory对象，取名为myCar，</span></span><br><span class="line"><span class="comment">    这一句配置的意思是，调用SimpleFactory的getCar方法，创建一个car实例对象，</span></span><br><span class="line"><span class="comment">    将这个car对象取名为myCar。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.factory.SimpleFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getCar"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name和age使用set注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"aaa"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将上面配置的car，注入到user的car属性中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"car"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>    以上就配置成功了，测试方法以及执行效果如下，注意看<code>car</code>的属性值，就是我们在静态工厂中配置的那样，这说明，<code>Spring</code>容器确实是使用我们定义的静态工厂方法，创建了<code>car</code>这个<code>bean</code>：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context =</span><br><span class="line">        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">// 获取静态工厂创建的car</span></span><br><span class="line">    Car car = (Car) context.getBean(<span class="string">"car"</span>);</span><br><span class="line">    <span class="comment">// 获取user</span></span><br><span class="line">    User user = context.getBean(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(car);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    输出如下所示：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car&#123;speed&#x3D;12345, price&#x3D;5.4321&#125;</span><br><span class="line">User&#123;name&#x3D;&#39;aaa&#39;, age&#x3D;123, car&#x3D;Car&#123;speed&#x3D;12345, price&#x3D;5.4321&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-实例工厂注入"><a href="#4-实例工厂注入" class="headerlink" title="4.实例工厂注入"></a>4.实例工厂注入</h4><p>    实例工厂与静态工厂类似，不同的是，静态工厂调用工厂方法不需要先创建工厂类的对象，因为静态方法可以直接通过类调用，所以在上面的配置文件中，并没有声明工厂类的<code>bean</code>。但是，实例工厂，需要有一个实例对象，才能调用它的工厂方法。我们先看看实例工厂的定义：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例工厂方法，返回一个Car的实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car(<span class="number">12345</span>, <span class="number">5.4321</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例工厂方法，返回一个String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"tewuyiang"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例工厂方法，返回一个int，在Spring容器中会被包装成Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">128</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    在上面的工厂类中，共定义了三个工厂方法，分别用来返回<code>user</code>所需的<code>car</code>，<code>name</code>以及<code>age</code>，而配置文件如下：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明实例工厂bean，Spring容器需要先创建一个SimpleFactory对象，才能调用工厂方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.factory.SimpleFactory"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    通过实例工厂的工厂方法，创建三个bean，通过factory-bean指定工厂对象，</span></span><br><span class="line"><span class="comment">    通过factory-method指定需要调用的工厂方法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"getName"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"age"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"getAge"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"getCar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"cn.tewuyiang.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将上面通过实例工厂方法创建的bean，注入到user中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">ref</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">ref</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"car"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>    我们尝试从<code>Spring</code>容器中取出<code>name</code>，<code>age</code>，<code>car</code>以及<code>user</code>，看看它们的值，测试代码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context =</span><br><span class="line">        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">// 获取静态工厂创建的car，name和age这三个bean</span></span><br><span class="line">    Car car = (Car) context.getBean(<span class="string">"car"</span>);</span><br><span class="line">    String name = (String) context.getBean(<span class="string">"name"</span>);</span><br><span class="line">    Integer age = (Integer) context.getBean(<span class="string">"age"</span>);</span><br><span class="line">    <span class="comment">// 获取user这个bean</span></span><br><span class="line">    User user = context.getBean(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(car);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    以下就是输出结果，可以看到，我们通过工厂创建的<code>bean</code>，都在<code>Spring</code>容器中能够获取到：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car&#123;speed&#x3D;12345, price&#x3D;5.4321&#125;</span><br><span class="line">tewuyiang</span><br><span class="line">128</span><br><span class="line">User&#123;name&#x3D;&#39;tewuyiang&#39;, age&#x3D;128, car&#x3D;Car&#123;speed&#x3D;12345, price&#x3D;5.4321&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17、当前bean有没有都行，应该采用什么方式注入"><a href="#17、当前bean有没有都行，应该采用什么方式注入" class="headerlink" title="17、当前bean有没有都行，应该采用什么方式注入"></a>17、当前bean有没有都行，应该采用什么方式注入</h3><h3 id="18、Redis的数据类型，常用的Redis命令"><a href="#18、Redis的数据类型，常用的Redis命令" class="headerlink" title="18、Redis的数据类型，常用的Redis命令"></a>18、Redis的数据类型，常用的Redis命令</h3><h4 id="Redis支持的五种数据类型"><a href="#Redis支持的五种数据类型" class="headerlink" title="Redis支持的五种数据类型"></a>Redis支持的五种数据类型</h4><ul>
<li>字符串 (string)</li>
<li>字符串列表 (list)</li>
<li>散列 (hash)</li>
<li>字符串集合 (set)</li>
<li>有序字符串集合 (sorted-set)</li>
</ul>
<h4 id="key（键）"><a href="#key（键）" class="headerlink" title="key（键）"></a>key（键）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">keys * 获取所有的key</span><br><span class="line">select 0 选择第一个库</span><br><span class="line">move myString 1 将当前的数据库key移动到某个数据库,目标库有，则不能移动</span><br><span class="line">flush db      清除指定库</span><br><span class="line">randomkey     随机key</span><br><span class="line">type key      类型</span><br><span class="line">set key1 value1 设置key</span><br><span class="line">get key1    获取key</span><br><span class="line">mset key1 value1 key2 value2 key3 value3</span><br><span class="line">mget key1 key2 key3</span><br><span class="line">del key1   删除key</span><br><span class="line">exists key      判断是否存在key</span><br><span class="line">expire key 10   10过期</span><br><span class="line">pexpire key 1000 毫秒</span><br><span class="line">persist key     删除过期时间</span><br></pre></td></tr></table></figure>

<h4 id="string-（字符串）"><a href="#string-（字符串）" class="headerlink" title="string （字符串）"></a>string （字符串）</h4><ul>
<li>String类型是以二进制进行操作，最多容量数据的长度是512M</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">set name cxx</span><br><span class="line">get name</span><br><span class="line">getrange name 0 -1        字符串分段</span><br><span class="line">getset name new_cxx       设置值，返回旧值</span><br><span class="line">mset key1 key2            批量设置</span><br><span class="line">mget key1 key2            批量获取</span><br><span class="line">setnx key value           不存在就插入（not exists）</span><br><span class="line">setex key time value      过期时间（expire）</span><br><span class="line">setrange key index value  从index开始替换value</span><br><span class="line">incr age        递增</span><br><span class="line">incrby age 10   递增</span><br><span class="line">decr age        递减</span><br><span class="line">decrby age 10   递减</span><br><span class="line">incrbyfloat     增减浮点数</span><br><span class="line">append          追加</span><br><span class="line">strlen          长度</span><br><span class="line">getbit&#x2F;setbit&#x2F;bitcount&#x2F;bitop    位操作</span><br></pre></td></tr></table></figure>

<h4 id="hash（散列）"><a href="#hash（散列）" class="headerlink" title="hash（散列）"></a>hash（散列）</h4><ul>
<li>每一个Hash可以储存(2^32-1)个：4294967295个键值对</li>
<li>String Key和String Value的map容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hset myhash name cxx</span><br><span class="line">hget myhash name</span><br><span class="line">hmset myhash name cxx age 25 note &quot;i am notes&quot;</span><br><span class="line">hmget myhash name age note   </span><br><span class="line">hgetall myhash               获取所有的</span><br><span class="line">hexists myhash name          是否存在</span><br><span class="line">hsetnx myhash score 100      设置不存在的</span><br><span class="line">hincrby myhash id 1          递增</span><br><span class="line">hdel myhash name             删除</span><br><span class="line">hkeys myhash                 只取key</span><br><span class="line">hvals myhash                 只取value</span><br><span class="line">hlen myhash                  长度</span><br></pre></td></tr></table></figure>

<h4 id="list（字符串列表）"><a href="#list（字符串列表）" class="headerlink" title="list（字符串列表）"></a>list（字符串列表）</h4><ul>
<li>经常用于消息队列的服务，多个程序之间的交互</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lpush mylist a b c  左插入</span><br><span class="line">rpush mylist x y z  右插入</span><br><span class="line">lrange mylist 0 -1  数据集合</span><br><span class="line">lpop mylist  弹出元素</span><br><span class="line">rpop mylist  弹出元素</span><br><span class="line">llen mylist  长度</span><br><span class="line">lrem mylist count value  删除</span><br><span class="line">lindex mylist 2          指定索引的值</span><br><span class="line">lset mylist 2 n          索引设值</span><br><span class="line">ltrim mylist 0 4         删除key</span><br><span class="line">linsert mylist before a  插入</span><br><span class="line">linsert mylist after a   插入</span><br><span class="line">rpoplpush list list2     转移列表的数据</span><br></pre></td></tr></table></figure>

<h4 id="set（字符串集合）"><a href="#set（字符串集合）" class="headerlink" title="set（字符串集合）"></a>set（字符串集合）</h4><ul>
<li><p>Set集合中不允许出现重复的元素</p>
</li>
<li><p>使用场景：</p>
<p>1、跟踪一些唯一性数据：访问某博客的IP信息（将访问者的IP存入redis中）</p>
<p>2、用于维护数据对象之间的关联关系（所有购买某一电子设备的用户的ID）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sadd myset redis </span><br><span class="line">smembers myset       数据集合</span><br><span class="line">srem myset set1         删除</span><br><span class="line">sismember myset set1 判断元素是否在集合中</span><br><span class="line">scard key_name       个数</span><br><span class="line">sdiff | sinter | sunion myset1 myset2 操作：集合间运算：差集 | 交集 | 并集</span><br><span class="line">srandmember          随机获取集合中的元素</span><br><span class="line">spop                 从集合中弹出一个元素</span><br></pre></td></tr></table></figure>

<h4 id="sorted-set（有序字符串集合）"><a href="#sorted-set（有序字符串集合）" class="headerlink" title="sorted-set（有序字符串集合）"></a>sorted-set（有序字符串集合）</h4><ul>
<li>与set类似，但每个成员都有一个关联的score属性，用于排序。成员不可以重复，score可以重复</li>
<li>sorted-set中的每一个成员都有一个分数与之关联，redis通过这个分数来为集合中的成员进行排序（成员必须唯一，但是分数可以重复）</li>
<li>Sorted-Set : 字符串集合，不允许元素重复。存储元素时需要关联存储一个对应的分数，分数用于排序。元素不可重复但分数可重复。成员在集合中的位置是有序的。</li>
<li>使用场景：游戏排名、微博热点话题、构建索引数据等等</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">zadd zset 1 one</span><br><span class="line">zadd zset 2 two</span><br><span class="line">zadd zset 3 three</span><br><span class="line">zincrby zset 1 one              增长分数</span><br><span class="line">zscore zset two                 获取分数</span><br><span class="line">zrange zset 0 -1 withscores     范围值</span><br><span class="line">zrangebyscore zset 10 25 withscores 指定范围的值</span><br><span class="line">zrangebyscore zset 10 25 withscores limit 1 2 分页</span><br><span class="line">Zrevrangebyscore zset 10 25 withscores  指定范围的值</span><br><span class="line">zcard zset  元素数量</span><br><span class="line">Zcount zset 获得指定分数范围内的元素个数</span><br><span class="line">Zrem zset one two        删除一个或多个元素</span><br><span class="line">Zremrangebyrank zset 0 1  按照排名范围删除元素</span><br><span class="line">Zremrangebyscore zset 0 1 按照分数范围删除元素</span><br><span class="line">Zrank zset 0 -1    分数最小的元素排名为0</span><br><span class="line">Zrevrank zset 0 -1  分数最大的元素排名为0</span><br><span class="line">Zinterstore</span><br><span class="line">zunionstore rank:last_week 7 rank:20150323 rank:20150324 rank:20150325  weights 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure>

<h3 id="19、MyBatis中-和-的区别"><a href="#19、MyBatis中-和-的区别" class="headerlink" title="19、MyBatis中 # 和 $ 的区别"></a>19、MyBatis中 # 和 $ 的区别</h3><p><strong>先给大家介绍下MyBatis中#{}和${}的区别，具体介绍如下：</strong></p>
<p>\1. #将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by “111”, 如果传入的值是id，则解析成的sql为order by “id”.</p>
<p>\2. $将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id, 如果传入的值是id，则解析成的sql为order by id.</p>
<p>\3. #方式能够很大程度防止sql注入。　</p>
<p>4.$方式无法防止Sql注入。</p>
<p>5.$方式一般用于传入数据库对象，例如传入表名.</p>
<p>6.一般能用#的就别用$.</p>
<p>MyBatis排序时使用order by 动态参数时需要注意，用$而不是#</p>
<p><strong>字符串替换</strong></p>
<p>默认情况下，使用#{}格式的语法会导致MyBatis创建预处理语句属性并以它为背景设置安全的值（比如?）。这样做很安全，很迅速也是首选做法，有时你只是想直接在SQL语句中插入一个不改变的字符串。比如，像ORDER BY，你可以这样来使用：<br>ORDER BY ${columnName}</p>
<p>这里MyBatis不会修改或转义字符串。</p>
<p>重要：接受从用户输出的内容并提供给语句中不变的字符串，这样做是不安全的。这会导致潜在的SQL注入攻击，因此你不应该允许用户输入这些字段，或者通常自行转义并检查。</p>
<p><strong>mybatis本身的说明：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;String Substitution&#96;&#96;By &#96;&#96;default&#96;&#96;, using the #&#123;&#125; syntax will cause MyBatis to generate PreparedStatement properties and set the values safely against the PreparedStatement parameters (e.g. ?). While &#96;&#96;this&#96; &#96;is safer, faster and almost always preferred, sometimes you just want to directly inject a string unmodified into the SQL Statement. For example, &#96;&#96;for&#96; &#96;ORDER BY, you might use something like &#96;&#96;this&#96;&#96;:&#96;&#96;ORDER BY $&#123;columnName&#125;&#96;&#96;Here MyBatis won&#39;t modify or escape the string.&#96;&#96;NOTE It&#39;s not safe to accept input from a user and supply it to a statement unmodified in &#96;&#96;this&#96; &#96;way. This leads to potential SQL Injection attacks and therefore you should either disallow user input in these fields, or always perform your own escapes and checks.&#96;</span><br></pre></td></tr></table></figure>

<p><strong>从上文可以看出：</strong></p>
<p>\1. 使用#{}格式的语法在mybatis中使用Preparement语句来安全的设置值，执行sql类似下面的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;PreparedStatement ps &#x3D; conn.prepareStatement(sql);&#96;&#96;ps.setInt(&#96;&#96;1&#96;&#96;,id);&#96;</span><br></pre></td></tr></table></figure>

<p>这样做的好处是：更安全，更迅速，通常也是首选做法。</p>
<p>\2. 不过有时你只是想直接在 SQL 语句中插入一个不改变的字符串。比如，像 ORDER BY，你可以这样来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;ORDER BY $&#123;columnName&#125;&#96;</span><br></pre></td></tr></table></figure>

<p>此时MyBatis 不会修改或转义字符串。</p>
<p>这种方式类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;Statement st &#x3D; conn.createStatement();&#96;&#96;ResultSet rs &#x3D; st.executeQuery(sql);&#96;</span><br></pre></td></tr></table></figure>

<p><strong>这种方式的缺点是：</strong></p>
<p>以这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。</p>
<h3 id="20、Mysql联合索引的最左匹配原则"><a href="#20、Mysql联合索引的最左匹配原则" class="headerlink" title="20、Mysql联合索引的最左匹配原则"></a>20、Mysql联合索引的最左匹配原则</h3><blockquote>
<h2 id="创建联合索引时列的选择原则"><a href="#创建联合索引时列的选择原则" class="headerlink" title="创建联合索引时列的选择原则"></a>创建联合索引时列的选择原则</h2><ol>
<li>经常用的列优先（最左匹配原则）</li>
<li>离散度高的列优先（离散度高原则）</li>
<li>宽度小的列优先（最少空间原则） </li>
</ol>
<p>在Mysql建立多列索引（联合索引）有最左前缀的原则，即最左优先。<br>如果我们建立了一个2列的联合索引(col1,col2),实际上已经建立了两个联合索引(col1)、(col1,col2）;<br>如果有一个3列索引(col1,col2,col3)，实际上已经建立了三个联合索引(col1)、(col1,col2)、(col1,col2,col3)。</p>
</blockquote>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>1、b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。</p>
<p>2、比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）</p>
<h2 id="mysql里创建联合索引的意义"><a href="#mysql里创建联合索引的意义" class="headerlink" title="mysql里创建联合索引的意义"></a>mysql里创建联合索引的意义</h2><h3 id="一个顶三个"><a href="#一个顶三个" class="headerlink" title="一个顶三个"></a>一个顶三个</h3><p>建了一个(a,b,c)的复合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，这可是不小的开销！</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>同样的有复合索引（a,b,c），如果有如下的sql: select a,b,c from table where a=1 and b = 1。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一</p>
<h3 id="索引列越多，通过索引筛选出的数据越少"><a href="#索引列越多，通过索引筛选出的数据越少" class="headerlink" title="索引列越多，通过索引筛选出的数据越少"></a>索引列越多，通过索引筛选出的数据越少</h3><p>有1000W条数据的表，有如下sql:select * from table where a = 1 and b =2 and c = 3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W<em>10%=100w 条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是复合索引，通过索引筛选出1000w</em> 10% <em>10%</em> 10%=1w，然后再排序、分页，哪个更高效，一眼便知</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Hiasenna 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Hiasenna 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"><i class="fa fa-tag"></i> 面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/" rel="prev" title="动态规划笔记">
      <i class="fa fa-chevron-left"></i> 动态规划笔记
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、List和Set的区别"><span class="nav-text">1、List和Set的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、List常用的实现类"><span class="nav-text">2、List常用的实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、ArrayList"><span class="nav-text">1、ArrayList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、LinkedList"><span class="nav-text">2、LinkedList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、Vector（线程安全的ArrayList）"><span class="nav-text">3、Vector（线程安全的ArrayList）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、Stack（继承于Vector）"><span class="nav-text">4、Stack（继承于Vector）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、ArrayList和LinkedList的区别"><span class="nav-text">3、ArrayList和LinkedList的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Array"><span class="nav-text">1. Array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-List"><span class="nav-text">2. List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-ArrayList"><span class="nav-text">3. ArrayList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-LinkList"><span class="nav-text">4. LinkList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、Set常用的实现类"><span class="nav-text">4、Set常用的实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet定义及特点"><span class="nav-text">HashSet定义及特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeSet定义及特点"><span class="nav-text">TreeSet定义及特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedHashSet定义及特点"><span class="nav-text">LinkedHashSet定义及特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、HashSet和LinkedHashSet的区别"><span class="nav-text">5、HashSet和LinkedHashSet的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、int和Integer的区别"><span class="nav-text">6、int和Integer的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#深入对比"><span class="nav-text">深入对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、-和equals的区别"><span class="nav-text">7、&#x3D;&#x3D;和equals的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、final关键字"><span class="nav-text">8、final关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#final关键字"><span class="nav-text">final关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-修饰数据"><span class="nav-text">1.修饰数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-修饰方法"><span class="nav-text">3.修饰方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-修饰类"><span class="nav-text">4.修饰类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、接口和抽象类的区别"><span class="nav-text">9、接口和抽象类的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口和抽象类的区别是什么？"><span class="nav-text">接口和抽象类的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类必须要有抽象方法吗？"><span class="nav-text">抽象类必须要有抽象方法吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类能使用-final-修饰吗？"><span class="nav-text">抽象类能使用 final 修饰吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、原子操作，CAS存在的问题，如何解决"><span class="nav-text">10、原子操作，CAS存在的问题，如何解决</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是CAS"><span class="nav-text">什么是CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS的目的"><span class="nav-text">CAS的目的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、-和–操作是否为原子操作，为什么"><span class="nav-text">11、++和–操作是否为原子操作，为什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、Java的异常处理机制，Error和Exception的区别"><span class="nav-text">12、Java的异常处理机制，Error和Exception的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是异常"><span class="nav-text">什么是异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unchecked-exception（非检查异常）"><span class="nav-text">unchecked exception（非检查异常）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#checked-exception（检查异常，编译异常）"><span class="nav-text">checked exception（检查异常，编译异常）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Throwable"><span class="nav-text">Throwable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Error（错误）"><span class="nav-text">Error（错误）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exception（异常）"><span class="nav-text">Exception（异常）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区别"><span class="nav-text">区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应该catch什么"><span class="nav-text">应该catch什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Error可以catch吗？-可以catch了后做些其他处理吗？"><span class="nav-text">Error可以catch吗？ 可以catch了后做些其他处理吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、IOException需要捕获吗？"><span class="nav-text">13、IOException需要捕获吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14、synchronized和Lock的区别"><span class="nav-text">14、synchronized和Lock的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15、线程池：创建、核心参数、拒绝策略"><span class="nav-text">15、线程池：创建、核心参数、拒绝策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16、Spring依赖注入的方式"><span class="nav-text">16、Spring依赖注入的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-set方法注入"><span class="nav-text">1.set方法注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-构造器注入"><span class="nav-text">2.构造器注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-静态工厂注入"><span class="nav-text">3.静态工厂注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-实例工厂注入"><span class="nav-text">4.实例工厂注入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17、当前bean有没有都行，应该采用什么方式注入"><span class="nav-text">17、当前bean有没有都行，应该采用什么方式注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18、Redis的数据类型，常用的Redis命令"><span class="nav-text">18、Redis的数据类型，常用的Redis命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis支持的五种数据类型"><span class="nav-text">Redis支持的五种数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#key（键）"><span class="nav-text">key（键）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string-（字符串）"><span class="nav-text">string （字符串）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hash（散列）"><span class="nav-text">hash（散列）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list（字符串列表）"><span class="nav-text">list（字符串列表）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set（字符串集合）"><span class="nav-text">set（字符串集合）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sorted-set（有序字符串集合）"><span class="nav-text">sorted-set（有序字符串集合）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19、MyBatis中-和-的区别"><span class="nav-text">19、MyBatis中 # 和 $ 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20、Mysql联合索引的最左匹配原则"><span class="nav-text">20、Mysql联合索引的最左匹配原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建联合索引时列的选择原则"><span class="nav-text">创建联合索引时列的选择原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解释"><span class="nav-text">解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql里创建联合索引的意义"><span class="nav-text">mysql里创建联合索引的意义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一个顶三个"><span class="nav-text">一个顶三个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖索引"><span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引列越多，通过索引筛选出的数据越少"><span class="nav-text">索引列越多，通过索引筛选出的数据越少</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hiasenna"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Hiasenna</p>
  <div class="site-description" itemprop="description">自律 稳健</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhanghaoyu2017" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhanghaoyu2017" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hiasenna</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">531k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:03</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
